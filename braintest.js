document.open()
document.write("<!DOCTYPE html>\r\n<html>\r\n\r\n<head>\r\n    <base href = \"https:\/\/cdn.jsdelivr.net\/gh\/cooldude2349\/braintest@main\/\">\r\n    <!--<script src=\"adSense.js\"><\/script>-->\r\n    \r\n\t\r\n\t<link rel=\"manifest\" href=\"appmanifest.json\">\r\n\r\n\r\n\t<link rel=\"stylesheet\" href=\"style.css\">\r\n\r\n\r\n<\/head>\r\n\r\n<body style=\"overflow:hidden;\">\r\n\r\n\t<script>\r\n\r\n\t<\/script>\r\n\t<script src=\"patch\/poki-sdk.js\"><\/script>\r\n\t<script src=\"box2d.wasm.js\"><\/script>\r\n\t<noscript>\r\n\t\t<div id=\"notSupportedWrap\">\r\n\t\t\t<h2 id=\"notSupportedTitle\">This content requires JavaScript<\/h2>\r\n\t\t\t<p class=\"notSupportedMessage\">JavaScript appears to be disabled. Please enable it to view this content.<\/p>\r\n\t\t<\/div>\r\n\t<\/noscript>\r\n\t<script src=\"scripts\/supportcheck.js\"><\/script>\r\n\t<script src=\"scripts\/offlineclient.js\" type=\"module\"><\/script>\r\n\t<script type=\"module\">\r\n\t    'use strict';\r\n{\r\n    window.DOMHandler = class DOMHandler {\r\n        constructor(iRuntime, componentId) {\r\n            this._iRuntime = iRuntime;\r\n            this._componentId = componentId;\r\n            this._hasTickCallback = false;\r\n            this._tickCallback = () => this.Tick()\r\n        }\r\n        Attach() {}\r\n        PostToRuntime(handler, data, dispatchOpts, transferables) {\r\n            this._iRuntime.PostToRuntimeComponent(this._componentId, handler, data, dispatchOpts, transferables)\r\n        }\r\n        PostToRuntimeAsync(handler, data, dispatchOpts, transferables) {\r\n            return this._iRuntime.PostToRuntimeComponentAsync(this._componentId, handler, data, dispatchOpts, transferables)\r\n        }\r\n        _PostToRuntimeMaybeSync(name, data, dispatchOpts) {\r\n            if (this._iRuntime.UsesWorker())\r\n                this.PostToRuntime(name, data, dispatchOpts);\r\n            else\r\n                this._iRuntime._GetLocalRuntime()[\"_OnMessageFromDOM\"]({\r\n                    \"type\": \"event\",\r\n                    \"component\": this._componentId,\r\n                    \"handler\": name,\r\n                    \"dispatchOpts\": dispatchOpts || null,\r\n                    \"data\": data,\r\n                    \"responseId\": null\r\n                })\r\n        }\r\n        AddRuntimeMessageHandler(handler, func) {\r\n            this._iRuntime.AddRuntimeComponentMessageHandler(this._componentId, handler, func)\r\n        }\r\n        AddRuntimeMessageHandlers(list) {\r\n            for (const [handler,func] of list)\r\n                this.AddRuntimeMessageHandler(handler, func)\r\n        }\r\n        GetRuntimeInterface() {\r\n            return this._iRuntime\r\n        }\r\n        GetComponentID() {\r\n            return this._componentId\r\n        }\r\n        _StartTicking() {\r\n            if (this._hasTickCallback)\r\n                return;\r\n            this._iRuntime._AddRAFCallback(this._tickCallback);\r\n            this._hasTickCallback = true\r\n        }\r\n        _StopTicking() {\r\n            if (!this._hasTickCallback)\r\n                return;\r\n            this._iRuntime._RemoveRAFCallback(this._tickCallback);\r\n            this._hasTickCallback = false\r\n        }\r\n        Tick() {}\r\n    }\r\n    ;\r\n    window.RateLimiter = class RateLimiter {\r\n        constructor(callback, interval) {\r\n            this._callback = callback;\r\n            this._interval = interval;\r\n            this._timerId = -1;\r\n            this._lastCallTime = -Infinity;\r\n            this._timerCallFunc = () => this._OnTimer();\r\n            this._ignoreReset = false;\r\n            this._canRunImmediate = false\r\n        }\r\n        SetCanRunImmediate(c) {\r\n            this._canRunImmediate = !!c\r\n        }\r\n        Call() {\r\n            if (this._timerId !== -1)\r\n                return;\r\n            const nowTime = Date.now();\r\n            const timeSinceLastCall = nowTime - this._lastCallTime;\r\n            const interval = this._interval;\r\n            if (timeSinceLastCall >= interval && this._canRunImmediate) {\r\n                this._lastCallTime = nowTime;\r\n                this._RunCallback()\r\n            } else\r\n                this._timerId = self.setTimeout(this._timerCallFunc, Math.max(interval - timeSinceLastCall, 4))\r\n        }\r\n        _RunCallback() {\r\n            this._ignoreReset = true;\r\n            this._callback();\r\n            this._ignoreReset = false\r\n        }\r\n        Reset() {\r\n            if (this._ignoreReset)\r\n                return;\r\n            this._CancelTimer();\r\n            this._lastCallTime = Date.now()\r\n        }\r\n        _OnTimer() {\r\n            this._timerId = -1;\r\n            this._lastCallTime = Date.now();\r\n            this._RunCallback()\r\n        }\r\n        _CancelTimer() {\r\n            if (this._timerId !== -1) {\r\n                self.clearTimeout(this._timerId);\r\n                this._timerId = -1\r\n            }\r\n        }\r\n        Release() {\r\n            this._CancelTimer();\r\n            this._callback = null;\r\n            this._timerCallFunc = null\r\n        }\r\n    }\r\n}\r\n;\r\n'use strict';\r\n{\r\n    window.DOMElementHandler = class DOMElementHandler extends self.DOMHandler {\r\n        constructor(iRuntime, componentId) {\r\n            super(iRuntime, componentId);\r\n            this._elementMap = new Map;\r\n            this._autoAttach = true;\r\n            this.AddRuntimeMessageHandlers([[\"create\", e => this._OnCreate(e)], [\"destroy\", e => this._OnDestroy(e)], [\"set-visible\", e => this._OnSetVisible(e)], [\"update-position\", e => this._OnUpdatePosition(e)], [\"update-state\", e => this._OnUpdateState(e)], [\"focus\", e => this._OnSetFocus(e)], [\"set-css-style\", e => this._OnSetCssStyle(e)], [\"set-attribute\", e => this._OnSetAttribute(e)], [\"remove-attribute\", e => this._OnRemoveAttribute(e)]]);\r\n            this.AddDOMElementMessageHandler(\"get-element\", elem => elem)\r\n        }\r\n        SetAutoAttach(e) {\r\n            this._autoAttach = !!e\r\n        }\r\n        AddDOMElementMessageHandler(handler, func) {\r\n            this.AddRuntimeMessageHandler(handler, e => {\r\n                const elementId = e[\"elementId\"];\r\n                const elem = this._elementMap.get(elementId);\r\n                return func(elem, e)\r\n            }\r\n            )\r\n        }\r\n        _OnCreate(e) {\r\n            const elementId = e[\"elementId\"];\r\n            const elem = this.CreateElement(elementId, e);\r\n            this._elementMap.set(elementId, elem);\r\n            elem.style.boxSizing = \"border-box\";\r\n            if (!e[\"isVisible\"])\r\n                elem.style.display = \"none\";\r\n            const focusElem = this._GetFocusElement(elem);\r\n            focusElem.addEventListener(\"focus\", e => this._OnFocus(elementId));\r\n            focusElem.addEventListener(\"blur\", e => this._OnBlur(elementId));\r\n            if (this._autoAttach)\r\n                document.body.appendChild(elem)\r\n        }\r\n        CreateElement(elementId, e) {\r\n            throw new Error(\"required override\");\r\n        }\r\n        DestroyElement(elem) {}\r\n        _OnDestroy(e) {\r\n            const elementId = e[\"elementId\"];\r\n            const elem = this._elementMap.get(elementId);\r\n            this.DestroyElement(elem);\r\n            if (this._autoAttach)\r\n                elem.parentElement.removeChild(elem);\r\n            this._elementMap.delete(elementId)\r\n        }\r\n        PostToRuntimeElement(handler, elementId, data) {\r\n            if (!data)\r\n                data = {};\r\n            data[\"elementId\"] = elementId;\r\n            this.PostToRuntime(handler, data)\r\n        }\r\n        _PostToRuntimeElementMaybeSync(handler, elementId, data) {\r\n            if (!data)\r\n                data = {};\r\n            data[\"elementId\"] = elementId;\r\n            this._PostToRuntimeMaybeSync(handler, data)\r\n        }\r\n        _OnSetVisible(e) {\r\n            if (!this._autoAttach)\r\n                return;\r\n            const elem = this._elementMap.get(e[\"elementId\"]);\r\n            elem.style.display = e[\"isVisible\"] ? \"\" : \"none\"\r\n        }\r\n        _OnUpdatePosition(e) {\r\n            if (!this._autoAttach)\r\n                return;\r\n            const elem = this._elementMap.get(e[\"elementId\"]);\r\n            elem.style.left = e[\"left\"] + \"px\";\r\n            elem.style.top = e[\"top\"] + \"px\";\r\n            elem.style.width = e[\"width\"] + \"px\";\r\n            elem.style.height = e[\"height\"] + \"px\";\r\n            const fontSize = e[\"fontSize\"];\r\n            if (fontSize !== null)\r\n                elem.style.fontSize = fontSize + \"em\"\r\n        }\r\n        _OnUpdateState(e) {\r\n            const elem = this._elementMap.get(e[\"elementId\"]);\r\n            this.UpdateState(elem, e)\r\n        }\r\n        UpdateState(elem, e) {\r\n            throw new Error(\"required override\");\r\n        }\r\n        _GetFocusElement(elem) {\r\n            return elem\r\n        }\r\n        _OnFocus(elementId) {\r\n            this.PostToRuntimeElement(\"elem-focused\", elementId)\r\n        }\r\n        _OnBlur(elementId) {\r\n            this.PostToRuntimeElement(\"elem-blurred\", elementId)\r\n        }\r\n        _OnSetFocus(e) {\r\n            const elem = this._GetFocusElement(this._elementMap.get(e[\"elementId\"]));\r\n            if (e[\"focus\"])\r\n                elem.focus();\r\n            else\r\n                elem.blur()\r\n        }\r\n        _OnSetCssStyle(e) {\r\n            const elem = this._elementMap.get(e[\"elementId\"]);\r\n            elem.style[e[\"prop\"]] = e[\"val\"]\r\n        }\r\n        _OnSetAttribute(e) {\r\n            const elem = this._elementMap.get(e[\"elementId\"]);\r\n            elem.setAttribute(e[\"name\"], e[\"val\"])\r\n        }\r\n        _OnRemoveAttribute(e) {\r\n            const elem = this._elementMap.get(e[\"elementId\"]);\r\n            elem.removeAttribute(e[\"name\"])\r\n        }\r\n        GetElementById(elementId) {\r\n            return this._elementMap.get(elementId)\r\n        }\r\n    }\r\n}\r\n;\r\n'use strict';\r\n{\r\n    const isiOSLike = \/(iphone|ipod|ipad|macos|macintosh|mac os x)\/i.test(navigator.userAgent);\r\n    const isAndroid = \/android\/i.test(navigator.userAgent);\r\n    let resolveCounter = 0;\r\n    function AddScript(url) {\r\n        const elem = document.createElement(\"script\");\r\n        elem.async = false;\r\n        elem.type = \"module\";\r\n        if (url.isStringSrc)\r\n            return new Promise(resolve => {\r\n                const resolveName = \"c3_resolve_\" + resolveCounter;\r\n                ++resolveCounter;\r\n                self[resolveName] = resolve;\r\n                elem.textContent = url.str + `\\n\\nself[\"${resolveName}\"]();`;\r\n                document.head.appendChild(elem)\r\n            }\r\n            );\r\n        else\r\n            return new Promise( (resolve, reject) => {\r\n                elem.onload = resolve;\r\n                elem.onerror = reject;\r\n                elem.src = url;\r\n                document.head.appendChild(elem)\r\n            }\r\n            )\r\n    }\r\n    let didCheckWorkerModuleSupport = false;\r\n    let isWorkerModuleSupported = false;\r\n    function SupportsWorkerTypeModule() {\r\n        if (!didCheckWorkerModuleSupport) {\r\n            try {\r\n                new Worker(\"blob:\/\/\",{\r\n                    get type() {\r\n                        isWorkerModuleSupported = true\r\n                    }\r\n                })\r\n            } catch (e) {}\r\n            didCheckWorkerModuleSupport = true\r\n        }\r\n        return isWorkerModuleSupported\r\n    }\r\n    let tmpAudio = new Audio;\r\n    const supportedAudioFormats = {\r\n        \"audio\/webm; codecs=opus\": !!tmpAudio.canPlayType(\"audio\/webm; codecs=opus\"),\r\n        \"audio\/ogg; codecs=opus\": !!tmpAudio.canPlayType(\"audio\/ogg; codecs=opus\"),\r\n        \"audio\/webm; codecs=vorbis\": !!tmpAudio.canPlayType(\"audio\/webm; codecs=vorbis\"),\r\n        \"audio\/ogg; codecs=vorbis\": !!tmpAudio.canPlayType(\"audio\/ogg; codecs=vorbis\"),\r\n        \"audio\/mp4\": !!tmpAudio.canPlayType(\"audio\/mp4\"),\r\n        \"audio\/mpeg\": !!tmpAudio.canPlayType(\"audio\/mpeg\")\r\n    };\r\n    tmpAudio = null;\r\n    async function BlobToString(blob) {\r\n        const arrayBuffer = await BlobToArrayBuffer(blob);\r\n        const textDecoder = new TextDecoder(\"utf-8\");\r\n        return textDecoder.decode(arrayBuffer)\r\n    }\r\n    function BlobToArrayBuffer(blob) {\r\n        return new Promise( (resolve, reject) => {\r\n            const fileReader = new FileReader;\r\n            fileReader.onload = e => resolve(e.target.result);\r\n            fileReader.onerror = err => reject(err);\r\n            fileReader.readAsArrayBuffer(blob)\r\n        }\r\n        )\r\n    }\r\n    const queuedArrayBufferReads = [];\r\n    let activeArrayBufferReads = 0;\r\n    const MAX_ARRAYBUFFER_READS = 8;\r\n    window[\"RealFile\"] = window[\"File\"];\r\n    const domHandlerClasses = [];\r\n    const runtimeEventHandlers = new Map;\r\n    const pendingResponsePromises = new Map;\r\n    let nextResponseId = 0;\r\n    const runOnStartupFunctions = [];\r\n    self.runOnStartup = function runOnStartup(f) {\r\n        if (typeof f !== \"function\")\r\n            throw new Error(\"runOnStartup called without a function\");\r\n        runOnStartupFunctions.push(f)\r\n    }\r\n    ;\r\n    const WEBVIEW_EXPORT_TYPES = new Set([\"cordova\", \"playable-ad\", \"instant-games\"]);\r\n    function IsWebViewExportType(exportType) {\r\n        return WEBVIEW_EXPORT_TYPES.has(exportType)\r\n    }\r\n    let isWrapperFullscreen = false;\r\n    window.RuntimeInterface = class RuntimeInterface {\r\n        constructor(opts) {\r\n            this._useWorker = opts.useWorker;\r\n            this._messageChannelPort = null;\r\n            this._runtimeBaseUrl = \"\";\r\n            this._scriptFolder = opts.scriptFolder;\r\n            this._workerScriptURLs = {};\r\n            this._worker = null;\r\n            this._localRuntime = null;\r\n            this._domHandlers = [];\r\n            this._runtimeDomHandler = null;\r\n            this._canvas = null;\r\n            this._isExportingToVideo = false;\r\n            this._exportToVideoDuration = 0;\r\n            this._jobScheduler = null;\r\n            this._rafId = -1;\r\n            this._rafFunc = () => this._OnRAFCallback();\r\n            this._rafCallbacks = [];\r\n            this._exportType = opts.exportType;\r\n            this._isFileProtocol = location.protocol.substr(0, 4) === \"file\";\r\n            if (this._useWorker && (typeof OffscreenCanvas === \"undefined\" || !navigator[\"userActivation\"] || !SupportsWorkerTypeModule()))\r\n                this._useWorker = false;\r\n            if (this._exportType === \"playable-ad\" || this._exportType === \"instant-games\")\r\n                this._useWorker = false;\r\n            if (this._exportType === \"cordova\" && this._useWorker)\r\n                if (isAndroid) {\r\n                    const chromeVer = \/Chrome\\\/(\\d+)\/i.exec(navigator.userAgent);\r\n                    if (!chromeVer || !(parseInt(chromeVer[1], 10) >= 90))\r\n                        this._useWorker = false\r\n                } else\r\n                    this._useWorker = false;\r\n            this._localFileBlobs = null;\r\n            this._localFileStrings = null;\r\n            if (this._exportType === \"html5\" && !window.isSecureContext)\r\n                console.warn(\"[Construct] Warning: the browser indicates this is not a secure context. Some features may be unavailable. Use secure (HTTPS) hosting to ensure all features are available.\");\r\n            this.AddRuntimeComponentMessageHandler(\"runtime\", \"cordova-fetch-local-file\", e => this._OnCordovaFetchLocalFile(e));\r\n            this.AddRuntimeComponentMessageHandler(\"runtime\", \"create-job-worker\", e => this._OnCreateJobWorker(e));\r\n            if (this._exportType === \"cordova\")\r\n                document.addEventListener(\"deviceready\", () => this._Init(opts));\r\n            else\r\n                this._Init(opts)\r\n        }\r\n        Release() {\r\n            this._CancelAnimationFrame();\r\n            if (this._messageChannelPort) {\r\n                this._messageChannelPort.onmessage = null;\r\n                this._messageChannelPort = null\r\n            }\r\n            if (this._worker) {\r\n                this._worker.terminate();\r\n                this._worker = null\r\n            }\r\n            if (this._localRuntime) {\r\n                this._localRuntime.Release();\r\n                this._localRuntime = null\r\n            }\r\n            if (this._canvas) {\r\n                this._canvas.parentElement.removeChild(this._canvas);\r\n                this._canvas = null\r\n            }\r\n        }\r\n        GetCanvas() {\r\n            return this._canvas\r\n        }\r\n        GetRuntimeBaseURL() {\r\n            return this._runtimeBaseUrl\r\n        }\r\n        UsesWorker() {\r\n            return this._useWorker\r\n        }\r\n        GetExportType() {\r\n            return this._exportType\r\n        }\r\n        IsFileProtocol() {\r\n            return this._isFileProtocol\r\n        }\r\n        GetScriptFolder() {\r\n            return this._scriptFolder\r\n        }\r\n        IsiOSCordova() {\r\n            return isiOSLike && this._exportType === \"cordova\"\r\n        }\r\n        IsiOSWebView() {\r\n            const ua = navigator.userAgent;\r\n            return isiOSLike && IsWebViewExportType(this._exportType) || navigator[\"standalone\"] || \/crios\\\/|fxios\\\/|edgios\\\/\/i.test(ua)\r\n        }\r\n        IsAndroid() {\r\n            return isAndroid\r\n        }\r\n        IsAndroidWebView() {\r\n            return isAndroid && IsWebViewExportType(this._exportType)\r\n        }\r\n        async _Init(opts) {\r\n            if (this._exportType === \"macos-wkwebview\")\r\n                this._SendWrapperMessage({\r\n                    \"type\": \"ready\"\r\n                });\r\n            if (this._exportType === \"playable-ad\") {\r\n                this._localFileBlobs = self[\"c3_base64files\"];\r\n                this._localFileStrings = {};\r\n                await this._ConvertDataUrisToBlobs();\r\n                for (let i = 0, len = opts.engineScripts.length; i < len; ++i) {\r\n                    const src = opts.engineScripts[i].toLowerCase();\r\n                    if (this._localFileStrings.hasOwnProperty(src))\r\n                        opts.engineScripts[i] = {\r\n                            isStringSrc: true,\r\n                            str: this._localFileStrings[src]\r\n                        };\r\n                    else if (this._localFileBlobs.hasOwnProperty(src))\r\n                        opts.engineScripts[i] = URL.createObjectURL(this._localFileBlobs[src])\r\n                }\r\n            }\r\n            if (opts.runtimeBaseUrl)\r\n                this._runtimeBaseUrl = opts.runtimeBaseUrl;\r\n            else {\r\n                const origin = location.origin;\r\n                this._runtimeBaseUrl = (origin === \"null\" ? \"file:\/\/\/\" : origin) + location.pathname;\r\n                const i = this._runtimeBaseUrl.lastIndexOf(\"\/\");\r\n                if (i !== -1)\r\n                    this._runtimeBaseUrl = this._runtimeBaseUrl.substr(0, i + 1)\r\n            }\r\n            if (opts.workerScripts)\r\n                this._workerScriptURLs = opts.workerScripts;\r\n            const messageChannel = new MessageChannel;\r\n            this._messageChannelPort = messageChannel.port1;\r\n            this._messageChannelPort.onmessage = e => this[\"_OnMessageFromRuntime\"](e.data);\r\n            if (window[\"c3_addPortMessageHandler\"])\r\n                window[\"c3_addPortMessageHandler\"](e => this._OnMessageFromDebugger(e));\r\n            this._jobScheduler = new self.JobSchedulerDOM(this);\r\n            await this._jobScheduler.Init();\r\n            if (typeof window[\"StatusBar\"] === \"object\")\r\n                window[\"StatusBar\"][\"hide\"]();\r\n            if (typeof window[\"AndroidFullScreen\"] === \"object\")\r\n                try {\r\n                    await new Promise( (resolve, reject) => {\r\n                        window[\"AndroidFullScreen\"][\"immersiveMode\"](resolve, reject)\r\n                    }\r\n                    )\r\n                } catch (err) {\r\n                    console.error(\"Failed to enter Android immersive mode: \", err)\r\n                }\r\n            if (this._useWorker)\r\n                await this._InitWorker(opts, messageChannel.port2);\r\n            else\r\n                await this._InitDOM(opts, messageChannel.port2)\r\n        }\r\n        _GetWorkerURL(url) {\r\n            let ret;\r\n            if (this._workerScriptURLs.hasOwnProperty(url))\r\n                ret = this._workerScriptURLs[url];\r\n            else if (url.endsWith(\"\/workermain.js\") && this._workerScriptURLs.hasOwnProperty(\"workermain.js\"))\r\n                ret = this._workerScriptURLs[\"workermain.js\"];\r\n            else if (this._exportType === \"playable-ad\" && this._localFileBlobs.hasOwnProperty(url.toLowerCase()))\r\n                ret = this._localFileBlobs[url.toLowerCase()];\r\n            else\r\n                ret = url;\r\n            if (ret instanceof Blob)\r\n                ret = URL.createObjectURL(ret);\r\n            return ret\r\n        }\r\n        async CreateWorker(url, baseUrl, workerOpts) {\r\n            if (url.startsWith(\"blob:\"))\r\n                return new Worker(url,workerOpts);\r\n            if (this._exportType === \"cordova\" && this._isFileProtocol) {\r\n                let filePath = \"\";\r\n                if (workerOpts.isC3MainWorker)\r\n                    filePath = url;\r\n                else\r\n                    filePath = this._scriptFolder + url;\r\n                const arrayBuffer = await this.CordovaFetchLocalFileAsArrayBuffer(filePath);\r\n                const blob = new Blob([arrayBuffer],{\r\n                    type: \"application\/javascript\"\r\n                });\r\n                return new Worker(URL.createObjectURL(blob),workerOpts)\r\n            }\r\n            const absUrl = new URL(url,baseUrl);\r\n            const isCrossOrigin = location.origin !== absUrl.origin;\r\n            if (isCrossOrigin) {\r\n                const response = await fetch(absUrl);\r\n                if (!response.ok)\r\n                    throw new Error(\"failed to fetch worker script\");\r\n                const blob = await response.blob();\r\n                return new Worker(URL.createObjectURL(blob),workerOpts)\r\n            } else\r\n                return new Worker(absUrl,workerOpts)\r\n        }\r\n        _GetWindowInnerWidth() {\r\n            return Math.max(window.innerWidth, 1)\r\n        }\r\n        _GetWindowInnerHeight() {\r\n            return Math.max(window.innerHeight, 1)\r\n        }\r\n        _GetCommonRuntimeOptions(opts) {\r\n            return {\r\n                \"runtimeBaseUrl\": this._runtimeBaseUrl,\r\n                \"previewUrl\": location.href,\r\n                \"windowInnerWidth\": this._GetWindowInnerWidth(),\r\n                \"windowInnerHeight\": this._GetWindowInnerHeight(),\r\n                \"devicePixelRatio\": window.devicePixelRatio,\r\n                \"isFullscreen\": RuntimeInterface.IsDocumentFullscreen(),\r\n                \"projectData\": opts.projectData,\r\n                \"previewImageBlobs\": window[\"cr_previewImageBlobs\"] || this._localFileBlobs,\r\n                \"previewProjectFileBlobs\": window[\"cr_previewProjectFileBlobs\"],\r\n                \"previewProjectFileSWUrls\": window[\"cr_previewProjectFiles\"],\r\n                \"swClientId\": window.cr_swClientId || \"\",\r\n                \"exportType\": opts.exportType,\r\n                \"isDebug\": (new URLSearchParams(self.location.search)).has(\"debug\"),\r\n                \"ife\": !!self.ife,\r\n                \"jobScheduler\": this._jobScheduler.GetPortData(),\r\n                \"supportedAudioFormats\": supportedAudioFormats,\r\n                \"opusWasmScriptUrl\": window[\"cr_opusWasmScriptUrl\"] || this._scriptFolder + \"opus.wasm.js\",\r\n                \"opusWasmBinaryUrl\": window[\"cr_opusWasmBinaryUrl\"] || this._scriptFolder + \"opus.wasm.wasm\",\r\n                \"isFileProtocol\": this._isFileProtocol,\r\n                \"isiOSCordova\": this.IsiOSCordova(),\r\n                \"isiOSWebView\": this.IsiOSWebView(),\r\n                \"isFBInstantAvailable\": typeof self[\"FBInstant\"] !== \"undefined\"\r\n            }\r\n        }\r\n        async _InitWorker(opts, port2) {\r\n            const workerMainUrl = this._GetWorkerURL(opts.workerMainUrl);\r\n            this._worker = await this.CreateWorker(workerMainUrl, this._runtimeBaseUrl, {\r\n                type: \"module\",\r\n                name: \"Runtime\",\r\n                isC3MainWorker: true\r\n            });\r\n            this._canvas = document.createElement(\"canvas\");\r\n            this._canvas.style.display = \"none\";\r\n            const offscreenCanvas = this._canvas[\"transferControlToOffscreen\"]();\r\n            document.body.appendChild(this._canvas);\r\n            window[\"c3canvas\"] = this._canvas;\r\n            if (self[\"C3_InsertHTMLPlaceholders\"])\r\n                self[\"C3_InsertHTMLPlaceholders\"]();\r\n            let workerDependencyScripts = opts.workerDependencyScripts || [];\r\n            let engineScripts = opts.engineScripts;\r\n            workerDependencyScripts = await Promise.all(workerDependencyScripts.map(url => this._MaybeGetCordovaScriptURL(url)));\r\n            engineScripts = await Promise.all(engineScripts.map(url => this._MaybeGetCordovaScriptURL(url)));\r\n            if (this._exportType === \"cordova\")\r\n                for (let i = 0, len = opts.projectScripts.length; i < len; ++i) {\r\n                    const info = opts.projectScripts[i];\r\n                    const originalUrl = info[0];\r\n                    if (originalUrl === opts.mainProjectScript || (originalUrl === \"scriptsInEvents.js\" || originalUrl.endsWith(\"\/scriptsInEvents.js\")))\r\n                        info[1] = await this._MaybeGetCordovaScriptURL(originalUrl)\r\n                }\r\n            this._worker.postMessage(Object.assign(this._GetCommonRuntimeOptions(opts), {\r\n                \"type\": \"init-runtime\",\r\n                \"isInWorker\": true,\r\n                \"messagePort\": port2,\r\n                \"canvas\": offscreenCanvas,\r\n                \"workerDependencyScripts\": workerDependencyScripts,\r\n                \"engineScripts\": engineScripts,\r\n                \"projectScripts\": opts.projectScripts,\r\n                \"mainProjectScript\": opts.mainProjectScript,\r\n                \"projectScriptsStatus\": self[\"C3_ProjectScriptsStatus\"]\r\n            }), [port2, offscreenCanvas, ...this._jobScheduler.GetPortTransferables()]);\r\n            this._domHandlers = domHandlerClasses.map(C => new C(this));\r\n            this._FindRuntimeDOMHandler();\r\n            self[\"c3_callFunction\"] = (name, params) => this._runtimeDomHandler._InvokeFunctionFromJS(name, params);\r\n            if (this._exportType === \"preview\")\r\n                self[\"goToLastErrorScript\"] = () => this.PostToRuntimeComponent(\"runtime\", \"go-to-last-error-script\")\r\n        }\r\n        async _InitDOM(opts, port2) {\r\n            this._canvas = document.createElement(\"canvas\");\r\n            this._canvas.style.display = \"none\";\r\n            document.body.appendChild(this._canvas);\r\n            window[\"c3canvas\"] = this._canvas;\r\n            if (self[\"C3_InsertHTMLPlaceholders\"])\r\n                self[\"C3_InsertHTMLPlaceholders\"]();\r\n            this._domHandlers = domHandlerClasses.map(C => new C(this));\r\n            this._FindRuntimeDOMHandler();\r\n            let engineScripts = opts.engineScripts.map(url => typeof url === \"string\" ? (new URL(url,this._runtimeBaseUrl)).toString() : url);\r\n            if (Array.isArray(opts.workerDependencyScripts))\r\n                engineScripts.unshift(...opts.workerDependencyScripts);\r\n            engineScripts = await Promise.all(engineScripts.map(url => this._MaybeGetCordovaScriptURL(url)));\r\n            await Promise.all(engineScripts.map(url => AddScript(url)));\r\n            const scriptsStatus = self[\"C3_ProjectScriptsStatus\"];\r\n            const mainProjectScript = opts.mainProjectScript;\r\n            const allProjectScripts = opts.projectScripts;\r\n            for (let[originalUrl,loadUrl] of allProjectScripts) {\r\n                if (!loadUrl)\r\n                    loadUrl = originalUrl;\r\n                if (originalUrl === mainProjectScript)\r\n                    try {\r\n                        loadUrl = await this._MaybeGetCordovaScriptURL(loadUrl);\r\n                        await AddScript(loadUrl);\r\n                        if (this._exportType === \"preview\" && !scriptsStatus[originalUrl])\r\n                            this._ReportProjectMainScriptError(originalUrl, \"main script did not run to completion\")\r\n                    } catch (err) {\r\n                        this._ReportProjectMainScriptError(originalUrl, err)\r\n                    }\r\n                else if (originalUrl === \"scriptsInEvents.js\" || originalUrl.endsWith(\"\/scriptsInEvents.js\")) {\r\n                    loadUrl = await this._MaybeGetCordovaScriptURL(loadUrl);\r\n                    await AddScript(loadUrl)\r\n                }\r\n            }\r\n            if (this._exportType === \"preview\" && typeof self.C3.ScriptsInEvents !== \"object\") {\r\n                this._RemoveLoadingMessage();\r\n                const msg = \"Failed to load JavaScript code used in events. Check all your JavaScript code has valid syntax.\";\r\n                console.error(\"[C3 runtime] \" + msg);\r\n                alert(msg);\r\n                return\r\n            }\r\n            const runtimeOpts = Object.assign(this._GetCommonRuntimeOptions(opts), {\r\n                \"isInWorker\": false,\r\n                \"messagePort\": port2,\r\n                \"canvas\": this._canvas,\r\n                \"runOnStartupFunctions\": runOnStartupFunctions\r\n            });\r\n            this._OnBeforeCreateRuntime();\r\n            this._localRuntime = self[\"C3_CreateRuntime\"](runtimeOpts);\r\n            await self[\"C3_InitRuntime\"](this._localRuntime, runtimeOpts)\r\n        }\r\n        _ReportProjectMainScriptError(url, err) {\r\n            this._RemoveLoadingMessage();\r\n            console.error(`[Preview] Failed to load project main script (${url}): `, err);\r\n            alert(`Failed to load project main script (${url}). Check all your JavaScript code has valid syntax. Press F12 and check the console for error details.`)\r\n        }\r\n        _OnBeforeCreateRuntime() {\r\n            this._RemoveLoadingMessage()\r\n        }\r\n        _RemoveLoadingMessage() {\r\n            const loadingElem = window.cr_previewLoadingElem;\r\n            if (loadingElem) {\r\n                loadingElem.parentElement.removeChild(loadingElem);\r\n                window.cr_previewLoadingElem = null\r\n            }\r\n        }\r\n        async _OnCreateJobWorker(e) {\r\n            const outputPort = await this._jobScheduler._CreateJobWorker();\r\n            return {\r\n                \"outputPort\": outputPort,\r\n                \"transferables\": [outputPort]\r\n            }\r\n        }\r\n        _GetLocalRuntime() {\r\n            if (this._useWorker)\r\n                throw new Error(\"not available in worker mode\");\r\n            return this._localRuntime\r\n        }\r\n        PostToRuntimeComponent(component, handler, data, dispatchOpts, transferables) {\r\n            this._messageChannelPort.postMessage({\r\n                \"type\": \"event\",\r\n                \"component\": component,\r\n                \"handler\": handler,\r\n                \"dispatchOpts\": dispatchOpts || null,\r\n                \"data\": data,\r\n                \"responseId\": null\r\n            }, transferables)\r\n        }\r\n        PostToRuntimeComponentAsync(component, handler, data, dispatchOpts, transferables) {\r\n            const responseId = nextResponseId++;\r\n            const ret = new Promise( (resolve, reject) => {\r\n                pendingResponsePromises.set(responseId, {\r\n                    resolve,\r\n                    reject\r\n                })\r\n            }\r\n            );\r\n            this._messageChannelPort.postMessage({\r\n                \"type\": \"event\",\r\n                \"component\": component,\r\n                \"handler\": handler,\r\n                \"dispatchOpts\": dispatchOpts || null,\r\n                \"data\": data,\r\n                \"responseId\": responseId\r\n            }, transferables);\r\n            return ret\r\n        }\r\n        [\"_OnMessageFromRuntime\"](data) {\r\n            const type = data[\"type\"];\r\n            if (type === \"event\")\r\n                return this._OnEventFromRuntime(data);\r\n            else if (type === \"result\")\r\n                this._OnResultFromRuntime(data);\r\n            else if (type === \"runtime-ready\")\r\n                this._OnRuntimeReady();\r\n            else if (type === \"alert-error\") {\r\n                this._RemoveLoadingMessage();\r\n                alert(data[\"message\"])\r\n            } else if (type === \"creating-runtime\")\r\n                this._OnBeforeCreateRuntime();\r\n            else\r\n                throw new Error(`unknown message '${type}'`);\r\n        }\r\n        _OnEventFromRuntime(e) {\r\n            const component = e[\"component\"];\r\n            const handler = e[\"handler\"];\r\n            const data = e[\"data\"];\r\n            const responseId = e[\"responseId\"];\r\n            const handlerMap = runtimeEventHandlers.get(component);\r\n            if (!handlerMap) {\r\n                console.warn(`[DOM] No event handlers for component '${component}'`);\r\n                return\r\n            }\r\n            const func = handlerMap.get(handler);\r\n            if (!func) {\r\n                console.warn(`[DOM] No handler '${handler}' for component '${component}'`);\r\n                return\r\n            }\r\n            let ret = null;\r\n            try {\r\n                ret = func(data)\r\n            } catch (err) {\r\n                console.error(`Exception in '${component}' handler '${handler}':`, err);\r\n                if (responseId !== null)\r\n                    this._PostResultToRuntime(responseId, false, \"\" + err);\r\n                return\r\n            }\r\n            if (responseId === null)\r\n                return ret;\r\n            else if (ret && ret.then)\r\n                ret.then(result => this._PostResultToRuntime(responseId, true, result)).catch(err => {\r\n                    console.error(`Rejection from '${component}' handler '${handler}':`, err);\r\n                    this._PostResultToRuntime(responseId, false, \"\" + err)\r\n                }\r\n                );\r\n            else\r\n                this._PostResultToRuntime(responseId, true, ret)\r\n        }\r\n        _PostResultToRuntime(responseId, isOk, result) {\r\n            let transferables;\r\n            if (result && result[\"transferables\"])\r\n                transferables = result[\"transferables\"];\r\n            this._messageChannelPort.postMessage({\r\n                \"type\": \"result\",\r\n                \"responseId\": responseId,\r\n                \"isOk\": isOk,\r\n                \"result\": result\r\n            }, transferables)\r\n        }\r\n        _OnResultFromRuntime(data) {\r\n            const responseId = data[\"responseId\"];\r\n            const isOk = data[\"isOk\"];\r\n            const result = data[\"result\"];\r\n            const pendingPromise = pendingResponsePromises.get(responseId);\r\n            if (isOk)\r\n                pendingPromise.resolve(result);\r\n            else\r\n                pendingPromise.reject(result);\r\n            pendingResponsePromises.delete(responseId)\r\n        }\r\n        AddRuntimeComponentMessageHandler(component, handler, func) {\r\n            let handlerMap = runtimeEventHandlers.get(component);\r\n            if (!handlerMap) {\r\n                handlerMap = new Map;\r\n                runtimeEventHandlers.set(component, handlerMap)\r\n            }\r\n            if (handlerMap.has(handler))\r\n                throw new Error(`[DOM] Component '${component}' already has handler '${handler}'`);\r\n            handlerMap.set(handler, func)\r\n        }\r\n        static AddDOMHandlerClass(Class) {\r\n            if (domHandlerClasses.includes(Class))\r\n                throw new Error(\"DOM handler already added\");\r\n            domHandlerClasses.push(Class)\r\n        }\r\n        _FindRuntimeDOMHandler() {\r\n            for (const dh of this._domHandlers)\r\n                if (dh.GetComponentID() === \"runtime\") {\r\n                    this._runtimeDomHandler = dh;\r\n                    return\r\n                }\r\n            throw new Error(\"cannot find runtime DOM handler\");\r\n        }\r\n        _OnMessageFromDebugger(e) {\r\n            this.PostToRuntimeComponent(\"debugger\", \"message\", e)\r\n        }\r\n        _OnRuntimeReady() {\r\n            for (const h of this._domHandlers)\r\n                h.Attach()\r\n        }\r\n        static IsDocumentFullscreen() {\r\n            return !!(document[\"fullscreenElement\"] || document[\"webkitFullscreenElement\"] || document[\"mozFullScreenElement\"] || isWrapperFullscreen)\r\n        }\r\n        static _SetWrapperIsFullscreenFlag(f) {\r\n            isWrapperFullscreen = !!f\r\n        }\r\n        async GetRemotePreviewStatusInfo() {\r\n            return await this.PostToRuntimeComponentAsync(\"runtime\", \"get-remote-preview-status-info\")\r\n        }\r\n        _AddRAFCallback(f) {\r\n            this._rafCallbacks.push(f);\r\n            this._RequestAnimationFrame()\r\n        }\r\n        _RemoveRAFCallback(f) {\r\n            const i = this._rafCallbacks.indexOf(f);\r\n            if (i === -1)\r\n                throw new Error(\"invalid callback\");\r\n            this._rafCallbacks.splice(i, 1);\r\n            if (!this._rafCallbacks.length)\r\n                this._CancelAnimationFrame()\r\n        }\r\n        _RequestAnimationFrame() {\r\n            if (this._rafId === -1 && this._rafCallbacks.length)\r\n                this._rafId = requestAnimationFrame(this._rafFunc)\r\n        }\r\n        _CancelAnimationFrame() {\r\n            if (this._rafId !== -1) {\r\n                cancelAnimationFrame(this._rafId);\r\n                this._rafId = -1\r\n            }\r\n        }\r\n        _OnRAFCallback() {\r\n            this._rafId = -1;\r\n            for (const f of this._rafCallbacks)\r\n                f();\r\n            this._RequestAnimationFrame()\r\n        }\r\n        TryPlayMedia(mediaElem) {\r\n            this._runtimeDomHandler.TryPlayMedia(mediaElem)\r\n        }\r\n        RemovePendingPlay(mediaElem) {\r\n            this._runtimeDomHandler.RemovePendingPlay(mediaElem)\r\n        }\r\n        _PlayPendingMedia() {\r\n            this._runtimeDomHandler._PlayPendingMedia()\r\n        }\r\n        SetSilent(s) {\r\n            this._runtimeDomHandler.SetSilent(s)\r\n        }\r\n        IsAudioFormatSupported(typeStr) {\r\n            return !!supportedAudioFormats[typeStr]\r\n        }\r\n        async _WasmDecodeWebMOpus(arrayBuffer) {\r\n            const result = await this.PostToRuntimeComponentAsync(\"runtime\", \"opus-decode\", {\r\n                \"arrayBuffer\": arrayBuffer\r\n            }, null, [arrayBuffer]);\r\n            return new Float32Array(result)\r\n        }\r\n        SetIsExportingToVideo(duration) {\r\n            this._isExportingToVideo = true;\r\n            this._exportToVideoDuration = duration\r\n        }\r\n        IsExportingToVideo() {\r\n            return this._isExportingToVideo\r\n        }\r\n        GetExportToVideoDuration() {\r\n            return this._exportToVideoDuration\r\n        }\r\n        IsAbsoluteURL(url) {\r\n            return \/^(?:[a-z\\-]+:)?\\\/\\\/\/.test(url) || url.substr(0, 5) === \"data:\" || url.substr(0, 5) === \"blob:\"\r\n        }\r\n        IsRelativeURL(url) {\r\n            return !this.IsAbsoluteURL(url)\r\n        }\r\n        async _MaybeGetCordovaScriptURL(url) {\r\n            if (this._exportType === \"cordova\" && (url.startsWith(\"file:\") || this._isFileProtocol && this.IsRelativeURL(url))) {\r\n                let filename = url;\r\n                if (filename.startsWith(this._runtimeBaseUrl))\r\n                    filename = filename.substr(this._runtimeBaseUrl.length);\r\n                const arrayBuffer = await this.CordovaFetchLocalFileAsArrayBuffer(filename);\r\n                const blob = new Blob([arrayBuffer],{\r\n                    type: \"application\/javascript\"\r\n                });\r\n                return URL.createObjectURL(blob)\r\n            } else\r\n                return url\r\n        }\r\n        async _OnCordovaFetchLocalFile(e) {\r\n            const filename = e[\"filename\"];\r\n            switch (e[\"as\"]) {\r\n            case \"text\":\r\n                return await this.CordovaFetchLocalFileAsText(filename);\r\n            case \"buffer\":\r\n                return await this.CordovaFetchLocalFileAsArrayBuffer(filename);\r\n            default:\r\n                throw new Error(\"unsupported type\");\r\n            }\r\n        }\r\n        _GetPermissionAPI() {\r\n            const api = window[\"cordova\"] && window[\"cordova\"][\"plugins\"] && window[\"cordova\"][\"plugins\"][\"permissions\"];\r\n            if (typeof api !== \"object\")\r\n                throw new Error(\"Permission API is not loaded\");\r\n            return api\r\n        }\r\n        _MapPermissionID(api, permission) {\r\n            const permissionID = api[permission];\r\n            if (typeof permissionID !== \"string\")\r\n                throw new Error(\"Invalid permission name\");\r\n            return permissionID\r\n        }\r\n        _HasPermission(id) {\r\n            const api = this._GetPermissionAPI();\r\n            return new Promise( (resolve, reject) => api[\"checkPermission\"](this._MapPermissionID(api, id), status => resolve(!!status[\"hasPermission\"]), reject))\r\n        }\r\n        _RequestPermission(id) {\r\n            const api = this._GetPermissionAPI();\r\n            return new Promise( (resolve, reject) => api[\"requestPermission\"](this._MapPermissionID(api, id), status => resolve(!!status[\"hasPermission\"]), reject))\r\n        }\r\n        async RequestPermissions(permissions) {\r\n            if (this.GetExportType() !== \"cordova\")\r\n                return true;\r\n            if (this.IsiOSCordova())\r\n                return true;\r\n            for (const id of permissions) {\r\n                const alreadyGranted = await this._HasPermission(id);\r\n                if (alreadyGranted)\r\n                    continue;\r\n                const granted = await this._RequestPermission(id);\r\n                if (granted === false)\r\n                    return false\r\n            }\r\n            return true\r\n        }\r\n        async RequirePermissions(...permissions) {\r\n            if (await this.RequestPermissions(permissions) === false)\r\n                throw new Error(\"Permission not granted\");\r\n        }\r\n        CordovaFetchLocalFile(filename) {\r\n            const path = window[\"cordova\"][\"file\"][\"applicationDirectory\"] + \"www\/\" + filename.toLowerCase();\r\n            return new Promise( (resolve, reject) => {\r\n                window[\"resolveLocalFileSystemURL\"](path, entry => {\r\n                    entry[\"file\"](resolve, reject)\r\n                }\r\n                , reject)\r\n            }\r\n            )\r\n        }\r\n        async CordovaFetchLocalFileAsText(filename) {\r\n            const file = await this.CordovaFetchLocalFile(filename);\r\n            return await BlobToString(file)\r\n        }\r\n        _CordovaMaybeStartNextArrayBufferRead() {\r\n            if (!queuedArrayBufferReads.length)\r\n                return;\r\n            if (activeArrayBufferReads >= MAX_ARRAYBUFFER_READS)\r\n                return;\r\n            activeArrayBufferReads++;\r\n            const job = queuedArrayBufferReads.shift();\r\n            this._CordovaDoFetchLocalFileAsAsArrayBuffer(job.filename, job.successCallback, job.errorCallback)\r\n        }\r\n        CordovaFetchLocalFileAsArrayBuffer(filename) {\r\n            return new Promise( (resolve, reject) => {\r\n                queuedArrayBufferReads.push({\r\n                    filename: filename,\r\n                    successCallback: result => {\r\n                        activeArrayBufferReads--;\r\n                        this._CordovaMaybeStartNextArrayBufferRead();\r\n                        resolve(result)\r\n                    }\r\n                    ,\r\n                    errorCallback: err => {\r\n                        activeArrayBufferReads--;\r\n                        this._CordovaMaybeStartNextArrayBufferRead();\r\n                        reject(err)\r\n                    }\r\n                });\r\n                this._CordovaMaybeStartNextArrayBufferRead()\r\n            }\r\n            )\r\n        }\r\n        async _CordovaDoFetchLocalFileAsAsArrayBuffer(filename, successCallback, errorCallback) {\r\n            try {\r\n                const file = await this.CordovaFetchLocalFile(filename);\r\n                const arrayBuffer = await BlobToArrayBuffer(file);\r\n                successCallback(arrayBuffer)\r\n            } catch (err) {\r\n                errorCallback(err)\r\n            }\r\n        }\r\n        _SendWrapperMessage(o) {\r\n            if (this._exportType === \"windows-webview2\")\r\n                window[\"chrome\"][\"webview\"][\"postMessage\"](JSON.stringify(o));\r\n            else if (this._exportType === \"macos-wkwebview\")\r\n                window[\"webkit\"][\"messageHandlers\"][\"C3Wrapper\"][\"postMessage\"](JSON.stringify(o));\r\n            else\r\n                throw new Error(\"cannot send wrapper message\");\r\n        }\r\n        async _ConvertDataUrisToBlobs() {\r\n            const promises = [];\r\n            for (const [filename,data] of Object.entries(this._localFileBlobs))\r\n                promises.push(this._ConvertDataUriToBlobs(filename, data));\r\n            await Promise.all(promises)\r\n        }\r\n        async _ConvertDataUriToBlobs(filename, data) {\r\n            if (typeof data === \"object\") {\r\n                this._localFileBlobs[filename] = new Blob([data[\"str\"]],{\r\n                    \"type\": data[\"type\"]\r\n                });\r\n                this._localFileStrings[filename] = data[\"str\"]\r\n            } else {\r\n                let blob = await this._FetchDataUri(data);\r\n                if (!blob)\r\n                    blob = this._DataURIToBinaryBlobSync(data);\r\n                this._localFileBlobs[filename] = blob\r\n            }\r\n        }\r\n        async _FetchDataUri(dataUri) {\r\n            try {\r\n                const response = await fetch(dataUri);\r\n                return await response.blob()\r\n            } catch (err) {\r\n                console.warn(\"Failed to fetch a data: URI. Falling back to a slower workaround. This is probably because the Content Security Policy unnecessarily blocked it. Allow data: URIs in your CSP to avoid this.\", err);\r\n                return null\r\n            }\r\n        }\r\n        _DataURIToBinaryBlobSync(datauri) {\r\n            const o = this._ParseDataURI(datauri);\r\n            return this._BinaryStringToBlob(o.data, o.mime_type)\r\n        }\r\n        _ParseDataURI(datauri) {\r\n            const comma = datauri.indexOf(\",\");\r\n            if (comma < 0)\r\n                throw new URIError(\"expected comma in data: uri\");\r\n            const typepart = datauri.substring(5, comma);\r\n            const datapart = datauri.substring(comma + 1);\r\n            const typearr = typepart.split(\";\");\r\n            const mimetype = typearr[0] || \"\";\r\n            const encoding1 = typearr[1];\r\n            const encoding2 = typearr[2];\r\n            let decodeddata;\r\n            if (encoding1 === \"base64\" || encoding2 === \"base64\")\r\n                decodeddata = atob(datapart);\r\n            else\r\n                decodeddata = decodeURIComponent(datapart);\r\n            return {\r\n                mime_type: mimetype,\r\n                data: decodeddata\r\n            }\r\n        }\r\n        _BinaryStringToBlob(binstr, mime_type) {\r\n            let len = binstr.length;\r\n            let len32 = len >> 2;\r\n            let a8 = new Uint8Array(len);\r\n            let a32 = new Uint32Array(a8.buffer,0,len32);\r\n            let i, j;\r\n            for (i = 0,\r\n            j = 0; i < len32; ++i)\r\n                a32[i] = binstr.charCodeAt(j++) | binstr.charCodeAt(j++) << 8 | binstr.charCodeAt(j++) << 16 | binstr.charCodeAt(j++) << 24;\r\n            let tailLength = len & 3;\r\n            while (tailLength--) {\r\n                a8[j] = binstr.charCodeAt(j);\r\n                ++j\r\n            }\r\n            return new Blob([a8],{\r\n                \"type\": mime_type\r\n            })\r\n        }\r\n    }\r\n}\r\n;\r\n'use strict';\r\n{\r\n    const RuntimeInterface = self.RuntimeInterface;\r\n    function IsCompatibilityMouseEvent(e) {\r\n        return e[\"sourceCapabilities\"] && e[\"sourceCapabilities\"][\"firesTouchEvents\"] || e[\"originalEvent\"] && e[\"originalEvent\"][\"sourceCapabilities\"] && e[\"originalEvent\"][\"sourceCapabilities\"][\"firesTouchEvents\"]\r\n    }\r\n    const KEY_CODE_ALIASES = new Map([[\"OSLeft\", \"MetaLeft\"], [\"OSRight\", \"MetaRight\"]]);\r\n    const DISPATCH_RUNTIME_AND_SCRIPT = {\r\n        \"dispatchRuntimeEvent\": true,\r\n        \"dispatchUserScriptEvent\": true\r\n    };\r\n    const DISPATCH_SCRIPT_ONLY = {\r\n        \"dispatchUserScriptEvent\": true\r\n    };\r\n    const DISPATCH_RUNTIME_ONLY = {\r\n        \"dispatchRuntimeEvent\": true\r\n    };\r\n    function AddStyleSheet(cssUrl) {\r\n        return new Promise( (resolve, reject) => {\r\n            const styleLink = document.createElement(\"link\");\r\n            styleLink.onload = () => resolve(styleLink);\r\n            styleLink.onerror = err => reject(err);\r\n            styleLink.rel = \"stylesheet\";\r\n            styleLink.href = cssUrl;\r\n            document.head.appendChild(styleLink)\r\n        }\r\n        )\r\n    }\r\n    function FetchImage(url) {\r\n        return new Promise( (resolve, reject) => {\r\n            const img = new Image;\r\n            img.onload = () => resolve(img);\r\n            img.onerror = err => reject(err);\r\n            img.src = url\r\n        }\r\n        )\r\n    }\r\n    async function BlobToImage(blob) {\r\n        const blobUrl = URL.createObjectURL(blob);\r\n        try {\r\n            return await FetchImage(blobUrl)\r\n        } finally {\r\n            URL.revokeObjectURL(blobUrl)\r\n        }\r\n    }\r\n    function BlobToString(blob) {\r\n        return new Promise( (resolve, reject) => {\r\n            let fileReader = new FileReader;\r\n            fileReader.onload = e => resolve(e.target.result);\r\n            fileReader.onerror = err => reject(err);\r\n            fileReader.readAsText(blob)\r\n        }\r\n        )\r\n    }\r\n    async function BlobToSvgImage(blob, width, height) {\r\n        if (!\/firefox\/i.test(navigator.userAgent))\r\n            return await BlobToImage(blob);\r\n        let str = await BlobToString(blob);\r\n        const parser = new DOMParser;\r\n        const doc = parser.parseFromString(str, \"image\/svg+xml\");\r\n        const rootElem = doc.documentElement;\r\n        if (rootElem.hasAttribute(\"width\") && rootElem.hasAttribute(\"height\")) {\r\n            const widthStr = rootElem.getAttribute(\"width\");\r\n            const heightStr = rootElem.getAttribute(\"height\");\r\n            if (!widthStr.includes(\"%\") && !heightStr.includes(\"%\"))\r\n                return await BlobToImage(blob)\r\n        }\r\n        rootElem.setAttribute(\"width\", width + \"px\");\r\n        rootElem.setAttribute(\"height\", height + \"px\");\r\n        const serializer = new XMLSerializer;\r\n        str = serializer.serializeToString(doc);\r\n        blob = new Blob([str],{\r\n            type: \"image\/svg+xml\"\r\n        });\r\n        return await BlobToImage(blob)\r\n    }\r\n    function IsInContentEditable(el) {\r\n        do {\r\n            if (el.parentNode && el.hasAttribute(\"contenteditable\"))\r\n                return true;\r\n            el = el.parentNode\r\n        } while (el);\r\n        return false\r\n    }\r\n    const keyboardInputElementTagNames = new Set([\"input\", \"textarea\", \"datalist\", \"select\"]);\r\n    function IsKeyboardInputElement(elem) {\r\n        return keyboardInputElementTagNames.has(elem.tagName.toLowerCase()) || IsInContentEditable(elem)\r\n    }\r\n    const canvasOrDocTags = new Set([\"canvas\", \"body\", \"html\"]);\r\n    function PreventDefaultOnCanvasOrDoc(e) {\r\n        const tagName = e.target.tagName.toLowerCase();\r\n        if (canvasOrDocTags.has(tagName))\r\n            e.preventDefault()\r\n    }\r\n    function BlockWheelZoom(e) {\r\n        if (e.metaKey || e.ctrlKey)\r\n            e.preventDefault()\r\n    }\r\n    self[\"C3_GetSvgImageSize\"] = async function(blob) {\r\n        const img = await BlobToImage(blob);\r\n        if (img.width > 0 && img.height > 0)\r\n            return [img.width, img.height];\r\n        else {\r\n            img.style.position = \"absolute\";\r\n            img.style.left = \"0px\";\r\n            img.style.top = \"0px\";\r\n            img.style.visibility = \"hidden\";\r\n            document.body.appendChild(img);\r\n            const rc = img.getBoundingClientRect();\r\n            document.body.removeChild(img);\r\n            return [rc.width, rc.height]\r\n        }\r\n    }\r\n    ;\r\n    self[\"C3_RasterSvgImageBlob\"] = async function(blob, imageWidth, imageHeight, surfaceWidth, surfaceHeight) {\r\n        const img = await BlobToSvgImage(blob, imageWidth, imageHeight);\r\n        const canvas = document.createElement(\"canvas\");\r\n        canvas.width = surfaceWidth;\r\n        canvas.height = surfaceHeight;\r\n        const ctx = canvas.getContext(\"2d\");\r\n        ctx.drawImage(img, 0, 0, imageWidth, imageHeight);\r\n        return canvas\r\n    }\r\n    ;\r\n    let isCordovaPaused = false;\r\n    document.addEventListener(\"pause\", () => isCordovaPaused = true);\r\n    document.addEventListener(\"resume\", () => isCordovaPaused = false);\r\n    function ParentHasFocus() {\r\n        try {\r\n            return window.parent && window.parent.document.hasFocus()\r\n        } catch (err) {\r\n            return false\r\n        }\r\n    }\r\n    function KeyboardIsVisible() {\r\n        const elem = document.activeElement;\r\n        if (!elem)\r\n            return false;\r\n        const tagName = elem.tagName.toLowerCase();\r\n        const inputTypes = new Set([\"email\", \"number\", \"password\", \"search\", \"tel\", \"text\", \"url\"]);\r\n        if (tagName === \"textarea\")\r\n            return true;\r\n        if (tagName === \"input\")\r\n            return inputTypes.has(elem.type.toLowerCase() || \"text\");\r\n        return IsInContentEditable(elem)\r\n    }\r\n    const DOM_COMPONENT_ID = \"runtime\";\r\n    const HANDLER_CLASS = class RuntimeDOMHandler extends self.DOMHandler {\r\n        constructor(iRuntime) {\r\n            super(iRuntime, DOM_COMPONENT_ID);\r\n            this._isFirstSizeUpdate = true;\r\n            this._simulatedResizeTimerId = -1;\r\n            this._targetOrientation = \"any\";\r\n            this._attachedDeviceOrientationEvent = false;\r\n            this._attachedDeviceMotionEvent = false;\r\n            this._debugHighlightElem = null;\r\n            this._isExportToVideo = false;\r\n            this._exportVideoProgressMessage = \"\";\r\n            this._exportVideoUpdateTimerId = -1;\r\n            this._pointerRawUpdateRateLimiter = null;\r\n            this._lastPointerRawUpdateEvent = null;\r\n            this._pointerRawMovementX = 0;\r\n            this._pointerRawMovementY = 0;\r\n            this._enableAndroidVKDetection = false;\r\n            this._lastWindowWidth = iRuntime._GetWindowInnerWidth();\r\n            this._lastWindowHeight = iRuntime._GetWindowInnerHeight();\r\n            this._virtualKeyboardHeight = 0;\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"canvas\", \"update-size\", e => this._OnUpdateCanvasSize(e));\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"invoke-download\", e => this._OnInvokeDownload(e));\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"raster-svg-image\", e => this._OnRasterSvgImage(e));\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"get-svg-image-size\", e => this._OnGetSvgImageSize(e));\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"set-target-orientation\", e => this._OnSetTargetOrientation(e));\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"register-sw\", () => this._OnRegisterSW());\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"post-to-debugger\", e => this._OnPostToDebugger(e));\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"go-to-script\", e => this._OnPostToDebugger(e));\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"before-start-ticking\", () => this._OnBeforeStartTicking());\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"debug-highlight\", e => this._OnDebugHighlight(e));\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"enable-device-orientation\", () => this._AttachDeviceOrientationEvent());\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"enable-device-motion\", () => this._AttachDeviceMotionEvent());\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"add-stylesheet\", e => this._OnAddStylesheet(e));\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"alert\", e => this._OnAlert(e));\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"hide-cordova-splash\", () => this._OnHideCordovaSplash());\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"set-exporting-to-video\", e => this._SetExportingToVideo(e));\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"export-to-video-progress\", e => this._OnExportVideoProgress(e));\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"exported-to-video\", e => this._OnExportedToVideo(e));\r\n            iRuntime.AddRuntimeComponentMessageHandler(\"runtime\", \"exported-to-image-sequence\", e => this._OnExportedToImageSequence(e));\r\n            const allowDefaultContextMenuTagNames = new Set([\"input\", \"textarea\", \"datalist\"]);\r\n            window.addEventListener(\"contextmenu\", e => {\r\n                const t = e.target;\r\n                const name = t.tagName.toLowerCase();\r\n                if (!allowDefaultContextMenuTagNames.has(name) && !IsInContentEditable(t))\r\n                    e.preventDefault()\r\n            }\r\n            );\r\n            const canvas = iRuntime.GetCanvas();\r\n            window.addEventListener(\"selectstart\", PreventDefaultOnCanvasOrDoc);\r\n            window.addEventListener(\"gesturehold\", PreventDefaultOnCanvasOrDoc);\r\n            canvas.addEventListener(\"selectstart\", PreventDefaultOnCanvasOrDoc);\r\n            canvas.addEventListener(\"gesturehold\", PreventDefaultOnCanvasOrDoc);\r\n            window.addEventListener(\"touchstart\", PreventDefaultOnCanvasOrDoc, {\r\n                \"passive\": false\r\n            });\r\n            if (typeof PointerEvent !== \"undefined\") {\r\n                window.addEventListener(\"pointerdown\", PreventDefaultOnCanvasOrDoc, {\r\n                    \"passive\": false\r\n                });\r\n                canvas.addEventListener(\"pointerdown\", PreventDefaultOnCanvasOrDoc)\r\n            } else\r\n                canvas.addEventListener(\"touchstart\", PreventDefaultOnCanvasOrDoc);\r\n            this._mousePointerLastButtons = 0;\r\n            window.addEventListener(\"mousedown\", e => {\r\n                if (e.button === 1)\r\n                    e.preventDefault()\r\n            }\r\n            );\r\n            window.addEventListener(\"mousewheel\", BlockWheelZoom, {\r\n                \"passive\": false\r\n            });\r\n            window.addEventListener(\"wheel\", BlockWheelZoom, {\r\n                \"passive\": false\r\n            });\r\n            window.addEventListener(\"resize\", () => this._OnWindowResize());\r\n            window.addEventListener(\"fullscreenchange\", () => this._OnFullscreenChange());\r\n            window.addEventListener(\"webkitfullscreenchange\", () => this._OnFullscreenChange());\r\n            window.addEventListener(\"mozfullscreenchange\", () => this._OnFullscreenChange());\r\n            window.addEventListener(\"fullscreenerror\", e => this._OnFullscreenError(e));\r\n            window.addEventListener(\"webkitfullscreenerror\", e => this._OnFullscreenError(e));\r\n            window.addEventListener(\"mozfullscreenerror\", e => this._OnFullscreenError(e));\r\n            if (iRuntime.IsiOSWebView())\r\n                if (window[\"visualViewport\"]) {\r\n                    let lastVisualViewportHeight = Infinity;\r\n                    window[\"visualViewport\"].addEventListener(\"resize\", () => {\r\n                        const curVisualViewportHeight = window[\"visualViewport\"].height;\r\n                        if (curVisualViewportHeight > lastVisualViewportHeight)\r\n                            document.scrollingElement.scrollTop = 0;\r\n                        lastVisualViewportHeight = curVisualViewportHeight\r\n                    }\r\n                    )\r\n                } else\r\n                    window.addEventListener(\"focusout\", () => {\r\n                        if (!KeyboardIsVisible())\r\n                            document.scrollingElement.scrollTop = 0\r\n                    }\r\n                    );\r\n            self[\"C3WrapperOnMessage\"] = msg => this._OnWrapperMessage(msg);\r\n            this._mediaPendingPlay = new Set;\r\n            this._mediaRemovedPendingPlay = new WeakSet;\r\n            this._isSilent = false\r\n        }\r\n        _OnBeforeStartTicking() {\r\n            self.setTimeout( () => {\r\n                this._enableAndroidVKDetection = true\r\n            }\r\n            , 1E3);\r\n            if (this._iRuntime.GetExportType() === \"cordova\") {\r\n                document.addEventListener(\"pause\", () => this._OnVisibilityChange(true));\r\n                document.addEventListener(\"resume\", () => this._OnVisibilityChange(false))\r\n            } else\r\n                document.addEventListener(\"visibilitychange\", () => this._OnVisibilityChange(document.hidden));\r\n            return {\r\n                \"isSuspended\": !!(document.hidden || isCordovaPaused)\r\n            }\r\n        }\r\n        Attach() {\r\n            window.addEventListener(\"focus\", () => this._PostRuntimeEvent(\"window-focus\"));\r\n            window.addEventListener(\"blur\", () => {\r\n                this._PostRuntimeEvent(\"window-blur\", {\r\n                    \"parentHasFocus\": ParentHasFocus()\r\n                });\r\n                this._mousePointerLastButtons = 0\r\n            }\r\n            );\r\n            window.addEventListener(\"focusin\", e => {\r\n                if (IsKeyboardInputElement(e.target))\r\n                    this._PostRuntimeEvent(\"keyboard-blur\")\r\n            }\r\n            );\r\n            window.addEventListener(\"keydown\", e => this._OnKeyEvent(\"keydown\", e));\r\n            window.addEventListener(\"keyup\", e => this._OnKeyEvent(\"keyup\", e));\r\n            window.addEventListener(\"dblclick\", e => this._OnMouseEvent(\"dblclick\", e, DISPATCH_RUNTIME_AND_SCRIPT));\r\n            window.addEventListener(\"wheel\", e => this._OnMouseWheelEvent(\"wheel\", e));\r\n            if (typeof PointerEvent !== \"undefined\") {\r\n                window.addEventListener(\"pointerdown\", e => {\r\n                    this._HandlePointerDownFocus(e);\r\n                    this._OnPointerEvent(\"pointerdown\", e)\r\n                }\r\n                );\r\n                if (this._iRuntime.UsesWorker() && typeof window[\"onpointerrawupdate\"] !== \"undefined\" && self === self.top) {\r\n                    this._pointerRawUpdateRateLimiter = new self.RateLimiter( () => this._DoSendPointerRawUpdate(),5);\r\n                    this._pointerRawUpdateRateLimiter.SetCanRunImmediate(true);\r\n                    window.addEventListener(\"pointerrawupdate\", e => this._OnPointerRawUpdate(e))\r\n                } else\r\n                    window.addEventListener(\"pointermove\", e => this._OnPointerEvent(\"pointermove\", e));\r\n                window.addEventListener(\"pointerup\", e => this._OnPointerEvent(\"pointerup\", e));\r\n                window.addEventListener(\"pointercancel\", e => this._OnPointerEvent(\"pointercancel\", e))\r\n            } else {\r\n                window.addEventListener(\"mousedown\", e => {\r\n                    this._HandlePointerDownFocus(e);\r\n                    this._OnMouseEventAsPointer(\"pointerdown\", e)\r\n                }\r\n                );\r\n                window.addEventListener(\"mousemove\", e => this._OnMouseEventAsPointer(\"pointermove\", e));\r\n                window.addEventListener(\"mouseup\", e => this._OnMouseEventAsPointer(\"pointerup\", e));\r\n                window.addEventListener(\"touchstart\", e => {\r\n                    this._HandlePointerDownFocus(e);\r\n                    this._OnTouchEvent(\"pointerdown\", e)\r\n                }\r\n                );\r\n                window.addEventListener(\"touchmove\", e => this._OnTouchEvent(\"pointermove\", e));\r\n                window.addEventListener(\"touchend\", e => this._OnTouchEvent(\"pointerup\", e));\r\n                window.addEventListener(\"touchcancel\", e => this._OnTouchEvent(\"pointercancel\", e))\r\n            }\r\n            const playFunc = () => this._PlayPendingMedia();\r\n            window.addEventListener(\"pointerup\", playFunc, true);\r\n            window.addEventListener(\"touchend\", playFunc, true);\r\n            window.addEventListener(\"click\", playFunc, true);\r\n            window.addEventListener(\"keydown\", playFunc, true);\r\n            window.addEventListener(\"gamepadconnected\", playFunc, true);\r\n            if (this._iRuntime.IsAndroid() && !this._iRuntime.IsAndroidWebView() && navigator[\"virtualKeyboard\"]) {\r\n                navigator[\"virtualKeyboard\"][\"overlaysContent\"] = true;\r\n                navigator[\"virtualKeyboard\"].addEventListener(\"geometrychange\", () => {\r\n                    this._OnAndroidVirtualKeyboardChange(this._GetWindowInnerHeight(), navigator[\"virtualKeyboard\"][\"boundingRect\"][\"height\"])\r\n                }\r\n                )\r\n            }\r\n        }\r\n        _OnAndroidVirtualKeyboardChange(windowHeight, vkHeight) {\r\n            document.body.style.transform = \"\";\r\n            if (vkHeight > 0) {\r\n                const activeElement = document.activeElement;\r\n                if (activeElement) {\r\n                    const rc = activeElement.getBoundingClientRect();\r\n                    const rcMidY = (rc.top + rc.bottom) \/ 2;\r\n                    const targetY = (windowHeight - vkHeight) \/ 2;\r\n                    let shiftY = rcMidY - targetY;\r\n                    if (shiftY > vkHeight)\r\n                        shiftY = vkHeight;\r\n                    if (shiftY < 0)\r\n                        shiftY = 0;\r\n                    if (shiftY > 0)\r\n                        document.body.style.transform = `translateY(${-shiftY}px)`\r\n                }\r\n            }\r\n        }\r\n        _PostRuntimeEvent(name, data) {\r\n            this.PostToRuntime(name, data || null, DISPATCH_RUNTIME_ONLY)\r\n        }\r\n        _GetWindowInnerWidth() {\r\n            return this._iRuntime._GetWindowInnerWidth()\r\n        }\r\n        _GetWindowInnerHeight() {\r\n            return this._iRuntime._GetWindowInnerHeight()\r\n        }\r\n        _OnWindowResize() {\r\n            if (this._isExportToVideo)\r\n                return;\r\n            const width = this._GetWindowInnerWidth();\r\n            const height = this._GetWindowInnerHeight();\r\n            if (this._iRuntime.IsAndroidWebView())\r\n                if (this._enableAndroidVKDetection)\r\n                    if (this._lastWindowWidth === width && height < this._lastWindowHeight) {\r\n                        this._virtualKeyboardHeight = this._lastWindowHeight - height;\r\n                        this._OnAndroidVirtualKeyboardChange(this._lastWindowHeight, this._virtualKeyboardHeight);\r\n                        return\r\n                    } else {\r\n                        if (this._virtualKeyboardHeight > 0) {\r\n                            this._virtualKeyboardHeight = 0;\r\n                            this._OnAndroidVirtualKeyboardChange(height, this._virtualKeyboardHeight)\r\n                        }\r\n                        this._lastWindowWidth = width;\r\n                        this._lastWindowHeight = height\r\n                    }\r\n                else {\r\n                    this._lastWindowWidth = width;\r\n                    this._lastWindowHeight = height\r\n                }\r\n            this.PostToRuntime(\"window-resize\", {\r\n                \"innerWidth\": width,\r\n                \"innerHeight\": height,\r\n                \"devicePixelRatio\": window.devicePixelRatio,\r\n                \"isFullscreen\": RuntimeInterface.IsDocumentFullscreen()\r\n            });\r\n            if (this._iRuntime.IsiOSWebView()) {\r\n                if (this._simulatedResizeTimerId !== -1)\r\n                    clearTimeout(this._simulatedResizeTimerId);\r\n                this._OnSimulatedResize(width, height, 0)\r\n            }\r\n        }\r\n        _ScheduleSimulatedResize(width, height, count) {\r\n            if (this._simulatedResizeTimerId !== -1)\r\n                clearTimeout(this._simulatedResizeTimerId);\r\n            this._simulatedResizeTimerId = setTimeout( () => this._OnSimulatedResize(width, height, count), 48)\r\n        }\r\n        _OnSimulatedResize(originalWidth, originalHeight, count) {\r\n            const width = this._GetWindowInnerWidth();\r\n            const height = this._GetWindowInnerHeight();\r\n            this._simulatedResizeTimerId = -1;\r\n            if (width != originalWidth || height != originalHeight)\r\n                this.PostToRuntime(\"window-resize\", {\r\n                    \"innerWidth\": width,\r\n                    \"innerHeight\": height,\r\n                    \"devicePixelRatio\": window.devicePixelRatio,\r\n                    \"isFullscreen\": RuntimeInterface.IsDocumentFullscreen()\r\n                });\r\n            else if (count < 10)\r\n                this._ScheduleSimulatedResize(width, height, count + 1)\r\n        }\r\n        _OnSetTargetOrientation(e) {\r\n            this._targetOrientation = e[\"targetOrientation\"]\r\n        }\r\n        _TrySetTargetOrientation() {\r\n            const orientation = this._targetOrientation;\r\n            if (screen[\"orientation\"] && screen[\"orientation\"][\"lock\"])\r\n                screen[\"orientation\"][\"lock\"](orientation).catch(err => console.warn(\"[Construct] Failed to lock orientation: \", err));\r\n            else\r\n                try {\r\n                    let result = false;\r\n                    if (screen[\"lockOrientation\"])\r\n                        result = screen[\"lockOrientation\"](orientation);\r\n                    else if (screen[\"webkitLockOrientation\"])\r\n                        result = screen[\"webkitLockOrientation\"](orientation);\r\n                    else if (screen[\"mozLockOrientation\"])\r\n                        result = screen[\"mozLockOrientation\"](orientation);\r\n                    else if (screen[\"msLockOrientation\"])\r\n                        result = screen[\"msLockOrientation\"](orientation);\r\n                    if (!result)\r\n                        console.warn(\"[Construct] Failed to lock orientation\")\r\n                } catch (err) {\r\n                    console.warn(\"[Construct] Failed to lock orientation: \", err)\r\n                }\r\n        }\r\n        _OnFullscreenChange() {\r\n            if (this._isExportToVideo)\r\n                return;\r\n            const isDocFullscreen = RuntimeInterface.IsDocumentFullscreen();\r\n            if (isDocFullscreen && this._targetOrientation !== \"any\")\r\n                this._TrySetTargetOrientation();\r\n            this.PostToRuntime(\"fullscreenchange\", {\r\n                \"isFullscreen\": isDocFullscreen,\r\n                \"innerWidth\": this._GetWindowInnerWidth(),\r\n                \"innerHeight\": this._GetWindowInnerHeight()\r\n            })\r\n        }\r\n        _OnFullscreenError(e) {\r\n            console.warn(\"[Construct] Fullscreen request failed: \", e);\r\n            this.PostToRuntime(\"fullscreenerror\", {\r\n                \"isFullscreen\": RuntimeInterface.IsDocumentFullscreen(),\r\n                \"innerWidth\": this._GetWindowInnerWidth(),\r\n                \"innerHeight\": this._GetWindowInnerHeight()\r\n            })\r\n        }\r\n        _OnVisibilityChange(isHidden) {\r\n            if (isHidden)\r\n                this._iRuntime._CancelAnimationFrame();\r\n            else\r\n                this._iRuntime._RequestAnimationFrame();\r\n            this.PostToRuntime(\"visibilitychange\", {\r\n                \"hidden\": isHidden\r\n            })\r\n        }\r\n        _OnKeyEvent(name, e) {\r\n            if (e.key === \"Backspace\")\r\n                PreventDefaultOnCanvasOrDoc(e);\r\n            if (this._isExportToVideo)\r\n                return;\r\n            const code = KEY_CODE_ALIASES.get(e.code) || e.code;\r\n            this._PostToRuntimeMaybeSync(name, {\r\n                \"code\": code,\r\n                \"key\": e.key,\r\n                \"which\": e.which,\r\n                \"repeat\": e.repeat,\r\n                \"altKey\": e.altKey,\r\n                \"ctrlKey\": e.ctrlKey,\r\n                \"metaKey\": e.metaKey,\r\n                \"shiftKey\": e.shiftKey,\r\n                \"timeStamp\": e.timeStamp\r\n            }, DISPATCH_RUNTIME_AND_SCRIPT)\r\n        }\r\n        _OnMouseWheelEvent(name, e) {\r\n            if (this._isExportToVideo)\r\n                return;\r\n            this.PostToRuntime(name, {\r\n                \"clientX\": e.clientX,\r\n                \"clientY\": e.clientY,\r\n                \"pageX\": e.pageX,\r\n                \"pageY\": e.pageY,\r\n                \"deltaX\": e.deltaX,\r\n                \"deltaY\": e.deltaY,\r\n                \"deltaZ\": e.deltaZ,\r\n                \"deltaMode\": e.deltaMode,\r\n                \"timeStamp\": e.timeStamp\r\n            }, DISPATCH_RUNTIME_AND_SCRIPT)\r\n        }\r\n        _OnMouseEvent(name, e, opts) {\r\n            if (this._isExportToVideo)\r\n                return;\r\n            if (IsCompatibilityMouseEvent(e))\r\n                return;\r\n            this._PostToRuntimeMaybeSync(name, {\r\n                \"button\": e.button,\r\n                \"buttons\": e.buttons,\r\n                \"clientX\": e.clientX,\r\n                \"clientY\": e.clientY,\r\n                \"pageX\": e.pageX,\r\n                \"pageY\": e.pageY,\r\n                \"movementX\": e.movementX || 0,\r\n                \"movementY\": e.movementY || 0,\r\n                \"timeStamp\": e.timeStamp\r\n            }, opts)\r\n        }\r\n        _OnMouseEventAsPointer(name, e) {\r\n            if (this._isExportToVideo)\r\n                return;\r\n            if (IsCompatibilityMouseEvent(e))\r\n                return;\r\n            const pointerId = 1;\r\n            const lastButtons = this._mousePointerLastButtons;\r\n            if (name === \"pointerdown\" && lastButtons !== 0)\r\n                name = \"pointermove\";\r\n            else if (name === \"pointerup\" && e.buttons !== 0)\r\n                name = \"pointermove\";\r\n            this._PostToRuntimeMaybeSync(name, {\r\n                \"pointerId\": pointerId,\r\n                \"pointerType\": \"mouse\",\r\n                \"button\": e.button,\r\n                \"buttons\": e.buttons,\r\n                \"lastButtons\": lastButtons,\r\n                \"clientX\": e.clientX,\r\n                \"clientY\": e.clientY,\r\n                \"pageX\": e.pageX,\r\n                \"pageY\": e.pageY,\r\n                \"movementX\": e.movementX || 0,\r\n                \"movementY\": e.movementY || 0,\r\n                \"width\": 0,\r\n                \"height\": 0,\r\n                \"pressure\": 0,\r\n                \"tangentialPressure\": 0,\r\n                \"tiltX\": 0,\r\n                \"tiltY\": 0,\r\n                \"twist\": 0,\r\n                \"timeStamp\": e.timeStamp\r\n            }, DISPATCH_RUNTIME_AND_SCRIPT);\r\n            this._mousePointerLastButtons = e.buttons;\r\n            this._OnMouseEvent(e.type, e, DISPATCH_SCRIPT_ONLY)\r\n        }\r\n        _OnPointerEvent(name, e) {\r\n            if (this._isExportToVideo)\r\n                return;\r\n            if (this._pointerRawUpdateRateLimiter && name !== \"pointermove\")\r\n                this._pointerRawUpdateRateLimiter.Reset();\r\n            let lastButtons = 0;\r\n            if (e.pointerType === \"mouse\")\r\n                lastButtons = this._mousePointerLastButtons;\r\n            this._PostToRuntimeMaybeSync(name, {\r\n                \"pointerId\": e.pointerId,\r\n                \"pointerType\": e.pointerType,\r\n                \"button\": e.button,\r\n                \"buttons\": e.buttons,\r\n                \"lastButtons\": lastButtons,\r\n                \"clientX\": e.clientX,\r\n                \"clientY\": e.clientY,\r\n                \"pageX\": e.pageX,\r\n                \"pageY\": e.pageY,\r\n                \"movementX\": (e.movementX || 0) + this._pointerRawMovementX,\r\n                \"movementY\": (e.movementY || 0) + this._pointerRawMovementY,\r\n                \"width\": e.width || 0,\r\n                \"height\": e.height || 0,\r\n                \"pressure\": e.pressure || 0,\r\n                \"tangentialPressure\": e[\"tangentialPressure\"] || 0,\r\n                \"tiltX\": e.tiltX || 0,\r\n                \"tiltY\": e.tiltY || 0,\r\n                \"twist\": e[\"twist\"] || 0,\r\n                \"timeStamp\": e.timeStamp\r\n            }, DISPATCH_RUNTIME_AND_SCRIPT);\r\n            this._pointerRawMovementX = 0;\r\n            this._pointerRawMovementY = 0;\r\n            if (e.pointerType === \"mouse\") {\r\n                let mouseEventName = \"mousemove\";\r\n                if (name === \"pointerdown\")\r\n                    mouseEventName = \"mousedown\";\r\n                else if (name === \"pointerup\")\r\n                    mouseEventName = \"mouseup\";\r\n                this._OnMouseEvent(mouseEventName, e, DISPATCH_SCRIPT_ONLY);\r\n                this._mousePointerLastButtons = e.buttons\r\n            }\r\n        }\r\n        _OnPointerRawUpdate(e) {\r\n            if (this._lastPointerRawUpdateEvent) {\r\n                this._pointerRawMovementX += this._lastPointerRawUpdateEvent.movementX || 0;\r\n                this._pointerRawMovementY += this._lastPointerRawUpdateEvent.movementY || 0\r\n            }\r\n            this._lastPointerRawUpdateEvent = e;\r\n            this._pointerRawUpdateRateLimiter.Call()\r\n        }\r\n        _DoSendPointerRawUpdate() {\r\n            this._OnPointerEvent(\"pointermove\", this._lastPointerRawUpdateEvent);\r\n            this._lastPointerRawUpdateEvent = null\r\n        }\r\n        _OnTouchEvent(fireName, e) {\r\n            if (this._isExportToVideo)\r\n                return;\r\n            for (let i = 0, len = e.changedTouches.length; i < len; ++i) {\r\n                const t = e.changedTouches[i];\r\n                this._PostToRuntimeMaybeSync(fireName, {\r\n                    \"pointerId\": t.identifier,\r\n                    \"pointerType\": \"touch\",\r\n                    \"button\": 0,\r\n                    \"buttons\": 0,\r\n                    \"lastButtons\": 0,\r\n                    \"clientX\": t.clientX,\r\n                    \"clientY\": t.clientY,\r\n                    \"pageX\": t.pageX,\r\n                    \"pageY\": t.pageY,\r\n                    \"movementX\": e.movementX || 0,\r\n                    \"movementY\": e.movementY || 0,\r\n                    \"width\": (t[\"radiusX\"] || t[\"webkitRadiusX\"] || 0) * 2,\r\n                    \"height\": (t[\"radiusY\"] || t[\"webkitRadiusY\"] || 0) * 2,\r\n                    \"pressure\": t[\"force\"] || t[\"webkitForce\"] || 0,\r\n                    \"tangentialPressure\": 0,\r\n                    \"tiltX\": 0,\r\n                    \"tiltY\": 0,\r\n                    \"twist\": t[\"rotationAngle\"] || 0,\r\n                    \"timeStamp\": e.timeStamp\r\n                }, DISPATCH_RUNTIME_AND_SCRIPT)\r\n            }\r\n        }\r\n        _HandlePointerDownFocus(e) {\r\n            if (window !== window.top)\r\n                window.focus();\r\n            if (this._IsElementCanvasOrDocument(e.target) && document.activeElement && !this._IsElementCanvasOrDocument(document.activeElement))\r\n                document.activeElement.blur()\r\n        }\r\n        _IsElementCanvasOrDocument(elem) {\r\n            return !elem || elem === document || elem === window || elem === document.body || elem.tagName.toLowerCase() === \"canvas\"\r\n        }\r\n        _AttachDeviceOrientationEvent() {\r\n            if (this._attachedDeviceOrientationEvent)\r\n                return;\r\n            this._attachedDeviceOrientationEvent = true;\r\n            window.addEventListener(\"deviceorientation\", e => this._OnDeviceOrientation(e));\r\n            window.addEventListener(\"deviceorientationabsolute\", e => this._OnDeviceOrientationAbsolute(e))\r\n        }\r\n        _AttachDeviceMotionEvent() {\r\n            if (this._attachedDeviceMotionEvent)\r\n                return;\r\n            this._attachedDeviceMotionEvent = true;\r\n            window.addEventListener(\"devicemotion\", e => this._OnDeviceMotion(e))\r\n        }\r\n        _OnDeviceOrientation(e) {\r\n            if (this._isExportToVideo)\r\n                return;\r\n            this.PostToRuntime(\"deviceorientation\", {\r\n                \"absolute\": !!e[\"absolute\"],\r\n                \"alpha\": e[\"alpha\"] || 0,\r\n                \"beta\": e[\"beta\"] || 0,\r\n                \"gamma\": e[\"gamma\"] || 0,\r\n                \"timeStamp\": e.timeStamp,\r\n                \"webkitCompassHeading\": e[\"webkitCompassHeading\"],\r\n                \"webkitCompassAccuracy\": e[\"webkitCompassAccuracy\"]\r\n            }, DISPATCH_RUNTIME_AND_SCRIPT)\r\n        }\r\n        _OnDeviceOrientationAbsolute(e) {\r\n            if (this._isExportToVideo)\r\n                return;\r\n            this.PostToRuntime(\"deviceorientationabsolute\", {\r\n                \"absolute\": !!e[\"absolute\"],\r\n                \"alpha\": e[\"alpha\"] || 0,\r\n                \"beta\": e[\"beta\"] || 0,\r\n                \"gamma\": e[\"gamma\"] || 0,\r\n                \"timeStamp\": e.timeStamp\r\n            }, DISPATCH_RUNTIME_AND_SCRIPT)\r\n        }\r\n        _OnDeviceMotion(e) {\r\n            if (this._isExportToVideo)\r\n                return;\r\n            let accProp = null;\r\n            const acc = e[\"acceleration\"];\r\n            if (acc)\r\n                accProp = {\r\n                    \"x\": acc[\"x\"] || 0,\r\n                    \"y\": acc[\"y\"] || 0,\r\n                    \"z\": acc[\"z\"] || 0\r\n                };\r\n            let withGProp = null;\r\n            const withG = e[\"accelerationIncludingGravity\"];\r\n            if (withG)\r\n                withGProp = {\r\n                    \"x\": withG[\"x\"] || 0,\r\n                    \"y\": withG[\"y\"] || 0,\r\n                    \"z\": withG[\"z\"] || 0\r\n                };\r\n            let rotationRateProp = null;\r\n            const rotationRate = e[\"rotationRate\"];\r\n            if (rotationRate)\r\n                rotationRateProp = {\r\n                    \"alpha\": rotationRate[\"alpha\"] || 0,\r\n                    \"beta\": rotationRate[\"beta\"] || 0,\r\n                    \"gamma\": rotationRate[\"gamma\"] || 0\r\n                };\r\n            this.PostToRuntime(\"devicemotion\", {\r\n                \"acceleration\": accProp,\r\n                \"accelerationIncludingGravity\": withGProp,\r\n                \"rotationRate\": rotationRateProp,\r\n                \"interval\": e[\"interval\"],\r\n                \"timeStamp\": e.timeStamp\r\n            }, DISPATCH_RUNTIME_AND_SCRIPT)\r\n        }\r\n        _OnUpdateCanvasSize(e) {\r\n            const runtimeInterface = this.GetRuntimeInterface();\r\n            if (runtimeInterface.IsExportingToVideo())\r\n                return;\r\n            const canvas = runtimeInterface.GetCanvas();\r\n            canvas.style.width = e[\"styleWidth\"] + \"px\";\r\n            canvas.style.height = e[\"styleHeight\"] + \"px\";\r\n            canvas.style.marginLeft = e[\"marginLeft\"] + \"px\";\r\n            canvas.style.marginTop = e[\"marginTop\"] + \"px\";\r\n            if (this._isFirstSizeUpdate) {\r\n                canvas.style.display = \"\";\r\n                this._isFirstSizeUpdate = false\r\n            }\r\n        }\r\n        _OnInvokeDownload(e) {\r\n            const url = e[\"url\"];\r\n            const filename = e[\"filename\"];\r\n            const a = document.createElement(\"a\");\r\n            const body = document.body;\r\n            a.textContent = filename;\r\n            a.href = url;\r\n            a.download = filename;\r\n            body.appendChild(a);\r\n            a.click();\r\n            body.removeChild(a)\r\n        }\r\n        async _OnRasterSvgImage(e) {\r\n            const blob = e[\"blob\"];\r\n            const imageWidth = e[\"imageWidth\"];\r\n            const imageHeight = e[\"imageHeight\"];\r\n            const surfaceWidth = e[\"surfaceWidth\"];\r\n            const surfaceHeight = e[\"surfaceHeight\"];\r\n            const imageBitmapOpts = e[\"imageBitmapOpts\"];\r\n            const canvas = await self[\"C3_RasterSvgImageBlob\"](blob, imageWidth, imageHeight, surfaceWidth, surfaceHeight);\r\n            let ret;\r\n            if (imageBitmapOpts)\r\n                ret = await createImageBitmap(canvas, imageBitmapOpts);\r\n            else\r\n                ret = await createImageBitmap(canvas);\r\n            return {\r\n                \"imageBitmap\": ret,\r\n                \"transferables\": [ret]\r\n            }\r\n        }\r\n        async _OnGetSvgImageSize(e) {\r\n            return await self[\"C3_GetSvgImageSize\"](e[\"blob\"])\r\n        }\r\n        async _OnAddStylesheet(e) {\r\n            await AddStyleSheet(e[\"url\"])\r\n        }\r\n        _PlayPendingMedia() {\r\n            const mediaToTryPlay = [...this._mediaPendingPlay];\r\n            this._mediaPendingPlay.clear();\r\n            if (!this._isSilent)\r\n                for (const mediaElem of mediaToTryPlay) {\r\n                    const playRet = mediaElem.play();\r\n                    if (playRet)\r\n                        playRet.catch(err => {\r\n                            if (!this._mediaRemovedPendingPlay.has(mediaElem))\r\n                                this._mediaPendingPlay.add(mediaElem)\r\n                        }\r\n                        )\r\n                }\r\n        }\r\n        TryPlayMedia(mediaElem) {\r\n            if (typeof mediaElem.play !== \"function\")\r\n                throw new Error(\"missing play function\");\r\n            this._mediaRemovedPendingPlay.delete(mediaElem);\r\n            let playRet;\r\n            try {\r\n                playRet = mediaElem.play()\r\n            } catch (err) {\r\n                this._mediaPendingPlay.add(mediaElem);\r\n                return\r\n            }\r\n            if (playRet)\r\n                playRet.catch(err => {\r\n                    if (!this._mediaRemovedPendingPlay.has(mediaElem))\r\n                        this._mediaPendingPlay.add(mediaElem)\r\n                }\r\n                )\r\n        }\r\n        RemovePendingPlay(mediaElem) {\r\n            this._mediaPendingPlay.delete(mediaElem);\r\n            this._mediaRemovedPendingPlay.add(mediaElem)\r\n        }\r\n        SetSilent(s) {\r\n            this._isSilent = !!s\r\n        }\r\n        _OnHideCordovaSplash() {\r\n            if (navigator[\"splashscreen\"] && navigator[\"splashscreen\"][\"hide\"])\r\n                navigator[\"splashscreen\"][\"hide\"]()\r\n        }\r\n        _OnDebugHighlight(e) {\r\n            const show = e[\"show\"];\r\n            if (!show) {\r\n                if (this._debugHighlightElem)\r\n                    this._debugHighlightElem.style.display = \"none\";\r\n                return\r\n            }\r\n            if (!this._debugHighlightElem) {\r\n                this._debugHighlightElem = document.createElement(\"div\");\r\n                this._debugHighlightElem.id = \"inspectOutline\";\r\n                document.body.appendChild(this._debugHighlightElem)\r\n            }\r\n            const elem = this._debugHighlightElem;\r\n            elem.style.display = \"\";\r\n            elem.style.left = e[\"left\"] - 1 + \"px\";\r\n            elem.style.top = e[\"top\"] - 1 + \"px\";\r\n            elem.style.width = e[\"width\"] + 2 + \"px\";\r\n            elem.style.height = e[\"height\"] + 2 + \"px\";\r\n            elem.textContent = e[\"name\"]\r\n        }\r\n        _OnRegisterSW() {\r\n            if (window[\"C3_RegisterSW\"])\r\n                window[\"C3_RegisterSW\"]()\r\n        }\r\n        _OnPostToDebugger(data) {\r\n            if (!window[\"c3_postToMessagePort\"])\r\n                return;\r\n            data[\"from\"] = \"runtime\";\r\n            window[\"c3_postToMessagePort\"](data)\r\n        }\r\n        _InvokeFunctionFromJS(name, params) {\r\n            return this.PostToRuntimeAsync(\"js-invoke-function\", {\r\n                \"name\": name,\r\n                \"params\": params\r\n            })\r\n        }\r\n        _OnAlert(e) {\r\n            alert(e[\"message\"])\r\n        }\r\n        _OnWrapperMessage(msg) {\r\n            if (msg === \"entered-fullscreen\") {\r\n                RuntimeInterface._SetWrapperIsFullscreenFlag(true);\r\n                this._OnFullscreenChange()\r\n            } else if (msg === \"exited-fullscreen\") {\r\n                RuntimeInterface._SetWrapperIsFullscreenFlag(false);\r\n                this._OnFullscreenChange()\r\n            } else\r\n                console.warn(\"Unknown wrapper message: \", msg)\r\n        }\r\n        _SetExportingToVideo(e) {\r\n            this._isExportToVideo = true;\r\n            const headerElem = document.createElement(\"h1\");\r\n            headerElem.id = \"exportToVideoMessage\";\r\n            headerElem.textContent = e[\"message\"];\r\n            document.body.prepend(headerElem);\r\n            document.body.classList.add(\"exportingToVideo\");\r\n            this.GetRuntimeInterface().GetCanvas().style.display = \"\";\r\n            this._iRuntime.SetIsExportingToVideo(e[\"duration\"])\r\n        }\r\n        _OnExportVideoProgress(e) {\r\n            this._exportVideoProgressMessage = e[\"message\"];\r\n            if (this._exportVideoUpdateTimerId === -1)\r\n                this._exportVideoUpdateTimerId = setTimeout( () => this._DoUpdateExportVideoProgressMessage(), 250)\r\n        }\r\n        _DoUpdateExportVideoProgressMessage() {\r\n            this._exportVideoUpdateTimerId = -1;\r\n            const headerElem = document.getElementById(\"exportToVideoMessage\");\r\n            if (headerElem)\r\n                headerElem.textContent = this._exportVideoProgressMessage\r\n        }\r\n        _OnExportedToVideo(e) {\r\n            window.c3_postToMessagePort({\r\n                \"type\": \"exported-video\",\r\n                \"blob\": e[\"blob\"],\r\n                \"time\": e[\"time\"]\r\n            })\r\n        }\r\n        _OnExportedToImageSequence(e) {\r\n            window.c3_postToMessagePort({\r\n                \"type\": \"exported-image-sequence\",\r\n                \"blobArr\": e[\"blobArr\"],\r\n                \"time\": e[\"time\"]\r\n            })\r\n        }\r\n    }\r\n    ;\r\n    RuntimeInterface.AddDOMHandlerClass(HANDLER_CLASS)\r\n}\r\n;\r\n'use strict';\r\n{\r\n    const DISPATCH_WORKER_SCRIPT_NAME = \"dispatchworker.js\";\r\n    const JOB_WORKER_SCRIPT_NAME = \"jobworker.js\";\r\n    self.JobSchedulerDOM = class JobSchedulerDOM {\r\n        constructor(runtimeInterface) {\r\n            this._runtimeInterface = runtimeInterface;\r\n            this._baseUrl = runtimeInterface.GetRuntimeBaseURL();\r\n            if (runtimeInterface.GetExportType() === \"preview\")\r\n                this._baseUrl += \"workers\/\";\r\n            else\r\n                this._baseUrl += runtimeInterface.GetScriptFolder();\r\n            this._maxNumWorkers = Math.min(navigator.hardwareConcurrency || 2, 16);\r\n            this._dispatchWorker = null;\r\n            this._jobWorkers = [];\r\n            this._inputPort = null;\r\n            this._outputPort = null\r\n        }\r\n        async Init() {\r\n            if (this._hasInitialised)\r\n                throw new Error(\"already initialised\");\r\n            this._hasInitialised = true;\r\n            const dispatchWorkerScriptUrl = this._runtimeInterface._GetWorkerURL(DISPATCH_WORKER_SCRIPT_NAME);\r\n            this._dispatchWorker = await this._runtimeInterface.CreateWorker(dispatchWorkerScriptUrl, this._baseUrl, {\r\n                name: \"DispatchWorker\"\r\n            });\r\n            const messageChannel = new MessageChannel;\r\n            this._inputPort = messageChannel.port1;\r\n            this._dispatchWorker.postMessage({\r\n                \"type\": \"_init\",\r\n                \"in-port\": messageChannel.port2\r\n            }, [messageChannel.port2]);\r\n            this._outputPort = await this._CreateJobWorker()\r\n        }\r\n        async _CreateJobWorker() {\r\n            const number = this._jobWorkers.length;\r\n            const jobWorkerScriptUrl = this._runtimeInterface._GetWorkerURL(JOB_WORKER_SCRIPT_NAME);\r\n            const jobWorker = await this._runtimeInterface.CreateWorker(jobWorkerScriptUrl, this._baseUrl, {\r\n                name: \"JobWorker\" + number\r\n            });\r\n            const dispatchChannel = new MessageChannel;\r\n            const outputChannel = new MessageChannel;\r\n            this._dispatchWorker.postMessage({\r\n                \"type\": \"_addJobWorker\",\r\n                \"port\": dispatchChannel.port1\r\n            }, [dispatchChannel.port1]);\r\n            jobWorker.postMessage({\r\n                \"type\": \"init\",\r\n                \"number\": number,\r\n                \"dispatch-port\": dispatchChannel.port2,\r\n                \"output-port\": outputChannel.port2\r\n            }, [dispatchChannel.port2, outputChannel.port2]);\r\n            this._jobWorkers.push(jobWorker);\r\n            return outputChannel.port1\r\n        }\r\n        GetPortData() {\r\n            return {\r\n                \"inputPort\": this._inputPort,\r\n                \"outputPort\": this._outputPort,\r\n                \"maxNumWorkers\": this._maxNumWorkers\r\n            }\r\n        }\r\n        GetPortTransferables() {\r\n            return [this._inputPort, this._outputPort]\r\n        }\r\n    }\r\n}\r\n;\r\n'use strict';\r\n{\r\n    if (window[\"C3_IsSupported\"]) {\r\n        const enableWorker = false;\r\n        window[\"c3_runtimeInterface\"] = new self.RuntimeInterface({\r\n            useWorker: enableWorker,\r\n            workerMainUrl: \"workermain.js\",\r\n            engineScripts: [\"https:\/\/cdn.jsdelivr.net\/gh\/cooldude2349\/braintest@main\/scripts\/c3runtime.js\"],\r\n            projectScripts: [[\"https:\/\/cdn.jsdelivr.net\/gh\/cooldude2349\/braintest@main\/scripts\/project\/poki-start.js\"], [\"https:\/\/cdn.jsdelivr.net\/gh\/cooldude2349\/braintest@main\/scripts\/project\/scriptsInEvents.js\"]],\r\n            mainProjectScript: \"https:\/\/cdn.jsdelivr.net\/gh\/cooldude2349\/braintest@main\/scripts\/project\/poki-start.js\",\r\n            scriptFolder: \"https:\/\/cdn.jsdelivr.net\/gh\/cooldude2349\/braintest@main\/scripts\/\",\r\n            workerDependencyScripts: [],\r\n            exportType: \"html5\"\r\n        })\r\n    }\r\n}\r\n;'use strict';\r\n{\r\n    const DOM_COMPONENT_ID = \"touch\";\r\n    const HANDLER_CLASS = class TouchDOMHandler extends self.DOMHandler {\r\n        constructor(iRuntime) {\r\n            super(iRuntime, DOM_COMPONENT_ID);\r\n            this.AddRuntimeMessageHandler(\"request-permission\", e => this._OnRequestPermission(e))\r\n        }\r\n        async _OnRequestPermission(e) {\r\n            const type = e[\"type\"];\r\n            let result = true;\r\n            if (type === 0)\r\n                result = await this._RequestOrientationPermission();\r\n            else if (type === 1)\r\n                result = await this._RequestMotionPermission();\r\n            this.PostToRuntime(\"permission-result\", {\r\n                \"type\": type,\r\n                \"result\": result\r\n            })\r\n        }\r\n        async _RequestOrientationPermission() {\r\n            if (!self[\"DeviceOrientationEvent\"] || !self[\"DeviceOrientationEvent\"][\"requestPermission\"])\r\n                return true;\r\n            try {\r\n                const state = await self[\"DeviceOrientationEvent\"][\"requestPermission\"]();\r\n                return state === \"granted\"\r\n            } catch (err) {\r\n                console.warn(\"[Touch] Failed to request orientation permission: \", err);\r\n                return false\r\n            }\r\n        }\r\n        async _RequestMotionPermission() {\r\n            if (!self[\"DeviceMotionEvent\"] || !self[\"DeviceMotionEvent\"][\"requestPermission\"])\r\n                return true;\r\n            try {\r\n                const state = await self[\"DeviceMotionEvent\"][\"requestPermission\"]();\r\n                return state === \"granted\"\r\n            } catch (err) {\r\n                console.warn(\"[Touch] Failed to request motion permission: \", err);\r\n                return false\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    self.RuntimeInterface.AddDOMHandlerClass(HANDLER_CLASS)\r\n}\r\n;'use strict';\r\n{\r\n    const R_TO_D = 180 \/ Math.PI;\r\n    const DOM_COMPONENT_ID = \"audio\";\r\n    self.AudioDOMHandler = class AudioDOMHandler extends self.DOMHandler {\r\n        constructor(iRuntime) {\r\n            super(iRuntime, DOM_COMPONENT_ID);\r\n            this._audioContext = null;\r\n            this._destinationNode = null;\r\n            this._hasUnblocked = false;\r\n            this._hasAttachedUnblockEvents = false;\r\n            this._unblockFunc = () => this._UnblockAudioContext();\r\n            this._audioBuffers = [];\r\n            this._audioInstances = [];\r\n            this._lastAudioInstance = null;\r\n            this._lastPlayedTag = \"\";\r\n            this._lastTickCount = -1;\r\n            this._pendingTags = new Map;\r\n            this._masterVolume = 1;\r\n            this._isSilent = false;\r\n            this._timeScaleMode = 0;\r\n            this._timeScale = 1;\r\n            this._gameTime = 0;\r\n            this._panningModel = \"HRTF\";\r\n            this._distanceModel = \"inverse\";\r\n            this._refDistance = 600;\r\n            this._maxDistance = 1E4;\r\n            this._rolloffFactor = 1;\r\n            this._playMusicAsSound = false;\r\n            this._hasAnySoftwareDecodedMusic = false;\r\n            this._supportsWebMOpus = this._iRuntime.IsAudioFormatSupported(\"audio\/webm; codecs=opus\");\r\n            this._effects = new Map;\r\n            this._analysers = new Set;\r\n            this._isPendingPostFxState = false;\r\n            this._hasStartedOfflineRender = false;\r\n            this._microphoneTag = \"\";\r\n            this._microphoneSource = null;\r\n            self[\"C3Audio_OnMicrophoneStream\"] = (localMediaStream, tag) => this._OnMicrophoneStream(localMediaStream, tag);\r\n            this._destMediaStreamNode = null;\r\n            self[\"C3Audio_GetOutputStream\"] = () => this._OnGetOutputStream();\r\n            self[\"C3Audio_DOMInterface\"] = this;\r\n            this.AddRuntimeMessageHandlers([[\"create-audio-context\", e => this._CreateAudioContext(e)], [\"play\", e => this._Play(e)], [\"stop\", e => this._Stop(e)], [\"stop-all\", () => this._StopAll()], [\"set-paused\", e => this._SetPaused(e)], [\"set-volume\", e => this._SetVolume(e)], [\"fade-volume\", e => this._FadeVolume(e)], [\"set-master-volume\", e => this._SetMasterVolume(e)], [\"set-muted\", e => this._SetMuted(e)], [\"set-silent\", e => this._SetSilent(e)], [\"set-looping\", e => this._SetLooping(e)], [\"set-playback-rate\", e => this._SetPlaybackRate(e)], [\"seek\", e => this._Seek(e)], [\"preload\", e => this._Preload(e)], [\"unload\", e => this._Unload(e)], [\"unload-all\", () => this._UnloadAll()], [\"set-suspended\", e => this._SetSuspended(e)], [\"add-effect\", e => this._AddEffect(e)], [\"set-effect-param\", e => this._SetEffectParam(e)], [\"remove-effects\", e => this._RemoveEffects(e)], [\"tick\", e => this._OnTick(e)], [\"load-state\", e => this._OnLoadState(e)], [\"offline-render-audio\", e => this._OnOfflineRenderAudio(e)], [\"offline-render-finish\", () => this._OnOfflineRenderFinish()]])\r\n        }\r\n        async _CreateAudioContext(e) {\r\n            if (e[\"isiOSCordova\"])\r\n                this._playMusicAsSound = true;\r\n            this._timeScaleMode = e[\"timeScaleMode\"];\r\n            this._panningModel = [\"equalpower\", \"HRTF\", \"soundfield\"][e[\"panningModel\"]];\r\n            this._distanceModel = [\"linear\", \"inverse\", \"exponential\"][e[\"distanceModel\"]];\r\n            this._refDistance = e[\"refDistance\"];\r\n            this._maxDistance = e[\"maxDistance\"];\r\n            this._rolloffFactor = e[\"rolloffFactor\"];\r\n            if (this._iRuntime.IsExportingToVideo()) {\r\n                this._playMusicAsSound = true;\r\n                const sampleRate = 48E3;\r\n                this._audioContext = new OfflineAudioContext({\r\n                    \"numberOfChannels\": 2,\r\n                    \"sampleRate\": sampleRate,\r\n                    \"length\": Math.ceil(this._iRuntime.GetExportToVideoDuration() * sampleRate)\r\n                })\r\n            } else {\r\n                const opts = {\r\n                    \"latencyHint\": e[\"latencyHint\"]\r\n                };\r\n                if (!this.SupportsWebMOpus())\r\n                    opts[\"sampleRate\"] = 48E3;\r\n                if (typeof AudioContext !== \"undefined\")\r\n                    this._audioContext = new AudioContext(opts);\r\n                else if (typeof webkitAudioContext !== \"undefined\")\r\n                    this._audioContext = new webkitAudioContext(opts);\r\n                else\r\n                    throw new Error(\"Web Audio API not supported\");\r\n                this._AttachUnblockEvents();\r\n                this._audioContext.onstatechange = () => {\r\n                    if (this._audioContext.state !== \"running\")\r\n                        this._AttachUnblockEvents();\r\n                    this.PostToRuntime(\"audiocontext-state\", {\r\n                        \"audioContextState\": this._audioContext.state\r\n                    })\r\n                }\r\n            }\r\n            this._destinationNode = this._audioContext[\"createGain\"]();\r\n            this._destinationNode[\"connect\"](this._audioContext[\"destination\"]);\r\n            const listenerPos = e[\"listenerPos\"];\r\n            this._audioContext[\"listener\"][\"setPosition\"](listenerPos[0], listenerPos[1], listenerPos[2]);\r\n            this._audioContext[\"listener\"][\"setOrientation\"](0, 0, 1, 0, -1, 0);\r\n            self[\"C3_GetAudioContextCurrentTime\"] = () => this.GetAudioCurrentTime();\r\n            try {\r\n                await Promise.all(e[\"preloadList\"].map(o => this._GetAudioBuffer(o[\"originalUrl\"], o[\"url\"], o[\"type\"], false)))\r\n            } catch (err) {\r\n                console.error(\"[Construct] Preloading sounds failed: \", err)\r\n            }\r\n            return {\r\n                \"sampleRate\": this._audioContext[\"sampleRate\"],\r\n                \"audioContextState\": this._audioContext.state\r\n            }\r\n        }\r\n        _AttachUnblockEvents() {\r\n            if (this._hasAttachedUnblockEvents)\r\n                return;\r\n            this._hasUnblocked = false;\r\n            window.addEventListener(\"pointerup\", this._unblockFunc, true);\r\n            window.addEventListener(\"touchend\", this._unblockFunc, true);\r\n            window.addEventListener(\"click\", this._unblockFunc, true);\r\n            window.addEventListener(\"keydown\", this._unblockFunc, true);\r\n            this._hasAttachedUnblockEvents = true\r\n        }\r\n        _DetachUnblockEvents() {\r\n            if (!this._hasAttachedUnblockEvents)\r\n                return;\r\n            this._hasUnblocked = true;\r\n            window.removeEventListener(\"pointerup\", this._unblockFunc, true);\r\n            window.removeEventListener(\"touchend\", this._unblockFunc, true);\r\n            window.removeEventListener(\"click\", this._unblockFunc, true);\r\n            window.removeEventListener(\"keydown\", this._unblockFunc, true);\r\n            this._hasAttachedUnblockEvents = false\r\n        }\r\n        _UnblockAudioContext() {\r\n            if (this._hasUnblocked)\r\n                return;\r\n            const audioContext = this._audioContext;\r\n            if (audioContext[\"state\"] === \"suspended\" && audioContext[\"resume\"])\r\n                audioContext[\"resume\"]();\r\n            const buffer = audioContext[\"createBuffer\"](1, 220, 22050);\r\n            const source = audioContext[\"createBufferSource\"]();\r\n            source[\"buffer\"] = buffer;\r\n            source[\"connect\"](audioContext[\"destination\"]);\r\n            source[\"start\"](0);\r\n            if (audioContext[\"state\"] === \"running\")\r\n                this._DetachUnblockEvents()\r\n        }\r\n        GetAudioContext() {\r\n            return this._audioContext\r\n        }\r\n        GetAudioCurrentTime() {\r\n            return this._audioContext[\"currentTime\"]\r\n        }\r\n        GetDestinationNode() {\r\n            return this._destinationNode\r\n        }\r\n        GetDestinationForTag(tag) {\r\n            const fxChain = this._effects.get(tag.toLowerCase());\r\n            if (fxChain)\r\n                return fxChain[0].GetInputNode();\r\n            else\r\n                return this.GetDestinationNode()\r\n        }\r\n        AddEffectForTag(tag, effect) {\r\n            tag = tag.toLowerCase();\r\n            let fxChain = this._effects.get(tag);\r\n            if (!fxChain) {\r\n                fxChain = [];\r\n                this._effects.set(tag, fxChain)\r\n            }\r\n            effect._SetIndex(fxChain.length);\r\n            effect._SetTag(tag);\r\n            fxChain.push(effect);\r\n            this._ReconnectEffects(tag)\r\n        }\r\n        _ReconnectEffects(tag) {\r\n            let destNode = this.GetDestinationNode();\r\n            const fxChain = this._effects.get(tag);\r\n            if (fxChain && fxChain.length) {\r\n                destNode = fxChain[0].GetInputNode();\r\n                for (let i = 0, len = fxChain.length; i < len; ++i) {\r\n                    const n = fxChain[i];\r\n                    if (i + 1 === len)\r\n                        n.ConnectTo(this.GetDestinationNode());\r\n                    else\r\n                        n.ConnectTo(fxChain[i + 1].GetInputNode())\r\n                }\r\n            }\r\n            for (const ai of this.audioInstancesByTag(tag))\r\n                ai.Reconnect(destNode);\r\n            if (this._microphoneSource && this._microphoneTag === tag) {\r\n                this._microphoneSource[\"disconnect\"]();\r\n                this._microphoneSource[\"connect\"](destNode)\r\n            }\r\n        }\r\n        GetMasterVolume() {\r\n            return this._masterVolume\r\n        }\r\n        IsSilent() {\r\n            return this._isSilent\r\n        }\r\n        GetTimeScaleMode() {\r\n            return this._timeScaleMode\r\n        }\r\n        GetTimeScale() {\r\n            return this._timeScale\r\n        }\r\n        GetGameTime() {\r\n            return this._gameTime\r\n        }\r\n        IsPlayMusicAsSound() {\r\n            return this._playMusicAsSound\r\n        }\r\n        SupportsWebMOpus() {\r\n            return this._supportsWebMOpus\r\n        }\r\n        _SetHasAnySoftwareDecodedMusic() {\r\n            this._hasAnySoftwareDecodedMusic = true\r\n        }\r\n        GetPanningModel() {\r\n            return this._panningModel\r\n        }\r\n        GetDistanceModel() {\r\n            return this._distanceModel\r\n        }\r\n        GetReferenceDistance() {\r\n            return this._refDistance\r\n        }\r\n        GetMaxDistance() {\r\n            return this._maxDistance\r\n        }\r\n        GetRolloffFactor() {\r\n            return this._rolloffFactor\r\n        }\r\n        DecodeAudioData(audioData, needsSoftwareDecode) {\r\n            if (needsSoftwareDecode)\r\n                return this._iRuntime._WasmDecodeWebMOpus(audioData).then(rawAudio => {\r\n                    const audioBuffer = this._audioContext[\"createBuffer\"](1, rawAudio.length, 48E3);\r\n                    const channelBuffer = audioBuffer[\"getChannelData\"](0);\r\n                    channelBuffer.set(rawAudio);\r\n                    return audioBuffer\r\n                }\r\n                );\r\n            else\r\n                return new Promise( (resolve, reject) => {\r\n                    this._audioContext[\"decodeAudioData\"](audioData, resolve, reject)\r\n                }\r\n                )\r\n        }\r\n        TryPlayMedia(mediaElem) {\r\n            this._iRuntime.TryPlayMedia(mediaElem)\r\n        }\r\n        RemovePendingPlay(mediaElem) {\r\n            this._iRuntime.RemovePendingPlay(mediaElem)\r\n        }\r\n        ReleaseInstancesForBuffer(buffer) {\r\n            let j = 0;\r\n            for (let i = 0, len = this._audioInstances.length; i < len; ++i) {\r\n                const a = this._audioInstances[i];\r\n                this._audioInstances[j] = a;\r\n                if (a.GetBuffer() === buffer)\r\n                    a.Release();\r\n                else\r\n                    ++j\r\n            }\r\n            this._audioInstances.length = j\r\n        }\r\n        ReleaseAllMusicBuffers() {\r\n            let j = 0;\r\n            for (let i = 0, len = this._audioBuffers.length; i < len; ++i) {\r\n                const b = this._audioBuffers[i];\r\n                this._audioBuffers[j] = b;\r\n                if (b.IsMusic())\r\n                    b.Release();\r\n                else\r\n                    ++j\r\n            }\r\n            this._audioBuffers.length = j\r\n        }\r\n        *audioInstancesByTag(tag) {\r\n            if (tag)\r\n                for (const ai of this._audioInstances) {\r\n                    if (self.AudioDOMHandler.EqualsNoCase(ai.GetTag(), tag))\r\n                        yield ai\r\n                }\r\n            else if (this._lastAudioInstance && !this._lastAudioInstance.HasEnded())\r\n                yield this._lastAudioInstance\r\n        }\r\n        async _GetAudioBuffer(originalUrl, url, type, isMusic, dontCreate) {\r\n            for (const ab of this._audioBuffers)\r\n                if (ab.GetUrl() === url) {\r\n                    await ab.Load();\r\n                    return ab\r\n                }\r\n            if (dontCreate)\r\n                return null;\r\n            if (isMusic && (this._playMusicAsSound || this._hasAnySoftwareDecodedMusic))\r\n                this.ReleaseAllMusicBuffers();\r\n            const ret = self.C3AudioBuffer.Create(this, originalUrl, url, type, isMusic);\r\n            this._audioBuffers.push(ret);\r\n            await ret.Load();\r\n            return ret\r\n        }\r\n        async _GetAudioInstance(originalUrl, url, type, tag, isMusic) {\r\n            for (const ai of this._audioInstances)\r\n                if (ai.GetUrl() === url && (ai.CanBeRecycled() || isMusic)) {\r\n                    ai.SetTag(tag);\r\n                    return ai\r\n                }\r\n            const buffer = await this._GetAudioBuffer(originalUrl, url, type, isMusic);\r\n            const ret = buffer.CreateInstance(tag);\r\n            this._audioInstances.push(ret);\r\n            return ret\r\n        }\r\n        _AddPendingTag(tag) {\r\n            let info = this._pendingTags.get(tag);\r\n            if (!info) {\r\n                let resolve = null;\r\n                const promise = new Promise(r => resolve = r);\r\n                info = {\r\n                    pendingCount: 0,\r\n                    promise,\r\n                    resolve\r\n                };\r\n                this._pendingTags.set(tag, info)\r\n            }\r\n            info.pendingCount++\r\n        }\r\n        _RemovePendingTag(tag) {\r\n            const info = this._pendingTags.get(tag);\r\n            if (!info)\r\n                throw new Error(\"expected pending tag\");\r\n            info.pendingCount--;\r\n            if (info.pendingCount === 0) {\r\n                info.resolve();\r\n                this._pendingTags.delete(tag)\r\n            }\r\n        }\r\n        TagReady(tag) {\r\n            if (!tag)\r\n                tag = this._lastPlayedTag;\r\n            const info = this._pendingTags.get(tag);\r\n            if (info)\r\n                return info.promise;\r\n            else\r\n                return Promise.resolve()\r\n        }\r\n        _MaybeStartTicking() {\r\n            if (this._analysers.size > 0) {\r\n                this._StartTicking();\r\n                return\r\n            }\r\n            for (const ai of this._audioInstances)\r\n                if (ai.IsActive()) {\r\n                    this._StartTicking();\r\n                    return\r\n                }\r\n        }\r\n        Tick() {\r\n            for (const a of this._analysers)\r\n                a.Tick();\r\n            const currentTime = this.GetAudioCurrentTime();\r\n            for (const ai of this._audioInstances)\r\n                ai.Tick(currentTime);\r\n            const instStates = this._audioInstances.filter(a => a.IsActive()).map(a => a.GetState());\r\n            this.PostToRuntime(\"state\", {\r\n                \"tickCount\": this._lastTickCount,\r\n                \"audioInstances\": instStates,\r\n                \"analysers\": [...this._analysers].map(a => a.GetData())\r\n            });\r\n            if (instStates.length === 0 && this._analysers.size === 0)\r\n                this._StopTicking()\r\n        }\r\n        PostTrigger(type, tag, aiid) {\r\n            this.PostToRuntime(\"trigger\", {\r\n                \"type\": type,\r\n                \"tag\": tag,\r\n                \"aiid\": aiid\r\n            })\r\n        }\r\n        async _Play(e) {\r\n            const originalUrl = e[\"originalUrl\"];\r\n            const url = e[\"url\"];\r\n            const type = e[\"type\"];\r\n            const isMusic = e[\"isMusic\"];\r\n            const tag = e[\"tag\"];\r\n            const isLooping = e[\"isLooping\"];\r\n            const volume = e[\"vol\"];\r\n            const position = e[\"pos\"];\r\n            const panning = e[\"panning\"];\r\n            let startTime = e[\"off\"];\r\n            if (startTime > 0 && !e[\"trueClock\"])\r\n                if (this._audioContext[\"getOutputTimestamp\"]) {\r\n                    const outputTimestamp = this._audioContext[\"getOutputTimestamp\"]();\r\n                    startTime = startTime - outputTimestamp[\"performanceTime\"] \/ 1E3 + outputTimestamp[\"contextTime\"]\r\n                } else\r\n                    startTime = startTime - performance.now() \/ 1E3 + this._audioContext[\"currentTime\"];\r\n            this._lastPlayedTag = tag;\r\n            this._AddPendingTag(tag);\r\n            try {\r\n                this._lastAudioInstance = await this._GetAudioInstance(originalUrl, url, type, tag, isMusic);\r\n                if (panning) {\r\n                    this._lastAudioInstance.SetPannerEnabled(true);\r\n                    this._lastAudioInstance.SetPan(panning[\"x\"], panning[\"y\"], panning[\"angle\"], panning[\"innerAngle\"], panning[\"outerAngle\"], panning[\"outerGain\"]);\r\n                    if (panning.hasOwnProperty(\"uid\"))\r\n                        this._lastAudioInstance.SetUID(panning[\"uid\"])\r\n                } else\r\n                    this._lastAudioInstance.SetPannerEnabled(false);\r\n                this._lastAudioInstance.Play(isLooping, volume, position, startTime)\r\n            } catch (err) {\r\n                console.error(\"[Construct] Audio: error starting playback: \", err);\r\n                return\r\n            } finally {\r\n                this._RemovePendingTag(tag)\r\n            }\r\n            this._StartTicking()\r\n        }\r\n        _Stop(e) {\r\n            const tag = e[\"tag\"];\r\n            for (const ai of this.audioInstancesByTag(tag))\r\n                ai.Stop()\r\n        }\r\n        _StopAll() {\r\n            for (const ai of this._audioInstances)\r\n                ai.Stop()\r\n        }\r\n        _SetPaused(e) {\r\n            const tag = e[\"tag\"];\r\n            const paused = e[\"paused\"];\r\n            for (const ai of this.audioInstancesByTag(tag))\r\n                if (paused)\r\n                    ai.Pause();\r\n                else\r\n                    ai.Resume();\r\n            this._MaybeStartTicking()\r\n        }\r\n        _SetVolume(e) {\r\n            const tag = e[\"tag\"];\r\n            const vol = e[\"vol\"];\r\n            for (const ai of this.audioInstancesByTag(tag))\r\n                ai.SetVolume(vol)\r\n        }\r\n        async _FadeVolume(e) {\r\n            const tag = e[\"tag\"];\r\n            const vol = e[\"vol\"];\r\n            const duration = e[\"duration\"];\r\n            const stopOnEnd = e[\"stopOnEnd\"];\r\n            await this.TagReady(tag);\r\n            for (const ai of this.audioInstancesByTag(tag))\r\n                ai.FadeVolume(vol, duration, stopOnEnd);\r\n            this._MaybeStartTicking()\r\n        }\r\n        _SetMasterVolume(e) {\r\n            this._masterVolume = e[\"vol\"];\r\n            this._destinationNode[\"gain\"][\"value\"] = this._masterVolume\r\n        }\r\n        _SetMuted(e) {\r\n            const tag = e[\"tag\"];\r\n            const isMuted = e[\"isMuted\"];\r\n            for (const ai of this.audioInstancesByTag(tag))\r\n                ai.SetMuted(isMuted)\r\n        }\r\n        _SetSilent(e) {\r\n            this._isSilent = e[\"isSilent\"];\r\n            this._iRuntime.SetSilent(this._isSilent);\r\n            for (const ai of this._audioInstances)\r\n                ai._UpdateMuted()\r\n        }\r\n        _SetLooping(e) {\r\n            const tag = e[\"tag\"];\r\n            const isLooping = e[\"isLooping\"];\r\n            for (const ai of this.audioInstancesByTag(tag))\r\n                ai.SetLooping(isLooping)\r\n        }\r\n        async _SetPlaybackRate(e) {\r\n            const tag = e[\"tag\"];\r\n            const rate = e[\"rate\"];\r\n            await this.TagReady(tag);\r\n            for (const ai of this.audioInstancesByTag(tag))\r\n                ai.SetPlaybackRate(rate)\r\n        }\r\n        async _Seek(e) {\r\n            const tag = e[\"tag\"];\r\n            const pos = e[\"pos\"];\r\n            await this.TagReady(tag);\r\n            for (const ai of this.audioInstancesByTag(tag))\r\n                ai.Seek(pos)\r\n        }\r\n        async _Preload(e) {\r\n            const originalUrl = e[\"originalUrl\"];\r\n            const url = e[\"url\"];\r\n            const type = e[\"type\"];\r\n            const isMusic = e[\"isMusic\"];\r\n            try {\r\n                await this._GetAudioInstance(originalUrl, url, type, \"\", isMusic)\r\n            } catch (err) {\r\n                console.error(\"[Construct] Audio: error preloading: \", err)\r\n            }\r\n        }\r\n        async _Unload(e) {\r\n            const url = e[\"url\"];\r\n            const type = e[\"type\"];\r\n            const isMusic = e[\"isMusic\"];\r\n            const buffer = await this._GetAudioBuffer(\"\", url, type, isMusic, true);\r\n            if (!buffer)\r\n                return;\r\n            buffer.Release();\r\n            const i = this._audioBuffers.indexOf(buffer);\r\n            if (i !== -1)\r\n                this._audioBuffers.splice(i, 1)\r\n        }\r\n        _UnloadAll() {\r\n            for (const buffer of this._audioBuffers)\r\n                buffer.Release();\r\n            this._audioBuffers.length = 0\r\n        }\r\n        _SetSuspended(e) {\r\n            const isSuspended = e[\"isSuspended\"];\r\n            if (!isSuspended && this._audioContext[\"resume\"])\r\n                this._audioContext[\"resume\"]();\r\n            for (const ai of this._audioInstances)\r\n                ai.SetSuspended(isSuspended);\r\n            if (isSuspended && this._audioContext[\"suspend\"])\r\n                this._audioContext[\"suspend\"]()\r\n        }\r\n        _OnTick(e) {\r\n            this._timeScale = e[\"timeScale\"];\r\n            this._gameTime = e[\"gameTime\"];\r\n            this._lastTickCount = e[\"tickCount\"];\r\n            if (this._timeScaleMode !== 0)\r\n                for (const ai of this._audioInstances)\r\n                    ai._UpdatePlaybackRate();\r\n            const listenerPos = e[\"listenerPos\"];\r\n            if (listenerPos)\r\n                this._audioContext[\"listener\"][\"setPosition\"](listenerPos[0], listenerPos[1], listenerPos[2]);\r\n            for (const instPan of e[\"instPans\"]) {\r\n                const uid = instPan[\"uid\"];\r\n                for (const ai of this._audioInstances)\r\n                    if (ai.GetUID() === uid)\r\n                        ai.SetPanXYA(instPan[\"x\"], instPan[\"y\"], instPan[\"angle\"])\r\n            }\r\n        }\r\n        async _AddEffect(e) {\r\n            const type = e[\"type\"];\r\n            const tag = e[\"tag\"];\r\n            const params = e[\"params\"];\r\n            let effect;\r\n            if (type === \"filter\")\r\n                effect = new self.C3AudioFilterFX(this,...params);\r\n            else if (type === \"delay\")\r\n                effect = new self.C3AudioDelayFX(this,...params);\r\n            else if (type === \"convolution\") {\r\n                let buffer = null;\r\n                try {\r\n                    buffer = await this._GetAudioBuffer(e[\"bufferOriginalUrl\"], e[\"bufferUrl\"], e[\"bufferType\"], false)\r\n                } catch (err) {\r\n                    console.log(\"[Construct] Audio: error loading convolution: \", err);\r\n                    return\r\n                }\r\n                effect = new self.C3AudioConvolveFX(this,buffer.GetAudioBuffer(),...params);\r\n                effect._SetBufferInfo(e[\"bufferOriginalUrl\"], e[\"bufferUrl\"], e[\"bufferType\"])\r\n            } else if (type === \"flanger\")\r\n                effect = new self.C3AudioFlangerFX(this,...params);\r\n            else if (type === \"phaser\")\r\n                effect = new self.C3AudioPhaserFX(this,...params);\r\n            else if (type === \"gain\")\r\n                effect = new self.C3AudioGainFX(this,...params);\r\n            else if (type === \"tremolo\")\r\n                effect = new self.C3AudioTremoloFX(this,...params);\r\n            else if (type === \"ringmod\")\r\n                effect = new self.C3AudioRingModFX(this,...params);\r\n            else if (type === \"distortion\")\r\n                effect = new self.C3AudioDistortionFX(this,...params);\r\n            else if (type === \"compressor\")\r\n                effect = new self.C3AudioCompressorFX(this,...params);\r\n            else if (type === \"analyser\")\r\n                effect = new self.C3AudioAnalyserFX(this,...params);\r\n            else\r\n                throw new Error(\"invalid effect type\");\r\n            this.AddEffectForTag(tag, effect);\r\n            this._PostUpdatedFxState()\r\n        }\r\n        _SetEffectParam(e) {\r\n            const tag = e[\"tag\"];\r\n            const index = e[\"index\"];\r\n            const param = e[\"param\"];\r\n            const value = e[\"value\"];\r\n            const ramp = e[\"ramp\"];\r\n            const time = e[\"time\"];\r\n            const fxChain = this._effects.get(tag);\r\n            if (!fxChain || index < 0 || index >= fxChain.length)\r\n                return;\r\n            fxChain[index].SetParam(param, value, ramp, time);\r\n            this._PostUpdatedFxState()\r\n        }\r\n        _RemoveEffects(e) {\r\n            const tag = e[\"tag\"].toLowerCase();\r\n            const fxChain = this._effects.get(tag);\r\n            if (!fxChain || !fxChain.length)\r\n                return;\r\n            for (const effect of fxChain)\r\n                effect.Release();\r\n            this._effects.delete(tag);\r\n            this._ReconnectEffects(tag)\r\n        }\r\n        _AddAnalyser(analyser) {\r\n            this._analysers.add(analyser);\r\n            this._MaybeStartTicking()\r\n        }\r\n        _RemoveAnalyser(analyser) {\r\n            this._analysers.delete(analyser)\r\n        }\r\n        _PostUpdatedFxState() {\r\n            if (this._isPendingPostFxState)\r\n                return;\r\n            this._isPendingPostFxState = true;\r\n            Promise.resolve().then( () => this._DoPostUpdatedFxState())\r\n        }\r\n        _DoPostUpdatedFxState() {\r\n            const fxstate = {};\r\n            for (const [tag,fxChain] of this._effects)\r\n                fxstate[tag] = fxChain.map(e => e.GetState());\r\n            this.PostToRuntime(\"fxstate\", {\r\n                \"fxstate\": fxstate\r\n            });\r\n            this._isPendingPostFxState = false\r\n        }\r\n        async _OnLoadState(e) {\r\n            const saveLoadMode = e[\"saveLoadMode\"];\r\n            if (saveLoadMode !== 3)\r\n                for (const ai of this._audioInstances) {\r\n                    if (ai.IsMusic() && saveLoadMode === 1)\r\n                        continue;\r\n                    if (!ai.IsMusic() && saveLoadMode === 2)\r\n                        continue;\r\n                    ai.Stop()\r\n                }\r\n            for (const fxChain of this._effects.values())\r\n                for (const effect of fxChain)\r\n                    effect.Release();\r\n            this._effects.clear();\r\n            this._timeScale = e[\"timeScale\"];\r\n            this._gameTime = e[\"gameTime\"];\r\n            const listenerPos = e[\"listenerPos\"];\r\n            this._audioContext[\"listener\"][\"setPosition\"](listenerPos[0], listenerPos[1], listenerPos[2]);\r\n            this._isSilent = e[\"isSilent\"];\r\n            this._iRuntime.SetSilent(this._isSilent);\r\n            this._masterVolume = e[\"masterVolume\"];\r\n            this._destinationNode[\"gain\"][\"value\"] = this._masterVolume;\r\n            const promises = [];\r\n            for (const fxChainData of Object.values(e[\"effects\"]))\r\n                promises.push(Promise.all(fxChainData.map(d => this._AddEffect(d))));\r\n            await Promise.all(promises);\r\n            await Promise.all(e[\"playing\"].map(d => this._LoadAudioInstance(d, saveLoadMode)));\r\n            this._MaybeStartTicking()\r\n        }\r\n        async _LoadAudioInstance(d, saveLoadMode) {\r\n            if (saveLoadMode === 3)\r\n                return;\r\n            const originalUrl = d[\"bufferOriginalUrl\"];\r\n            const url = d[\"bufferUrl\"];\r\n            const type = d[\"bufferType\"];\r\n            const isMusic = d[\"isMusic\"];\r\n            const tag = d[\"tag\"];\r\n            const isLooping = d[\"isLooping\"];\r\n            const volume = d[\"volume\"];\r\n            const position = d[\"playbackTime\"];\r\n            if (isMusic && saveLoadMode === 1)\r\n                return;\r\n            if (!isMusic && saveLoadMode === 2)\r\n                return;\r\n            let ai = null;\r\n            try {\r\n                ai = await this._GetAudioInstance(originalUrl, url, type, tag, isMusic)\r\n            } catch (err) {\r\n                console.error(\"[Construct] Audio: error loading audio state: \", err);\r\n                return\r\n            }\r\n            ai.LoadPanState(d[\"pan\"]);\r\n            ai.Play(isLooping, volume, position, 0);\r\n            if (!d[\"isPlaying\"])\r\n                ai.Pause();\r\n            ai._LoadAdditionalState(d)\r\n        }\r\n        _OnMicrophoneStream(localMediaStream, tag) {\r\n            if (this._microphoneSource)\r\n                this._microphoneSource[\"disconnect\"]();\r\n            this._microphoneTag = tag.toLowerCase();\r\n            this._microphoneSource = this._audioContext[\"createMediaStreamSource\"](localMediaStream);\r\n            this._microphoneSource[\"connect\"](this.GetDestinationForTag(this._microphoneTag))\r\n        }\r\n        _OnGetOutputStream() {\r\n            if (!this._destMediaStreamNode) {\r\n                this._destMediaStreamNode = this._audioContext[\"createMediaStreamDestination\"]();\r\n                this._destinationNode[\"connect\"](this._destMediaStreamNode)\r\n            }\r\n            return this._destMediaStreamNode[\"stream\"]\r\n        }\r\n        async _OnOfflineRenderAudio(e) {\r\n            try {\r\n                const time = e[\"time\"];\r\n                const suspendPromise = this._audioContext[\"suspend\"](time);\r\n                if (!this._hasStartedOfflineRender) {\r\n                    this._audioContext[\"startRendering\"]().then(buffer => this._OnOfflineRenderCompleted(buffer)).catch(err => this._OnOfflineRenderError(err));\r\n                    this._hasStartedOfflineRender = true\r\n                } else\r\n                    this._audioContext[\"resume\"]();\r\n                await suspendPromise\r\n            } catch (err) {\r\n                this._OnOfflineRenderError(err)\r\n            }\r\n        }\r\n        _OnOfflineRenderFinish() {\r\n            this._audioContext[\"resume\"]()\r\n        }\r\n        _OnOfflineRenderCompleted(buffer) {\r\n            const channelArrayBuffers = [];\r\n            for (let i = 0, len = buffer[\"numberOfChannels\"]; i < len; ++i) {\r\n                const f32arr = buffer[\"getChannelData\"](i);\r\n                channelArrayBuffers.push(f32arr.buffer)\r\n            }\r\n            this._iRuntime.PostToRuntimeComponent(\"runtime\", \"offline-audio-render-completed\", {\r\n                \"duration\": buffer[\"duration\"],\r\n                \"length\": buffer[\"length\"],\r\n                \"numberOfChannels\": buffer[\"numberOfChannels\"],\r\n                \"sampleRate\": buffer[\"sampleRate\"],\r\n                \"channelData\": channelArrayBuffers\r\n            }, null, channelArrayBuffers)\r\n        }\r\n        _OnOfflineRenderError(err) {\r\n            console.error(`[Audio] Offline rendering error: `, err)\r\n        }\r\n        static EqualsNoCase(a, b) {\r\n            if (a.length !== b.length)\r\n                return false;\r\n            if (a === b)\r\n                return true;\r\n            return a.toLowerCase() === b.toLowerCase()\r\n        }\r\n        static ToDegrees(x) {\r\n            return x * R_TO_D\r\n        }\r\n        static DbToLinearNoCap(x) {\r\n            return Math.pow(10, x \/ 20)\r\n        }\r\n        static DbToLinear(x) {\r\n            return Math.max(Math.min(self.AudioDOMHandler.DbToLinearNoCap(x), 1), 0)\r\n        }\r\n        static LinearToDbNoCap(x) {\r\n            return Math.log(x) \/ Math.log(10) * 20\r\n        }\r\n        static LinearToDb(x) {\r\n            return self.AudioDOMHandler.LinearToDbNoCap(Math.max(Math.min(x, 1), 0))\r\n        }\r\n        static e4(x, k) {\r\n            return 1 - Math.exp(-k * x)\r\n        }\r\n    }\r\n    ;\r\n    self.RuntimeInterface.AddDOMHandlerClass(self.AudioDOMHandler)\r\n}\r\n;'use strict';\r\n{\r\n    self.C3AudioBuffer = class C3AudioBuffer {\r\n        constructor(audioDomHandler, originalUrl, url, type, isMusic) {\r\n            this._audioDomHandler = audioDomHandler;\r\n            this._originalUrl = originalUrl;\r\n            this._url = url;\r\n            this._type = type;\r\n            this._isMusic = isMusic;\r\n            this._api = \"\";\r\n            this._loadState = \"not-loaded\";\r\n            this._loadPromise = null\r\n        }\r\n        Release() {\r\n            this._loadState = \"not-loaded\";\r\n            this._audioDomHandler = null;\r\n            this._loadPromise = null\r\n        }\r\n        static Create(audioDomHandler, originalUrl, url, type, isMusic) {\r\n            const needsSoftwareDecode = type === \"audio\/webm; codecs=opus\" && !audioDomHandler.SupportsWebMOpus();\r\n            if (isMusic && needsSoftwareDecode)\r\n                audioDomHandler._SetHasAnySoftwareDecodedMusic();\r\n            if (!isMusic || audioDomHandler.IsPlayMusicAsSound() || needsSoftwareDecode)\r\n                return new self.C3WebAudioBuffer(audioDomHandler,originalUrl,url,type,isMusic,needsSoftwareDecode);\r\n            else\r\n                return new self.C3Html5AudioBuffer(audioDomHandler,originalUrl,url,type,isMusic)\r\n        }\r\n        CreateInstance(tag) {\r\n            if (this._api === \"html5\")\r\n                return new self.C3Html5AudioInstance(this._audioDomHandler,this,tag);\r\n            else\r\n                return new self.C3WebAudioInstance(this._audioDomHandler,this,tag)\r\n        }\r\n        _Load() {}\r\n        Load() {\r\n            if (!this._loadPromise)\r\n                this._loadPromise = this._Load();\r\n            return this._loadPromise\r\n        }\r\n        IsLoaded() {}\r\n        IsLoadedAndDecoded() {}\r\n        HasFailedToLoad() {\r\n            return this._loadState === \"failed\"\r\n        }\r\n        GetAudioContext() {\r\n            return this._audioDomHandler.GetAudioContext()\r\n        }\r\n        GetApi() {\r\n            return this._api\r\n        }\r\n        GetOriginalUrl() {\r\n            return this._originalUrl\r\n        }\r\n        GetUrl() {\r\n            return this._url\r\n        }\r\n        GetContentType() {\r\n            return this._type\r\n        }\r\n        IsMusic() {\r\n            return this._isMusic\r\n        }\r\n        GetDuration() {}\r\n    }\r\n}\r\n;'use strict';\r\n{\r\n    self.C3Html5AudioBuffer = class C3Html5AudioBuffer extends self.C3AudioBuffer {\r\n        constructor(audioDomHandler, originalUrl, url, type, isMusic) {\r\n            super(audioDomHandler, originalUrl, url, type, isMusic);\r\n            this._api = \"html5\";\r\n            this._audioElem = new Audio;\r\n            this._audioElem.crossOrigin = \"anonymous\";\r\n            this._audioElem.autoplay = false;\r\n            this._audioElem.preload = \"auto\";\r\n            this._loadResolve = null;\r\n            this._loadReject = null;\r\n            this._reachedCanPlayThrough = false;\r\n            this._audioElem.addEventListener(\"canplaythrough\", () => this._reachedCanPlayThrough = true);\r\n            this._outNode = this.GetAudioContext()[\"createGain\"]();\r\n            this._mediaSourceNode = null;\r\n            this._audioElem.addEventListener(\"canplay\", () => {\r\n                if (this._loadResolve) {\r\n                    this._loadState = \"loaded\";\r\n                    this._loadResolve();\r\n                    this._loadResolve = null;\r\n                    this._loadReject = null\r\n                }\r\n                if (this._mediaSourceNode || !this._audioElem)\r\n                    return;\r\n                this._mediaSourceNode = this.GetAudioContext()[\"createMediaElementSource\"](this._audioElem);\r\n                this._mediaSourceNode[\"connect\"](this._outNode)\r\n            }\r\n            );\r\n            this.onended = null;\r\n            this._audioElem.addEventListener(\"ended\", () => {\r\n                if (this.onended)\r\n                    this.onended()\r\n            }\r\n            );\r\n            this._audioElem.addEventListener(\"error\", e => this._OnError(e))\r\n        }\r\n        Release() {\r\n            this._audioDomHandler.ReleaseInstancesForBuffer(this);\r\n            this._outNode[\"disconnect\"]();\r\n            this._outNode = null;\r\n            this._mediaSourceNode[\"disconnect\"]();\r\n            this._mediaSourceNode = null;\r\n            if (this._audioElem && !this._audioElem.paused)\r\n                this._audioElem.pause();\r\n            this.onended = null;\r\n            this._audioElem = null;\r\n            super.Release()\r\n        }\r\n        _Load() {\r\n            this._loadState = \"loading\";\r\n            return new Promise( (resolve, reject) => {\r\n                this._loadResolve = resolve;\r\n                this._loadReject = reject;\r\n                this._audioElem.src = this._url\r\n            }\r\n            )\r\n        }\r\n        _OnError(e) {\r\n            console.error(`[Construct] Audio '${this._url}' error: `, e);\r\n            if (this._loadReject) {\r\n                this._loadState = \"failed\";\r\n                this._loadReject(e);\r\n                this._loadResolve = null;\r\n                this._loadReject = null\r\n            }\r\n        }\r\n        IsLoaded() {\r\n            const ret = this._audioElem[\"readyState\"] >= 4;\r\n            if (ret)\r\n                this._reachedCanPlayThrough = true;\r\n            return ret || this._reachedCanPlayThrough\r\n        }\r\n        IsLoadedAndDecoded() {\r\n            return this.IsLoaded()\r\n        }\r\n        GetAudioElement() {\r\n            return this._audioElem\r\n        }\r\n        GetOutputNode() {\r\n            return this._outNode\r\n        }\r\n        GetDuration() {\r\n            return this._audioElem[\"duration\"]\r\n        }\r\n    }\r\n}\r\n;'use strict';\r\n{\r\n    self.C3WebAudioBuffer = class C3WebAudioBuffer extends self.C3AudioBuffer {\r\n        constructor(audioDomHandler, originalUrl, url, type, isMusic, needsSoftwareDecode) {\r\n            super(audioDomHandler, originalUrl, url, type, isMusic);\r\n            this._api = \"webaudio\";\r\n            this._audioData = null;\r\n            this._audioBuffer = null;\r\n            this._needsSoftwareDecode = !!needsSoftwareDecode\r\n        }\r\n        Release() {\r\n            this._audioDomHandler.ReleaseInstancesForBuffer(this);\r\n            this._audioData = null;\r\n            this._audioBuffer = null;\r\n            super.Release()\r\n        }\r\n        async _Fetch() {\r\n            if (this._audioData)\r\n                return this._audioData;\r\n            const iRuntime = this._audioDomHandler.GetRuntimeInterface();\r\n            if (iRuntime.GetExportType() === \"cordova\" && iRuntime.IsRelativeURL(this._url) && iRuntime.IsFileProtocol())\r\n                this._audioData = await iRuntime.CordovaFetchLocalFileAsArrayBuffer(this._url);\r\n            else {\r\n                const response = await fetch(this._url);\r\n                if (!response.ok)\r\n                    throw new Error(`error fetching audio data: ${response.status} ${response.statusText}`);\r\n                this._audioData = await response.arrayBuffer()\r\n            }\r\n        }\r\n        async _Decode() {\r\n            if (this._audioBuffer)\r\n                return this._audioBuffer;\r\n            this._audioBuffer = await this._audioDomHandler.DecodeAudioData(this._audioData, this._needsSoftwareDecode);\r\n            this._audioData = null\r\n        }\r\n        async _Load() {\r\n            try {\r\n                this._loadState = \"loading\";\r\n                await this._Fetch();\r\n                await this._Decode();\r\n                this._loadState = \"loaded\"\r\n            } catch (err) {\r\n                this._loadState = \"failed\";\r\n                console.error(`[Construct] Failed to load audio '${this._url}': `, err)\r\n            }\r\n        }\r\n        IsLoaded() {\r\n            return !!(this._audioData || this._audioBuffer)\r\n        }\r\n        IsLoadedAndDecoded() {\r\n            return !!this._audioBuffer\r\n        }\r\n        GetAudioBuffer() {\r\n            return this._audioBuffer\r\n        }\r\n        GetDuration() {\r\n            return this._audioBuffer ? this._audioBuffer[\"duration\"] : 0\r\n        }\r\n    }\r\n}\r\n;'use strict';\r\n{\r\n    let nextAiId = 0;\r\n    self.C3AudioInstance = class C3AudioInstance {\r\n        constructor(audioDomHandler, buffer, tag) {\r\n            this._audioDomHandler = audioDomHandler;\r\n            this._buffer = buffer;\r\n            this._tag = tag;\r\n            this._aiId = nextAiId++;\r\n            this._gainNode = this.GetAudioContext()[\"createGain\"]();\r\n            this._gainNode[\"connect\"](this.GetDestinationNode());\r\n            this._pannerNode = null;\r\n            this._isPannerEnabled = false;\r\n            this._pannerPosition = [0, 0, 0];\r\n            this._pannerOrientation = [0, 0, 0];\r\n            this._isStopped = true;\r\n            this._isPaused = false;\r\n            this._resumeMe = false;\r\n            this._isLooping = false;\r\n            this._volume = 1;\r\n            this._isMuted = false;\r\n            this._playbackRate = 1;\r\n            const timeScaleMode = this._audioDomHandler.GetTimeScaleMode();\r\n            this._isTimescaled = timeScaleMode === 1 && !this.IsMusic() || timeScaleMode === 2;\r\n            this._instUid = -1;\r\n            this._fadeEndTime = -1;\r\n            this._stopOnFadeEnd = false\r\n        }\r\n        Release() {\r\n            this._audioDomHandler = null;\r\n            this._buffer = null;\r\n            if (this._pannerNode) {\r\n                this._pannerNode[\"disconnect\"]();\r\n                this._pannerNode = null\r\n            }\r\n            this._gainNode[\"disconnect\"]();\r\n            this._gainNode = null\r\n        }\r\n        GetAudioContext() {\r\n            return this._audioDomHandler.GetAudioContext()\r\n        }\r\n        GetDestinationNode() {\r\n            return this._audioDomHandler.GetDestinationForTag(this._tag)\r\n        }\r\n        GetCurrentTime() {\r\n            if (this._isTimescaled)\r\n                return this._audioDomHandler.GetGameTime();\r\n            else\r\n                return performance.now() \/ 1E3\r\n        }\r\n        GetOriginalUrl() {\r\n            return this._buffer.GetOriginalUrl()\r\n        }\r\n        GetUrl() {\r\n            return this._buffer.GetUrl()\r\n        }\r\n        GetContentType() {\r\n            return this._buffer.GetContentType()\r\n        }\r\n        GetBuffer() {\r\n            return this._buffer\r\n        }\r\n        IsMusic() {\r\n            return this._buffer.IsMusic()\r\n        }\r\n        SetTag(tag) {\r\n            this._tag = tag\r\n        }\r\n        GetTag() {\r\n            return this._tag\r\n        }\r\n        GetAiId() {\r\n            return this._aiId\r\n        }\r\n        HasEnded() {}\r\n        CanBeRecycled() {}\r\n        IsPlaying() {\r\n            return !this._isStopped && !this._isPaused && !this.HasEnded()\r\n        }\r\n        IsActive() {\r\n            return !this._isStopped && !this.HasEnded()\r\n        }\r\n        GetPlaybackTime() {}\r\n        GetDuration(applyPlaybackRate) {\r\n            let ret = this._buffer.GetDuration();\r\n            if (applyPlaybackRate)\r\n                ret \/= this._playbackRate || .001;\r\n            return ret\r\n        }\r\n        Play(isLooping, vol, seekPos, scheduledTime) {}\r\n        Stop() {}\r\n        Pause() {}\r\n        IsPaused() {\r\n            return this._isPaused\r\n        }\r\n        Resume() {}\r\n        SetVolume(v) {\r\n            this._volume = v;\r\n            this._gainNode[\"gain\"][\"cancelScheduledValues\"](0);\r\n            this._fadeEndTime = -1;\r\n            this._gainNode[\"gain\"][\"value\"] = this.GetOutputVolume()\r\n        }\r\n        FadeVolume(vol, duration, stopOnEnd) {\r\n            if (this.IsMuted())\r\n                return;\r\n            const gainParam = this._gainNode[\"gain\"];\r\n            gainParam[\"cancelScheduledValues\"](0);\r\n            const currentTime = this._audioDomHandler.GetAudioCurrentTime();\r\n            const endTime = currentTime + duration;\r\n            gainParam[\"setValueAtTime\"](gainParam[\"value\"], currentTime);\r\n            gainParam[\"linearRampToValueAtTime\"](vol, endTime);\r\n            this._volume = vol;\r\n            this._fadeEndTime = endTime;\r\n            this._stopOnFadeEnd = stopOnEnd\r\n        }\r\n        _UpdateVolume() {\r\n            this.SetVolume(this._volume)\r\n        }\r\n        Tick(currentTime) {\r\n            if (this._fadeEndTime !== -1 && currentTime >= this._fadeEndTime) {\r\n                this._fadeEndTime = -1;\r\n                if (this._stopOnFadeEnd)\r\n                    this.Stop();\r\n                this._audioDomHandler.PostTrigger(\"fade-ended\", this._tag, this._aiId)\r\n            }\r\n        }\r\n        GetOutputVolume() {\r\n            const ret = this._volume;\r\n            return isFinite(ret) ? ret : 0\r\n        }\r\n        SetMuted(m) {\r\n            m = !!m;\r\n            if (this._isMuted === m)\r\n                return;\r\n            this._isMuted = m;\r\n            this._UpdateMuted()\r\n        }\r\n        IsMuted() {\r\n            return this._isMuted\r\n        }\r\n        IsSilent() {\r\n            return this._audioDomHandler.IsSilent()\r\n        }\r\n        _UpdateMuted() {}\r\n        SetLooping(l) {}\r\n        IsLooping() {\r\n            return this._isLooping\r\n        }\r\n        SetPlaybackRate(r) {\r\n            if (this._playbackRate === r)\r\n                return;\r\n            this._playbackRate = r;\r\n            this._UpdatePlaybackRate()\r\n        }\r\n        _UpdatePlaybackRate() {}\r\n        GetPlaybackRate() {\r\n            return this._playbackRate\r\n        }\r\n        Seek(pos) {}\r\n        SetSuspended(s) {}\r\n        SetPannerEnabled(e) {\r\n            e = !!e;\r\n            if (this._isPannerEnabled === e)\r\n                return;\r\n            this._isPannerEnabled = e;\r\n            if (this._isPannerEnabled) {\r\n                if (!this._pannerNode) {\r\n                    this._pannerNode = this.GetAudioContext()[\"createPanner\"]();\r\n                    this._pannerNode[\"panningModel\"] = this._audioDomHandler.GetPanningModel();\r\n                    this._pannerNode[\"distanceModel\"] = this._audioDomHandler.GetDistanceModel();\r\n                    this._pannerNode[\"refDistance\"] = this._audioDomHandler.GetReferenceDistance();\r\n                    this._pannerNode[\"maxDistance\"] = this._audioDomHandler.GetMaxDistance();\r\n                    this._pannerNode[\"rolloffFactor\"] = this._audioDomHandler.GetRolloffFactor()\r\n                }\r\n                this._gainNode[\"disconnect\"]();\r\n                this._gainNode[\"connect\"](this._pannerNode);\r\n                this._pannerNode[\"connect\"](this.GetDestinationNode())\r\n            } else {\r\n                this._pannerNode[\"disconnect\"]();\r\n                this._gainNode[\"disconnect\"]();\r\n                this._gainNode[\"connect\"](this.GetDestinationNode())\r\n            }\r\n        }\r\n        SetPan(x, y, angle, innerAngle, outerAngle, outerGain) {\r\n            if (!this._isPannerEnabled)\r\n                return;\r\n            this.SetPanXYA(x, y, angle);\r\n            const toDegrees = self.AudioDOMHandler.ToDegrees;\r\n            this._pannerNode[\"coneInnerAngle\"] = toDegrees(innerAngle);\r\n            this._pannerNode[\"coneOuterAngle\"] = toDegrees(outerAngle);\r\n            this._pannerNode[\"coneOuterGain\"] = outerGain\r\n        }\r\n        SetPanXYA(x, y, angle) {\r\n            if (!this._isPannerEnabled)\r\n                return;\r\n            this._pannerPosition[0] = x;\r\n            this._pannerPosition[1] = y;\r\n            this._pannerPosition[2] = 0;\r\n            this._pannerOrientation[0] = Math.cos(angle);\r\n            this._pannerOrientation[1] = Math.sin(angle);\r\n            this._pannerOrientation[2] = 0;\r\n            this._pannerNode[\"setPosition\"](...this._pannerPosition);\r\n            this._pannerNode[\"setOrientation\"](...this._pannerOrientation)\r\n        }\r\n        SetUID(uid) {\r\n            this._instUid = uid\r\n        }\r\n        GetUID() {\r\n            return this._instUid\r\n        }\r\n        GetResumePosition() {}\r\n        Reconnect(toNode) {\r\n            const outNode = this._pannerNode || this._gainNode;\r\n            outNode[\"disconnect\"]();\r\n            outNode[\"connect\"](toNode)\r\n        }\r\n        GetState() {\r\n            return {\r\n                \"aiid\": this.GetAiId(),\r\n                \"tag\": this._tag,\r\n                \"duration\": this.GetDuration(),\r\n                \"volume\": this._volume,\r\n                \"isPlaying\": this.IsPlaying(),\r\n                \"playbackTime\": this.GetPlaybackTime(),\r\n                \"playbackRate\": this.GetPlaybackRate(),\r\n                \"uid\": this._instUid,\r\n                \"bufferOriginalUrl\": this.GetOriginalUrl(),\r\n                \"bufferUrl\": \"\",\r\n                \"bufferType\": this.GetContentType(),\r\n                \"isMusic\": this.IsMusic(),\r\n                \"isLooping\": this.IsLooping(),\r\n                \"isMuted\": this.IsMuted(),\r\n                \"resumePosition\": this.GetResumePosition(),\r\n                \"pan\": this.GetPanState()\r\n            }\r\n        }\r\n        _LoadAdditionalState(d) {\r\n            this.SetPlaybackRate(d[\"playbackRate\"]);\r\n            this.SetMuted(d[\"isMuted\"])\r\n        }\r\n        GetPanState() {\r\n            if (!this._pannerNode)\r\n                return null;\r\n            const pn = this._pannerNode;\r\n            return {\r\n                \"pos\": this._pannerPosition,\r\n                \"orient\": this._pannerOrientation,\r\n                \"cia\": pn[\"coneInnerAngle\"],\r\n                \"coa\": pn[\"coneOuterAngle\"],\r\n                \"cog\": pn[\"coneOuterGain\"],\r\n                \"uid\": this._instUid\r\n            }\r\n        }\r\n        LoadPanState(d) {\r\n            if (!d) {\r\n                this.SetPannerEnabled(false);\r\n                return\r\n            }\r\n            this.SetPannerEnabled(true);\r\n            const pn = this._pannerNode;\r\n            const panPos = pn[\"pos\"];\r\n            this._pannerPosition[0] = panPos[0];\r\n            this._pannerPosition[1] = panPos[1];\r\n            this._pannerPosition[2] = panPos[2];\r\n            const panOrient = pn[\"orient\"];\r\n            this._pannerOrientation[0] = panOrient[0];\r\n            this._pannerOrientation[1] = panOrient[1];\r\n            this._pannerOrientation[2] = panOrient[2];\r\n            pn[\"setPosition\"](...this._pannerPosition);\r\n            pn[\"setOrientation\"](...this._pannerOrientation);\r\n            pn[\"coneInnerAngle\"] = pn[\"cia\"];\r\n            pn[\"coneOuterAngle\"] = pn[\"coa\"];\r\n            pn[\"coneOuterGain\"] = pn[\"cog\"];\r\n            this._instUid = pn[\"uid\"]\r\n        }\r\n    }\r\n}\r\n;'use strict';\r\n{\r\n    self.C3Html5AudioInstance = class C3Html5AudioInstance extends self.C3AudioInstance {\r\n        constructor(audioDomHandler, buffer, tag) {\r\n            super(audioDomHandler, buffer, tag);\r\n            this._buffer.GetOutputNode()[\"connect\"](this._gainNode);\r\n            this._buffer.onended = () => this._OnEnded()\r\n        }\r\n        Release() {\r\n            this.Stop();\r\n            this._buffer.GetOutputNode()[\"disconnect\"]();\r\n            super.Release()\r\n        }\r\n        GetAudioElement() {\r\n            return this._buffer.GetAudioElement()\r\n        }\r\n        _OnEnded() {\r\n            this._isStopped = true;\r\n            this._instUid = -1;\r\n            this._audioDomHandler.PostTrigger(\"ended\", this._tag, this._aiId)\r\n        }\r\n        HasEnded() {\r\n            return this.GetAudioElement()[\"ended\"]\r\n        }\r\n        CanBeRecycled() {\r\n            if (this._isStopped)\r\n                return true;\r\n            return this.HasEnded()\r\n        }\r\n        GetPlaybackTime() {\r\n            let ret = this.GetAudioElement()[\"currentTime\"];\r\n            if (!this._isLooping)\r\n                ret = Math.min(ret, this.GetDuration());\r\n            return ret\r\n        }\r\n        Play(isLooping, vol, seekPos, scheduledTime) {\r\n            const audioElem = this.GetAudioElement();\r\n            if (audioElem.playbackRate !== 1)\r\n                audioElem.playbackRate = 1;\r\n            if (audioElem.loop !== isLooping)\r\n                audioElem.loop = isLooping;\r\n            this.SetVolume(vol);\r\n            if (audioElem.muted)\r\n                audioElem.muted = false;\r\n            if (audioElem.currentTime !== seekPos)\r\n                try {\r\n                    audioElem.currentTime = seekPos\r\n                } catch (err) {\r\n                    console.warn(`[Construct] Exception seeking audio '${this._buffer.GetUrl()}' to position '${seekPos}': `, err)\r\n                }\r\n            this._audioDomHandler.TryPlayMedia(audioElem);\r\n            this._isStopped = false;\r\n            this._isPaused = false;\r\n            this._isLooping = isLooping;\r\n            this._playbackRate = 1\r\n        }\r\n        Stop() {\r\n            const audioElem = this.GetAudioElement();\r\n            if (!audioElem.paused)\r\n                audioElem.pause();\r\n            this._audioDomHandler.RemovePendingPlay(audioElem);\r\n            this._isStopped = true;\r\n            this._isPaused = false;\r\n            this._instUid = -1\r\n        }\r\n        Pause() {\r\n            if (this._isPaused || this._isStopped || this.HasEnded())\r\n                return;\r\n            const audioElem = this.GetAudioElement();\r\n            if (!audioElem.paused)\r\n                audioElem.pause();\r\n            this._audioDomHandler.RemovePendingPlay(audioElem);\r\n            this._isPaused = true\r\n        }\r\n        Resume() {\r\n            if (!this._isPaused || this._isStopped || this.HasEnded())\r\n                return;\r\n            this._audioDomHandler.TryPlayMedia(this.GetAudioElement());\r\n            this._isPaused = false\r\n        }\r\n        _UpdateMuted() {\r\n            this.GetAudioElement().muted = this._isMuted || this.IsSilent()\r\n        }\r\n        SetLooping(l) {\r\n            l = !!l;\r\n            if (this._isLooping === l)\r\n                return;\r\n            this._isLooping = l;\r\n            this.GetAudioElement().loop = l\r\n        }\r\n        _UpdatePlaybackRate() {\r\n            let r = this._playbackRate;\r\n            if (this._isTimescaled)\r\n                r *= this._audioDomHandler.GetTimeScale();\r\n            try {\r\n                this.GetAudioElement()[\"playbackRate\"] = r\r\n            } catch (err) {\r\n                console.warn(`[Construct] Unable to set playback rate '${r}':`, err)\r\n            }\r\n        }\r\n        Seek(pos) {\r\n            if (this._isStopped || this.HasEnded())\r\n                return;\r\n            try {\r\n                this.GetAudioElement()[\"currentTime\"] = pos\r\n            } catch (err) {\r\n                console.warn(`[Construct] Error seeking audio to '${pos}': `, err)\r\n            }\r\n        }\r\n        GetResumePosition() {\r\n            return this.GetPlaybackTime()\r\n        }\r\n        SetSuspended(s) {\r\n            if (s)\r\n                if (this.IsPlaying()) {\r\n                    this.GetAudioElement()[\"pause\"]();\r\n                    this._resumeMe = true\r\n                } else\r\n                    this._resumeMe = false;\r\n            else if (this._resumeMe) {\r\n                this._audioDomHandler.TryPlayMedia(this.GetAudioElement());\r\n                this._resumeMe = false\r\n            }\r\n        }\r\n    }\r\n}\r\n;'use strict';\r\n{\r\n    self.C3WebAudioInstance = class C3WebAudioInstance extends self.C3AudioInstance {\r\n        constructor(audioDomHandler, buffer, tag) {\r\n            super(audioDomHandler, buffer, tag);\r\n            this._bufferSource = null;\r\n            this._onended_handler = e => this._OnEnded(e);\r\n            this._hasPlaybackEnded = true;\r\n            this._activeSource = null;\r\n            this._playStartTime = 0;\r\n            this._playFromSeekPos = 0;\r\n            this._resumePosition = 0;\r\n            this._muteVol = 1\r\n        }\r\n        Release() {\r\n            this.Stop();\r\n            this._ReleaseBufferSource();\r\n            this._onended_handler = null;\r\n            super.Release()\r\n        }\r\n        _ReleaseBufferSource() {\r\n            if (this._bufferSource)\r\n                this._bufferSource[\"disconnect\"]();\r\n            this._bufferSource = null;\r\n            this._activeSource = null\r\n        }\r\n        _OnEnded(e) {\r\n            if (this._isPaused || this._resumeMe)\r\n                return;\r\n            if (e.target !== this._activeSource)\r\n                return;\r\n            this._hasPlaybackEnded = true;\r\n            this._isStopped = true;\r\n            this._instUid = -1;\r\n            this._ReleaseBufferSource();\r\n            this._audioDomHandler.PostTrigger(\"ended\", this._tag, this._aiId)\r\n        }\r\n        HasEnded() {\r\n            if (!this._isStopped && this._bufferSource && this._bufferSource[\"loop\"])\r\n                return false;\r\n            if (this._isPaused)\r\n                return false;\r\n            return this._hasPlaybackEnded\r\n        }\r\n        CanBeRecycled() {\r\n            if (!this._bufferSource || this._isStopped)\r\n                return true;\r\n            return this.HasEnded()\r\n        }\r\n        GetPlaybackTime() {\r\n            let ret = 0;\r\n            if (this._isPaused)\r\n                ret = this._resumePosition;\r\n            else\r\n                ret = this._playFromSeekPos + (this.GetCurrentTime() - this._playStartTime) * this._playbackRate;\r\n            if (!this._isLooping)\r\n                ret = Math.min(ret, this.GetDuration());\r\n            return ret\r\n        }\r\n        Play(isLooping, vol, seekPos, scheduledTime) {\r\n            this._muteVol = 1;\r\n            this.SetVolume(vol);\r\n            this._ReleaseBufferSource();\r\n            this._bufferSource = this.GetAudioContext()[\"createBufferSource\"]();\r\n            this._bufferSource[\"buffer\"] = this._buffer.GetAudioBuffer();\r\n            this._bufferSource[\"connect\"](this._gainNode);\r\n            this._activeSource = this._bufferSource;\r\n            this._bufferSource[\"onended\"] = this._onended_handler;\r\n            this._bufferSource[\"loop\"] = isLooping;\r\n            this._bufferSource[\"start\"](scheduledTime, seekPos);\r\n            this._hasPlaybackEnded = false;\r\n            this._isStopped = false;\r\n            this._isPaused = false;\r\n            this._isLooping = isLooping;\r\n            this._playbackRate = 1;\r\n            this._playStartTime = this.GetCurrentTime();\r\n            this._playFromSeekPos = seekPos\r\n        }\r\n        Stop() {\r\n            if (this._bufferSource)\r\n                try {\r\n                    this._bufferSource[\"stop\"](0)\r\n                } catch (err) {}\r\n            this._isStopped = true;\r\n            this._isPaused = false;\r\n            this._instUid = -1\r\n        }\r\n        Pause() {\r\n            if (this._isPaused || this._isStopped || this.HasEnded())\r\n                return;\r\n            this._resumePosition = this.GetPlaybackTime();\r\n            if (this._isLooping)\r\n                this._resumePosition %= this.GetDuration();\r\n            this._isPaused = true;\r\n            this._bufferSource[\"stop\"](0)\r\n        }\r\n        Resume() {\r\n            if (!this._isPaused || this._isStopped || this.HasEnded())\r\n                return;\r\n            this._ReleaseBufferSource();\r\n            this._bufferSource = this.GetAudioContext()[\"createBufferSource\"]();\r\n            this._bufferSource[\"buffer\"] = this._buffer.GetAudioBuffer();\r\n            this._bufferSource[\"connect\"](this._gainNode);\r\n            this._activeSource = this._bufferSource;\r\n            this._bufferSource[\"onended\"] = this._onended_handler;\r\n            this._bufferSource[\"loop\"] = this._isLooping;\r\n            this._UpdateVolume();\r\n            this._UpdatePlaybackRate();\r\n            this._bufferSource[\"start\"](0, this._resumePosition);\r\n            this._playStartTime = this.GetCurrentTime();\r\n            this._playFromSeekPos = this._resumePosition;\r\n            this._isPaused = false\r\n        }\r\n        GetOutputVolume() {\r\n            return super.GetOutputVolume() * this._muteVol\r\n        }\r\n        _UpdateMuted() {\r\n            this._muteVol = this._isMuted || this.IsSilent() ? 0 : 1;\r\n            this._UpdateVolume()\r\n        }\r\n        SetLooping(l) {\r\n            l = !!l;\r\n            if (this._isLooping === l)\r\n                return;\r\n            this._isLooping = l;\r\n            if (this._bufferSource)\r\n                this._bufferSource[\"loop\"] = l\r\n        }\r\n        _UpdatePlaybackRate() {\r\n            let r = this._playbackRate;\r\n            if (this._isTimescaled)\r\n                r *= this._audioDomHandler.GetTimeScale();\r\n            if (this._bufferSource)\r\n                this._bufferSource[\"playbackRate\"][\"value\"] = r\r\n        }\r\n        Seek(pos) {\r\n            if (this._isStopped || this.HasEnded())\r\n                return;\r\n            if (this._isPaused)\r\n                this._resumePosition = pos;\r\n            else {\r\n                this.Pause();\r\n                this._resumePosition = pos;\r\n                this.Resume()\r\n            }\r\n        }\r\n        GetResumePosition() {\r\n            return this._resumePosition\r\n        }\r\n        SetSuspended(s) {\r\n            if (s)\r\n                if (this.IsPlaying()) {\r\n                    this._resumeMe = true;\r\n                    this._resumePosition = this.GetPlaybackTime();\r\n                    if (this._isLooping)\r\n                        this._resumePosition %= this.GetDuration();\r\n                    this._bufferSource[\"stop\"](0)\r\n                } else\r\n                    this._resumeMe = false;\r\n            else if (this._resumeMe) {\r\n                this._ReleaseBufferSource();\r\n                this._bufferSource = this.GetAudioContext()[\"createBufferSource\"]();\r\n                this._bufferSource[\"buffer\"] = this._buffer.GetAudioBuffer();\r\n                this._bufferSource[\"connect\"](this._gainNode);\r\n                this._activeSource = this._bufferSource;\r\n                this._bufferSource[\"onended\"] = this._onended_handler;\r\n                this._bufferSource[\"loop\"] = this._isLooping;\r\n                this._UpdateVolume();\r\n                this._UpdatePlaybackRate();\r\n                this._bufferSource[\"start\"](0, this._resumePosition);\r\n                this._playStartTime = this.GetCurrentTime();\r\n                this._playFromSeekPos = this._resumePosition;\r\n                this._resumeMe = false\r\n            }\r\n        }\r\n        _LoadAdditionalState(d) {\r\n            super._LoadAdditionalState(d);\r\n            this._resumePosition = d[\"resumePosition\"]\r\n        }\r\n    }\r\n}\r\n;'use strict';\r\n{\r\n    class AudioFXBase {\r\n        constructor(audioDomHandler) {\r\n            this._audioDomHandler = audioDomHandler;\r\n            this._audioContext = audioDomHandler.GetAudioContext();\r\n            this._index = -1;\r\n            this._tag = \"\";\r\n            this._type = \"\";\r\n            this._params = null\r\n        }\r\n        Release() {\r\n            this._audioContext = null\r\n        }\r\n        _SetIndex(i) {\r\n            this._index = i\r\n        }\r\n        GetIndex() {\r\n            return this._index\r\n        }\r\n        _SetTag(t) {\r\n            this._tag = t\r\n        }\r\n        GetTag() {\r\n            return this._tag\r\n        }\r\n        CreateGain() {\r\n            return this._audioContext[\"createGain\"]()\r\n        }\r\n        GetInputNode() {}\r\n        ConnectTo(node) {}\r\n        SetAudioParam(ap, value, ramp, time) {\r\n            ap[\"cancelScheduledValues\"](0);\r\n            if (time === 0) {\r\n                ap[\"value\"] = value;\r\n                return\r\n            }\r\n            const curTime = this._audioContext[\"currentTime\"];\r\n            time += curTime;\r\n            switch (ramp) {\r\n            case 0:\r\n                ap[\"setValueAtTime\"](value, time);\r\n                break;\r\n            case 1:\r\n                ap[\"setValueAtTime\"](ap[\"value\"], curTime);\r\n                ap[\"linearRampToValueAtTime\"](value, time);\r\n                break;\r\n            case 2:\r\n                ap[\"setValueAtTime\"](ap[\"value\"], curTime);\r\n                ap[\"exponentialRampToValueAtTime\"](value, time);\r\n                break\r\n            }\r\n        }\r\n        GetState() {\r\n            return {\r\n                \"type\": this._type,\r\n                \"tag\": this._tag,\r\n                \"params\": this._params\r\n            }\r\n        }\r\n    }\r\n    self.C3AudioFilterFX = class C3AudioFilterFX extends AudioFXBase {\r\n        constructor(audioDomHandler, type, freq, detune, q, gain, mix) {\r\n            super(audioDomHandler);\r\n            this._type = \"filter\";\r\n            this._params = [type, freq, detune, q, gain, mix];\r\n            this._inputNode = this.CreateGain();\r\n            this._wetNode = this.CreateGain();\r\n            this._wetNode[\"gain\"][\"value\"] = mix;\r\n            this._dryNode = this.CreateGain();\r\n            this._dryNode[\"gain\"][\"value\"] = 1 - mix;\r\n            this._filterNode = this._audioContext[\"createBiquadFilter\"]();\r\n            this._filterNode[\"type\"] = type;\r\n            this._filterNode[\"frequency\"][\"value\"] = freq;\r\n            this._filterNode[\"detune\"][\"value\"] = detune;\r\n            this._filterNode[\"Q\"][\"value\"] = q;\r\n            this._filterNode[\"gain\"][\"vlaue\"] = gain;\r\n            this._inputNode[\"connect\"](this._filterNode);\r\n            this._inputNode[\"connect\"](this._dryNode);\r\n            this._filterNode[\"connect\"](this._wetNode)\r\n        }\r\n        Release() {\r\n            this._inputNode[\"disconnect\"]();\r\n            this._filterNode[\"disconnect\"]();\r\n            this._wetNode[\"disconnect\"]();\r\n            this._dryNode[\"disconnect\"]();\r\n            super.Release()\r\n        }\r\n        ConnectTo(node) {\r\n            this._wetNode[\"disconnect\"]();\r\n            this._wetNode[\"connect\"](node);\r\n            this._dryNode[\"disconnect\"]();\r\n            this._dryNode[\"connect\"](node)\r\n        }\r\n        GetInputNode() {\r\n            return this._inputNode\r\n        }\r\n        SetParam(param, value, ramp, time) {\r\n            switch (param) {\r\n            case 0:\r\n                value = Math.max(Math.min(value \/ 100, 1), 0);\r\n                this._params[5] = value;\r\n                this.SetAudioParam(this._wetNode[\"gain\"], value, ramp, time);\r\n                this.SetAudioParam(this._dryNode[\"gain\"], 1 - value, ramp, time);\r\n                break;\r\n            case 1:\r\n                this._params[1] = value;\r\n                this.SetAudioParam(this._filterNode[\"frequency\"], value, ramp, time);\r\n                break;\r\n            case 2:\r\n                this._params[2] = value;\r\n                this.SetAudioParam(this._filterNode[\"detune\"], value, ramp, time);\r\n                break;\r\n            case 3:\r\n                this._params[3] = value;\r\n                this.SetAudioParam(this._filterNode[\"Q\"], value, ramp, time);\r\n                break;\r\n            case 4:\r\n                this._params[4] = value;\r\n                this.SetAudioParam(this._filterNode[\"gain\"], value, ramp, time);\r\n                break\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    self.C3AudioDelayFX = class C3AudioDelayFX extends AudioFXBase {\r\n        constructor(audioDomHandler, delayTime, delayGain, mix) {\r\n            super(audioDomHandler);\r\n            this._type = \"delay\";\r\n            this._params = [delayTime, delayGain, mix];\r\n            this._inputNode = this.CreateGain();\r\n            this._wetNode = this.CreateGain();\r\n            this._wetNode[\"gain\"][\"value\"] = mix;\r\n            this._dryNode = this.CreateGain();\r\n            this._dryNode[\"gain\"][\"value\"] = 1 - mix;\r\n            this._mainNode = this.CreateGain();\r\n            this._delayNode = this._audioContext[\"createDelay\"](delayTime);\r\n            this._delayNode[\"delayTime\"][\"value\"] = delayTime;\r\n            this._delayGainNode = this.CreateGain();\r\n            this._delayGainNode[\"gain\"][\"value\"] = delayGain;\r\n            this._inputNode[\"connect\"](this._mainNode);\r\n            this._inputNode[\"connect\"](this._dryNode);\r\n            this._mainNode[\"connect\"](this._wetNode);\r\n            this._mainNode[\"connect\"](this._delayNode);\r\n            this._delayNode[\"connect\"](this._delayGainNode);\r\n            this._delayGainNode[\"connect\"](this._mainNode)\r\n        }\r\n        Release() {\r\n            this._inputNode[\"disconnect\"]();\r\n            this._wetNode[\"disconnect\"]();\r\n            this._dryNode[\"disconnect\"]();\r\n            this._mainNode[\"disconnect\"]();\r\n            this._delayNode[\"disconnect\"]();\r\n            this._delayGainNode[\"disconnect\"]();\r\n            super.Release()\r\n        }\r\n        ConnectTo(node) {\r\n            this._wetNode[\"disconnect\"]();\r\n            this._wetNode[\"connect\"](node);\r\n            this._dryNode[\"disconnect\"]();\r\n            this._dryNode[\"connect\"](node)\r\n        }\r\n        GetInputNode() {\r\n            return this._inputNode\r\n        }\r\n        SetParam(param, value, ramp, time) {\r\n            const DbToLinear = self.AudioDOMHandler.DbToLinear;\r\n            switch (param) {\r\n            case 0:\r\n                value = Math.max(Math.min(value \/ 100, 1), 0);\r\n                this._params[2] = value;\r\n                this.SetAudioParam(this._wetNode[\"gain\"], value, ramp, time);\r\n                this.SetAudioParam(this._dryNode[\"gain\"], 1 - value, ramp, time);\r\n                break;\r\n            case 4:\r\n                this._params[1] = DbToLinear(value);\r\n                this.SetAudioParam(this._delayGainNode[\"gain\"], DbToLinear(value), ramp, time);\r\n                break;\r\n            case 5:\r\n                this._params[0] = value;\r\n                this.SetAudioParam(this._delayNode[\"delayTime\"], value, ramp, time);\r\n                break\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    self.C3AudioConvolveFX = class C3AudioConvolveFX extends AudioFXBase {\r\n        constructor(audioDomHandler, buffer, normalize, mix) {\r\n            super(audioDomHandler);\r\n            this._type = \"convolution\";\r\n            this._params = [normalize, mix];\r\n            this._bufferOriginalUrl = \"\";\r\n            this._bufferUrl = \"\";\r\n            this._bufferType = \"\";\r\n            this._inputNode = this.CreateGain();\r\n            this._wetNode = this.CreateGain();\r\n            this._wetNode[\"gain\"][\"value\"] = mix;\r\n            this._dryNode = this.CreateGain();\r\n            this._dryNode[\"gain\"][\"value\"] = 1 - mix;\r\n            this._convolveNode = this._audioContext[\"createConvolver\"]();\r\n            this._convolveNode[\"normalize\"] = normalize;\r\n            this._convolveNode[\"buffer\"] = buffer;\r\n            this._inputNode[\"connect\"](this._convolveNode);\r\n            this._inputNode[\"connect\"](this._dryNode);\r\n            this._convolveNode[\"connect\"](this._wetNode)\r\n        }\r\n        Release() {\r\n            this._inputNode[\"disconnect\"]();\r\n            this._convolveNode[\"disconnect\"]();\r\n            this._wetNode[\"disconnect\"]();\r\n            this._dryNode[\"disconnect\"]();\r\n            super.Release()\r\n        }\r\n        ConnectTo(node) {\r\n            this._wetNode[\"disconnect\"]();\r\n            this._wetNode[\"connect\"](node);\r\n            this._dryNode[\"disconnect\"]();\r\n            this._dryNode[\"connect\"](node)\r\n        }\r\n        GetInputNode() {\r\n            return this._inputNode\r\n        }\r\n        SetParam(param, value, ramp, time) {\r\n            switch (param) {\r\n            case 0:\r\n                value = Math.max(Math.min(value \/ 100, 1), 0);\r\n                this._params[1] = value;\r\n                this.SetAudioParam(this._wetNode[\"gain\"], value, ramp, time);\r\n                this.SetAudioParam(this._dryNode[\"gain\"], 1 - value, ramp, time);\r\n                break\r\n            }\r\n        }\r\n        _SetBufferInfo(bufferOriginalUrl, bufferUrl, bufferType) {\r\n            this._bufferOriginalUrl = bufferOriginalUrl;\r\n            this._bufferUrl = bufferUrl;\r\n            this._bufferType = bufferType\r\n        }\r\n        GetState() {\r\n            const ret = super.GetState();\r\n            ret[\"bufferOriginalUrl\"] = this._bufferOriginalUrl;\r\n            ret[\"bufferUrl\"] = \"\";\r\n            ret[\"bufferType\"] = this._bufferType;\r\n            return ret\r\n        }\r\n    }\r\n    ;\r\n    self.C3AudioFlangerFX = class C3AudioFlangerFX extends AudioFXBase {\r\n        constructor(audioDomHandler, delay, modulation, freq, feedback, mix) {\r\n            super(audioDomHandler);\r\n            this._type = \"flanger\";\r\n            this._params = [delay, modulation, freq, feedback, mix];\r\n            this._inputNode = this.CreateGain();\r\n            this._dryNode = this.CreateGain();\r\n            this._dryNode[\"gain\"][\"value\"] = 1 - mix \/ 2;\r\n            this._wetNode = this.CreateGain();\r\n            this._wetNode[\"gain\"][\"value\"] = mix \/ 2;\r\n            this._feedbackNode = this.CreateGain();\r\n            this._feedbackNode[\"gain\"][\"value\"] = feedback;\r\n            this._delayNode = this._audioContext[\"createDelay\"](delay + modulation);\r\n            this._delayNode[\"delayTime\"][\"value\"] = delay;\r\n            this._oscNode = this._audioContext[\"createOscillator\"]();\r\n            this._oscNode[\"frequency\"][\"value\"] = freq;\r\n            this._oscGainNode = this.CreateGain();\r\n            this._oscGainNode[\"gain\"][\"value\"] = modulation;\r\n            this._inputNode[\"connect\"](this._delayNode);\r\n            this._inputNode[\"connect\"](this._dryNode);\r\n            this._delayNode[\"connect\"](this._wetNode);\r\n            this._delayNode[\"connect\"](this._feedbackNode);\r\n            this._feedbackNode[\"connect\"](this._delayNode);\r\n            this._oscNode[\"connect\"](this._oscGainNode);\r\n            this._oscGainNode[\"connect\"](this._delayNode[\"delayTime\"]);\r\n            this._oscNode[\"start\"](0)\r\n        }\r\n        Release() {\r\n            this._oscNode[\"stop\"](0);\r\n            this._inputNode[\"disconnect\"]();\r\n            this._delayNode[\"disconnect\"]();\r\n            this._oscNode[\"disconnect\"]();\r\n            this._oscGainNode[\"disconnect\"]();\r\n            this._dryNode[\"disconnect\"]();\r\n            this._wetNode[\"disconnect\"]();\r\n            this._feedbackNode[\"disconnect\"]();\r\n            super.Release()\r\n        }\r\n        ConnectTo(node) {\r\n            this._wetNode[\"disconnect\"]();\r\n            this._wetNode[\"connect\"](node);\r\n            this._dryNode[\"disconnect\"]();\r\n            this._dryNode[\"connect\"](node)\r\n        }\r\n        GetInputNode() {\r\n            return this._inputNode\r\n        }\r\n        SetParam(param, value, ramp, time) {\r\n            switch (param) {\r\n            case 0:\r\n                value = Math.max(Math.min(value \/ 100, 1), 0);\r\n                this._params[4] = value;\r\n                this.SetAudioParam(this._wetNode[\"gain\"], value \/ 2, ramp, time);\r\n                this.SetAudioParam(this._dryNode[\"gain\"], 1 - value \/ 2, ramp, time);\r\n                break;\r\n            case 6:\r\n                this._params[1] = value \/ 1E3;\r\n                this.SetAudioParam(this._oscGainNode[\"gain\"], value \/ 1E3, ramp, time);\r\n                break;\r\n            case 7:\r\n                this._params[2] = value;\r\n                this.SetAudioParam(this._oscNode[\"frequency\"], value, ramp, time);\r\n                break;\r\n            case 8:\r\n                this._params[3] = value \/ 100;\r\n                this.SetAudioParam(this._feedbackNode[\"gain\"], value \/ 100, ramp, time);\r\n                break\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    self.C3AudioPhaserFX = class C3AudioPhaserFX extends AudioFXBase {\r\n        constructor(audioDomHandler, freq, detune, q, modulation, modfreq, mix) {\r\n            super(audioDomHandler);\r\n            this._type = \"phaser\";\r\n            this._params = [freq, detune, q, modulation, modfreq, mix];\r\n            this._inputNode = this.CreateGain();\r\n            this._dryNode = this.CreateGain();\r\n            this._dryNode[\"gain\"][\"value\"] = 1 - mix \/ 2;\r\n            this._wetNode = this.CreateGain();\r\n            this._wetNode[\"gain\"][\"value\"] = mix \/ 2;\r\n            this._filterNode = this._audioContext[\"createBiquadFilter\"]();\r\n            this._filterNode[\"type\"] = \"allpass\";\r\n            this._filterNode[\"frequency\"][\"value\"] = freq;\r\n            this._filterNode[\"detune\"][\"value\"] = detune;\r\n            this._filterNode[\"Q\"][\"value\"] = q;\r\n            this._oscNode = this._audioContext[\"createOscillator\"]();\r\n            this._oscNode[\"frequency\"][\"value\"] = modfreq;\r\n            this._oscGainNode = this.CreateGain();\r\n            this._oscGainNode[\"gain\"][\"value\"] = modulation;\r\n            this._inputNode[\"connect\"](this._filterNode);\r\n            this._inputNode[\"connect\"](this._dryNode);\r\n            this._filterNode[\"connect\"](this._wetNode);\r\n            this._oscNode[\"connect\"](this._oscGainNode);\r\n            this._oscGainNode[\"connect\"](this._filterNode[\"frequency\"]);\r\n            this._oscNode[\"start\"](0)\r\n        }\r\n        Release() {\r\n            this._oscNode[\"stop\"](0);\r\n            this._inputNode[\"disconnect\"]();\r\n            this._filterNode[\"disconnect\"]();\r\n            this._oscNode[\"disconnect\"]();\r\n            this._oscGainNode[\"disconnect\"]();\r\n            this._dryNode[\"disconnect\"]();\r\n            this._wetNode[\"disconnect\"]();\r\n            super.Release()\r\n        }\r\n        ConnectTo(node) {\r\n            this._wetNode[\"disconnect\"]();\r\n            this._wetNode[\"connect\"](node);\r\n            this._dryNode[\"disconnect\"]();\r\n            this._dryNode[\"connect\"](node)\r\n        }\r\n        GetInputNode() {\r\n            return this._inputNode\r\n        }\r\n        SetParam(param, value, ramp, time) {\r\n            switch (param) {\r\n            case 0:\r\n                value = Math.max(Math.min(value \/ 100, 1), 0);\r\n                this._params[5] = value;\r\n                this.SetAudioParam(this._wetNode[\"gain\"], value \/ 2, ramp, time);\r\n                this.SetAudioParam(this._dryNode[\"gain\"], 1 - value \/ 2, ramp, time);\r\n                break;\r\n            case 1:\r\n                this._params[0] = value;\r\n                this.SetAudioParam(this._filterNode[\"frequency\"], value, ramp, time);\r\n                break;\r\n            case 2:\r\n                this._params[1] = value;\r\n                this.SetAudioParam(this._filterNode[\"detune\"], value, ramp, time);\r\n                break;\r\n            case 3:\r\n                this._params[2] = value;\r\n                this.SetAudioParam(this._filterNode[\"Q\"], value, ramp, time);\r\n                break;\r\n            case 6:\r\n                this._params[3] = value;\r\n                this.SetAudioParam(this._oscGainNode[\"gain\"], value, ramp, time);\r\n                break;\r\n            case 7:\r\n                this._params[4] = value;\r\n                this.SetAudioParam(this._oscNode[\"frequency\"], value, ramp, time);\r\n                break\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    self.C3AudioGainFX = class C3AudioGainFX extends AudioFXBase {\r\n        constructor(audioDomHandler, g) {\r\n            super(audioDomHandler);\r\n            this._type = \"gain\";\r\n            this._params = [g];\r\n            this._node = this.CreateGain();\r\n            this._node[\"gain\"][\"value\"] = g\r\n        }\r\n        Release() {\r\n            this._node[\"disconnect\"]();\r\n            super.Release()\r\n        }\r\n        ConnectTo(node) {\r\n            this._node[\"disconnect\"]();\r\n            this._node[\"connect\"](node)\r\n        }\r\n        GetInputNode() {\r\n            return this._node\r\n        }\r\n        SetParam(param, value, ramp, time) {\r\n            const DbToLinear = self.AudioDOMHandler.DbToLinear;\r\n            switch (param) {\r\n            case 4:\r\n                this._params[0] = DbToLinear(value);\r\n                this.SetAudioParam(this._node[\"gain\"], DbToLinear(value), ramp, time);\r\n                break\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    self.C3AudioTremoloFX = class C3AudioTremoloFX extends AudioFXBase {\r\n        constructor(audioDomHandler, freq, mix) {\r\n            super(audioDomHandler);\r\n            this._type = \"tremolo\";\r\n            this._params = [freq, mix];\r\n            this._node = this.CreateGain();\r\n            this._node[\"gain\"][\"value\"] = 1 - mix \/ 2;\r\n            this._oscNode = this._audioContext[\"createOscillator\"]();\r\n            this._oscNode[\"frequency\"][\"value\"] = freq;\r\n            this._oscGainNode = this.CreateGain();\r\n            this._oscGainNode[\"gain\"][\"value\"] = mix \/ 2;\r\n            this._oscNode[\"connect\"](this._oscGainNode);\r\n            this._oscGainNode[\"connect\"](this._node[\"gain\"]);\r\n            this._oscNode[\"start\"](0)\r\n        }\r\n        Release() {\r\n            this._oscNode[\"stop\"](0);\r\n            this._oscNode[\"disconnect\"]();\r\n            this._oscGainNode[\"disconnect\"]();\r\n            this._node[\"disconnect\"]();\r\n            super.Release()\r\n        }\r\n        ConnectTo(node) {\r\n            this._node[\"disconnect\"]();\r\n            this._node[\"connect\"](node)\r\n        }\r\n        GetInputNode() {\r\n            return this._node\r\n        }\r\n        SetParam(param, value, ramp, time) {\r\n            switch (param) {\r\n            case 0:\r\n                value = Math.max(Math.min(value \/ 100, 1), 0);\r\n                this._params[1] = value;\r\n                this.SetAudioParam(this._node[\"gain\"], 1 - value \/ 2, ramp, time);\r\n                this.SetAudioParam(this._oscGainNode[\"gain\"], value \/ 2, ramp, time);\r\n                break;\r\n            case 7:\r\n                this._params[0] = value;\r\n                this.SetAudioParam(this._oscNode[\"frequency\"], value, ramp, time);\r\n                break\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    self.C3AudioRingModFX = class C3AudioRingModFX extends AudioFXBase {\r\n        constructor(audioDomHandler, freq, mix) {\r\n            super(audioDomHandler);\r\n            this._type = \"ringmod\";\r\n            this._params = [freq, mix];\r\n            this._inputNode = this.CreateGain();\r\n            this._wetNode = this.CreateGain();\r\n            this._wetNode[\"gain\"][\"value\"] = mix;\r\n            this._dryNode = this.CreateGain();\r\n            this._dryNode[\"gain\"][\"value\"] = 1 - mix;\r\n            this._ringNode = this.CreateGain();\r\n            this._ringNode[\"gain\"][\"value\"] = 0;\r\n            this._oscNode = this._audioContext[\"createOscillator\"]();\r\n            this._oscNode[\"frequency\"][\"value\"] = freq;\r\n            this._oscNode[\"connect\"](this._ringNode[\"gain\"]);\r\n            this._oscNode[\"start\"](0);\r\n            this._inputNode[\"connect\"](this._ringNode);\r\n            this._inputNode[\"connect\"](this._dryNode);\r\n            this._ringNode[\"connect\"](this._wetNode)\r\n        }\r\n        Release() {\r\n            this._oscNode[\"stop\"](0);\r\n            this._oscNode[\"disconnect\"]();\r\n            this._ringNode[\"disconnect\"]();\r\n            this._inputNode[\"disconnect\"]();\r\n            this._wetNode[\"disconnect\"]();\r\n            this._dryNode[\"disconnect\"]();\r\n            super.Release()\r\n        }\r\n        ConnectTo(node) {\r\n            this._wetNode[\"disconnect\"]();\r\n            this._wetNode[\"connect\"](node);\r\n            this._dryNode[\"disconnect\"]();\r\n            this._dryNode[\"connect\"](node)\r\n        }\r\n        GetInputNode() {\r\n            return this._inputNode\r\n        }\r\n        SetParam(param, value, ramp, time) {\r\n            switch (param) {\r\n            case 0:\r\n                value = Math.max(Math.min(value \/ 100, 1), 0);\r\n                this._params[1] = value;\r\n                this.SetAudioParam(this._wetNode[\"gain\"], value, ramp, time);\r\n                this.SetAudioParam(this._dryNode[\"gain\"], 1 - value, ramp, time);\r\n                break;\r\n            case 7:\r\n                this._params[0] = value;\r\n                this.SetAudioParam(this._oscNode[\"frequency\"], value, ramp, time);\r\n                break\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    self.C3AudioDistortionFX = class C3AudioDistortionFX extends AudioFXBase {\r\n        constructor(audioDomHandler, threshold, headroom, drive, makeupgain, mix) {\r\n            super(audioDomHandler);\r\n            this._type = \"distortion\";\r\n            this._params = [threshold, headroom, drive, makeupgain, mix];\r\n            this._inputNode = this.CreateGain();\r\n            this._preGain = this.CreateGain();\r\n            this._postGain = this.CreateGain();\r\n            this._SetDrive(drive, makeupgain);\r\n            this._wetNode = this.CreateGain();\r\n            this._wetNode[\"gain\"][\"value\"] = mix;\r\n            this._dryNode = this.CreateGain();\r\n            this._dryNode[\"gain\"][\"value\"] = 1 - mix;\r\n            this._waveShaper = this._audioContext[\"createWaveShaper\"]();\r\n            this._curve = new Float32Array(65536);\r\n            this._GenerateColortouchCurve(threshold, headroom);\r\n            this._waveShaper.curve = this._curve;\r\n            this._inputNode[\"connect\"](this._preGain);\r\n            this._inputNode[\"connect\"](this._dryNode);\r\n            this._preGain[\"connect\"](this._waveShaper);\r\n            this._waveShaper[\"connect\"](this._postGain);\r\n            this._postGain[\"connect\"](this._wetNode)\r\n        }\r\n        Release() {\r\n            this._inputNode[\"disconnect\"]();\r\n            this._preGain[\"disconnect\"]();\r\n            this._waveShaper[\"disconnect\"]();\r\n            this._postGain[\"disconnect\"]();\r\n            this._wetNode[\"disconnect\"]();\r\n            this._dryNode[\"disconnect\"]();\r\n            super.Release()\r\n        }\r\n        _SetDrive(drive, makeupgain) {\r\n            if (drive < .01)\r\n                drive = .01;\r\n            this._preGain[\"gain\"][\"value\"] = drive;\r\n            this._postGain[\"gain\"][\"value\"] = Math.pow(1 \/ drive, .6) * makeupgain\r\n        }\r\n        _GenerateColortouchCurve(threshold, headroom) {\r\n            const n = 65536;\r\n            const n2 = n \/ 2;\r\n            for (let i = 0; i < n2; ++i) {\r\n                let x = i \/ n2;\r\n                x = this._Shape(x, threshold, headroom);\r\n                this._curve[n2 + i] = x;\r\n                this._curve[n2 - i - 1] = -x\r\n            }\r\n        }\r\n        _Shape(x, threshold, headroom) {\r\n            const maximum = 1.05 * headroom * threshold;\r\n            const kk = maximum - threshold;\r\n            const sign = x < 0 ? -1 : +1;\r\n            const absx = x < 0 ? -x : x;\r\n            let shapedInput = absx < threshold ? absx : threshold + kk * self.AudioDOMHandler.e4(absx - threshold, 1 \/ kk);\r\n            shapedInput *= sign;\r\n            return shapedInput\r\n        }\r\n        ConnectTo(node) {\r\n            this._wetNode[\"disconnect\"]();\r\n            this._wetNode[\"connect\"](node);\r\n            this._dryNode[\"disconnect\"]();\r\n            this._dryNode[\"connect\"](node)\r\n        }\r\n        GetInputNode() {\r\n            return this._inputNode\r\n        }\r\n        SetParam(param, value, ramp, time) {\r\n            switch (param) {\r\n            case 0:\r\n                value = Math.max(Math.min(value \/ 100, 1), 0);\r\n                this._params[4] = value;\r\n                this.SetAudioParam(this._wetNode[\"gain\"], value, ramp, time);\r\n                this.SetAudioParam(this._dryNode[\"gain\"], 1 - value, ramp, time);\r\n                break\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    self.C3AudioCompressorFX = class C3AudioCompressorFX extends AudioFXBase {\r\n        constructor(audioDomHandler, threshold, knee, ratio, attack, release) {\r\n            super(audioDomHandler);\r\n            this._type = \"compressor\";\r\n            this._params = [threshold, knee, ratio, attack, release];\r\n            this._node = this._audioContext[\"createDynamicsCompressor\"]();\r\n            this._node[\"threshold\"][\"value\"] = threshold;\r\n            this._node[\"knee\"][\"value\"] = knee;\r\n            this._node[\"ratio\"][\"value\"] = ratio;\r\n            this._node[\"attack\"][\"value\"] = attack;\r\n            this._node[\"release\"][\"value\"] = release\r\n        }\r\n        Release() {\r\n            this._node[\"disconnect\"]();\r\n            super.Release()\r\n        }\r\n        ConnectTo(node) {\r\n            this._node[\"disconnect\"]();\r\n            this._node[\"connect\"](node)\r\n        }\r\n        GetInputNode() {\r\n            return this._node\r\n        }\r\n        SetParam(param, value, ramp, time) {}\r\n    }\r\n    ;\r\n    self.C3AudioAnalyserFX = class C3AudioAnalyserFX extends AudioFXBase {\r\n        constructor(audioDomHandler, fftSize, smoothing) {\r\n            super(audioDomHandler);\r\n            this._type = \"analyser\";\r\n            this._params = [fftSize, smoothing];\r\n            this._node = this._audioContext[\"createAnalyser\"]();\r\n            this._node[\"fftSize\"] = fftSize;\r\n            this._node[\"smoothingTimeConstant\"] = smoothing;\r\n            this._freqBins = new Float32Array(this._node[\"frequencyBinCount\"]);\r\n            this._signal = new Uint8Array(fftSize);\r\n            this._peak = 0;\r\n            this._rms = 0;\r\n            this._audioDomHandler._AddAnalyser(this)\r\n        }\r\n        Release() {\r\n            this._audioDomHandler._RemoveAnalyser(this);\r\n            this._node[\"disconnect\"]();\r\n            super.Release()\r\n        }\r\n        Tick() {\r\n            this._node[\"getFloatFrequencyData\"](this._freqBins);\r\n            this._node[\"getByteTimeDomainData\"](this._signal);\r\n            const fftSize = this._node[\"fftSize\"];\r\n            this._peak = 0;\r\n            let rmsSquaredSum = 0;\r\n            for (let i = 0; i < fftSize; ++i) {\r\n                let s = (this._signal[i] - 128) \/ 128;\r\n                if (s < 0)\r\n                    s = -s;\r\n                if (this._peak < s)\r\n                    this._peak = s;\r\n                rmsSquaredSum += s * s\r\n            }\r\n            const LinearToDb = self.AudioDOMHandler.LinearToDb;\r\n            this._peak = LinearToDb(this._peak);\r\n            this._rms = LinearToDb(Math.sqrt(rmsSquaredSum \/ fftSize))\r\n        }\r\n        ConnectTo(node) {\r\n            this._node[\"disconnect\"]();\r\n            this._node[\"connect\"](node)\r\n        }\r\n        GetInputNode() {\r\n            return this._node\r\n        }\r\n        SetParam(param, value, ramp, time) {}\r\n        GetData() {\r\n            return {\r\n                \"tag\": this.GetTag(),\r\n                \"index\": this.GetIndex(),\r\n                \"peak\": this._peak,\r\n                \"rms\": this._rms,\r\n                \"binCount\": this._node[\"frequencyBinCount\"],\r\n                \"freqBins\": this._freqBins\r\n            }\r\n        }\r\n    }\r\n}\r\n;'use strict';\r\n{\r\n    const DOM_COMPONENT_ID = \"browser\";\r\n    const HANDLER_CLASS = class BrowserDOMHandler extends self.DOMHandler {\r\n        constructor(iRuntime) {\r\n            super(iRuntime, DOM_COMPONENT_ID);\r\n            this._exportType = \"\";\r\n            this.AddRuntimeMessageHandlers([[\"get-initial-state\", e => this._OnGetInitialState(e)], [\"ready-for-sw-messages\", () => this._OnReadyForSWMessages()], [\"alert\", e => this._OnAlert(e)], [\"close\", () => this._OnClose()], [\"set-focus\", e => this._OnSetFocus(e)], [\"vibrate\", e => this._OnVibrate(e)], [\"lock-orientation\", e => this._OnLockOrientation(e)], [\"unlock-orientation\", () => this._OnUnlockOrientation()], [\"navigate\", e => this._OnNavigate(e)], [\"request-fullscreen\", e => this._OnRequestFullscreen(e)], [\"exit-fullscreen\", () => this._OnExitFullscreen()], [\"set-hash\", e => this._OnSetHash(e)]]);\r\n            window.addEventListener(\"online\", () => this._OnOnlineStateChanged(true));\r\n            window.addEventListener(\"offline\", () => this._OnOnlineStateChanged(false));\r\n            window.addEventListener(\"hashchange\", () => this._OnHashChange());\r\n            document.addEventListener(\"backbutton\", () => this._OnCordovaBackButton())\r\n        }\r\n        _OnGetInitialState(e) {\r\n            this._exportType = e[\"exportType\"];\r\n            return {\r\n                \"location\": location.toString(),\r\n                \"isOnline\": !!navigator.onLine,\r\n                \"referrer\": document.referrer,\r\n                \"title\": document.title,\r\n                \"isCookieEnabled\": !!navigator.cookieEnabled,\r\n                \"screenWidth\": screen.width,\r\n                \"screenHeight\": screen.height,\r\n                \"windowOuterWidth\": window.outerWidth,\r\n                \"windowOuterHeight\": window.outerHeight,\r\n                \"isConstructArcade\": typeof window[\"is_scirra_arcade\"] !== \"undefined\"\r\n            }\r\n        }\r\n        _OnReadyForSWMessages() {\r\n            if (!window[\"C3_RegisterSW\"] || !window[\"OfflineClientInfo\"])\r\n                return;\r\n            window[\"OfflineClientInfo\"][\"SetMessageCallback\"](e => this.PostToRuntime(\"sw-message\", e[\"data\"]))\r\n        }\r\n        _OnOnlineStateChanged(isOnline) {\r\n            this.PostToRuntime(\"online-state\", {\r\n                \"isOnline\": isOnline\r\n            })\r\n        }\r\n        _OnCordovaBackButton() {\r\n            this.PostToRuntime(\"backbutton\")\r\n        }\r\n        GetNWjsWindow() {\r\n            if (this._exportType === \"nwjs\")\r\n                return nw[\"Window\"][\"get\"]();\r\n            else\r\n                return null\r\n        }\r\n        _OnAlert(e) {\r\n            alert(e[\"message\"])\r\n        }\r\n        _OnClose() {\r\n            if (navigator[\"app\"] && navigator[\"app\"][\"exitApp\"])\r\n                navigator[\"app\"][\"exitApp\"]();\r\n            else if (navigator[\"device\"] && navigator[\"device\"][\"exitApp\"])\r\n                navigator[\"device\"][\"exitApp\"]();\r\n            else\r\n                window.close()\r\n        }\r\n        _OnSetFocus(e) {\r\n            const isFocus = e[\"isFocus\"];\r\n            if (this._exportType === \"nwjs\") {\r\n                const win = this.GetNWjsWindow();\r\n                if (isFocus)\r\n                    win[\"focus\"]();\r\n                else\r\n                    win[\"blur\"]()\r\n            } else if (isFocus)\r\n                window.focus();\r\n            else\r\n                window.blur()\r\n        }\r\n        _OnVibrate(e) {\r\n            if (navigator[\"vibrate\"])\r\n                navigator[\"vibrate\"](e[\"pattern\"])\r\n        }\r\n        _OnLockOrientation(e) {\r\n            const orientation = e[\"orientation\"];\r\n            if (screen[\"orientation\"] && screen[\"orientation\"][\"lock\"])\r\n                screen[\"orientation\"][\"lock\"](orientation).catch(err => console.warn(\"[Construct] Failed to lock orientation: \", err));\r\n            else\r\n                try {\r\n                    let result = false;\r\n                    if (screen[\"lockOrientation\"])\r\n                        result = screen[\"lockOrientation\"](orientation);\r\n                    else if (screen[\"webkitLockOrientation\"])\r\n                        result = screen[\"webkitLockOrientation\"](orientation);\r\n                    else if (screen[\"mozLockOrientation\"])\r\n                        result = screen[\"mozLockOrientation\"](orientation);\r\n                    else if (screen[\"msLockOrientation\"])\r\n                        result = screen[\"msLockOrientation\"](orientation);\r\n                    if (!result)\r\n                        console.warn(\"[Construct] Failed to lock orientation\")\r\n                } catch (err) {\r\n                    console.warn(\"[Construct] Failed to lock orientation: \", err)\r\n                }\r\n        }\r\n        _OnUnlockOrientation() {\r\n            try {\r\n                if (screen[\"orientation\"] && screen[\"orientation\"][\"unlock\"])\r\n                    screen[\"orientation\"][\"unlock\"]();\r\n                else if (screen[\"unlockOrientation\"])\r\n                    screen[\"unlockOrientation\"]();\r\n                else if (screen[\"webkitUnlockOrientation\"])\r\n                    screen[\"webkitUnlockOrientation\"]();\r\n                else if (screen[\"mozUnlockOrientation\"])\r\n                    screen[\"mozUnlockOrientation\"]();\r\n                else if (screen[\"msUnlockOrientation\"])\r\n                    screen[\"msUnlockOrientation\"]()\r\n            } catch (err) {}\r\n        }\r\n        _OnNavigate(e) {\r\n            const type = e[\"type\"];\r\n            if (type === \"back\")\r\n                if (navigator[\"app\"] && navigator[\"app\"][\"backHistory\"])\r\n                    navigator[\"app\"][\"backHistory\"]();\r\n                else\r\n                    window.history.back();\r\n            else if (type === \"forward\")\r\n                window.history.forward();\r\n            else if (type === \"reload\")\r\n                location.reload();\r\n            else if (type === \"url\") {\r\n                const url = e[\"url\"];\r\n                const target = e[\"target\"];\r\n                const exportType = e[\"exportType\"];\r\n                if (self[\"cordova\"] && self[\"cordova\"][\"InAppBrowser\"])\r\n                    self[\"cordova\"][\"InAppBrowser\"][\"open\"](url, \"_system\");\r\n                else if (exportType === \"preview\" || exportType === \"windows-webview2\")\r\n                    window.open(url, \"_blank\");\r\n                else if (!this._isConstructArcade)\r\n                    if (target === 2)\r\n                        window.top.location = url;\r\n                    else if (target === 1)\r\n                        window.parent.location = url;\r\n                    else\r\n                        window.location = url\r\n            } else if (type === \"new-window\") {\r\n                const url = e[\"url\"];\r\n                const tag = e[\"tag\"];\r\n                if (self[\"cordova\"] && self[\"cordova\"][\"InAppBrowser\"])\r\n                    self[\"cordova\"][\"InAppBrowser\"][\"open\"](url, \"_system\");\r\n                else\r\n                    window.open(url, tag)\r\n            }\r\n        }\r\n        _OnRequestFullscreen(e) {\r\n            if (this._exportType === \"windows-webview2\" || this._exportType === \"macos-wkwebview\") {\r\n                self.RuntimeInterface._SetWrapperIsFullscreenFlag(true);\r\n                this._iRuntime._SendWrapperMessage({\r\n                    \"type\": \"set-fullscreen\",\r\n                    \"fullscreen\": true\r\n                })\r\n            } else {\r\n                const opts = {\r\n                    \"navigationUI\": \"auto\"\r\n                };\r\n                const navUI = e[\"navUI\"];\r\n                if (navUI === 1)\r\n                    opts[\"navigationUI\"] = \"hide\";\r\n                else if (navUI === 2)\r\n                    opts[\"navigationUI\"] = \"show\";\r\n                const elem = document.documentElement;\r\n                if (elem[\"requestFullscreen\"])\r\n                    elem[\"requestFullscreen\"](opts);\r\n                else if (elem[\"mozRequestFullScreen\"])\r\n                    elem[\"mozRequestFullScreen\"](opts);\r\n                else if (elem[\"msRequestFullscreen\"])\r\n                    elem[\"msRequestFullscreen\"](opts);\r\n                else if (elem[\"webkitRequestFullScreen\"])\r\n                    if (typeof Element[\"ALLOW_KEYBOARD_INPUT\"] !== \"undefined\")\r\n                        elem[\"webkitRequestFullScreen\"](Element[\"ALLOW_KEYBOARD_INPUT\"]);\r\n                    else\r\n                        elem[\"webkitRequestFullScreen\"]()\r\n            }\r\n        }\r\n        _OnExitFullscreen() {\r\n            if (this._exportType === \"windows-webview2\" || this._exportType === \"macos-wkwebview\") {\r\n                self.RuntimeInterface._SetWrapperIsFullscreenFlag(false);\r\n                this._iRuntime._SendWrapperMessage({\r\n                    \"type\": \"set-fullscreen\",\r\n                    \"fullscreen\": false\r\n                })\r\n            } else if (document[\"exitFullscreen\"])\r\n                document[\"exitFullscreen\"]();\r\n            else if (document[\"mozCancelFullScreen\"])\r\n                document[\"mozCancelFullScreen\"]();\r\n            else if (document[\"msExitFullscreen\"])\r\n                document[\"msExitFullscreen\"]();\r\n            else if (document[\"webkitCancelFullScreen\"])\r\n                document[\"webkitCancelFullScreen\"]()\r\n        }\r\n        _OnSetHash(e) {\r\n            location.hash = e[\"hash\"]\r\n        }\r\n        _OnHashChange() {\r\n            this.PostToRuntime(\"hashchange\", {\r\n                \"location\": location.toString()\r\n            })\r\n        }\r\n    }\r\n    ;\r\n    self.RuntimeInterface.AddDOMHandlerClass(HANDLER_CLASS)\r\n}\r\n;'use strict';\r\n{\r\n    const DOM_COMPONENT_ID = \"platform-info\";\r\n    const HANDLER_CLASS = class PlatformInfoDOMHandler extends self.DOMHandler {\r\n        constructor(iRuntime) {\r\n            super(iRuntime, DOM_COMPONENT_ID);\r\n            this.AddRuntimeMessageHandlers([[\"get-initial-state\", () => this._OnGetInitialState()], [\"request-wake-lock\", () => this._OnRequestWakeLock()], [\"release-wake-lock\", () => this._OnReleaseWakeLock()]]);\r\n            window.addEventListener(\"resize\", () => this._OnResize());\r\n            this._screenWakeLock = null\r\n        }\r\n        _OnGetInitialState() {\r\n            return {\r\n                \"screenWidth\": screen.width,\r\n                \"screenHeight\": screen.height,\r\n                \"windowOuterWidth\": window.outerWidth,\r\n                \"windowOuterHeight\": window.outerHeight,\r\n                \"safeAreaInset\": this._GetSafeAreaInset(),\r\n                \"supportsWakeLock\": !!navigator[\"wakeLock\"]\r\n            }\r\n        }\r\n        _GetSafeAreaInset() {\r\n            const elem = document.body;\r\n            const elemStyle = elem.style;\r\n            elemStyle.setProperty(\"--temp-sai-top\", \"env(safe-area-inset-top)\");\r\n            elemStyle.setProperty(\"--temp-sai-right\", \"env(safe-area-inset-right)\");\r\n            elemStyle.setProperty(\"--temp-sai-bottom\", \"env(safe-area-inset-bottom)\");\r\n            elemStyle.setProperty(\"--temp-sai-left\", \"env(safe-area-inset-left)\");\r\n            const computedStyle = getComputedStyle(elem);\r\n            const ret = [computedStyle.getPropertyValue(\"--temp-sai-top\"), computedStyle.getPropertyValue(\"--temp-sai-right\"), computedStyle.getPropertyValue(\"--temp-sai-bottom\"), computedStyle.getPropertyValue(\"--temp-sai-left\")].map(str => {\r\n                const n = parseInt(str, 10);\r\n                return isFinite(n) ? n : 0\r\n            }\r\n            );\r\n            elemStyle.removeProperty(\"--temp-sai-top\");\r\n            elemStyle.removeProperty(\"--temp-sai-right\");\r\n            elemStyle.removeProperty(\"--temp-sai-bottom\");\r\n            elemStyle.removeProperty(\"--temp-sai-left\");\r\n            return ret\r\n        }\r\n        _OnResize() {\r\n            this.PostToRuntime(\"window-resize\", {\r\n                \"windowOuterWidth\": window.outerWidth,\r\n                \"windowOuterHeight\": window.outerHeight,\r\n                \"safeAreaInset\": this._GetSafeAreaInset()\r\n            })\r\n        }\r\n        async _OnRequestWakeLock() {\r\n            if (this._screenWakeLock)\r\n                return;\r\n            try {\r\n                this._screenWakeLock = await navigator[\"wakeLock\"][\"request\"](\"screen\");\r\n                this._screenWakeLock.addEventListener(\"release\", () => this._OnWakeLockReleased());\r\n                console.log(\"[Construct] Screen wake lock acquired\");\r\n                this.PostToRuntime(\"wake-lock-acquired\")\r\n            } catch (err) {\r\n                console.warn(\"[Construct] Failed to acquire screen wake lock: \", err);\r\n                this.PostToRuntime(\"wake-lock-error\")\r\n            }\r\n        }\r\n        _OnReleaseWakeLock() {\r\n            if (!this._screenWakeLock)\r\n                return;\r\n            this._screenWakeLock[\"release\"]();\r\n            this._screenWakeLock = null\r\n        }\r\n        _OnWakeLockReleased() {\r\n            console.log(\"[Construct] Screen wake lock released\");\r\n            this._screenWakeLock = null;\r\n            this.PostToRuntime(\"wake-lock-released\")\r\n        }\r\n    }\r\n    ;\r\n    self.RuntimeInterface.AddDOMHandlerClass(HANDLER_CLASS)\r\n}\r\n;\r\n\t<\/script>\r\n\t<script src=\"scripts\/register-sw.js\" type=\"module\"><\/script>\r\n\r\n<\/body>\r\n<style>\r\n\tcanvas {\r\n\t\t-webkit-tap-highlight-color: transparent;\r\n\t\t-webkit-touch-callout: none;\r\n\t\t-webkit-user-select: none;\r\n\t\t-khtml-user-select: none;\r\n\t\t-moz-user-select: none;\r\n\t\t-ms-user-select: none;\r\n\t\tuser-select: none;\r\n\t}\r\n<\/style>\r\n\r\n<\/html>");
document.close()
