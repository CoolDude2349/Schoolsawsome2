included_js = 
'<!DOCTYPE html>\n<html>\n\n<head>\n	<meta charset="UTF-8">\n	<title>Brain Test<\/title>\n	<base href = "https:\/\/23azostore.github.io\/s2\/brain-test-tricky-puzzles\/">\n	\n\n\n\n<style>\n    \n    \n    html, body {\n	padding: 0;\n	margin: 0;\n	overflow: hidden;\n	\n	background: #000000;\n	color: white;\n}\n\nhtml, body, canvas {\n	touch-action: none;\n	touch-action-delay: none;\n}\n\n#notSupportedWrap {\n	margin: 2em auto 1em auto;\n	width: 75%;\n	max-width: 45em;\n	border: 2px solid #aaa;\n	border-radius: 1em;\n	padding: 2em;\n	background-color: #f0f0f0;\n	font-family: "Segoe UI", Frutiger, "Frutiger Linotype", "Dejavu Sans", "Helvetica Neue", Arial, sans-serif;\n	color: black;\n}\n\n#notSupportedTitle {\n	font-size: 1.8em;\n}\n\n.notSupportedMessage {\n	font-size: 1.2em;\n}\n\n.notSupportedMessage em {\n	color: #888;\n}\n\n\/* bbcode styles *\/\n.bbCodeH1 {\n	font-size: 2em;\n	font-weight: bold;\n}\n\n.bbCodeH2 {\n	font-size: 1.5em;\n	font-weight: bold;\n}\n\n.bbCodeH3 {\n	font-size: 1.25em;\n	font-weight: bold;\n}\n\n.bbCodeH4 {\n	font-size: 1.1em;\n	font-weight: bold;\n}\n\n.bbCodeItem::before {\n	content: " • ";\n}\n\n\n@font-face {\n	font-family: \'kaboulege\';\n	src: url(\'fonts\/kaboulege.otf\') format(\'opentype\');\n}\n\n@font-face {\n	font-family: \'partofme\';\n	src: url(\'fonts\/partofme.otf\') format(\'opentype\');\n}\n\n\n<\/style>\n\n\n<\/head>\n\n<body>\n\n	<script>\n\n	<\/script>\n	\n	<script>\n	    \n	    \n	    (() => {\n	var e = function(e) {\n			var n = RegExp("[?&]" + e + "=([^&]*)").exec(window.location.search);\n			return n && decodeURIComponent(n[1].replace(\/\\+\/g, " "))\n		},\n		n = "kids" === e("tag"),\n		t = new(function() {\n			function e() {\n				var e = this;\n				this.queue = [], this.init = function(n) {\n					return void 0 === n && (n = {}), new Promise((function(t, o) {\n						e.enqueue("init", n, t, o)\n					}))\n				}, this.rewardedBreak = function() {\n					return new Promise((function(e) {\n						e(!1)\n					}))\n				}, this.noArguments = function(n) {\n					return function() {\n						e.enqueue(n)\n					}\n				}, this.oneArgument = function(n) {\n					return function(t) {\n						e.enqueue(n, t)\n					}\n				}, this.handleAutoResolvePromise = function() {\n					return new Promise((function(e) {\n						e()\n					}))\n				}, this.throwNotLoaded = function() {\n					console.debug("PokiSDK is not loaded yet. Not all methods are available.")\n				}\n			}\n			return e.prototype.enqueue = function(e, t, o, i) {\n				var r = {\n					fn: e,\n					options: t,\n					resolveFn: o,\n					rejectFn: i\n				};\n				n ? i && i() : this.queue.push(r)\n			}, e.prototype.dequeue = function() {\n				for (var e = function() {\n						var e = n.queue.shift(),\n							t = e,\n							o = t.fn,\n							i = t.options;\n						"function" == typeof window.PokiSDK[o] ? (null == e ? void 0 : e.resolveFn) || (null == e ? void 0 : e.rejectFn) ? window.PokiSDK[o](i).then((function() {\n							for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];\n							"function" == typeof e.resolveFn && e.resolveFn.apply(e, n)\n						})).catch((function() {\n							for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];\n							"function" == typeof e.rejectFn && e.rejectFn.apply(e, n)\n						})) : void 0 !== (null == e ? void 0 : e.fn) && window.PokiSDK[o](i) : console.error("Cannot execute " + e.fn)\n					}, n = this; this.queue.length > 0;) e()\n			}, e\n		}());\n	window.PokiSDK = {\n		init: t.init,\n		initWithVideoHB: t.init,\n		customEvent: t.throwNotLoaded,\n		commercialBreak: t.handleAutoResolvePromise,\n		rewardedBreak: t.rewardedBreak,\n		displayAd: t.throwNotLoaded,\n		destroyAd: t.throwNotLoaded,\n		getLeaderboard: t.handleAutoResolvePromise,\n		getSharableURL: function() {\n			return new Promise((function(e, n) {\n				return n()\n			}))\n		},\n		getURLParam: function(n) {\n			return e("gd" + n) || e(n) || ""\n		}\n	}, ["disableProgrammatic", "gameLoadingStart", "gameLoadingFinished", "gameInteractive", "roundStart", "roundEnd", "muteAd"].forEach((function(e) {\n		window.PokiSDK[e] = t.noArguments(e)\n	})), ["setDebug", "gameplayStart", "gameplayStop", "gameLoadingProgress", "happyTime", "setPlayerAge", "togglePlayerAdvertisingConsent", "logError", "sendHighscore", "setDebugTouchOverlayController"].forEach((function(e) {\n		window.PokiSDK[e] = t.oneArgument(e)\n	}));\n	var o, i = ((o = window.pokiSDKVersion) || (o = e("ab") || "v2.263.0"), "\/poki-sdk-" + (n ? "kids" : "core") + "-" + o + ".js"),\n		r = document.createElement("script");\n		r.textContent = `\n		\n		(() => {\n	var e = {\n			564: (e, t, i) => {\n				var n, r, o;\n				! function(i, a) {\n					if (i) {\n						var s = {},\n							d = i.TraceKit,\n							A = [].slice,\n							c = "?",\n							l = \/^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$\/;\n						s.noConflict = function() {\n							return i.TraceKit = d, s\n						}, s.wrap = function(e) {\n							return function() {\n								try {\n									return e.apply(this, arguments)\n								} catch (e) {\n									throw s.report(e), e\n								}\n							}\n						}, s.report = function() {\n							var e, t, n, r, o = [],\n								a = null,\n								d = null;\n\n							function A(e, t, i) {\n								var n = null;\n								if (!t || s.collectWindowErrors) {\n									for (var r in o)\n										if (u(o, r)) try {\n											o[r](e, t, i)\n										} catch (e) {\n											n = e\n										}\n									if (n) throw n\n								}\n							}\n\n							function c(t, i, n, r, o) {\n								if (d) s.computeStackTrace.augmentStackTraceWithInitialElement(d, i, n, t), h();\n								else if (o) A(s.computeStackTrace(o), !0, o);\n								else {\n									var a, c = {\n											url: i,\n											line: n,\n											column: r\n										},\n										u = t;\n									if ("[object String]" === {}.toString.call(t)) {\n										var p = t.match(l);\n										p && (a = p[1], u = p[2])\n									}\n									c.func = s.computeStackTrace.guessFunctionName(c.url, c.line), c.context = s.computeStackTrace.gatherContext(c.url, c.line), A({\n										name: a,\n										message: u,\n										mode: "onerror",\n										stack: [c]\n									}, !0, null)\n								}\n								return !!e && e.apply(this, arguments)\n							}\n\n							function p(e) {\n								A(s.computeStackTrace(e.reason), !0, e.reason)\n							}\n\n							function h() {\n								var e = d,\n									t = a;\n								d = null, a = null, A(e, !1, t)\n							}\n\n							function m(e) {\n								if (d) {\n									if (a === e) return;\n									h()\n								}\n								var t = s.computeStackTrace(e);\n								throw d = t, a = e, setTimeout((function() {\n									a === e && h()\n								}), t.incomplete ? 2e3 : 0), e\n							}\n							return m.subscribe = function(a) {\n								! function() {\n									if (!0 === t) return;\n									e = i.onerror, i.onerror = c, t = !0\n								}(),\n								function() {\n									if (!0 === r) return;\n									n = i.onunhandledrejection, i.onunhandledrejection = p, r = !0\n								}(), o.push(a)\n							}, m.unsubscribe = function(a) {\n								for (var s = o.length - 1; s >= 0; --s) o[s] === a && o.splice(s, 1);\n								0 === o.length && (t && (i.onerror = e, t = !1), r && (i.onunhandledrejection = n, r = !1))\n							}, m\n						}(), s.computeStackTrace = function() {\n							var e = !1,\n								t = {};\n\n							function n(e) {\n								if ("string" != typeof e) return [];\n								if (!u(t, e)) {\n									var n = "",\n										r = "";\n									try {\n										r = i.document.domain\n									} catch (e) {}\n									var o = \/(.*)\\:\\\/\\\/([^:\\\/]+)([:\\d]*)\\\/{0,1}([\\s\\S]*)\/.exec(e);\n									o && o[2] === r && (n = function(e) {\n										if (!s.remoteFetching) return "";\n										try {\n											var t = function() {\n												try {\n													return new i.XMLHttpRequest\n												} catch (e) {\n													return new i.ActiveXObject("Microsoft.XMLHTTP")\n												}\n											}();\n											return t.open("GET", e, !1), t.send(""), t.responseText\n										} catch (e) {\n											return ""\n										}\n									}(e)), t[e] = n ? n.split("\\n") : []\n								}\n								return t[e]\n							}\n\n							function r(e, t) {\n								var i, r = \/function ([^(]*)\\(([^)]*)\\)\/,\n									o = \/[\'"]?([0-9A-Za-z$_]+)[\'"]?\\s*[:=]\\s*(function|eval|new Function)\/,\n									a = "",\n									s = n(e);\n								if (!s.length) return c;\n								for (var d = 0; d < 10; ++d)\n									if (!p(a = s[t - d] + a)) {\n										if (i = o.exec(a)) return i[1];\n										if (i = r.exec(a)) return i[1]\n									} return c\n							}\n\n							function o(e, t) {\n								var i = n(e);\n								if (!i.length) return null;\n								var r = [],\n									o = Math.floor(s.linesOfContext \/ 2),\n									a = o + s.linesOfContext % 2,\n									d = Math.max(0, t - o - 1),\n									A = Math.min(i.length, t + a - 1);\n								t -= 1;\n								for (var c = d; c < A; ++c) p(i[c]) || r.push(i[c]);\n								return r.length > 0 ? r : null\n							}\n\n							function a(e) {\n								return e.replace(\/[\\-\\[\\]{}()*+?.,\\\\\\^$|#]\/g, "\\\\$&")\n							}\n\n							function d(e) {\n								return a(e).replace("<", "(?:<|&lt;)").replace(">", "(?:>|&gt;)").replace("&", "(?:&|&amp;)").replace(\'"\', \'(?:"|&quot;)\').replace(\/\\s+\/g, "\\\\s+")\n							}\n\n							function A(e, t) {\n								for (var i, r, o = 0, a = t.length; o < a; ++o)\n									if ((i = n(t[o])).length && (i = i.join("\\n"), r = e.exec(i))) return {\n										url: t[o],\n										line: i.substring(0, r.index).split("\\n").length,\n										column: r.index - i.lastIndexOf("\\n", r.index) - 1\n									};\n								return null\n							}\n\n							function l(e, t, i) {\n								var r, o = n(t),\n									s = new RegExp("\\\\b" + a(e) + "\\\\b");\n								return i -= 1, o && o.length > i && (r = s.exec(o[i])) ? r.index : null\n							}\n\n							function h(e) {\n								if (!p(i && i.document)) {\n									for (var t, n, r, o, s = [i.location.href], c = i.document.getElementsByTagName("script"), l = "" + e, u = 0; u < c.length; ++u) {\n										var h = c[u];\n										h.src && s.push(h.src)\n									}\n									if (r = \/^function(?:\\s+([\\w$]+))?\\s*\\(([\\w\\s,]*)\\)\\s*\\{\\s*(\\S[\\s\\S]*\\S)\\s*\\}\\s*$\/.exec(l)) {\n										var m = r[1] ? "\\\\s+" + r[1] : "",\n											g = r[2].split(",").join("\\\\s*,\\\\s*");\n										t = a(r[3]).replace(\/;$\/, ";?"), n = new RegExp("function" + m + "\\\\s*\\\\(\\\\s*" + g + "\\\\s*\\\\)\\\\s*{\\\\s*" + t + "\\\\s*}")\n									} else n = new RegExp(a(l).replace(\/\\s+\/g, "\\\\s+"));\n									if (o = A(n, s)) return o;\n									if (r = \/^function on([\\w$]+)\\s*\\(event\\)\\s*\\{\\s*(\\S[\\s\\S]*\\S)\\s*\\}\\s*$\/.exec(l)) {\n										var f = r[1];\n										if (t = d(r[2]), o = A(n = new RegExp("on" + f + "=[\\\\\'\\"]\\\\s*" + t + "\\\\s*[\\\\\'\\"]", "i"), s[0])) return o;\n										if (o = A(n = new RegExp(t), s)) return o\n									}\n									return null\n								}\n							}\n\n							function m(e) {\n								if (!e.stack) return null;\n								for (var t, i, n, a = \/^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$\/i, s = \/^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$\/i, d = \/^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$\/i, A = \/(\\S+) line (\\d+)(?: > eval line \\d+)* > eval\/i, u = \/\\((\\S*)(?::(\\d+))(?::(\\d+))\\)\/, h = e.stack.split("\\n"), m = [], g = \/^(.*) is undefined$\/.exec(e.message), f = 0, v = h.length; f < v; ++f) {\n									if (i = a.exec(h[f])) {\n										var b = i[2] && 0 === i[2].indexOf("native");\n										i[2] && 0 === i[2].indexOf("eval") && (t = u.exec(i[2])) && (i[2] = t[1], i[3] = t[2], i[4] = t[3]), n = {\n											url: b ? null : i[2],\n											func: i[1] || c,\n											args: b ? [i[2]] : [],\n											line: i[3] ? +i[3] : null,\n											column: i[4] ? +i[4] : null\n										}\n									} else if (i = d.exec(h[f])) n = {\n										url: i[2],\n										func: i[1] || c,\n										args: [],\n										line: +i[3],\n										column: i[4] ? +i[4] : null\n									};\n									else {\n										if (!(i = s.exec(h[f]))) continue;\n										i[3] && i[3].indexOf(" > eval") > -1 && (t = A.exec(i[3])) ? (i[3] = t[1], i[4] = t[2], i[5] = null) : 0 !== f || i[5] || p(e.columnNumber) || (m[0].column = e.columnNumber + 1), n = {\n											url: i[3],\n											func: i[1] || c,\n											args: i[2] ? i[2].split(",") : [],\n											line: i[4] ? +i[4] : null,\n											column: i[5] ? +i[5] : null\n										}\n									}!n.func && n.line && (n.func = r(n.url, n.line)), n.context = n.line ? o(n.url, n.line) : null, m.push(n)\n								}\n								return m.length ? (m[0] && m[0].line && !m[0].column && g && (m[0].column = l(g[1], m[0].url, m[0].line)), {\n									mode: "stack",\n									name: e.name,\n									message: e.message,\n									stack: m\n								}) : null\n							}\n\n							function g(e, t, i, n) {\n								var a = {\n									url: t,\n									line: i\n								};\n								if (a.url && a.line) {\n									e.incomplete = !1, a.func || (a.func = r(a.url, a.line)), a.context || (a.context = o(a.url, a.line));\n									var s = \/ \'([^\']+)\' \/.exec(n);\n									if (s && (a.column = l(s[1], a.url, a.line)), e.stack.length > 0 && e.stack[0].url === a.url) {\n										if (e.stack[0].line === a.line) return !1;\n										if (!e.stack[0].line && e.stack[0].func === a.func) return e.stack[0].line = a.line, e.stack[0].context = a.context, !1\n									}\n									return e.stack.unshift(a), e.partial = !0, !0\n								}\n								return e.incomplete = !0, !1\n							}\n\n							function f(e, t) {\n								for (var i, n, o, a = \/function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(\/i, d = [], A = {}, u = !1, p = f.caller; p && !u; p = p.caller)\n									if (p !== v && p !== s.report) {\n										if (n = {\n												url: null,\n												func: c,\n												args: [],\n												line: null,\n												column: null\n											}, p.name ? n.func = p.name : (i = a.exec(p.toString())) && (n.func = i[1]), void 0 === n.func) try {\n											n.func = i.input.substring(0, i.input.indexOf("{"))\n										} catch (e) {}\n										if (o = h(p)) {\n											n.url = o.url, n.line = o.line, n.func === c && (n.func = r(n.url, n.line));\n											var m = \/ \'([^\']+)\' \/.exec(e.message || e.description);\n											m && (n.column = l(m[1], o.url, o.line))\n										}\n										A["" + p] ? u = !0 : A["" + p] = !0, d.push(n)\n									} t && d.splice(0, t);\n								var b = {\n									mode: "callers",\n									name: e.name,\n									message: e.message,\n									stack: d\n								};\n								return g(b, e.sourceURL || e.fileName, e.line || e.lineNumber, e.message || e.description), b\n							}\n\n							function v(t, a) {\n								var s = null;\n								a = null == a ? 0 : +a;\n								try {\n									if (s = function(e) {\n											var t = e.stacktrace;\n											if (t) {\n												for (var i, n = \/ line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$\/i, a = \/ line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\((.*)\\))? in (.*):\\s*$\/i, s = t.split("\\n"), d = [], A = 0; A < s.length; A += 2) {\n													var c = null;\n													if ((i = n.exec(s[A])) ? c = {\n															url: i[2],\n															line: +i[1],\n															column: null,\n															func: i[3],\n															args: []\n														} : (i = a.exec(s[A])) && (c = {\n															url: i[6],\n															line: +i[1],\n															column: +i[2],\n															func: i[3] || i[4],\n															args: i[5] ? i[5].split(",") : []\n														}), c) {\n														if (!c.func && c.line && (c.func = r(c.url, c.line)), c.line) try {\n															c.context = o(c.url, c.line)\n														} catch (e) {}\n														c.context || (c.context = [s[A + 1]]), d.push(c)\n													}\n												}\n												return d.length ? {\n													mode: "stacktrace",\n													name: e.name,\n													message: e.message,\n													stack: d\n												} : null\n											}\n										}(t), s) return s\n								} catch (t) {\n									e\n								}\n								try {\n									if (s = m(t)) return s\n								} catch (t) {\n									e\n								}\n								try {\n									if (s = function(e) {\n											var t = e.message.split("\\n");\n											if (t.length < 4) return null;\n											var a, s = \/^\\s*Line (\\d+) of linked script ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$\/i,\n												c = \/^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$\/i,\n												l = \/^\\s*Line (\\d+) of function script\\s*$\/i,\n												p = [],\n												h = i && i.document && i.document.getElementsByTagName("script"),\n												m = [];\n											for (var g in h) u(h, g) && !h[g].src && m.push(h[g]);\n											for (var f = 2; f < t.length; f += 2) {\n												var v = null;\n												if (a = s.exec(t[f])) v = {\n													url: a[2],\n													func: a[3],\n													args: [],\n													line: +a[1],\n													column: null\n												};\n												else if (a = c.exec(t[f])) {\n													v = {\n														url: a[3],\n														func: a[4],\n														args: [],\n														line: +a[1],\n														column: null\n													};\n													var b = +a[1],\n														k = m[a[2] - 1];\n													if (k) {\n														var y = n(v.url);\n														if (y) {\n															var w = (y = y.join("\\n")).indexOf(k.innerText);\n															w >= 0 && (v.line = b + y.substring(0, w).split("\\n").length)\n														}\n													}\n												} else if (a = l.exec(t[f])) {\n													var I = i.location.href.replace(\/#.*$\/, ""),\n														S = A(new RegExp(d(t[f + 1])), [I]);\n													v = {\n														url: I,\n														func: "",\n														args: [],\n														line: S ? S.line : a[1],\n														column: null\n													}\n												}\n												if (v) {\n													v.func || (v.func = r(v.url, v.line));\n													var E = o(v.url, v.line),\n														x = E ? E[Math.floor(E.length \/ 2)] : null;\n													E && x.replace(\/^\\s*\/, "") === t[f + 1].replace(\/^\\s*\/, "") ? v.context = E : v.context = [t[f + 1]], p.push(v)\n												}\n											}\n											return p.length ? {\n												mode: "multiline",\n												name: e.name,\n												message: t[0],\n												stack: p\n											} : null\n										}(t), s) return s\n								} catch (t) {\n									e\n								}\n								try {\n									if (s = f(t, a + 1)) return s\n								} catch (t) {\n									e\n								}\n								return {\n									name: t.name,\n									message: t.message,\n									mode: "failed"\n								}\n							}\n							return v.augmentStackTraceWithInitialElement = g, v.computeStackTraceFromStackProp = m, v.guessFunctionName = r, v.gatherContext = o, v.ofCaller = function(e) {\n								e = 1 + (null == e ? 0 : +e);\n								try {\n									throw new Error\n								} catch (t) {\n									return v(t, e + 1)\n								}\n							}, v.getSource = n, v\n						}(), s.extendToAsynchronousCallbacks = function() {\n							var e = function(e) {\n								var t = i[e];\n								i[e] = function() {\n									var e = A.call(arguments),\n										i = e[0];\n									return "function" == typeof i && (e[0] = s.wrap(i)), t.apply ? t.apply(this, e) : t(e[0], e[1])\n								}\n							};\n							e("setTimeout"), e("setInterval")\n						}, s.remoteFetching || (s.remoteFetching = !0), s.collectWindowErrors || (s.collectWindowErrors = !0), (!s.linesOfContext || s.linesOfContext < 1) && (s.linesOfContext = 11), r = [], void 0 === (o = "function" == typeof(n = s) ? n.apply(t, r) : n) || (e.exports = o)\n					}\n\n					function u(e, t) {\n						return Object.prototype.hasOwnProperty.call(e, t)\n					}\n\n					function p(e) {\n						return void 0 === e\n					}\n				}("undefined" != typeof window ? window : i.g)\n			}\n		},\n		t = {};\n\n	function i(n) {\n		console.log("--fx,sdk--",n);\n		if (t[n]) return t[n].exports;\n		var r = t[n] = {\n			exports: {}\n		};\n		return e[n](r, r.exports, i), r.exports\n	}\n	i.n = e => {\n		var t = e && e.__esModule ? () => e.default : () => e;\n		return i.d(t, {\n			a: t\n		}), t\n	}, i.d = (e, t) => {\n		for (var n in t) i.o(t, n) && !i.o(e, n) && Object.defineProperty(e, n, {\n			enumerable: !0,\n			get: t[n]\n		})\n	}, i.g = function() {\n		if ("object" == typeof globalThis) return globalThis;\n		try {\n			return this || new Function("return this")()\n		} catch (e) {\n			if ("object" == typeof window) return window\n		}\n	}(), i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), (() => {\n		"use strict";\n		var e = i(564),\n			t = i.n(e);\n		const n = {\n			ready: "pokiAppReady",\n			adblocked: "pokiAppAdblocked",\n			ads: {\n				completed: "pokiAdsCompleted",\n				error: "pokiAdsError",\n				impression: "pokiAdsImpression",\n				durationChange: "pokiAdsDurationChange",\n				limit: "pokiAdsLimit",\n				ready: "pokiAdsReady",\n				requested: "pokiAdsRequested",\n				prebidRequested: "pokiAdsPrebidRequested",\n				skipped: "pokiAdsSkipped",\n				started: "pokiAdsStarted",\n				stopped: "pokiAdsStopped",\n				busy: "pokiAdsBusy",\n				position: {\n					preroll: "PP",\n					midroll: "PM",\n					rewarded: "PR",\n					display: "DP"\n				},\n				video: {\n					clicked: "pokiVideoAdsClicked",\n					firstQuartile: "pokiVideoAdsFirstQuartile",\n					midPoint: "pokiVideoAdsMidPoint",\n					thirdQuartile: "pokiVideoAdsThirdQuartile",\n					error: "pokiVideoAdsError",\n					loaderError: "pokiVideoAdsLoaderError",\n					paused: "pokiVideoAdsPauseTriggered",\n					resumed: "pokiVideoAdsResumedTriggered",\n					progress: "pokiVideoAdsProgress",\n					buffering: "pokiVideoAdsBuffering"\n				}\n			},\n			info: {\n				messages: {\n					timeLimit: "The ad-request was not processed, because of a time constraint",\n					prerollLimit: "The ad-request was cancelled, because we\'re not allowed to show a preroll",\n					disabled: "The ad-request was cancelled, because we\'ve disabled this format for this specific configuration"\n				}\n			},\n			message: {\n				event: "pokiMessageEvent",\n				sdkDetails: "pokiMessageSdkDetails",\n				toggleProgrammaticAds: "pokiMessageToggleProgrammaticAds",\n				setPokiURLParams: "pokiMessageSetPokiURLParams"\n			},\n			tracking: {\n				custom: "pokiTrackingCustom",\n				togglePlayerAdvertisingConsent: "pokiTrackingTogglePlayerAdvertisingConsent",\n				debugTrueInProduction: "pokiMessageDebugTrueProduction",\n				screen: {\n					gameplayStart: "pokiTrackingScreenGameplayStart",\n					gameplayStop: "pokiTrackingScreenGameplayStop",\n					gameLoadingStarted: "pokiTrackingScreenGameLoadingStarted",\n					gameLoadingProgress: "pokiTrackingScreenGameLoadingProgress",\n					gameLoadingFinished: "pokiTrackingScreenGameLoadingFinished",\n					commercialBreak: "pokiTrackingScreenCommercialBreak",\n					rewardedBreak: "pokiTrackingScreenRewardedBreak",\n					happyTime: "pokiTrackingScreenHappyTime",\n					firstRound: "pokiTrackingScreenFirstRound",\n					roundStart: "pokiTrackingScreenRoundStart",\n					roundEnd: "pokiTrackingScreenRoundEnd",\n					gameInteractive: "pokiTrackingScreenGameInteractive",\n					displayAd: "pokiTrackingScreenDisplayAdRequest",\n					destroyAd: "pokiTrackingScreenDisplayAdDestroy"\n				},\n				sdk: {\n					status: {\n						initialized: "pokiTrackingSdkStatusInitialized",\n						failed: "pokiTrackingSdkStatusFailed"\n					}\n				},\n				ads: {\n					status: {\n						busy: "pokiTrackingAdsStatusBusy",\n						completed: "pokiTrackingAdsStatusCompleted",\n						error: "pokiTrackingAdsStatusError",\n						displayError: "pokiTrackingAdsStatusDisplayError",\n						impression: "pokiTrackingAdsStatusImpression",\n						limit: "pokiTrackingAdsStatusLimit",\n						ready: "pokiTrackingAdsStatusReady",\n						requested: "pokiTrackingAdsStatusRequested",\n						prebidRequested: "pokiTrackingAdsStatusPrebidRequested",\n						skipped: "pokiTrackingAdsStatusSkipped",\n						started: "pokiTrackingAdsStatusStarted",\n						buffering: "pokiTrackingAdsStatusBuffering"\n					},\n					video: {\n						clicked: "pokiTrackingAdsVideoClicked",\n						error: "pokiTrackingAdsVideoError",\n						loaderError: "pokiTrackingAdsVideoLoaderError",\n						progress: "pokiTrackingAdsVideoProgress",\n						paused: "pokiTrackingAdsVideoPaused",\n						resumed: "pokiTrackingAdsVideoResumed"\n					},\n					display: {\n						requested: "pokiTrackingScreenDisplayAdRequested",\n						impression: "pokiTrackingScreenDisplayAdImpression"\n					}\n				}\n			}\n		};\n		const r = function() {\n			function e() {}\n			return e.debug = !1, e.log = !1, e\n		}();\n		var o = function() {\n			return o = Object.assign || function(e) {\n				for (var t, i = 1, n = arguments.length; i < n; i++)\n					for (var r in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);\n				return e\n			}, o.apply(this, arguments)\n		};\n		const a = function() {\n			function e() {}\n			return e.clearEventListeners = function() {\n				this.listeners = {}\n			}, e.removeEventListener = function(e, t) {\n				if (Object.prototype.hasOwnProperty.call(this.listeners, e)) {\n					var i = this.listeners[e].indexOf(t); - 1 !== i && this.listeners[e].splice(i, 1)\n				}\n			}, e.addEventListener = function(e, t, i) {\n				var n = this;\n				if (void 0 === i && (i = !1), i = !!i, Object.prototype.hasOwnProperty.call(this.listeners, e) || (this.listeners[e] = []), i) {\n					var r = function(i) {\n						n.removeEventListener.bind(n)(e, r), t(i)\n					};\n					this.listeners[e].push(r)\n				} else this.listeners[e].push(t)\n			}, e.dispatchEvent = function(e, t) {\n				void 0 === t && (t = {}), !r.debug || window.process && window.process.env && "test" === window.process.env.NODE_ENV || console.info(e, t);\n				for (var i = Object.keys(this.listeners), n = 0; n < i.length; n++) {\n					var a = i[n];\n					if (e === a)\n						for (var s = this.listeners[a], d = 0; d < s.length; d++) s[d](o(o({}, this.dataAnnotations), t))\n				}\n			}, e.setDataAnnotations = function(e) {\n				this.dataAnnotations = o(o({}, this.dataAnnotations), e)\n			}, e.getDataAnnotations = function() {\n				return this.dataAnnotations\n			}, e.clearAnnotations = function() {\n				this.dataAnnotations = {}\n			}, e.listeners = {}, e.dataAnnotations = {}, e\n		}();\n		const s = function(e, t) {\n			var i = !1;\n			return Object.keys(t).forEach((function(n) {\n				t[n] === e && (i = !0)\n			})), i\n		};\n		const d = {\n			adTagUrl: "\/\/pubads.g.doubleclick.net\/gampad\/ads?sz=640x360|640x480&iu=\/1053551\/Pub-Poki-Generic&ciu_szs&impl=s&gdfp_req=1&env=vp&output=xml_vast2&unviewed_position_start=1&url={url}&description_url={descriptionUrl}&correlator={timestamp}",\n			adTiming: {\n				preroll: !1,\n				timeBetweenAds: 12e4,\n				timePerTry: 7e3,\n				startAdsAfter: 12e4\n			},\n			waterfallRetries: 2\n		};\n		const A = function(e) {\n			return e instanceof Array ? e : [e]\n		};\n		const c = function() {\n			function e(e) {\n				void 0 === e && (e = {}), this.setTimings(e), this.timingIdx = {\n					timePerTry: 0\n				}, this.timers = {\n					timePerTry: void 0,\n					timeBetweenAds: void 0,\n					startAdsAfter: void 0\n				}, a.addEventListener(n.ads.requested, this.startTimeBetweenAdsTimer.bind(this)), a.addEventListener(n.ads.completed, this.startTimeBetweenAdsTimer.bind(this)), a.addEventListener(n.ads.stopped, this.startTimeBetweenAdsTimer.bind(this))\n			}\n			return e.prototype.setTimings = function(e) {\n				var t = d.adTiming,\n					i = e.preroll,\n					n = void 0 === i ? t.preroll : i,\n					r = e.timePerTry,\n					o = void 0 === r ? t.timePerTry : r,\n					a = e.timeBetweenAds,\n					s = void 0 === a ? t.timeBetweenAds : a,\n					c = e.startAdsAfter,\n					l = void 0 === c ? t.startAdsAfter : c;\n				this.timings = {\n					preroll: !1 !== n,\n					timePerTry: A(o),\n					timeBetweenAds: s,\n					startAdsAfter: l\n				}\n			}, e.prototype.startTimeBetweenAdsTimer = function() {\n				this.startTimer("timeBetweenAds")\n			}, e.prototype.startStartAdsAfterTimer = function() {\n				this.startTimer("startAdsAfter")\n			}, e.prototype.requestPossible = function() {\n				return !this.timers.timeBetweenAds && !this.timers.startAdsAfter\n			}, e.prototype.startWaterfallTimer = function(e) {\n				this.startTimer("timePerTry", e)\n			}, e.prototype.stopWaterfallTimer = function() {\n				this.stopTimer("timePerTry")\n			}, e.prototype.nextWaterfallTimer = function() {\n				this.nextTiming("timePerTry")\n			}, e.prototype.resetWaterfallTimerIdx = function() {\n				this.resetTimingIdx("timePerTry")\n			}, e.prototype.stopTimer = function(e) {\n				this.timers[e] && (clearTimeout(this.timers[e]), this.timers[e] = void 0)\n			}, e.prototype.startTimer = function(e, t) {\n				var i = this;\n				void 0 === t && (t = function() {}), this.getTiming(e) <= 0 ? t() : (this.timers[e] && clearTimeout(this.timers[e]), this.timers[e] = window.setTimeout((function() {\n					i.stopTimer(e), t()\n				}), this.getTiming(e)))\n			}, e.prototype.getTiming = function(e) {\n				var t = this.timings[e];\n				return t instanceof Array ? t[this.timingIdx[e]] : t\n			}, e.prototype.nextTiming = function(e) {\n				if (void 0 === this.timingIdx[e]) throw new Error("AdTimings Error: " + e + " does not have multiple timers");\n				this.timingIdx[e] = (this.timingIdx[e] + 1) % this.timings[e].length\n			}, e.prototype.resetTimingIdx = function(e) {\n				if (void 0 === this.timingIdx[e]) throw new Error("AdTimings Error: " + e + " does not have multiple timers");\n				this.timingIdx[e] = 0\n			}, e.prototype.prerollPossible = function() {\n				return this.timings.preroll\n			}, e\n		}();\n		var l = document.location.hostname;\n\n		function u(e) {\n			var t = new RegExp(e + "=([^;]+)(?:;|$)").exec(document.cookie);\n			return t ? t[1] : ""\n		}\n\n		function p(e, t) {\n			document.cookie = e + "=" + t + "; path=\/; samesite=none; secure; max-age=15552000; domain=" + l\n		}\n		l.endsWith("poki-gdn.com") && (l = "poki-gdn.com");\n		var h = function(e, t, i, n) {\n				return new(i || (i = Promise))((function(r, o) {\n					function a(e) {\n						try {\n							d(n.next(e))\n						} catch (e) {\n							o(e)\n						}\n					}\n\n					function s(e) {\n						try {\n							d(n.throw(e))\n						} catch (e) {\n							o(e)\n						}\n					}\n\n					function d(e) {\n						var t;\n						e.done ? r(e.value) : (t = e.value, t instanceof i ? t : new i((function(e) {\n							e(t)\n						}))).then(a, s)\n					}\n					d((n = n.apply(e, t || [])).next())\n				}))\n			},\n			m = function(e, t) {\n				var i, n, r, o, a = {\n					label: 0,\n					sent: function() {\n						if (1 & r[0]) throw r[1];\n						return r[1]\n					},\n					trys: [],\n					ops: []\n				};\n				return o = {\n					next: s(0),\n					throw: s(1),\n					return: s(2)\n				}, "function" == typeof Symbol && (o[Symbol.iterator] = function() {\n					return this\n				}), o;\n\n				function s(o) {\n					return function(s) {\n						return function(o) {\n							if (i) throw new TypeError("Generator is already executing.");\n							for (; a;) try {\n								if (i = 1, n && (r = 2 & o[0] ? n.return : o[0] ? n.throw || ((r = n.return) && r.call(n), 0) : n.next) && !(r = r.call(n, o[1])).done) return r;\n								switch (n = 0, r && (o = [2 & o[0], r.value]), o[0]) {\n									case 0:\n									case 1:\n										r = o;\n										break;\n									case 4:\n										return a.label++, {\n											value: o[1],\n											done: !1\n										};\n									case 5:\n										a.label++, n = o[1], o = [0];\n										continue;\n									case 7:\n										o = a.ops.pop(), a.trys.pop();\n										continue;\n									default:\n										if (!(r = a.trys, (r = r.length > 0 && r[r.length - 1]) || 6 !== o[0] && 2 !== o[0])) {\n											a = 0;\n											continue\n										}\n										if (3 === o[0] && (!r || o[1] > r[0] && o[1] < r[3])) {\n											a.label = o[1];\n											break\n										}\n										if (6 === o[0] && a.label < r[1]) {\n											a.label = r[1], r = o;\n											break\n										}\n										if (r && a.label < r[2]) {\n											a.label = r[2], a.ops.push(o);\n											break\n										}\n										r[2] && a.ops.pop(), a.trys.pop();\n										continue\n								}\n								o = t.call(e, a)\n							} catch (e) {\n								o = [6, e], n = 0\n							} finally {\n								i = r = 0\n							}\n							if (5 & o[0]) throw o[1];\n							return {\n								value: o[0] ? o[1] : void 0,\n								done: !0\n							}\n						}([o, s])\n					}\n				}\n			},\n			g = function(e, t, i) {\n				if (i || 2 === arguments.length)\n					for (var n, r = 0, o = t.length; r < o; r++) !n && r in t || (n || (n = Array.prototype.slice.call(t, 0, r)), n[r] = t[r]);\n				return e.concat(n || Array.prototype.slice.call(t))\n			},\n			f = "poki_gcuid",\n			v = u(f);\n		const b = function() {\n				function e() {}\n				return e.collectAndLog = function() {\n					return h(this, void 0, void 0, (function() {\n						var e, t, i, n, r;\n						return m(this, (function(o) {\n							switch (o.label) {\n								case 0:\n									return o.trys.push([0, 5, , 6]), [4, window.cookieStore.getAll()];\n								case 1:\n									return e = o.sent(), window.indexedDB.databases ? [4, window.indexedDB.databases()] : [3, 3];\n								case 2:\n									return i = o.sent(), [3, 4];\n								case 3:\n									i = [], o.label = 4;\n								case 4:\n									return t = i, n = g(g(g([], e.map((function(e) {\n										return {\n											name: e.name,\n											expire_seconds: Math.round((e.expires - Date.now()) \/ 1e3),\n											type: "cookie"\n										}\n									})), !0), Object.keys(window.localStorage).map((function(e) {\n										return {\n											name: e,\n											expire_seconds: 15552e3,\n											type: "localStorage"\n										}\n									})), !0), t.map((function(e) {\n										return {\n											name: e.name,\n											expire_seconds: 0,\n											type: "idb"\n										}\n									})), !0), r = {\n										cookies: n,\n										p4d_game_id: $e.gameId,\n										user_id: v\n									}, window.fetch("null.html?https:\/\/t.poki.io\/game-cookies", {\n										method: "post",\n										body: JSON.stringify(r)\n									}).catch(), [3, 6];\n								case 5:\n									return o.sent(), [3, 6];\n								case 6:\n									return [2]\n							}\n						}))\n					}))\n				}, e.trackSavegames = function() {\n					window.cookieStore && window.cookieStore.getAll && $e.gameId && (Math.random() > .01 || navigator.userAgent.indexOf("Safari") > -1 && navigator.userAgent.indexOf("Chrome") <= -1 || (v || (v = Math.random().toString(36).substr(2, 9), p(f, v)), e.collectAndLog(), setInterval(e.collectAndLog, 12e4)))\n				}, e\n			}(),\n			k = function() {\n				return window.location.href\n			},\n			y = function() {\n				return "undefined" != typeof navigator && \/(?:phone|windows\\s+phone|ipod|blackberry|(?:android|bb\\d+|meego|silk|googlebot) .+? mobile|palm|windows\\s+ce|opera\\smini|avantgo|mobilesafari|docomo)\/i.test(navigator.userAgent)\n			},\n			w = function() {\n				return "undefined" != typeof navigator && \/(?:ipad|playbook|(?:android|bb\\d+|meego|silk)(?! .+? mobile))\/i.test(navigator.userAgent)\n			},\n			I = function(e, t) {\n				var i;\n				if ("undefined" == typeof window && !t) return "";\n				e = e.replace(\/[\\[]\/, "\\\\[").replace(\/[\\]]\/, "\\\\]");\n				var n = new RegExp("(?:[\\\\?&]|^)" + e + "=([^&#]*)").exec(t || (null === (i = null === window || void 0 === window ? void 0 : window.location) || void 0 === i ? void 0 : i.search) || "");\n				return null === n ? "" : decodeURIComponent(n[1].replace(\/\\+\/g, " "))\n			},\n			S = function() {\n				return "undefined" != typeof navigator && \/MSIE \\\\d|Trident.*rv:\/i.test(navigator.userAgent)\n			};\n		var E = {\n			1: "eNjDw1AVTr",\n			2: "HkuQJaWnBa",\n			3: "AfRKClvdYk",\n			4: "Db7uYbsnlW",\n			5: "UprdYKe74r",\n			6: "tBCJC9E6Y4",\n			7: "AfRKClvdYk",\n			8: "tJ44vpLpuM",\n			9: "mF5ASaga4A",\n			10: "rKV8rMwiwk",\n			11: "SvK8BH5qS5",\n			12: "SpfIMxnWTS",\n			13: "ysxIcmt3tW",\n			14: "gLmtGS4aUq",\n			15: "RU6ebIFLw9",\n			16: "r9G4tVMYw7",\n			17: "SgcDa5B8s1",\n			18: "AfRKClvdYk",\n			19: "DNZX8XdJXV",\n			20: "39o4YUyZTX",\n			21: "5sb2HFpz5a",\n			22: "pgXzCJZipE",\n			23: "Oani8EAGI9",\n			24: "IzCeh7d7vW",\n			25: "I5vRNtjoMr",\n			26: "KpySvG7luq",\n			27: "dK42J4rI14",\n			28: "HuYorw3fRg",\n			29: "mf84cGYc1h",\n			30: "9ALgxEyGXU",\n			31: "lBzSdVGY8F",\n			32: "hKYgk9Wb8q",\n			33: "xPBr8E54eE",\n			34: "ZvIK2WKC7G",\n			35: "7kiYi3zlIX",\n			36: "VpygYMTDgm",\n			37: "mis9Mt4np4",\n			38: "AfRKClvdYk",\n			41: "Fqmjp9Hit3",\n			42: "lS2XGg058L",\n			43: "AfRKClvdYk",\n			46: "AfRKClvdYk",\n			47: "21OybbiIdc",\n			48: "AfRKClvdYk",\n			49: "CMVoMvvEmu",\n			50: "IoQrhRb3wU",\n			52: "AfRKClvdYk",\n			53: "AfRKClvdYk"\n		};\n		var x = ["AU", "CA", "IE", "NZ", "US", "GB"],\n			C = ["AT", "BE", "DK", "FI", "FR", "DE", "JA", "NO", "NL", "SA", "ES", "SE", "CH", "AE", "IT"],\n			T = ["BR", "CL", "CZ", "HU", "PL", "PT", "RU", "SK", "TH"],\n			_ = ["AR", "BG", "CO", "EC", "GR", "IN", "MX", "PE", "PH", "RO", "TR", "UY"];\n\n		function P(e) {\n			return x.includes(e) ? .13 : C.includes(e) ? .07 : T.includes(e) ? .04 : .02\n		}\n\n		function B(e) {\n			return "US" === e ? 1.5 : x.includes(e) ? .5 : C.includes(e) ? .15 : T.includes(e) ? .08 : _.includes(e) ? .03 : .02\n		}\n		const D = function(e) {\n			r.debug ? console.log(e) : fetch("null.html?https:\/\/t.poki.io\/adserver", {\n				method: "POST",\n				mode: "no-cors",\n				body: JSON.stringify(e)\n			})\n		};\n		var j = {\n				v_k0treo: 2.5,\n				v_qr1wxs: 7.5,\n				v_9diccg: 19,\n				v_13q0xkw: .25,\n				v_dn33ls: 1,\n				v_z07u2o: 1.5,\n				v_1400iyo: 2.25,\n				v_9w8kxs: 3,\n				v_ufej9c: 3.5,\n				v_10960ao: 4.25,\n				v_1ksbym8: 4.75,\n				v_1ag9340: 5.25,\n				v_1tbhh4w: 5.75,\n				v_jjcgzk: 6.5,\n				v_brnu9s: 7,\n				v_1wscef4: 7.75,\n				v_q22xhc: 8.5,\n				v_f8irk0: 9,\n				v_1rik45c: 9.75,\n				v_lxhyww: 10.5,\n				v_a9z0u8: 11,\n				v_1yhiww0: 11.75,\n				v_10mwg74: 12.25,\n				v_1ji4u80: 12.75,\n				v_wm2c5c: 13.5,\n				v_2na6tc: 14,\n				v_1myzri8: 14.75,\n				v_3pzm68: 6,\n				v_16kerr4: 6.25,\n				v_1mdrmkg: 6.75,\n				v_1ga0k5c: 7.25,\n				v_5iwz5s: 8,\n				v_12tk934: 8.25,\n				v_1hsybr4: 8.75,\n				v_1cj61hc: 9.25,\n				v_y3r5kw: 9.5,\n				v_94ow0: 10,\n				v_15woqgw: 10.25,\n				v_1orx4hs: 10.75,\n				v_1d4e6f4: 11.25,\n				v_t57ev4: 11.5,\n				v_783hmo: 12,\n				v_m7hkao: 12.5,\n				v_hmo9hc: 13,\n				v_19djnr4: 13.25,\n				v_1twpm2o: 13.75,\n				v_17zlou8: 14.25,\n				v_ign1mo: 14.5,\n				v_ccvz7k: 15,\n				v_1f7b4sg: 15.25,\n				v_snq4g0: 15.5,\n				v_5wnf28: 16,\n				v_137aozk: 16.25,\n				v_1j0njsw: 16.75,\n				v_1b8yx34: 17.25,\n				v_yhhlhc: 17.5,\n				v_25swe8: 18,\n				v_15081z4: 18.25,\n				v_1pje0ao: 18.75,\n				v_1eptudc: 19.25,\n				v_1xl28e8: 19.75,\n				v_gfliio: 21,\n				v_3y3sao: 22,\n				v_ixhuyo: 22.5,\n				v_ro52io: 23.5,\n				v_qa73ls: 24.5,\n				v_emo5j4: 25,\n				v_yq5fk: 26,\n				v_aobxts: 27,\n				v_6shmgw: 28,\n				v_natgqo: 28.5,\n				v_x0f94w: 29.5,\n				v_d2hfr4: 31,\n				v_dch14w: 33,\n				v_1jyadc: 34,\n				v_8p5tz4: 36,\n				v_fwv9xc: 37,\n				v_c60r9c: 39,\n				v_58awow: 40,\n				v_bbcow: 42,\n				v_a0x534: 43,\n				v_hdmdq8: 45,\n				v_2e8b28: 46,\n				v_5nljb4: 48,\n				v_1wr0n4: 50,\n				v_pam1og: .5,\n				v_1ipf08w: .75,\n				v_1axqdj4: 1.25,\n				v_1qr38cg: 1.75,\n				v_15ldds: 2,\n				v_1q248w0: 2.75,\n				v_1eelatc: 3.25,\n				v_1x9tou8: 3.75,\n				v_8iam0w: 4,\n				v_nhooow: 4.5,\n				v_fq01z4: 5,\n				v_w0u77k: 5.5,\n				v_1vi5a0w: 15.75,\n				v_orvt34: 16.5,\n				v_dybn5s: 17,\n				v_1q8czr4: 17.75,\n				v_l11af4: 18.5,\n				v_uqn2tc: 19.5,\n				v_7zkdfk: 20,\n				v_o7a58g: 20.5,\n				v_vezl6o: 21.5,\n				v_b5t88w: 23,\n				v_4x2d4w: 24,\n				v_xhwjk0: 25.5,\n				v_lhw3r4: 26.5,\n				v_tjkbuo: 27.5,\n				v_h72ebk: 29,\n				v_31n3sw: 30,\n				v_64rl6o: 32,\n				v_9lmigw: 35,\n				v_3fdjpc: 38,\n				v_fapfcw: 41,\n				v_7o0lc0: 44,\n				v_clbdvk: 47,\n				v_ee8qv4: 49\n			},\n			z = {\n				"11s3rwg": 2.49,\n				"1uhxr0g": 2.87,\n				qr1wxs: 7.5,\n				"15xxon4": .01,\n				o6no5c: .02,\n				fb0nwg: .04,\n				"1etkow0": .05,\n				x2aoe8: .06,\n				"1wkupds": .07,\n				"11i46io": .09,\n				jqu60w: .1,\n				"1j9e70g": .11,\n				"1adr6rk": .13,\n				smh69s: .14,\n				"1s5179c": .15,\n				"8naeps": .16,\n				qekf7k: .18,\n				"1px4g74": .19,\n				hixeyo: .2,\n				za7fgg: .22,\n				"1ysrgg0": .23,\n				lyqx34: .26,\n				"16hwveo": 1.13,\n				"1fdjvnk": 1.17,\n				"2jjcao": 1.2,\n				"1jtdds0": 1.23,\n				t6gd1c: 1.26,\n				"65e29s": 1.28,\n				"1nf83r4": 1.31,\n				wsb30g: 1.34,\n				jgukn4: 1.38,\n				al7ke8: 1.4,\n				"1a3rlds": 1.41,\n				"8datc0": 1.44,\n				"1pn4utc": 1.47,\n				z07u2o: 1.5,\n				"13g1c74": 1.53,\n				ct4bgg: 1.56,\n				ukeby8: 1.58,\n				mspp8g: 1.62,\n				"1dfmpz4": 1.65,\n				lm6m8: 1.68,\n				icw740: 1.7,\n				"18zt7uo": 1.73,\n				"79cfsw": 1.76,\n				"1oj6ha8": 1.79,\n				"1xethj4": 1.83,\n				"12c2yo0": 1.85,\n				bp5xxc: 1.88,\n				"1syzzeo": 1.91,\n				ncow00: 1.94,\n				"1dzlwqo": 1.97,\n				"15ldds": 2,\n				"10o5edc": 2.009999,\n				a18dmo: 2.04,\n				"1rb2f40": 2.069999,\n				pkln28: 2.1,\n				"1g7insw": 2.13,\n				"12w25fk": 2.17,\n				c954ow: 2.2,\n				"1brp5og": 2.21,\n				"1400iyo": 2.25,\n				v4dips: 2.3,\n				hsx0cg: 2.34,\n				"18fu134": 2.37,\n				"167xa0w": 2.41,\n				"1f3ka9s": 2.45,\n				"1d5n4lc": 1.01,\n				"1uwx534": 1.03,\n				bml8g: 1.04,\n				i2wlq8: 1.06,\n				"979lhc": 1.08,\n				"18ptmgw": 1.09,\n				"1qh3myo": 1.11,\n				"6zcuf4": 1.12,\n				oqmuww: 1.14,\n				fuzuo0: 1.16,\n				xm9v5s: 1.18,\n				"1x4tw5c": 1.19,\n				"1223da8": 1.21,\n				katcsg: 1.22,\n				bf6cjk: 1.24,\n				"1axqdj4": 1.25,\n				"1sp0e0w": 1.27,\n				"15ny39c": 1.29,\n				nwo2rk: 1.3,\n				f112io: 1.32,\n				"1ejl3i8": 1.33,\n				"1pkk5c": 1.36,\n				"1184l4w": 1.37,\n				"1izelmo": 1.39,\n				schkw0: 1.42,\n				"1rv1lvk": 1.43,\n				"17vuubk": 1.45,\n				q4ktts: 1.46,\n				h8xtkw: 1.48,\n				"1yirv28": 1.51,\n				"3xhb7k": 1.52,\n				lorbpc: 1.54,\n				"1l7bcow": 1.55,\n				"1cbocg0": 1.57,\n				"1u2ycxs": 1.59,\n				"51foqo": 1.6,\n				"14jzpq8": 1.61,\n				"1mb9q80": 1.63,\n				dx2ozk: 1.64,\n				vocphc: 1.66,\n				"1v6wqgw": 1.67,\n				"10467ls": 1.69,\n				"1hvg83k": 1.71,\n				"9h96v4": 1.72,\n				r8j7cw: 1.74,\n				"1qr38cg": 1.75,\n				"16rwgsg": 1.77,\n				p0mgao: 1.78,\n				g4zg1s: 1.8,\n				"1fnjh1c": 1.81,\n				xw9gjk: 1.82,\n				"2tixog": 1.84,\n				kksy68: 1.86,\n				"1k3cz5s": 1.87,\n				"1b7pyww": 1.89,\n				tgfyf4: 1.9,\n				"5levi8": 1.92,\n				"153ywhs": 1.93,\n				"1mv8wzk": 1.95,\n				eh1vr4: 1.96,\n				w8bw8w: 1.98,\n				iwvdvk: 2.02,\n				"1iffev4": 2.029999,\n				"19jsem8": 2.049999,\n				rsie4g: 2.06,\n				"7tbmkg": 2.08,\n				"17bvnk0": 2.089999,\n				"1p35o1s": 2.11,\n				goymtc: 2.12,\n				"1xysoao": 2.15,\n				"3di4g0": 2.16,\n				l4s4xs: 2.18,\n				"1knc5xc": 2.19,\n				u0f56o: 2.22,\n				"1tiz668": 2.23,\n				"4hghz4": 2.24,\n				m8qigw: 2.26,\n				dd3i80: 2.28,\n				"1cvnj7k": 2.29,\n				"1umxjpc": 2.31,\n				"1mzuo": 2.32,\n				zk70u8: 2.33,\n				"1hbh1c0": 2.35,\n				"8xa03k": 2.36,\n				qok0lc: 2.38,\n				"1q741kw": 2.39,\n				"6pd91c": 2.4,\n				ogn9j4: 2.42,\n				"1wuuark": 2.47,\n				k0treo: 2.5,\n				"1jjdse8": 2.51,\n				swgrnk: 2.54,\n				"162xhc0": 2.57,\n				fg0glc: 2.6,\n				l11af4: 18.5,\n				"9diccg": 19,\n				"7zkdfk": 20,\n				gfliio: 21,\n				b5t88w: 23,\n				"4x2d4w": 24,\n				emo5j4: 25,\n				aobxts: 27,\n				"6shmgw": 28,\n				"31n3sw": 30,\n				"64rl6o": 32,\n				dch14w: 33,\n				"9lmigw": 35,\n				"1yv9csg": 5.35,\n				o42yo: 6.8,\n				q22xhc: 8.5,\n				d2hfr4: 31,\n				"1np7p4w": .03,\n				"1zk5j4": .08,\n				av75s0: .12,\n				"185ufpc": .17,\n				"1h1hfy8": .21,\n				"47gwlc": .24,\n				d33wu8: .28,\n				uudxc0: .3,\n				"14tzb40": .33,\n				e72adc: .36,\n				"1vgwbuo": .39,\n				"10e5szk": .41,\n				"1i5fthc": .43,\n				"1r12tq8": .47,\n				pam1og: .5,\n				gez1fk: .52,\n				"1xot2ww": .55,\n				kusjk0: .58,\n				bz5jb4: .6,\n				tqfjsw: .62,\n				"5vegw0": .64,\n				"1n58idc": .67,\n				wibhmo: .7,\n				"1fkyrk": .72,\n				"1ipf08w": .75,\n				s2hzi8: .78,\n				pul8g0: .82,\n				"1ghi96o": .85,\n				"3nhpts": .88,\n				lerqbk: .9,\n				uaeqkg: .94,\n				"14a04cg": .97,\n				dn33ls: 1,\n				ved43k: 1.02,\n				zu6m80: 1.05,\n				"1hlgmps": 1.07,\n				qyjlz4: 1.1,\n				"1lhay2o": .27,\n				"1clnxts": .29,\n				"1ucxybk": .31,\n				"5bfa4g": .32,\n				n2pam8: .34,\n				"1ml9bls": .35,\n				"1dpmbcw": .37,\n				vycav4: .38,\n				vls00: .4,\n				imvshs: .42,\n				"9r8s8w": .44,\n				"199st8g": .45,\n				"7jc16o": .48,\n				"171w268": .49,\n				"1ot62o0": .51,\n				"1fxj2f4": .53,\n				y691xc: .54,\n				"33ij28": .56,\n				"12m2k1s": .57,\n				"1kdckjk": .59,\n				"1t8zksg": .63,\n				"15dyhvk": .65,\n				nmohds: .66,\n				er1h4w: .68,\n				"1e9li4g": .69,\n				"1w0vim8": .71,\n				"10y4zr4": .73,\n				j6uz9c: .74,\n				ab7z0g: .76,\n				"19ts000": .77,\n				"1rl20hs": .79,\n				"83b7y8": .8,\n				"17lv8xs": .81,\n				"1pd59fk": .83,\n				gyy874: .84,\n				yq88ow: .86,\n				"1y8s9og": .87,\n				"1361qtc": .89,\n				"1kxbrb4": .91,\n				"1c1or28": .93,\n				"1tsyrk0": .95,\n				"4rg3cw": .96,\n				miq3uo: .98,\n				"1m1a4u8": .99,\n				"11x3klc": 5.05,\n				"1nrplhc": 5.15,\n				"1ag9340": 5.25,\n				qh2bk0: 5.3,\n				"14wh7gg": 5.45,\n				w0u77k: 5.5,\n				"7ltxj4": 5.6,\n				kxafwg: 5.7,\n				"1tbhh4w": 5.75,\n				"110mw3k": 5.85,\n				"1pfn5s0": 5.95,\n				"3pzm68": 6,\n				ml8074: 6.1,\n				"1uzf1fk": 6.15,\n				"16kerr4": 6.25,\n				"1jvva4g": 6.35,\n				"67vym8": 6.4,\n				jjcgzk: 6.5,\n				hbfpxc: 6.6,\n				"13ij8jk": 6.65,\n				"1mdrmkg": 6.75,\n				p34cn4: 6.9,\n				"1xhbdvk": 6.95,\n				"1ihxb7k": 7.15,\n				"1ga0k5c": 7.25,\n				dflekg: 7.4,\n				"1o1p6v4": 7.55,\n				"2c1n9c": 7.6,\n				"1wscef4": 7.75,\n				zhp4hs: 7.9,\n				"5iwz5s": 8,\n				f8irk0: 9,\n				y3r5kw: 9.5,\n				lxhyww: 10.5,\n				a9z0u8: 11,\n				"783hmo": 12,\n				m7hkao: 12.5,\n				wm2c5c: 13.5,\n				"2na6tc": 14,\n				ign1mo: 14.5,\n				snq4g0: 15.5,\n				"5wnf28": 16,\n				dybn5s: 17,\n				yhhlhc: 17.5,\n				testbid: 0,\n				"1nz7aio": 2.43,\n				xca9s0: 2.46,\n				b56r5s: 2.52,\n				obngu8: 2.58,\n				"24jy80": 2.64,\n				"1jedzpc": 2.67,\n				"18au8e8": 2.73,\n				hnx7nk: 2.76,\n				"13v0q9s": 2.81,\n				"10lkow": 2.96,\n				"156gsu8": 7.05,\n				"1tlh2io": 7.35,\n				"1aq8ohs": 7.65,\n				"1losn40": 7.95,\n				"1sf0sn4": 2.55,\n				"1eykhkw": 2.61,\n				srgyyo: 2.7,\n				"1yxr94w": 2.79,\n				d83pj4: 2.84,\n				n7p3b4: 2.9,\n				"1dum41s": 2.93,\n				"1iafm68": 2.99,\n				"7vtiww": 7.2,\n				b2outc: 7.8,\n				"13q0xkw": .25,\n				riisqo: .46,\n				"1bhpkao": .61,\n				cj4q2o: .92,\n				"1o96vwg": 1.15,\n				"1wav400": 1.35,\n				"1grhukg": 1.49,\n				"1vqvx8g": 1.99,\n				yg8nb4: 2.14,\n				"1lrajgg": 2.27,\n				fl09a8: 2.44,\n				"1h6h8n4": 2.77,\n				"1m69xj4": 3.55,\n				rdj01s: 4.3,\n				"29jqww": 2.48,\n				"1anqs5c": 2.53,\n				"6kdgcg": 2.56,\n				"1nu7hts": 2.59,\n				"1wpui2o": 2.63,\n				jvtyps: 2.66,\n				"1sa0zy8": 2.71,\n				"1q248w0": 2.75,\n				"4cgpa8": 2.8,\n				"1cqnqio": 2.85,\n				"5gf2tc": 2.88,\n				ec2328: 2.92,\n				"1vlw4jk": 2.95,\n				"9w8kxs": 3,\n				"176vuv4": 3.05,\n				"1kicd8g": 3.15,\n				jbury8: 3.3,\n				h3y0w0: 3.4,\n				gmdxc: 3.6,\n				ovmnls: 3.7,\n				"15sxvy8": 3.85,\n				"1j4eebk": 3.95,\n				"1gwhn9c": 4.05,\n				e22hog: 4.2,\n				"1oo69z4": 4.35,\n				nhooow: 4.5,\n				"17gvg8w": 4.65,\n				"1ksbym8": 4.75,\n				hxwt1c: 4.9,\n				t1gkcg: 5.1,\n				"2221vk": 5.2,\n				d5lt6o: 5.4,\n				"1i7xpts": 5.55,\n				"1g00yrk": 5.65,\n				etjdhc: 5.8,\n				s4zvuo: 5.9,\n				"1c46neo": 6.05,\n				"99rhts": 6.2,\n				xorri8: 6.3,\n				"1em2zuo": 6.45,\n				"1rxji80": 6.55,\n				umw8ao: 6.7,\n				"192b474": 6.85,\n				brnu9s: 7,\n				x7ah34: 2.62,\n				"11n3z7k": 2.65,\n				b06ygw: 2.68,\n				"1aiqzgg": 2.69,\n				"8sa7eo": 2.72,\n				qjk7wg: 2.74,\n				zf785c: 2.78,\n				m3qps0: 2.82,\n				"1lmaqrk": 2.83,\n				uzdq0w: 2.86,\n				"14yz3sw": 2.89,\n				"1mq94ao": 2.91,\n				w3c3k0: 2.94,\n				"10j5log": 2.97,\n				irvl6o: 2.98,\n				yb8um8: 3.1,\n				"60e9kw": 3.2,\n				"1eelatc": 3.25,\n				"1rq1t6o": 3.35,\n				"13b1ji8": 3.45,\n				ufej9c: 3.5,\n				"18utf5s": 3.65,\n				"1x9tou8": 3.75,\n				bk658g: 3.8,\n				wxavpc: 3.9,\n				"8iam0w": 4,\n				ltr4e8: 4.099999,\n				"1u7y5mo": 4.15,\n				"10960ao": 4.25,\n				"2yiqdc": 4.4,\n				"1bcprls": 4.45,\n				"1vvvpxc": 4.55,\n				a686bk: 4.6,\n				yl8g00: 4.7,\n				"4mgao0": 4.8,\n				"1d0nbwg": 4.85,\n				"1qc3u9s": 4.95,\n				fq01z4: 5,\n				watslc: 7.1,\n				l7a1a8: 7.3,\n				zmox6o: 7.45,\n				oe5d6o: 7.7,\n				"18dc4qo": 7.85,\n				"94ow0": 10,\n				t57ev4: 11.5,\n				hmo9hc: 13,\n				ccvz7k: 15,\n				orvt34: 16.5,\n				"25swe8": 18,\n				uqn2tc: 19.5,\n				"3y3sao": 22,\n				yq5fk: 26,\n				h72ebk: 29,\n				"1jyadc": 34,\n				testBid: 50\n			},\n			M = {\n				hgfim8: "Amazon - DistrictM",\n				qc2iv4: "Amazon - Magnite",\n				"183cjcw": "Amazon - AppNexus",\n				"8ksidc": "Amazon - OpenX",\n				"1s2jaww": "Amazon - PubMatic",\n				"1pumjuo": "Amazon - EMX",\n				"12jknpc": "Amazon - Conversant UAM",\n				"1kauo74": "Amazon - Amobee DSP",\n				"15bglj4": "Amazon - PubMatic UAM APAC",\n				"5swkjk": "Amazon - PubMatic UAM EU",\n				"1d32f4": "Amazon - Simpli.fi",\n				ksan7k: "Amazon - Index Exchange",\n				urw0zk: "Amazon - Smaato",\n				"1dn4f0g": "Amazon - AdGeneration",\n				vvueio: "Amazon - DMX",\n				"1veefi8": "Amazon - Yieldmo",\n				"1i2xx4w": "Amazon - Yahoo Japan",\n				rg0we8: "Amazon - UnrulyX_SSP_APS",\n				y3r5kw: "Amazon - Verizon Media Group",\n				"1xmb6kg": "Amazon - GumGum UAM",\n				"1t6hog0": "Amazon - Acuity",\n				"1n2qm0w": "Amazon - Sharethrough",\n				j4d2ww: "Amazon - EMX UAM",\n				"1imx3wg": "Amazon - LoopMe_UAM",\n				z7pj40: "Amazon - Pulsepoint",\n				p845c0: "Amazon - SmartRTB+"\n			};\n		var R = {\n				skyscraper: {\n					1: "eexq7SUa6daeQrPF6q1CaKZ0",\n					10: "SSZzGHt3d4BrOdVUug1ypxji",\n					11: "OXc0ZJDJIcRgGcIta8mTUQSZ",\n					12: "ulACVGPjP002tSfhDGRApuub",\n					13: "c7FldnCsd9Mtcr7PgBFGKWEQ",\n					14: "KJouWQMjZwvE8fxw4mAvGopZ",\n					15: "ilNkOqBMO6EGbQwrZtCMHzeJ",\n					16: "Kg24ec1AyTvzJ6I3Cji8lqzx",\n					17: "iqvpcyepSMCVCsJfKu4JQGwr",\n					18: "es9ztDrPZDW883VHbK2gUfkQ",\n					19: "pvXQE41GXKGsW5Li0OSQavwT",\n					20: "MCy638sYvzVbsrvcPau6lABN",\n					21: "NkJeV6CuMlt41iJWcgnmMSDN",\n					22: "fjKznUvVWlp6TBxuSsEkQF8H",\n					23: "5tJM2ZFmNf7gii6KVS6msGc4",\n					24: "xZUYMFw1zGuRzFd6DRl88Pwk",\n					3: "xNmhWWy88VtzOGfderrtgDBb",\n					30: "KO0gUA5iJIsleK9a941H0pW1",\n					31: "wo0KU1WR11jNFxoy121ciQj8",\n					37: "areVtONg11YNRQin7R2sveKy",\n					4: "nip2pDW2AbU4GM5HMJcouuIa",\n					47: "uzLaOEe8yqB9eWZuxdnwyawr",\n					49: "ZYaqiQw00NSTBGJ4HacifENM",\n					5: "qe5Tc3N2MO3daALoTdIaTmSA",\n					50: "NZv1ui2F1tlQ6PQQi7umnFht",\n					6: "xbx8OLCAgjm0igkmFIBw8n6E",\n					8: "4vYDfNOQagnuwg9REGNWGv83"\n				},\n				rectangle: {\n					1: "Ka3KvQx9svu71CJoRtZlwFY9",\n					10: "9o5dMBQZX9bi2OsvTpc5j0pO",\n					11: "gwL6nB1Twy25gpWQyEP2cVMJ",\n					12: "yYUjIY5L6w2ukD5FxCIVydgG",\n					13: "PoqRXAEYHKTdqNY22lIFTXRp",\n					14: "eAudypoJLJEtFZz3zzvKYoAu",\n					15: "4b416MUjJEdZm5nDKwvn2ELO",\n					16: "H6jadzxgw0uRVRHHadZ19Zvp",\n					17: "5zG8Ioh6paBscdCgUQTQE0eu",\n					18: "OgMX0PlDPabF3BHOgxDbeH2n",\n					19: "uzK7eCjSVYDp4KvJEg6mC59r",\n					20: "yapIY909O3cgcD8QDAEehtkb",\n					21: "8KT1bEUCcvASfq0LXWN2nVe0",\n					22: "3LKyDpL1Xt7YactKFGxFpJO7",\n					23: "GMaOiZl6YeMzYckusbO4Cdh1",\n					24: "5iZnMqviynz6ndlaikqhMy73",\n					3: "lcpgaTLqkd6gRi8AVtVr0gLe",\n					30: "xWGhFW6bvMf9LuGYqQOhoD2h",\n					31: "GqMz69ka237zrG4H8bpMuYTy",\n					37: "lYrk2xnelCQrhwmO43AtjErF",\n					4: "wceshrwDAUvkTTLQZDgE1V5T",\n					47: "PDA12fEHtYIVr6A12fZ86JQH",\n					49: "RYn9wxADCbBgKeo8Lyxx1ZHE",\n					5: "N3wOmgPMiK6RaGNYjeqOzuHU",\n					50: "KwEXqYIZG8fOlJyePKTBiJFs",\n					6: "fJMv7XtKbfsRbzkO42fkS3Dr",\n					8: "915o8cwxF5rzfQsA1Op6hhQV"\n				},\n				leaderboard: {\n					4: "fZ4M7Isi1rLz2cjAcBBLmQGI",\n					16: "ZPwouCq7eD5kRnZjX5ct8ZIT",\n					1: "sysnuL1RKPIEL98w2l6lPc1w",\n					31: "FgHUFCWMZCCJaHKMF0LyIgSI",\n					23: "eyGVQGQkrHwJRcLoBzepUHW2",\n					14: "PeRnr3pCNPpCgJAOF3yuQCGg",\n					37: "5DXFSCYcaAxAXBuZVpTHAx59",\n					30: "MpHDUxZ178U65yD3l878z5m1",\n					47: "oYQGytr0CbDDQqIooggCsNTO",\n					18: "na3uJK58s0vgb7NyaPR6R5P8",\n					50: "m3hskIBrmloAWHD7i27q2ZPN",\n					3: "PIsUL8EJvXXA1thcFkCPWdhi",\n					19: "cluKVL1thRZlb3bsK7oVadOZ",\n					20: "8PPLwmi2mra9HNTdhftQOcC4",\n					8: "cCQE4L5S1j9BmKeywuonM6hM",\n					11: "uvkuS4QYv01YvuGoJvqa9xnz",\n					12: "GyG0XHcaahKmsXbcjDlgtjCQ",\n					17: "0ut5aHlZRj5dNfTKo9bM8nXj",\n					10: "TzMO5iGdP4vt7BIOAQ2e3kpU",\n					49: "f1vArQjoEfX9QdjK2TvBjnDv",\n					22: "92kdBH3AxvPr1pqZ1h1TYkjN",\n					13: "Y6Tl87JTAn9T1B8rq523UDeH",\n					15: "B3HlKKIdq8mGyoMGkjT4m9RD",\n					24: "nfS0DrtZtJ6eZVNqsWqyVVFS",\n					5: "gr33qXeArxdqi0Sk4i50TmE3",\n					6: "ACn0XyU2KP2l94N0HMf1vhlu",\n					21: "o2PQGGTxXO92in2mASt624tn"\n				},\n				mobile_leaderboard: {\n					4: "Ue573Dbj78H6RnJT1nlozaJY",\n					16: "5X98AYdO2OAIb2m6ThLjCGR5",\n					1: "nVDrFwfkiRg5Tb426duBnat4",\n					31: "H8tpygATsgJwk7qJzh612B0I",\n					23: "07iMij2dOIgPHzM7JFv5fYBN",\n					14: "XCQLWETuRkKmiN9jCOu01NOp",\n					37: "419OVNbGzLJn7wlh5jAiUFLA",\n					30: "ErE9N4WozhjbawA6HFN2hC0V",\n					47: "4aBsJtSPEivB07hrlV6nTgj7",\n					18: "waksL4h4X7gn2TU88OgeZHHl",\n					50: "Wi3BRMWcCUdKZO7leMhtCfdp",\n					3: "KQ3P2qVndkjlesGkzM5Rknma",\n					19: "OCsZIZrTXKyprJ8AKiI7e0Jl",\n					20: "h2aMA8KeZ3tHtfRgwT2xCHUJ",\n					8: "igvEPDF1ft8FBFQ2aVhCS0BG",\n					11: "I1ZnJzEjRg75BZikcGMWxMTF",\n					12: "ZrnW76G2qvB5pZx8VvOanqQQ",\n					17: "B4f8YQfcg3WWl5k9pAnqVCfm",\n					10: "cfNKknbTZxcxhNZCV2fWr4Ne",\n					49: "ziBY1mSHWj9UTGcq9Tbzo5J4",\n					22: "ImlLSALVeaqvi7y2e6qdBDkw",\n					13: "NUx9OmJMlzbkv39hUX5FOnXv",\n					15: "RxDq1opgeO5VXEQRPtdESHaX",\n					24: "aswJxUjNpHyiEunaOUBGbajK",\n					5: "1M1EIJhXdwEoJ8utYTDjj0DD",\n					6: "gExvCBm9TEaw4jV6kRzEuDxq",\n					21: "wNOOjIhadhe2s1jgq3LppWm0"\n				},\n				billboard: {\n					4: "NO39pgf3BaqIgRZoZ5SvYMXf",\n					16: "dr2IuY7Yb8POz9tbezoJUFey",\n					1: "WhhFn8GL9nBEK2z9psbtD1SV",\n					31: "JNfSIPKKAkfNgzkg3hrGlGEV",\n					23: "xvsrS9J4xrRGjlus3pKkIatI",\n					14: "4BL4a74RRMoiRu9D8jKAfdij",\n					37: "f8B8j7tjb1YA6lAcnHSRBlfI",\n					30: "vW1ODUqFt2jDk5laYsVh9PIF",\n					47: "R7GldiHZEWYFwdJq936YnbZW",\n					18: "83noJ3tAhRyFWDlS1iXKuRGa",\n					50: "WNu1woAb2OHf3KncItSAnYnm",\n					3: "Ydwhf5DPoJBinldgPdkD9okm",\n					19: "3X7dNFFm484Xx6aD6nBF0k43",\n					20: "qzLmNwSljh25A7s9HXQYVYtr",\n					8: "tXWpZaKO291ytd8kfiy3NWlz",\n					11: "0ePnxLUMZ8tKBxImFp2i1J4g",\n					12: "Y1HuzbhxRv1UmUhd8dUtONQI",\n					17: "lqSabVDWqYWy8jpJH57BK1vS",\n					10: "zVEWUpJuNfEipDrTPGwniMP3",\n					49: "B2srINo0hBkijyowlq4FQk7c",\n					22: "Ljcylng1YDm5yAqEpiomGazZ",\n					13: "hYTGyFgCiCUVtNOx56TkKexo",\n					15: "5xkx65Y9eEhPen8gqIuOFQRZ",\n					24: "ZH3Odxmz8QF49ZoZ16mPs08T",\n					5: "Ax2noHPv7iRdW6DM26NxmtFT",\n					6: "mZEu6Z0wDTq4UAHQoyUosm5y",\n					21: "7bAgpwCip0dSf6bJXgBO6nY1"\n				}\n			},\n			L = [];\n\n		function O(e, t) {\n			var i, n, r;\n			return (null === (n = null === (i = null == t ? void 0 : t.meta) || void 0 === i ? void 0 : i.advertiserDomains) || void 0 === n ? void 0 : n.length) > 0 && (null === (r = null == t ? void 0 : t.meta) || void 0 === r ? void 0 : r.advertiserDomains.find((function(e) {\n				return function(e) {\n					return L.includes(e) || L.includes("www." + e) || e.includes("game")\n				}(e)\n			}))) ? (console.warn("Blocked ad: ", t), 0) : e\n		}\n		var G = function() {\n				return G = Object.assign || function(e) {\n					for (var t, i = 1, n = arguments.length; i < n; i++)\n						for (var r in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);\n					return e\n				}, G.apply(this, arguments)\n			},\n			U = function(e, t, i) {\n				if (i || 2 === arguments.length)\n					for (var n, r = 0, o = t.length; r < o; r++) !n && r in t || (n || (n = Array.prototype.slice.call(t, 0, r)), n[r] = t[r]);\n				return e.concat(n || Array.prototype.slice.call(t))\n			},\n			Z = parseInt(I("site_id"), 10) || 0,\n			q = "desktop";\n		y() && (q = "mobile"), w() && (q = "tablet");\n		var K = "rewarded",\n			Q = "video",\n			N = {\n				"728x90": "\/21682198607\/" + q + "_ingame_728x90\/" + Z + "_" + q + "_ingame_728x90",\n				"300x250": "\/21682198607\/" + q + "_ingame_300x250\/" + Z + "_" + q + "_ingame_300x250",\n				"970x250": "\/21682198607\/" + q + "_ingame_970x250\/" + Z + "_" + q + "_ingame_970x250",\n				"160x600": "\/21682198607\/" + q + "_ingame_160x600\/" + Z + "_" + q + "_ingame_160x600",\n				"320x50": "\/21682198607\/" + q + "_ingame_320x50\/" + Z + "_" + q + "_ingame_320x50",\n				"728x90_external": "\/21682198607\/external_" + q + "_display_ingame\/external_" + q + "_ingame_728x90",\n				"300x250_external": "\/21682198607\/external_" + q + "_display_ingame\/external_" + q + "_ingame_300x250",\n				"970x250_external": "\/21682198607\/external_" + q + "_display_ingame\/external_" + q + "_ingame_970x250",\n				"160x600_external": "\/21682198607\/external_" + q + "_display_ingame\/external_" + q + "_ingame_160x600",\n				"320x50_external": "\/21682198607\/external_" + q + "_display_ingame\/external_" + q + "_ingame_320x50"\n			},\n			F = !1,\n			X = function(e, t, i) {\n				if (tt.prebidAvailable) {\n					F = !0;\n					var n = ["US", "CA", "AU"],\n						r = function(e) {\n							var i, r = S() || y() || w() ? ["video\/mp4", "application\/javascript"] : ["video\/mp4", "video\/webm", "video\/ogg", "application\/javascript"],\n								o = G(G({\n									mimes: r,\n									minduration: 0,\n									maxduration: 15,\n									protocols: [2, 3, 5, 6, 7, 8],\n									w: 640,\n									h: 480,\n									placement: 1,\n									linearity: 1\n								}, e ? {} : {\n									skip: 1,\n									skipafter: 5\n								}), {\n									boxingallowed: 1,\n									pos: 1,\n									api: [2]\n								});\n							return {\n								bids: U(U([{\n									bidder: "appnexus",\n									params: {\n										placementId: 13184250,\n										supplyType: "web"\n									}\n								}, {\n									bidder: "openx",\n									params: {\n										delDomain: "poki-d.openx.net",\n										unit: "540105196"\n									}\n								}, {\n									bidder: "spotx",\n									params: {\n										channel_id: "265590",\n										ad_unit: "instream",\n										secure: !0,\n										hide_skin: !0\n									}\n								}, {\n									bidder: "ix",\n									params: {\n										siteId: "436284",\n										video: {}\n									}\n								}, {\n									bidder: "richaudience",\n									params: {\n										pid: (i = Z, E[i] || "MP_gIE1VDieUi"),\n										supplyType: "site"\n									}\n								}, {\n									bidder: "onetag",\n									params: {\n										pubId: "6da09f566a9dc06"\n									}\n								}, {\n									bidder: "rubicon",\n									params: {\n										accountId: "18608",\n										siteId: "266914",\n										zoneId: "1322034",\n										position: "atf",\n										video: {\n											size_id: 204\n										}\n									}\n								}, {\n									bidder: "pubmatic",\n									params: {\n										publisherId: "156838",\n										adSlot: "3607869@640x360"\n									}\n								}], n.includes(t) ? [{\n									bidder: "33across",\n									params: {\n										siteId: "aRJKVCig8r7ikZaKj0P0Le",\n										productId: "instream"\n									}\n								}] : [], !0), [{\n									bidder: "sharethrough",\n									params: {\n										pkey: "vRjLnZDA86biUVrjIKVGxq3x"\n									}\n								}, {\n									bidder: "triplelift",\n									params: {\n										inventoryCode: "Poki_Instream_Prebid",\n										video: G({}, o)\n									}\n								}], !1),\n								mediaTypes: {\n									video: G({\n										context: "instream",\n										playerSize: [640, 480]\n									}, o)\n								}\n							}\n						},\n						o = r(!0),\n						a = r(!1),\n						s = [{\n							code: Q,\n							mediaTypes: a.mediaTypes,\n							bids: U([], a.bids, !0)\n						}, {\n							code: K,\n							mediaTypes: o.mediaTypes,\n							bids: U([], o.bids, !0)\n						}, {\n							code: N["728x90"],\n							mediaTypes: {\n								banner: {\n									sizes: [\n										[728, 90]\n									]\n								}\n							},\n							bids: U(U([{\n								bidder: "appnexus",\n								params: {\n									placementId: "12940427"\n								}\n							}, {\n								bidder: "openx",\n								params: {\n									unit: "539859872",\n									delDomain: "poki-d.openx.net"\n								}\n							}, {\n								bidder: "ix",\n								params: {\n									siteId: "268177",\n									size: [728, 90]\n								}\n							}, {\n								bidder: "pubmatic",\n								params: {\n									publisherId: "156838",\n									adSlot: "1374895@728x90"\n								}\n							}, {\n								bidder: "rubicon",\n								params: {\n									accountId: "18608",\n									siteId: "204596",\n									zoneId: "1008080"\n								}\n							}, {\n								bidder: "onetag",\n								params: {\n									pubId: "6da09f566a9dc06"\n								}\n							}, {\n								bidder: "richaudience",\n								params: {\n									pid: "1V6a2fgLvX",\n									supplyType: "site"\n								}\n							}], n.includes(t) ? [{\n								bidder: "33across",\n								params: {\n									siteId: "aRJKVCig8r7ikZaKj0P0Le",\n									productId: "siab"\n								}\n							}] : [], !0), [{\n								bidder: "sharethrough",\n								params: {\n									pkey: R.leaderboard[Z] || R.leaderboard[3]\n								}\n							}, {\n								bidder: "triplelift",\n								params: {\n									inventoryCode: "Poki_HDX_Prebid"\n								}\n							}], !1)\n						}, {\n							code: N["300x250"],\n							mediaTypes: {\n								banner: {\n									sizes: [\n										[300, 250]\n									]\n								}\n							},\n							bids: U(U([{\n								bidder: "appnexus",\n								params: {\n									placementId: "12935252"\n								}\n							}, {\n								bidder: "openx",\n								params: {\n									unit: "539859873",\n									delDomain: "poki-d.openx.net"\n								}\n							}, {\n								bidder: "ix",\n								params: {\n									siteId: "268178",\n									size: [300, 250]\n								}\n							}, {\n								bidder: "pubmatic",\n								params: {\n									publisherId: "156838",\n									adSlot: "1374896@300x250"\n								}\n							}, {\n								bidder: "rubicon",\n								params: {\n									accountId: "18608",\n									siteId: "204596",\n									zoneId: "1008080"\n								}\n							}, {\n								bidder: "onetag",\n								params: {\n									pubId: "6da09f566a9dc06"\n								}\n							}, {\n								bidder: "richaudience",\n								params: {\n									pid: "pKqNt5LyvF",\n									supplyType: "site"\n								}\n							}], n.includes(t) ? [{\n								bidder: "33across",\n								params: {\n									siteId: "aRJKVCig8r7ikZaKj0P0Le",\n									productId: "siab"\n								}\n							}] : [], !0), [{\n								bidder: "sharethrough",\n								params: {\n									pkey: R.skyscraper[Z] || R.skyscraper[3]\n								}\n							}, {\n								bidder: "triplelift",\n								params: {\n									inventoryCode: "Poki_300x250_Prebid"\n								}\n							}], !1)\n						}, {\n							code: N["970x250"],\n							mediaTypes: {\n								banner: {\n									sizes: [\n										[970, 250]\n									]\n								}\n							},\n							bids: U(U([{\n								bidder: "appnexus",\n								params: {\n									placementId: "20595278"\n								}\n							}, {\n								bidder: "openx",\n								params: {\n									unit: "543540497",\n									delDomain: "poki-d.openx.net"\n								}\n							}, {\n								bidder: "ix",\n								params: {\n									siteId: "597527",\n									size: [970, 250]\n								}\n							}, {\n								bidder: "pubmatic",\n								params: {\n									publisherId: "156838",\n									adSlot: "3344351@970x250"\n								}\n							}, {\n								bidder: "onetag",\n								params: {\n									pubId: "6da09f566a9dc06"\n								}\n							}, {\n								bidder: "richaudience",\n								params: {\n									pid: "yYyae7vnIh",\n									supplyType: "site"\n								}\n							}], n.includes(t) ? [{\n								bidder: "33across",\n								params: {\n									siteId: "aRJKVCig8r7ikZaKj0P0Le",\n									productId: "siab"\n								}\n							}] : [], !0), [{\n								bidder: "sharethrough",\n								params: {\n									pkey: R.rectangle[Z] || R.rectangle[3]\n								}\n							}, {\n								bidder: "triplelift",\n								params: {\n									inventoryCode: "Poki_970x250_Prebid"\n								}\n							}], !1)\n						}, {\n							code: N["160x600"],\n							mediaTypes: {\n								banner: {\n									sizes: [\n										[160, 600]\n									]\n								}\n							},\n							bids: U(U([{\n								bidder: "appnexus",\n								params: {\n									placementId: "12940425"\n								}\n							}, {\n								bidder: "openx",\n								params: {\n									unit: "539859871",\n									delDomain: "poki-d.openx.net"\n								}\n							}, {\n								bidder: "ix",\n								params: {\n									siteId: "268175",\n									size: [160, 600]\n								}\n							}, {\n								bidder: "pubmatic",\n								params: {\n									publisherId: "156838",\n									adSlot: "1374893@160x600"\n								}\n							}, {\n								bidder: "rubicon",\n								params: {\n									accountId: "18608",\n									siteId: "204596",\n									zoneId: "1008080"\n								}\n							}, {\n								bidder: "onetag",\n								params: {\n									pubId: "6da09f566a9dc06"\n								}\n							}, {\n								bidder: "richaudience",\n								params: {\n									pid: "rAEnPimPzC",\n									supplyType: "site"\n								}\n							}], n.includes(t) ? [{\n								bidder: "33across",\n								params: {\n									siteId: "aRJKVCig8r7ikZaKj0P0Le",\n									productId: "siab"\n								}\n							}] : [], !0), [{\n								bidder: "sharethrough",\n								params: {\n									pkey: R.billboard[Z] || R.billboard[3]\n								}\n							}, {\n								bidder: "triplelift",\n								params: {\n									inventoryCode: "Poki_HDX_Prebid"\n								}\n							}], !1)\n						}, {\n							code: N["320x50"],\n							mediaTypes: {\n								banner: {\n									sizes: [\n										[320, 50]\n									]\n								}\n							},\n							bids: U(U([{\n								bidder: "appnexus",\n								params: {\n									placementId: "20595224"\n								}\n							}, {\n								bidder: "openx",\n								params: {\n									unit: "543540495",\n									delDomain: "poki-d.openx.net"\n								}\n							}, {\n								bidder: "ix",\n								params: {\n									siteId: "597529",\n									size: [320, 50]\n								}\n							}, {\n								bidder: "pubmatic",\n								params: {\n									publisherId: "156838",\n									adSlot: "3344350@320x50"\n								}\n							}, {\n								bidder: "rubicon",\n								params: {\n									accountId: "18608",\n									siteId: "204596",\n									zoneId: "1008080"\n								}\n							}, {\n								bidder: "onetag",\n								params: {\n									pubId: "6da09f566a9dc06"\n								}\n							}, {\n								bidder: "richaudience",\n								params: {\n									pid: "1DP5EtcOip",\n									supplyType: "site"\n								}\n							}], n.includes(t) ? [{\n								bidder: "33across",\n								params: {\n									siteId: "aRJKVCig8r7ikZaKj0P0Le",\n									productId: "siab"\n								}\n							}] : [], !0), [{\n								bidder: "sharethrough",\n								params: {\n									pkey: R.skyscraper[Z] || R.skyscraper[3]\n								}\n							}, {\n								bidder: "triplelift",\n								params: {\n									inventoryCode: "Poki_HDX_Prebid"\n								}\n							}], !1)\n						}, {\n							code: N["728x90_external"],\n							mediaTypes: {\n								banner: {\n									sizes: [\n										[728, 90]\n									]\n								}\n							},\n							bids: U(U([{\n								bidder: "appnexus",\n								params: {\n									placementId: "20973406"\n								}\n							}, {\n								bidder: "openx",\n								params: {\n									unit: "543885656",\n									delDomain: "poki-d.openx.net"\n								}\n							}, {\n								bidder: "ix",\n								params: {\n									siteId: "268177",\n									placementId: "625562",\n									size: [728, 90]\n								}\n							}, {\n								bidder: "pubmatic",\n								params: {\n									publisherId: "156838",\n									adSlot: "3457872"\n								}\n							}, {\n								bidder: "rubicon",\n								params: {\n									accountId: "18608",\n									siteId: "362566",\n									zoneId: "1962680-2"\n								}\n							}, {\n								bidder: "onetag",\n								params: {\n									pubId: "6da09f566a9dc06"\n								}\n							}, {\n								bidder: "richaudience",\n								params: {\n									pid: "MP_gIE1VDieUi",\n									supplyType: "site"\n								}\n							}], n.includes(t) ? [{\n								bidder: "33across",\n								params: {\n									siteId: "aRJKVCig8r7ikZaKj0P0Le",\n									productId: "siab"\n								}\n							}] : [], !0), [{\n								bidder: "sharethrough",\n								params: {\n									pkey: R.billboard[Z] || R.billboard[3]\n								}\n							}, {\n								bidder: "triplelift",\n								params: {\n									inventoryCode: "Poki_HDX_Prebid"\n								}\n							}], !1)\n						}, {\n							code: N["300x250_external"],\n							mediaTypes: {\n								banner: {\n									sizes: [\n										[300, 250]\n									]\n								}\n							},\n							bids: U(U([{\n								bidder: "appnexus",\n								params: {\n									placementId: "20973408"\n								}\n							}, {\n								bidder: "openx",\n								params: {\n									unit: "543885657",\n									delDomain: "poki-d.openx.net"\n								}\n							}, {\n								bidder: "ix",\n								params: {\n									siteId: "625564",\n									size: [300, 250]\n								}\n							}, {\n								bidder: "pubmatic",\n								params: {\n									publisherId: "156838",\n									adSlot: "3457874"\n								}\n							}, {\n								bidder: "rubicon",\n								params: {\n									accountId: "18608",\n									siteId: "362566",\n									zoneId: "1962680-15"\n								}\n							}, {\n								bidder: "onetag",\n								params: {\n									pubId: "6da09f566a9dc06"\n								}\n							}, {\n								bidder: "richaudience",\n								params: {\n									pid: "MP_gIE1VDieUi",\n									supplyType: "site"\n								}\n							}], n.includes(t) ? [{\n								bidder: "33across",\n								params: {\n									siteId: "aRJKVCig8r7ikZaKj0P0Le",\n									productId: "siab"\n								}\n							}] : [], !0), [{\n								bidder: "sharethrough",\n								params: {\n									pkey: R.mobile_leaderboard[Z] || R.mobile_leaderboard[3]\n								}\n							}, {\n								bidder: "triplelift",\n								params: {\n									inventoryCode: "Poki_300x250_Prebid"\n								}\n							}], !1)\n						}, {\n							code: N["970x250_external"],\n							mediaTypes: {\n								banner: {\n									sizes: [\n										[970, 250]\n									]\n								}\n							},\n							bids: U(U([{\n								bidder: "appnexus",\n								params: {\n									placementId: "20973415"\n								}\n							}, {\n								bidder: "openx",\n								params: {\n									unit: "543885650",\n									delDomain: "poki-d.openx.net"\n								}\n							}, {\n								bidder: "ix",\n								params: {\n									siteId: "625560",\n									size: [970, 250]\n								}\n							}, {\n								bidder: "pubmatic",\n								params: {\n									publisherId: "156838",\n									adSlot: "3457879"\n								}\n							}, {\n								bidder: "rubicon",\n								params: {\n									accountId: "18608",\n									siteId: "362566",\n									zoneId: "1962680-57"\n								}\n							}, {\n								bidder: "onetag",\n								params: {\n									pubId: "6da09f566a9dc06"\n								}\n							}, {\n								bidder: "richaudience",\n								params: {\n									pid: "MP_gIE1VDieUi",\n									supplyType: "site"\n								}\n							}], n.includes(t) ? [{\n								bidder: "33across",\n								params: {\n									siteId: "aRJKVCig8r7ikZaKj0P0Le",\n									productId: "siab"\n								}\n							}] : [], !0), [{\n								bidder: "sharethrough",\n								params: {\n									pkey: R.leaderboard[Z] || R.leaderboard[3]\n								}\n							}, {\n								bidder: "triplelift",\n								params: {\n									inventoryCode: "Poki_970x250_Prebid"\n								}\n							}], !1)\n						}, {\n							code: N["160x600_external"],\n							mediaTypes: {\n								banner: {\n									sizes: [\n										[160, 600]\n									]\n								}\n							},\n							bids: U(U([{\n								bidder: "appnexus",\n								params: {\n									placementId: "20973407"\n								}\n							}, {\n								bidder: "openx",\n								params: {\n									unit: "543885653",\n									delDomain: "poki-d.openx.net"\n								}\n							}, {\n								bidder: "ix",\n								params: {\n									siteId: "625563",\n									size: [160, 600]\n								}\n							}, {\n								bidder: "pubmatic",\n								params: {\n									publisherId: "156838",\n									adSlot: "3457877"\n								}\n							}, {\n								bidder: "rubicon",\n								params: {\n									accountId: "18608",\n									siteId: "362566",\n									zoneId: "1962680-9"\n								}\n							}, {\n								bidder: "onetag",\n								params: {\n									pubId: "6da09f566a9dc06"\n								}\n							}, {\n								bidder: "richaudience",\n								params: {\n									pid: "MP_gIE1VDieUi",\n									supplyType: "site"\n								}\n							}], n.includes(t) ? [{\n								bidder: "33across",\n								params: {\n									siteId: "aRJKVCig8r7ikZaKj0P0Le",\n									productId: "siab"\n								}\n							}] : [], !0), [{\n								bidder: "sharethrough",\n								params: {\n									pkey: R.rectangle[Z] || R.rectangle[3]\n								}\n							}, {\n								bidder: "triplelift",\n								params: {\n									inventoryCode: "Poki_HDX_Prebid"\n								}\n							}], !1)\n						}, {\n							code: N["320x50_external"],\n							mediaTypes: {\n								banner: {\n									sizes: [\n										[320, 50]\n									]\n								}\n							},\n							bids: U(U([{\n								bidder: "appnexus",\n								params: {\n									placementId: "20973413"\n								}\n							}, {\n								bidder: "openx",\n								params: {\n									unit: "543885649",\n									delDomain: "poki-d.openx.net"\n								}\n							}, {\n								bidder: "ix",\n								params: {\n									siteId: "625559",\n									size: [320, 50]\n								}\n							}, {\n								bidder: "pubmatic",\n								params: {\n									publisherId: "156838",\n									adSlot: "3457875"\n								}\n							}, {\n								bidder: "rubicon",\n								params: {\n									accountId: "18608",\n									siteId: "362566",\n									zoneId: "1962680-43"\n								}\n							}, {\n								bidder: "onetag",\n								params: {\n									pubId: "6da09f566a9dc06"\n								}\n							}, {\n								bidder: "richaudience",\n								params: {\n									pid: "MP_gIE1VDieUi",\n									supplyType: "site"\n								}\n							}], n.includes(t) ? [{\n								bidder: "33across",\n								params: {\n									siteId: "aRJKVCig8r7ikZaKj0P0Le",\n									productId: "siab"\n								}\n							}] : [], !0), [{\n								bidder: "sharethrough",\n								params: {\n									pkey: R.mobile_leaderboard[Z] || R.mobile_leaderboard[3]\n								}\n							}, {\n								bidder: "triplelift",\n								params: {\n									inventoryCode: "Poki_HDX_Prebid"\n								}\n							}], !1)\n						}],\n						d = {\n							debug: !1,\n							enableSendAllBids: !0,\n							usePrebidCache: !0,\n							bidderTimeout: 1500,\n							priceGranularity: {\n								buckets: [{\n									precision: 2,\n									min: .01,\n									max: 3,\n									increment: .01\n								}, {\n									precision: 2,\n									min: 3,\n									max: 8,\n									increment: .05\n								}, {\n									precision: 2,\n									min: 8,\n									max: 20,\n									increment: .5\n								}, {\n									precision: 2,\n									min: 20,\n									max: 45,\n									increment: 1\n								}]\n							},\n							currency: {\n								adServerCurrency: "EUR",\n								defaultRates: {\n									EUR: {\n										EUR: 1,\n										GBP: .86408,\n										USD: 1.2212\n									},\n									GBP: {\n										EUR: 1.157300249976854,\n										GBP: 1,\n										USD: 1.4132950652717342\n									},\n									USD: {\n										EUR: .8188666885031116,\n										GBP: .7075663282017687,\n										USD: 1\n									}\n								}\n							},\n							cache: {\n								url: "null.html?https:\/\/prebid.adnxs.com\/pbc\/v1\/cache"\n							},\n							targetingControls: {\n								allowTargetingKeys: ["BIDDER", "AD_ID", "PRICE_BUCKET", "SIZE", "DEAL", "SOURCE", "FORMAT", "UUID", "CACHE_ID", "CACHE_HOST", "ADOMAIN"],\n								allowSendAllBidsTargetingKeys: ["BIDDER", "AD_ID", "PRICE_BUCKET", "SIZE", "DEAL", "SOURCE", "FORMAT", "UUID", "CACHE_ID", "CACHE_HOST", "ADOMAIN"]\n							},\n							userSync: {\n								filterSettings: {\n									all: {\n										bidders: "*",\n										filter: "include"\n									}\n								},\n								syncsPerBidder: 1e3,\n								syncDelay: 100,\n								userIds: [{\n									name: "pubCommonId",\n									storage: {\n										type: "cookie",\n										name: "poki_pubcid",\n										expires: 180\n									}\n								}]\n							}\n						};\n					window.pbjs.que.push((function() {\n						var n = G(G({\n							floors: {\n								data: {\n									currency: "EUR",\n									schema: {\n										fields: ["mediaType"]\n									},\n									values: {\n										banner: P(t),\n										video: B(t)\n									}\n								}\n							}\n						}, d), e.config);\n						window.pbjs.addAdUnits(function(e, t, i) {\n							var n, r;\n							i = i.toUpperCase();\n							var o = null == t ? void 0 : t[i];\n							if (!o) return e;\n							for (var a = 0; a <= e.length; a++)\n								for (var s = e[a], d = o[(null === (n = null == s ? void 0 : s.mediaTypes) || void 0 === n ? void 0 : n.video) ? "video" : "display"] || {}, A = (null === (r = null == s ? void 0 : s.bids) || void 0 === r ? void 0 : r.length) - 1; A >= 0; A--) {\n									var c = s.bids[A],\n										l = Math.random();\n									d[c.bidder] && l > d[c.bidder] && e[a].bids.splice(A, 1)\n								}\n							return e\n						}(e.adUnits || s, i, t)), window.pbjs.setConfig(n), window.pbjs.bidderSettings = {\n							appnexus: {\n								bidCpmAdjustment: O\n							},\n							openx: {\n								bidCpmAdjustment: O\n							},\n							spotx: {\n								bidCpmAdjustment: O\n							},\n							ix: {\n								bidCpmAdjustment: O\n							},\n							richaudience: {\n								bidCpmAdjustment: O\n							},\n							onetag: {\n								bidCpmAdjustment: O\n							},\n							rubicon: {\n								bidCpmAdjustment: O\n							},\n							pubmatic: {\n								bidCpmAdjustment: O\n							},\n							"33across": {\n								bidCpmAdjustment: O\n							},\n							sharethrough: {\n								bidCpmAdjustment: O\n							},\n							triplelift: {\n								bidCpmAdjustment: O\n							}\n						}\n					}))\n				}\n			},\n			H = !1,\n			V = function(e, t, i, n) {\n				window.apstag && window.apstag.init(e.settings || G({\n					pubID: "e32f1423-28bc-43ed-8ab0-5ae6b4449cf8",\n					adServer: "googletag",\n					videoAdServer: "GAM"\n				}, i ? {\n					gdpr: {\n						cmpTimeout: 1e4\n					}\n				} : {}), (function() {\n					H = ! function(e, t) {\n						var i, n;\n						t = t.toUpperCase();\n						var r = null === (n = null === (i = null == e ? void 0 : e[t]) || void 0 === i ? void 0 : i.video) || void 0 === n ? void 0 : n.amazon;\n						return !!r && Math.random() > r\n					}(n, t), e.callback && e.callback()\n				}))\n			},\n			W = function() {\n				! function() {\n					if (!window.__tcfapi) {\n						var e = window.top,\n							t = {};\n						window.__tcfapi = function(i, n, r, o) {\n							var a = "" + Math.random(),\n								s = {\n									__tcfapiCall: {\n										command: i,\n										parameter: o,\n										version: n,\n										callId: a\n									}\n								};\n							t[a] = r, e.postMessage(s, "*")\n						}, window.addEventListener("message", (function(e) {\n							var i = {};\n							try {\n								i = "string" == typeof e.data ? JSON.parse(e.data) : e.data\n							} catch (e) {}\n							var n = i.__tcfapiReturn;\n							n && "function" == typeof t[n.callId] && (t[n.callId](n.returnValue, n.success), t[n.callId] = null)\n						}), !1)\n					}\n				}(), window.pbjs.que.push((function() {\n					window.pbjs.setConfig({\n						consentManagement: {\n							gdpr: {\n								cmpApi: "iab",\n								timeout: 8e3,\n								defaultGdprScope: !0\n							}\n						}\n					})\n				}))\n			},\n			J = function() {\n				! function() {\n					if (!window.__uspapi) {\n						var e = window.top,\n							t = {};\n						window.__uspapi = function(i, n, r) {\n							var o = "" + Math.random(),\n								a = {\n									__uspapiCall: {\n										command: i,\n										version: n,\n										callId: o\n									}\n								};\n							t[o] = r, e.postMessage(a, "*")\n						}, window.addEventListener("message", (function(e) {\n							var i = e && e.data && e.data.__uspapiReturn;\n							i && i.callId && "function" == typeof t[i.callId] && (t[i.callId](i.returnValue, i.success), t[i.callId] = null)\n						}), !1)\n					}\n				}(), window.pbjs.que.push((function() {\n					window.pbjs.setConfig({\n						consentManagement: {\n							usp: {\n								cmpApi: "iab",\n								timeout: 8e3\n							}\n						}\n					})\n				}))\n			};\n\n		function Y(e, t, i, r, o, s, d) {\n			var A = s ? "nope" : t;\n			if (window.pbjs && window.pbjs.que && window.pbjs.getConfig) {\n				var c, l = k().split("?"),\n					u = encodeURIComponent(l[0]),\n					p = r ? K : Q,\n					h = a.getDataAnnotations(),\n					m = 0,\n					g = function() {\n						var r, l, g;\n						if (!(--m > 0)) try {\n							a.dispatchEvent(n.ads.prebidRequested);\n							var f = window.pbjs.adUnits.filter((function(e) {\n								return e.code === p\n							}))[0];\n							if ("undefined" === f) return console.error("Video-ad-unit not found, did you give it the adunit.code=\'video\' value?"), void e.requestAd(A);\n							var v = window.pbjs.adServers.dfp.buildVideoUrl({\n									adUnit: f,\n									params: {\n										iu: I("iu", t),\n										sz: "640x360|640x480",\n										output: "vast",\n										cust_params: i,\n										description_url: u\n									}\n								}),\n								b = window.pbjs.getHighestCpmBids(p),\n								k = void 0;\n							b.length > 0 && (k = b[0]), window.pbjs.markWinningBidAsUsed({\n								adUnitCode: p\n							}), c && (v = v.replace("cust_params=", "cust_params=" + c + "%26")), k && (null === (l = null === (r = null == k ? void 0 : k.meta) || void 0 === r ? void 0 : r.advertiserDomains) || void 0 === l ? void 0 : l.length) > 0 && a.setDataAnnotations({\n								adDomain: k.meta.advertiserDomains.join(",")\n							});\n							var y = !1;\n							if (s) {\n								if (c) {\n									var w = function(e) {\n										var t = decodeURIComponent(e),\n											i = I("amznbid", t);\n										if (!i) return null;\n										var n = j[i];\n										return n ? {\n											bid: n,\n											vast: "null.html?https:\/\/aax.amazon-adsystem.com\/e\/dtb\/vast?b=" + I("amzniid", t) + "&rnd=" + Math.round(1e10 * Math.random()) + "&pp=" + i\n										} : null\n									}(c);\n									w && (!k || !k.videoCacheKey || k.cpm < w.bid) && (k = {\n										cpm: w.bid,\n										vast: w.vast,\n										bidder: "amazon",\n										videoCacheKey: "amazon"\n									})\n								}\n								if (1 !== d && (!k || !k.videoCacheKey || k.cpm < B(o))) {\n									var S = 5;\n									"ninja.io" === (null === (g = null === window || void 0 === window ? void 0 : window.location) || void 0 === g ? void 0 : g.hostname) && (S = function(e) {\n										return "US" === e ? 6.1 : x.includes(e) ? .5 : C.includes(e) ? .15 : T.includes(e) ? .08 : _.includes(e) ? .03 : .02\n									}(o)), k = {\n										cpm: S,\n										vast: "null.html?https:\/\/api.poki.com\/ads\/houseads\/video\/vast" + ("" === $e.gameId ? "" : "?game_id=" + $e.gameId),\n										bidder: "poki",\n										videoCacheKey: "poki"\n									}\n								}\n								if (!k || !k.videoCacheKey) return void a.dispatchEvent(1 === d ? n.ads.video.error : n.ads.completed);\n								switch (k.bidder) {\n									case "onetag":\n										v = "null.html?https:\/\/onetag-sys.com\/invocation\/?key=" + k.videoCacheKey;\n										break;\n									case "rubicon":\n										v = "null.html?https:\/\/prebid-server.rubiconproject.com\/cache?uuid=" + k.videoCacheKey;\n										break;\n									case "spotx":\n										v = "null.html?https:\/\/search.spotxchange.com\/ad\/vast.html?key=" + k.videoCacheKey;\n										break;\n									case "amazon":\n									case "poki":\n										v = k.vast;\n										break;\n									default:\n										v = "null.html?https:\/\/prebid.adnxs.com\/pbc\/v1\/cache?uuid=" + k.videoCacheKey\n								}\n								D({\n									event: "video-ready",\n									size: "640x360v",\n									opportunityId: null == h ? void 0 : h.opportunityId,\n									adUnitPath: null == h ? void 0 : h.adUnitPath,\n									p4d_game_id: $e.gameId,\n									p4d_version_id: $e.versionId,\n									bidder: null == k ? void 0 : k.bidder,\n									bid: null == k ? void 0 : k.cpm\n								}), y = !0, a.setDataAnnotations({\n									p4d_game_id: $e.gameId,\n									p4d_version_id: $e.versionId,\n									bidder: null == k ? void 0 : k.bidder,\n									bid: null == k ? void 0 : k.cpm\n								})\n							}\n							a.setDataAnnotations({\n								vhbOnlyMode: y,\n								adTagUrl: v\n							}), k ? a.setDataAnnotations({\n								prebidBidder: null == k ? void 0 : k.bidder,\n								prebidBid: null == k ? void 0 : k.cpm\n							}) : a.setDataAnnotations({\n								prebidBidder: void 0,\n								prebidBid: void 0\n							}), e.requestAd(v)\n						} catch (t) {\n							e.requestAd(A)\n						}\n					};\n				H && m++, F && m++, H && window.apstag.fetchBids({\n					slots: [{\n						slotID: r ? "Rewarded" : "Midroll",\n						mediaType: "video"\n					}],\n					timeout: 1500\n				}, (function(e) {\n					e.length > 0 && (c = e[0].encodedQsParams), g()\n				})), s && D({\n					event: "video-request",\n					size: "640x360v",\n					opportunityId: null == h ? void 0 : h.opportunityId,\n					adUnitPath: null == h ? void 0 : h.adUnitPath,\n					p4d_game_id: $e.gameId,\n					p4d_version_id: $e.versionId\n				}), F && window.pbjs.que.push((function() {\n					window.pbjs.requestBids({\n						adUnitCodes: [p],\n						bidsBackHandler: function() {\n							g()\n						}\n					})\n				}))\n			} else e.requestAd(A)\n		}\n\n		function $() {\n			var e, t = (null === (e = null === window || void 0 === window ? void 0 : window.location) || void 0 === e ? void 0 : e.hostname) || "";\n			return "yes" === I("poki-ad-server") ? (console.log("DEBUG: Only running Poki-ad-server"), !0) : "localhost" !== t && "game-cdn.poki.com" !== t && !t.endsWith(".poki-gdn.com") && ("ninja.io" === t ? Math.random() <= .5 : "venge.io" === t ? Math.random() <= .05 : "makeitmeme.com" === t)\n		}\n		var ee = function() {\n			function e(e, t) {\n				void 0 === t && (t = {}), this.retries = 0, this.running = !1, this.ima = e, this.siteID = t.siteID || 3, this.country = t.country || "ZZ", this.usePokiAdserver = $(), this.totalRetries = t.totalRetries || d.waterfallRetries || 1, this.timing = t.timing || new c(d.adTiming), a.addEventListener(n.ads.video.error, this.moveThroughWaterfall.bind(this)), a.addEventListener(n.ads.video.loaderError, this.moveThroughWaterfall.bind(this)), a.addEventListener(n.ads.ready, this.timing.stopWaterfallTimer.bind(this.timing)), a.addEventListener(n.ads.started, this.stopWaterfall.bind(this))\n			}\n			return e.prototype.moveThroughWaterfall = function() {\n				if (!1 !== this.running) {\n					var e = this.totalRetries;\n					if (this.timing.stopWaterfallTimer(), this.retries < e) return this.timing.nextWaterfallTimer(), void this.requestAd();\n					this.running = !1, this.timing.resetWaterfallTimerIdx(), a.dispatchEvent(n.ads.error, {\n						message: "No ads",\n						rewardAllowed: !0\n					})\n				}\n			}, e.prototype.cutOffWaterfall = function() {\n				this.ima.tearDown(), this.moveThroughWaterfall()\n			}, e.prototype.buildAdUnitPaths = function(e) {\n				if (r.debug) {\n					var t = "\/21682198607\/debug-video\/";\n					return e === n.ads.position.rewarded ? [t + "debug-video-rewarded"] : e === n.ads.position.preroll ? [t + "debug-video-preroll"] : [t + "debug-video-midroll"]\n				}\n				var i = "desktop",\n					o = "midroll";\n				y() ? i = "mobile" : w() && (i = "tablet"), e === n.ads.position.rewarded && (o = "rewarded");\n				var a = "\/21682198607\/";\n				return tt.GetIsPokiIFrame() ? ["" + a + i + "_ingame_" + o + "_1\/" + this.siteID + "_" + i + "_ingame_" + o + "_1", "" + a + i + "_ingame_" + o + "_2\/" + this.siteID + "_" + i + "_ingame_" + o + "_2"] : [a + "external_" + i + "_video_1\/external_" + i + "_ingame_" + o + "_1", a + "external_" + i + "_video_2\/external_" + i + "_ingame_" + o + "_2"]\n			}, e.prototype.start = function(e, t) {\n				void 0 === e && (e = {}), this.running = !0, this.retries = 0, this.criteria = e, this.timing.resetWaterfallTimerIdx(), this.rewarded = t === n.ads.position.rewarded, this.adUnitPaths = this.buildAdUnitPaths(t), this.requestAd()\n			}, e.prototype.requestAd = function() {\n				this.timing.startWaterfallTimer(this.cutOffWaterfall.bind(this)), this.retries++, this.criteria.waterfall = this.retries;\n				var e = (this.retries - 1) % this.adUnitPaths.length,\n					t = this.adUnitPaths[e],\n					i = "https:\/\/securepubads.g.doubleclick.net\/gampad\/ads?sz=640x360|640x480&iu=" + t + "&ciu_szs&impl=s&gdfp_req=1&env=vp&output=vast&unviewed_position_start=1&url={url}&description_url={descriptionUrl}&correlator={timestamp}";\n				tt.consentString && tt.consentString.length > 0 && (this.criteria.consent_string = tt.consentString);\n				var r = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0) > 970;\n				this.criteria.billboards_fit = r ? "yes" : "no";\n				var o, s, d = function(e) {\n					var t = k().split("?"),\n						i = encodeURIComponent(t[0]);\n					return (e = e.split("{descriptionUrl}").join(i)).split("{timestamp}").join((new Date).getTime().toString())\n				}(i) + (o = this.criteria, s = "", Object.keys(o).forEach((function(e) {\n					if (Object.prototype.hasOwnProperty.call(o, e)) {\n						var t = o[e];\n						Array.isArray(t) && (t = t.join()), s += e + "=" + t + "&"\n					}\n				})), "&cust_params=" + (s = encodeURIComponent(s)) + "&");\n				tt.childDirected && (d += "&tfcd=1"), tt.nonPersonalized && (d += "&npa=1"), a.setDataAnnotations({\n					adUnitPath: t,\n					adTagUrl: d,\n					waterfall: this.retries\n				}), a.dispatchEvent(n.ads.requested), this.usePokiAdserver ? (console.debug("adRequest started with Prebid Video enabled (" + this.retries + "\/" + this.totalRetries + ")"), Y(this.ima, d, this.criteria, this.rewarded, this.country, !0, this.retries)) : 1 === this.retries ? (console.debug("adRequest started with Prebid Video enabled (" + this.retries + "\/" + this.totalRetries + ")"), Y(this.ima, d, this.criteria, this.rewarded, this.country, !1, this.retries)) : (console.debug("adRequest started in plain mode (" + this.retries + "\/" + this.totalRetries + ")"), this.ima.requestAd(d))\n			}, e.prototype.isRunning = function() {\n				return true;\n				\/\/return this.running\n			}, e.prototype.stopWaterfall = function() {\n				this.running = !1, this.timing.stopWaterfallTimer(), this.timing.resetWaterfallTimerIdx()\n			}, e\n		}();\n		const te = ee;\n		var ie = "pokiSdkContainer",\n			ne = "pokiSdkFixed",\n			re = "pokiSdkOverlay",\n			oe = "pokiSdkHidden",\n			ae = "pokiSdkInsideContainer",\n			se = "pokiSdkPauseButton",\n			de = "pokiSdkPauseButtonBG",\n			Ae = "pokiSdkStartAdButton",\n			ce = "pokiSdkProgressBar",\n			le = "pokiSdkProgressContainer",\n			ue = "pokiSdkSpinnerContainer",\n			pe = "pokiSdkVideoContainer",\n			he = "pokiSdkVisible",\n			me = "pokiSDKAdContainer";\n		var ge = function(e, t, i) {\n			if (i || 2 === arguments.length)\n				for (var n, r = 0, o = t.length; r < o; r++) !n && r in t || (n || (n = Array.prototype.slice.call(t, 0, r)), n[r] = t[r]);\n			return e.concat(n || Array.prototype.slice.call(t))\n		};\n		const fe = function() {\n			function e(e) {\n				var t = this;\n				if (this.hideElement = function(e) {\n						e.classList.add(oe), e.classList.remove(he)\n					}, this.showElement = function(e) {\n						e.classList.add(he), e.classList.remove(oe)\n					}, this.progressFaker = new ve((function(e) {\n						return t.updateProgressBar(e)\n					})), this.progressFaker.queueFakeProgress(10, 1e3, n.ads.prebidRequested), this.progressFaker.queueFakeProgress(20, 2e3, n.ads.started), this.createElements(e.wrapper), "undefined" != typeof window && document) {\n					var i = document.createElement("style");\n					i.innerHTML = "\\n.pokiSdkContainer {\\n\\toverflow: hidden;\\n\\tposition: absolute;\\n\\tleft: 0;\\n\\ttop: 0;\\n\\twidth: 100%;\\n\\theight: 100%;\\n\\tz-index: 1000;\\n\\tdisplay: flex;\\n\\talign-items: center;\\n\\tjustify-content: center;\\n}\\n\\n.pokiSdkContainer.pokiSdkFixed {\\n\\tposition: fixed;\\n}\\n\\n.pokiSdkContainer.pokiSdkVisible {\\n\\tdisplay: block;\\n}\\n\\n.pokiSdkContainer.pokiSdkHidden,\\n.pokiSdkSpinnerContainer.pokiSdkHidden {\\n\\tdisplay: none;\\n}\\n\\n.pokiSdkContainer.pokiSdkHidden,\\n.pokiSdkSpinnerContainer {\\n\\tpointer-events: none;\\n}\\n\\n.pokiSdkSpinnerContainer {\\n\\tz-index: 10;\\n\\tposition: absolute;\\n\\ttop: 0;\\n\\tleft: 0;\\n\\twidth: 100%;\\n\\theight: 100%;\\n\\tbackground: url(\'https:\/\/a.poki.com\/images\/thumb_anim_2x.gif\') 50% 50% no-repeat;\\n\\tuser-select: none;\\n}\\n\\n.pokiSdkInsideContainer {\\n\\tbackground: #000;\\n\\tposition: relative;\\n\\tz-index: 1;\\n\\twidth: 100%;\\n\\theight: 100%;\\n\\tdisplay: flex;\\n\\tflex-direction: column;\\n\\n\\topacity: 0;\\n\\t-webkit-transition: opacity 0.5s ease-in-out;\\n\\t-moz-transition: opacity 0.5s ease-in-out;\\n\\t-ms-transition: opacity 0.5s ease-in-out;\\n\\t-o-transition: opacity 0.5s ease-in-out;\\n\\ttransition: opacity 0.5s ease-in-out;\\n}\\n\\n.pokiSdkContainer.pokiSdkVisible .pokiSdkInsideContainer {\\n\\topacity: 1;\\n}\\n\\n.pokiSDKAdContainer, .pokiSdkVideoContainer {\\n\\tposition: absolute;\\n\\twidth: 100%;\\n\\theight: 100%;\\n}\\n\\n.pokiSdkStartAdButton {\\n\\tposition: absolute;\\n\\tz-index: 9999;\\n\\ttop: 0;\\n\\n\\tpadding-top: 10%;\\n\\twidth: 100%;\\n\\theight: 100%;\\n\\ttext-align: center;\\n\\tcolor: #FFF;\\n\\n\\tfont: 700 15pt \'Arial\', sans-serif;\\n\\tfont-weight: bold;\\n\\tletter-spacing: 1px;\\n\\ttransition: 0.1s ease-in-out;\\n\\tline-height: 1em;\\n}\\n\\n.pokiSdkPauseButton {\\n\\tcursor:pointer;\\n    position: absolute;\\n    top: 50%;\\n    left: 50%;\\n    z-index: 1;\\n}\\n\\n.pokiSdkPauseButton:before {\\n\\tcontent: \'\';\\n\\tposition: absolute;\\n\\twidth: 100px;\\n\\theight: 100px;\\n\\tdisplay: block;\\n\\tborder: 2px solid #fff;\\n\\tborder-radius: 50%;\\n\\tuser-select: none;\\n\\tbackground-color: rgba(0, 0, 0, 0.6);\\n\\ttransition: background-color 0.5s ease;\\n\\tanimation: 1s linear infinite pulse;\\n}\\n\\n.pokiSdkPauseButton:after {\\n\\tcontent: \'\';\\n\\tposition: absolute;\\n\\tdisplay: block;\\n\\tbox-sizing: border-box;\\n\\tborder-color: transparent transparent transparent #fff;\\n\\tborder-style: solid;\\n\\tborder-width: 26px 0 26px 40px;\\n\\tpointer-events: none;\\n\\tanimation: 1s linear infinite pulse;\\n\\tleft: 6px;\\n}\\n.pokiSdkPauseButtonBG {\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    display: block;\\n    content: \'\';\\n    background: rgba(0, 43, 80, 0.5);\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.pokiSdkPauseButtonBG:hover{\\n\\tbackground: rgba(0, 43, 80, 0.7);\\n}\\n\\n@keyframes pulse {\\n\\t0% {\\n\\t\\ttransform: translate(-50%, -50%) scale(0.95);\\n\\t}\\n\\t70% {\\n\\t\\ttransform: translate(-50%, -50%) scale(1.1);\\n\\t}\\n\\t100% {\\n\\t\\ttransform: translate(-50%, -50%) scale(0.95);\\n\\t}\\n}\\n\\n.pokiSdkProgressContainer {\\n\\tbackground: #B8C7DD;\\n\\twidth: 100%;\\n\\theight: 5px;\\n\\tposition: absolute;\\n\\tbottom: 0;\\n\\tz-index: 9999;\\n}\\n\\n.pokiSdkProgressBar {\\n\\tposition:relative;\\n\\tbottom:0px;\\n\\tbackground: #FFDC00;\\n\\theight: 100%;\\n\\twidth: 0%;\\n\\ttransition: width 0.5s;\\n\\ttransition-timing-function: linear;\\n}\\n\\n.pokiSdkProgressBar.pokiSdkVisible, .pokiSdkPauseButton.pokiSdkVisible, .pokiSdkStartAdButton.pokiSdkVisible {\\n\\tdisplay: block;\\n\\tpointer-events: auto;\\n}\\n\\n.pokiSdkProgressBar.pokiSdkHidden, .pokiSdkPauseButton.pokiSdkHidden, .pokiSdkStartAdButton.pokiSdkHidden {\\n\\tdisplay: none;\\n\\tpointer-events: none;\\n}\\n", document.head.appendChild(i)\n				}\n			}\n			return e.prototype.updateProgressBar = function(e) {\n				this.progressBar.style.width = e + "%"\n			}, e.prototype.setupEvents = function(e) {\n				this.internalSDK = e\n			}, e.prototype.hide = function() {\n				this.hideElement(this.containerDiv), this.hideElement(this.progressContainer), this.hidePauseButton(), this.hideElement(this.startAdButton), this.containerDiv.classList.remove(re), this.progressBar.style.width = "0%", this.progressFaker.reset()\n			}, e.prototype.hideSpinner = function() {\n				this.hideElement(this.spinnerContainer)\n			}, e.prototype.show = function() {\n				this.containerDiv.classList.add(re), this.showElement(this.containerDiv), this.showElement(this.spinnerContainer), this.showElement(this.progressContainer), this.progressFaker.start()\n			}, e.prototype.getVideoBounds = function() {\n				return this.adContainer.getBoundingClientRect()\n			}, e.prototype.getAdContainer = function() {\n				return this.adContainer\n			}, e.prototype.getVideoContainer = function() {\n				return this.videoContainer\n			}, e.prototype.showPauseButton = function() {\n				this.showElement(this.pauseButton), this.internalSDK && this.pauseButton.addEventListener("click", this.internalSDK.resumeAd.bind(this.internalSDK))\n			}, e.prototype.hidePauseButton = function() {\n				this.hideElement(this.pauseButton), this.internalSDK && this.pauseButton.removeEventListener("click", this.internalSDK.resumeAd.bind(this.internalSDK))\n			}, e.prototype.showStartAdButton = function() {\n				this.showElement(this.startAdButton), this.internalSDK && this.startAdButton.addEventListener("click", this.internalSDK.startAdClicked.bind(this.internalSDK))\n			}, e.prototype.hideStartAdButton = function() {\n				this.hideElement(this.startAdButton), this.internalSDK && this.startAdButton.removeEventListener("click", this.internalSDK.startAdClicked.bind(this.internalSDK))\n			}, e.prototype.createElements = function(e) {\n				var t = this;\n				this.containerDiv = document.createElement("div"), this.insideContainer = document.createElement("div"), this.pauseButton = document.createElement("div"), this.pauseButtonBG = document.createElement("div"), this.startAdButton = document.createElement("div"), this.progressBar = document.createElement("div"), this.progressContainer = document.createElement("div"), this.spinnerContainer = document.createElement("div"), this.adContainer = document.createElement("div"), this.videoContainer = document.createElement("video"), this.adContainer.id = "pokiSDKAdContainer", this.videoContainer.id = "pokiSDKVideoContainer", this.containerDiv.className = ie, this.insideContainer.className = ae, this.pauseButton.className = se, this.pauseButtonBG.className = de, this.pauseButton.appendChild(this.pauseButtonBG), this.startAdButton.className = Ae, this.startAdButton.innerHTML = "Tap anywhere to play ad", this.progressBar.className = ce, this.progressContainer.className = le, this.spinnerContainer.className = ue, this.adContainer.className = me, this.videoContainer.className = pe, this.hide(), this.videoContainer.setAttribute("playsinline", "playsinline"), this.videoContainer.setAttribute("muted", "muted"), this.containerDiv.appendChild(this.insideContainer), this.containerDiv.appendChild(this.spinnerContainer), this.insideContainer.appendChild(this.progressContainer), this.insideContainer.appendChild(this.videoContainer), this.insideContainer.appendChild(this.adContainer), this.containerDiv.appendChild(this.pauseButton), this.containerDiv.appendChild(this.startAdButton), this.progressContainer.appendChild(this.progressBar);\n				var i = e || null,\n					n = function() {\n						if (i || (i = document.body), i)\n							if (i.appendChild(t.containerDiv), i === document.body) t.containerDiv.classList.add(ne);\n							else {\n								var e = window.getComputedStyle(i).position;\n								e && -1 !== ["absolute", "fixed", "relative"].indexOf(e) || (i.style.position = "relative")\n							}\n						else window.requestAnimationFrame(n)\n					};\n				!i || i instanceof HTMLElement || (i = null, console.error("POKI-SDK: wrapper is not a HTMLElement, falling back to document.body")), n()\n			}, e\n		}();\n		var ve = function() {\n				function e(e) {\n					var t = this;\n					this.storedQueue = [], this.progressCallback = e, this.reset(), a.addEventListener(n.ads.video.progress, (function(e) {\n						var i = 100 - t.currentProgress,\n							n = e.currentTime \/ e.duration * i;\n						n < i && t.progressCallback(t.currentProgress + n)\n					})), this.initializeNoProgressFix()\n				}\n				return e.prototype.queueFakeProgress = function(e, t, i) {\n					var n = this;\n					this.storedQueue.push({\n						progressToFake: e,\n						duration: t,\n						stopEvent: i\n					}), a.addEventListener(i, (function() {\n						n.eventWatcher[i] = !0, n.currentProgress = n.startProgress + e, n.startProgress = n.currentProgress, n.progressCallback(n.currentProgress), n.activeQueue.shift(), n.activeQueue.length > 0 ? n.continue() : n.pause()\n					}))\n				}, e.prototype.fakeProgress = function(e, t, i) {\n					this.activeQueue.push({\n						progressToFake: e,\n						duration: t,\n						stopEvent: i\n					}), this.fakeProgressEvents = !0, this.continue()\n				}, e.prototype.start = function() {\n					this.activeQueue.length > 0 || (this.activeQueue = ge([], this.storedQueue, !0), this.active = !0, this.continue())\n				}, e.prototype.continue = function() {\n					if (this.activeQueue.length > 0 && !this.tickInterval) {\n						this.startTime = Date.now();\n						this.tickInterval = window.setInterval(this.tick.bind(this), 50), this.active = !0\n					}\n				}, e.prototype.pause = function() {\n					this.clearInterval()\n				}, e.prototype.tick = function() {\n					var e = this.activeQueue[0],\n						t = Date.now() - this.startTime,\n						i = Math.min(t \/ e.duration, 1);\n					this.currentProgress = this.startProgress + e.progressToFake * i, this.fakeProgressEvents && a.dispatchEvent(n.ads.video.progress, {\n						duration: e.duration \/ 1e3,\n						currentTime: t \/ 1e3\n					}), this.progressCallback(this.currentProgress), (this.eventWatcher[e.stopEvent] || 1 === i) && this.pause()\n				}, e.prototype.clearInterval = function() {\n					this.tickInterval && (clearInterval(this.tickInterval), this.tickInterval = 0)\n				}, e.prototype.initializeNoProgressFix = function() {\n					var e = this;\n					a.addEventListener(n.ads.started, (function(t) {\n						e.progressWatcherTimeout = window.setTimeout((function() {\n							if (e.active) {\n								var i = 100 - e.currentProgress,\n									r = 1e3 * t.duration - 1e3;\n								e.fakeProgress(i, r, n.ads.completed)\n							}\n						}), 1e3)\n					})), a.addEventListener(n.ads.video.progress, (function() {\n						e.progressWatcherTimeout && (clearTimeout(e.progressWatcherTimeout), e.progressWatcherTimeout = 0)\n					}))\n				}, e.prototype.reset = function() {\n					this.eventWatcher = {}, this.startProgress = 0, this.startTime = 0, this.currentProgress = 0, this.activeQueue = [], this.active = !1, this.fakeProgressEvents = !1, this.clearInterval()\n				}, e\n			}(),\n			be = !0,\n			ke = {};\n\n		function ye() {\n			if (document.body && document.body.appendChild) {\n				var e = document.createElement("iframe");\n				if (e.style.display = "none", document.body.appendChild(e), e.contentWindow && (window.pokiKeysChanged = new Map, e.contentWindow.document.open(), e.contentWindow.document.write("<script>\\nconst lsKey = \'poki_lsexpire\';\\nconst lifetime = 1000*60*60*24*30*6;\\n\\nwindow.addEventListener(\'storage\', function(event) {\\n\\ttry {\\n\\t\\tconst key = event.key;\\n\\n\\t\\t\/\/ key is null when localStorage.clear() is called.\\n\\t\\tif (key === null) {\\n\\t\\t\\tlocalStorage.removeItem(lsKey);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (key === lsKey) return;\\n\\n\\t\\tconst updates = JSON.parse(localStorage.getItem(lsKey)) || {};\\n\\n\\t\\t\/\/ newValue is null when localStorage.removeItem() is called.\\n\\t\\tif (event.newValue === null) {\\n\\t\\t\\tdelete updates[key];\\n\\n\\t\\t\\t\/\/ window.parent is the game itself. This code is executed in\\n\\t\\t\\t\/\/ an iframe without src which makes it the same context as it\'s parent\\n\\t\\t\\t\/\/ which makes it save to access the parent\'s properties.\\n\\t\\t\\twindow.parent.pokiKeysChanged.set(key, \'remove\');\\n\\t\\t} else {\\n\\t\\t\\tupdates[key] = Date.now();\\n\\t\\t\\twindow.parent.pokiKeysChanged.set(key, \'set\');\\n\\t\\t}\\n\\t\\tlocalStorage.setItem(lsKey, JSON.stringify(updates));\\n\\t} catch (e) {}\\n});\\n\\nfunction expire() {\\n\\tconst updates = JSON.parse(localStorage.getItem(lsKey)) || {};\\n\\tconst expireBefore = Date.now() - lifetime;\\n\\tvar removed = false;\\n\\n\\tObject.keys(updates).map(function(key) {\\n\\t\\tif (updates[key] < expireBefore) {\\n\\t\\t\\tlocalStorage.removeItem(key);\\n\\t\\t\\tdelete updates[key];\\n\\t\\t\\tremoved = true;\\n\\t\\t}\\n\\t});\\n\\n\\tif (removed) {\\n\\t\\tlocalStorage.setItem(lsKey, JSON.stringify(updates));\\n\\t}\\n}\\n\\ntry {\\n\\texpire();\\n} catch (e) {}\\n<\\\/script>"), e.contentWindow.document.close(), !window.location.hostname.endsWith("poki-gdn.com") && $e.gameId)) {\n					var t = document.createElement("iframe");\n					t.style.display = "none", t.src = "null.html?https:\/\/" + $e.gameId + ".poki-gdn.com\/poki-savegame-store.html", t.onload = function() {\n						if (setInterval((function() {\n								var e = [];\n								window.pokiKeysChanged.forEach((function(t, i) {\n									"set" === t ? e.push([t, i, localStorage.getItem(i)]) : e.push([t, i])\n								})), e.length > 0 && (t.contentWindow && t.contentWindow.postMessage({\n									type: "store",\n									data: e\n								}, "*"), window.pokiKeysChanged.clear())\n							}), 1e3), !localStorage.getItem("pokiMigrated")) {\n							for (var e = [], i = 0; i < localStorage.length; i++) {\n								var n = localStorage.key(i);\n								e.push(["set", n, localStorage.getItem(n)])\n							}\n							e.length > 0 && t.contentWindow && t.contentWindow.postMessage({\n								type: "store",\n								data: e\n							}, "*"), localStorage.setItem("pokiMigrated", "1")\n						}\n					}, document.body.appendChild(t)\n				}\n			} else document.addEventListener("DOMContentLoaded", ye)\n		}\n		var we = ["AT", "BE", "BG", "HR", "CY", "CZ", "DK", "EE", "FI", "FR", "DE", "GR", "HU", "IE", "IT", "LV", "LT", "LU", "MT", "NL", "PL", "PT", "RO", "SK", "SI", "ES", "SE", "IS", "LI", "NO"],\n			Ie = ["US"],\n			Se = ["ZZ"];\n\n		function Ee(e) {\n			return we.includes(e)\n		}\n\n		function xe(e) {\n			return Se.includes(e)\n		}\n		var Ce = function(e, t, i, n) {\n				return new(i || (i = Promise))((function(r, o) {\n					function a(e) {\n						try {\n							d(n.next(e))\n						} catch (e) {\n							o(e)\n						}\n					}\n\n					function s(e) {\n						try {\n							d(n.throw(e))\n						} catch (e) {\n							o(e)\n						}\n					}\n\n					function d(e) {\n						var t;\n						e.done ? r(e.value) : (t = e.value, t instanceof i ? t : new i((function(e) {\n							e(t)\n						}))).then(a, s)\n					}\n					d((n = n.apply(e, t || [])).next())\n				}))\n			},\n			Te = function(e, t) {\n				var i, n, r, o, a = {\n					label: 0,\n					sent: function() {\n						if (1 & r[0]) throw r[1];\n						return r[1]\n					},\n					trys: [],\n					ops: []\n				};\n				return o = {\n					next: s(0),\n					throw: s(1),\n					return: s(2)\n				}, "function" == typeof Symbol && (o[Symbol.iterator] = function() {\n					return this\n				}), o;\n\n				function s(o) {\n					return function(s) {\n						return function(o) {\n							if (i) throw new TypeError("Generator is already executing.");\n							for (; a;) try {\n								if (i = 1, n && (r = 2 & o[0] ? n.return : o[0] ? n.throw || ((r = n.return) && r.call(n), 0) : n.next) && !(r = r.call(n, o[1])).done) return r;\n								switch (n = 0, r && (o = [2 & o[0], r.value]), o[0]) {\n									case 0:\n									case 1:\n										r = o;\n										break;\n									case 4:\n										return a.label++, {\n											value: o[1],\n											done: !1\n										};\n									case 5:\n										a.label++, n = o[1], o = [0];\n										continue;\n									case 7:\n										o = a.ops.pop(), a.trys.pop();\n										continue;\n									default:\n										if (!(r = a.trys, (r = r.length > 0 && r[r.length - 1]) || 6 !== o[0] && 2 !== o[0])) {\n											a = 0;\n											continue\n										}\n										if (3 === o[0] && (!r || o[1] > r[0] && o[1] < r[3])) {\n											a.label = o[1];\n											break\n										}\n										if (6 === o[0] && a.label < r[1]) {\n											a.label = r[1], r = o;\n											break\n										}\n										if (r && a.label < r[2]) {\n											a.label = r[2], a.ops.push(o);\n											break\n										}\n										r[2] && a.ops.pop(), a.trys.pop();\n										continue\n								}\n								o = t.call(e, a)\n							} catch (e) {\n								o = [6, e], n = 0\n							} finally {\n								i = r = 0\n							}\n							if (5 & o[0]) throw o[1];\n							return {\n								value: o[0] ? o[1] : void 0,\n								done: !0\n							}\n						}([o, s])\n					}\n				}\n			};\n		const _e = function() {\n			function e(e) {\n				var t = this;\n				this.bannerTimeout = null, this.allowedToPlayAd = !1, this.runningAd = !1, this.currentWidth = 640, this.currentHeight = 480, this.currentRequestIsMuted = !1, this.volume = 1, this.canWeAutoPlayWithSound = function() {\n					return Ce(t, void 0, void 0, (function() {\n						return Te(this, (function(e) {\n							switch (e.label) {\n								case 0:\n									if (!this.blankVideo) return [2, !1];\n									e.label = 1;\n								case 1:\n									return e.trys.push([1, 3, , 4]), [4, this.blankVideo.play()];\n								case 2:\n									return e.sent(), [2, !0];\n								case 3:\n									return e.sent(), [2, !1];\n								case 4:\n									return [2]\n							}\n						}))\n					}))\n				}, this.videoElement = document.getElementById("pokiSDKVideoContainer"), this.adsManager = null, this.volume = e, this.initAdDisplayContainer(), this.initBlankVideo(), this.initAdsLoader()\n			}\n			return e.prototype.initAdDisplayContainer = function() {\n				this.adDisplayContainer || window.google && (this.adDisplayContainer = new google.ima.AdDisplayContainer(document.getElementById("pokiSDKAdContainer"), this.videoElement))\n			}, e.prototype.initBlankVideo = function() {\n				this.blankVideo = document.createElement("video"), this.blankVideo.setAttribute("playsinline", "playsinline");\n				var e = document.createElement("source");\n				e.src = "data:video\/mp4;base64, AAAAHGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMQAAAAhmcmVlAAAGF21kYXTeBAAAbGliZmFhYyAxLjI4AABCAJMgBDIARwAAArEGBf\/\/rdxF6b3m2Ui3lizYINkj7u94MjY0IC0gY29yZSAxNDIgcjIgOTU2YzhkOCAtIEguMjY0L01QRUctNCBBVkMgY29kZWMgLSBDb3B5bGVmdCAyMDAzLTIwMTQgLSBodHRwOi8vd3d3LnZpZGVvbGFuLm9yZy94MjY0Lmh0bWwgLSBvcHRpb25zOiBjYWJhYz0wIHJlZj0zIGRlYmxvY2s9MTowOjAgYW5hbHlzZT0weDE6MHgxMTEgbWU9aGV4IHN1Ym1lPTcgcHN5PTEgcHN5X3JkPTEuMDA6MC4wMCBtaXhlZF9yZWY9MSBtZV9yYW5nZT0xNiBjaHJvbWFfbWU9MSB0cmVsbGlzPTEgOHg4ZGN0PTAgY3FtPTAgZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0xIGNocm9tYV9xcF9vZmZzZXQ9LTIgdGhyZWFkcz02IGxvb2thaGVhZF90aHJlYWRzPTEgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNlZD0wIGJsdXJheV9jb21wYXQ9MCBjb25zdHJhaW5lZF9pbnRyYT0wIGJmcmFtZXM9MCB3ZWlnaHRwPTAga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCB2YnZfbWF4cmF0ZT03NjggdmJ2X2J1ZnNpemU9MzAwMCBjcmZfbWF4PTAuMCBuYWxfaHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAAFZliIQL8mKAAKvMnJycnJycnJycnXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXiEASZACGQAjgCEASZACGQAjgAAAAAdBmjgX4GSAIQBJkAIZACOAAAAAB0GaVAX4GSAhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGagC\/AySEASZACGQAjgAAAAAZBmqAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZrAL8DJIQBJkAIZACOAAAAABkGa4C\/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmwAvwMkhAEmQAhkAI4AAAAAGQZsgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGbQC\/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm2AvwMkhAEmQAhkAI4AAAAAGQZuAL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGboC\/AySEASZACGQAjgAAAAAZBm8AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZvgL8DJIQBJkAIZACOAAAAABkGaAC\/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmiAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpAL8DJIQBJkAIZACOAAAAABkGaYC\/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmoAvwMkhAEmQAhkAI4AAAAAGQZqgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGawC\/AySEASZACGQAjgAAAAAZBmuAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZsAL8DJIQBJkAIZACOAAAAABkGbIC\/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm0AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZtgL8DJIQBJkAIZACOAAAAABkGbgCvAySEASZACGQAjgCEASZACGQAjgAAAAAZBm6AnwMkhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AAAAhubW9vdgAAAGxtdmhkAAAAAAAAAAAAAAAAAAAD6AAABDcAAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAzB0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAABAAAAAAAAA+kAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAALAAAACQAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAPpAAAAAAABAAAAAAKobWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAB1MAAAdU5VxAAAAAAALWhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABWaWRlb0hhbmRsZXIAAAACU21pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAhNzdGJsAAAAr3N0c2QAAAAAAAAAAQAAAJ9hdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAALAAkABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP\/\/AAAALWF2Y0MBQsAN\/+EAFWdCwA3ZAsTsBEAAAPpAADqYA8UKkgEABWjLg8sgAAAAHHV1aWRraEDyXyRPxbo5pRvPAyPzAAAAAAAAABhzdHRzAAAAAAAAAAEAAAAeAAAD6QAAABRzdHNzAAAAAAAAAAEAAAABAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAABAAAAAQAAAIxzdHN6AAAAAAAAAAAAAAAeAAADDwAAAAsAAAALAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAAiHN0Y28AAAAAAAAAHgAAAEYAAANnAAADewAAA5gAAAO0AAADxwAAA+MAAAP2AAAEEgAABCUAAARBAAAEXQAABHAAAASMAAAEnwAABLsAAATOAAAE6gAABQYAAAUZAAAFNQAABUgAAAVkAAAFdwAABZMAAAWmAAAFwgAABd4AAAXxAAAGDQAABGh0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAABDcAAAAAAAAAAAAAAAEBAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAQkAAADcAABAAAAAAPgbWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAC7gAAAykBVxAAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAADi21pbmYAAAAQc21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAADT3N0YmwAAABnc3RzZAAAAAAAAAABAAAAV21wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAAC7gAAAAAAAM2VzZHMAAAAAA4CAgCIAAgAEgICAFEAVBbjYAAu4AAAADcoFgICAAhGQBoCAgAECAAAAIHN0dHMAAAAAAAAAAgAAADIAAAQAAAAAAQAAAkAAAAFUc3RzYwAAAAAAAAAbAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAwAAAAEAAAABAAAABAAAAAIAAAABAAAABgAAAAEAAAABAAAABwAAAAIAAAABAAAACAAAAAEAAAABAAAACQAAAAIAAAABAAAACgAAAAEAAAABAAAACwAAAAIAAAABAAAADQAAAAEAAAABAAAADgAAAAIAAAABAAAADwAAAAEAAAABAAAAEAAAAAIAAAABAAAAEQAAAAEAAAABAAAAEgAAAAIAAAABAAAAFAAAAAEAAAABAAAAFQAAAAIAAAABAAAAFgAAAAEAAAABAAAAFwAAAAIAAAABAAAAGAAAAAEAAAABAAAAGQAAAAIAAAABAAAAGgAAAAEAAAABAAAAGwAAAAIAAAABAAAAHQAAAAEAAAABAAAAHgAAAAIAAAABAAAAHwAAAAQAAAABAAAA4HN0c3oAAAAAAAAAAAAAADMAAAAaAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAACMc3RjbwAAAAAAAAAfAAAALAAAA1UAAANyAAADhgAAA6IAAAO+AAAD0QAAA+0AAAQAAAAEHAAABC8AAARLAAAEZwAABHoAAASWAAAEqQAABMUAAATYAAAE9AAABRAAAAUjAAAFPwAABVIAAAVuAAAFgQAABZ0AAAWwAAAFzAAABegAAAX7AAAGFwAAAGJ1ZHRhAAAAWm1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALWlsc3QAAAAlqXRvbwAAAB1kYXRhAAAAAQAAAABMYXZmNTUuMzMuMTAw", this.blankVideo.appendChild(e)\n			}, e.prototype.initAdsLoader = function() {\n				var e = this;\n				this.adsLoader || window.google && (this.adsLoader = new google.ima.AdsLoader(this.adDisplayContainer), this.adsLoader.getSettings().setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.INSECURE), this.adsLoader.getSettings().setDisableCustomPlaybackForIOS10Plus(!0), this.adsLoader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, this.onAdsManagerLoaded, !1, this), this.adsLoader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdLoaderError, !1, this), this.videoElement.addEventListener("onended", (function() {\n					return e.adsLoader.contentComplete()\n				})))\n			}, e.prototype.requestAd = function(e) {\n				return Ce(this, void 0, void 0, (function() {\n					var t;\n					this.runningAd = true;\n					return this.runningAd\n					return Te(this, (function(i) {\n						switch (i.label) {\n							case 0:\n								return this.runningAd ? [2] : (this.runningAd = !0, this.adDisplayContainer.initialize(), this.videoElement.src = "", (t = new google.ima.AdsRequest).adTagUrl = e, t.linearAdSlotWidth = this.currentWidth, t.linearAdSlotHeight = this.currentHeight, t.nonLinearAdSlotWidth = this.currentWidth, t.nonLinearAdSlotHeight = this.currentHeight, t.forceNonLinearFullSlot = !0, [4, this.canWeAutoPlayWithSound()]);\n							case 1:\n								return i.sent() ? (t.setAdWillPlayMuted(!1), this.currentRequestIsMuted = !1) : (t.setAdWillPlayMuted(!0), this.currentRequestIsMuted = !0), this.allowedToPlayAd = !0, this.adsLoader.requestAds(t), [2]\n						}\n					}))\n				}))\n			}, e.prototype.resize = function(e, t, i) {\n				void 0 === i && (i = google.ima.ViewMode.NORMAL), this.currentWidth = e, this.currentHeight = t, this.adsManager && this.adsManager.resize(e, t, i)\n			}, e.prototype.onAdsManagerLoaded = function(e) {\n				var t = new google.ima.AdsRenderingSettings;\n				t.enablePreloading = !0, t.restoreCustomPlaybackStateOnAdBreakComplete = !0, t.mimeTypes = S() || y() || w() ? ["video\/mp4"] : ["video\/mp4", "video\/webm", "video\/ogg"], t.loadVideoTimeout = 8e3, this.adsManager = e.getAdsManager(this.videoElement, t), this.adsManager.setVolume(Math.max(0, Math.min(1, this.volume))), this.currentRequestIsMuted && this.adsManager.setVolume(0), this.allowedToPlayAd ? (this.attachAdEvents(), a.dispatchEvent(n.ads.ready)) : this.tearDown()\n			}, e.prototype.setVolume = function(e) {\n				this.volume = e, this.adsManager && this.adsManager.setVolume(Math.max(0, Math.min(1, this.volume)))\n			}, e.prototype.startPlayback = function() {\n				try {\n					this.adsManager.init(this.currentWidth, this.currentHeight, google.ima.ViewMode.NORMAL), this.adsManager.start()\n				} catch (e) {\n					this.videoElement.play()\n				}\n			}, e.prototype.startIOSPlayback = function() {\n				this.adsManager.start()\n			}, e.prototype.stopPlayback = function() {\n				a.dispatchEvent(n.ads.stopped), this.tearDown()\n			}, e.prototype.resumeAd = function() {\n				a.dispatchEvent(n.ads.video.resumed), this.adsManager && this.adsManager.resume()\n			}, e.prototype.tearDown = function() {\n				this.adsManager && (this.adsManager.stop(), this.adsManager.destroy(), this.adsManager = null), null !== this.bannerTimeout && (clearTimeout(this.bannerTimeout), this.bannerTimeout = null), this.adsLoader && (this.adsLoader.contentComplete(), this.adsLoader.destroy(), this.adsLoader = null, this.initAdsLoader()), this.runningAd = !1\n			}, e.prototype.attachAdEvents = function() {\n				var e = this,\n					t = google.ima.AdEvent.Type;\n				this.adsManager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError, !1, this), [t.AD_PROGRESS, t.ALL_ADS_COMPLETED, t.CLICK, t.COMPLETE, t.IMPRESSION, t.PAUSED, t.SKIPPED, t.STARTED, t.USER_CLOSE, t.AD_BUFFERING].forEach((function(t) {\n					e.adsManager.addEventListener(t, e.onAdEvent, !1, e)\n				}))\n			}, e.prototype.onAdEvent = function(e) {\n				var t = this,\n					i = e.getAd();\n				switch (e.type) {\n					case google.ima.AdEvent.Type.AD_PROGRESS:\n						a.dispatchEvent(n.ads.video.progress, e.getAdData());\n						break;\n					case google.ima.AdEvent.Type.STARTED:\n						e.remainingTime = this.adsManager.getRemainingTime(), e.remainingTime <= 0 && (e.remainingTime = 15), i.isLinear() || (this.bannerTimeout = window.setTimeout((function() {\n							a.dispatchEvent(n.ads.completed, {\n								rewardAllowed: !!e.rewardAllowed\n							}), t.tearDown()\n						}), 1e3 * (e.remainingTime + 1))), a.setDataAnnotations({\n							creativeId: i.getCreativeId()\n						}), a.dispatchEvent(n.ads.started, {\n							duration: i.getDuration()\n						});\n						break;\n					case google.ima.AdEvent.Type.COMPLETE:\n						a.dispatchEvent(n.ads.completed, {\n							rewardAllowed: !0\n						}), this.tearDown();\n						break;\n					case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:\n					case google.ima.AdEvent.Type.USER_CLOSE:\n						this.tearDown();\n						break;\n					case google.ima.AdEvent.Type.PAUSED:\n						this.adsManager.pause(), a.dispatchEvent(n.ads.video.paused);\n						break;\n					case google.ima.AdEvent.Type.AD_BUFFERING:\n						a.dispatchEvent(n.ads.video.buffering);\n						break;\n					case google.ima.AdEvent.Type.CLICK:\n						a.dispatchEvent(n.ads.video.clicked);\n						break;\n					case google.ima.AdEvent.Type.SKIPPED:\n						a.dispatchEvent(n.ads.skipped), a.dispatchEvent(n.ads.completed, {\n							rewardAllowed: !0\n						}), document.activeElement && document.activeElement.blur();\n						break;\n					case google.ima.AdEvent.Type.IMPRESSION:\n						a.dispatchEvent(n.ads.impression)\n				}\n			}, e.prototype.onAdLoaderError = function(e) {\n				this.tearDown();\n				var t = e.getError && e.getError().toString() || "Unknown";\n				a.dispatchEvent(n.ads.video.loaderError, {\n					message: t\n				})\n			}, e.prototype.onAdError = function(e) {\n				this.tearDown();\n				var t = e.getError && e.getError().toString() || "Unknown";\n				a.dispatchEvent(n.ads.video.error, {\n					message: t\n				})\n			}, e.prototype.muteAd = function() {\n				void 0 !== this.adsManager && null != this.adsManager && this.adsManager.setVolume(0)\n			}, e.prototype.isAdRunning = function() {\n				return this.runningAd\n			}, e\n		}();\n		const Pe = function(e) {\n			return new Promise((function(t, i) {\n				var n = document.createElement("script");\n				n.type = "text\/javascript", n.async = !0, n.src = e;\n				var r = function() {\n					n.readyState && "loaded" !== n.readyState && "complete" !== n.readyState || (t(), n.onload = null, n.onreadystatechange = null)\n				};\n				n.onload = r, n.onreadystatechange = r, n.onerror = i, document.head.appendChild(n)\n			}))\n		};\n		var Be = function(e, t, i, n) {\n				return new(i || (i = Promise))((function(r, o) {\n					function a(e) {\n						try {\n							d(n.next(e))\n						} catch (e) {\n							o(e)\n						}\n					}\n\n					function s(e) {\n						try {\n							d(n.throw(e))\n						} catch (e) {\n							o(e)\n						}\n					}\n\n					function d(e) {\n						var t;\n						e.done ? r(e.value) : (t = e.value, t instanceof i ? t : new i((function(e) {\n							e(t)\n						}))).then(a, s)\n					}\n					d((n = n.apply(e, t || [])).next())\n				}))\n			},\n			De = function(e, t) {\n				var i, n, r, o, a = {\n					label: 0,\n					sent: function() {\n						if (1 & r[0]) throw r[1];\n						return r[1]\n					},\n					trys: [],\n					ops: []\n				};\n				return o = {\n					next: s(0),\n					throw: s(1),\n					return: s(2)\n				}, "function" == typeof Symbol && (o[Symbol.iterator] = function() {\n					return this\n				}), o;\n\n				function s(o) {\n					return function(s) {\n						return function(o) {\n							if (i) throw new TypeError("Generator is already executing.");\n							for (; a;) try {\n								if (i = 1, n && (r = 2 & o[0] ? n.return : o[0] ? n.throw || ((r = n.return) && r.call(n), 0) : n.next) && !(r = r.call(n, o[1])).done) return r;\n								switch (n = 0, r && (o = [2 & o[0], r.value]), o[0]) {\n									case 0:\n									case 1:\n										r = o;\n										break;\n									case 4:\n										return a.label++, {\n											value: o[1],\n											done: !1\n										};\n									case 5:\n										a.label++, n = o[1], o = [0];\n										continue;\n									case 7:\n										o = a.ops.pop(), a.trys.pop();\n										continue;\n									default:\n										if (!(r = a.trys, (r = r.length > 0 && r[r.length - 1]) || 6 !== o[0] && 2 !== o[0])) {\n											a = 0;\n											continue\n										}\n										if (3 === o[0] && (!r || o[1] > r[0] && o[1] < r[3])) {\n											a.label = o[1];\n											break\n										}\n										if (6 === o[0] && a.label < r[1]) {\n											a.label = r[1], r = o;\n											break\n										}\n										if (r && a.label < r[2]) {\n											a.label = r[2], a.ops.push(o);\n											break\n										}\n										r[2] && a.ops.pop(), a.trys.pop();\n										continue\n								}\n								o = t.call(e, a)\n							} catch (e) {\n								o = [6, e], n = 0\n							} finally {\n								i = r = 0\n							}\n							if (5 & o[0]) throw o[1];\n							return {\n								value: o[0] ? o[1] : void 0,\n								done: !0\n							}\n						}([o, s])\n					}\n				}\n			};\n		const je = function() {\n			var e = window.location.pathname;\n			"\/" !== e[0] && (e = "\/" + e);\n			var t = encodeURIComponent(window.location.protocol + "\/\/" + window.location.host + e + window.location.search),\n				i = encodeURIComponent(document.referrer);\n			return fetch("null.html?https:\/\/devs-api.poki.com\/gameinfo\/@sdk?href=" + t + "&referrer=" + i, {\n				method: "GET",\n				headers: {\n					"Content-Type": "text\/plain"\n				}\n			}).then((function(e) {\n				return Be(void 0, void 0, void 0, (function() {\n					var t;\n					return De(this, (function(i) {\n						switch (i.label) {\n							case 0:\n								return e.status >= 200 && e.status < 400 ? [4, e.json()] : [3, 2];\n							case 1:\n								return (t = i.sent()).game_id ? [2, {\n									gameId: t.game_id,\n									adTiming: {\n										preroll: t.ad_settings.preroll,\n										timePerTry: t.ad_settings.time_per_try,\n										timeBetweenAds: t.ad_settings.time_between_ads,\n										startAdsAfter: t.ad_settings.start_ads_after\n									}\n								}] : [2, void 0];\n							case 2:\n								throw e\n						}\n					}))\n				}))\n			})).catch((function(e) {\n				return function(e) {\n					return Be(this, void 0, void 0, (function() {\n						var t, i, n, r, o, a, s, d, A, c, l, u;\n						return De(this, (function(p) {\n							switch (p.label) {\n								case 0:\n									return p.trys.push([0, 3, , 4]), "\/" !== (t = window.location.pathname)[0] && (t = "\/" + t), r = (n = JSON).stringify, c = {\n										c: "sdk-p4d-error",\n										ve: 7\n									}, l = {\n										k: "error"\n									}, a = (o = JSON).stringify, u = {\n										status: e.status\n									}, (s = e.json) ? [4, e.json()] : [3, 2];\n								case 1:\n									s = p.sent(), p.label = 2;\n								case 2:\n									if (i = r.apply(n, [(c.d = [(l.v = a.apply(o, [(u.json = s, u.body = JSON.stringify({\n											href: window.location.protocol + "\/\/" + window.location.host + t + window.location.search\n										}), u.name = e.name, u.message = e.message, u)]), l)], c)]), d = "null.html?https:\/\/t.poki.io\/l", navigator.sendBeacon) navigator.sendBeacon(d, i);\n									else try {\n										(A = new XMLHttpRequest).open("POST", d, !0), A.send(i)\n									} catch (e) {}\n									return [3, 4];\n								case 3:\n									return p.sent(), [3, 4];\n								case 4:\n									return [2]\n							}\n						}))\n					}))\n				}(e)\n			}))\n		};\n		var ze = function(e, t, i, n) {\n				return new(i || (i = Promise))((function(r, o) {\n					function a(e) {\n						try {\n							d(n.next(e))\n						} catch (e) {\n							o(e)\n						}\n					}\n\n					function s(e) {\n						try {\n							d(n.throw(e))\n						} catch (e) {\n							o(e)\n						}\n					}\n\n					function d(e) {\n						var t;\n						e.done ? r(e.value) : (t = e.value, t instanceof i ? t : new i((function(e) {\n							e(t)\n						}))).then(a, s)\n					}\n					d((n = n.apply(e, t || [])).next())\n				}))\n			},\n			Me = function(e, t) {\n				var i, n, r, o, a = {\n					label: 0,\n					sent: function() {\n						if (1 & r[0]) throw r[1];\n						return r[1]\n					},\n					trys: [],\n					ops: []\n				};\n				return o = {\n					next: s(0),\n					throw: s(1),\n					return: s(2)\n				}, "function" == typeof Symbol && (o[Symbol.iterator] = function() {\n					return this\n				}), o;\n\n				function s(o) {\n					return function(s) {\n						return function(o) {\n							if (i) throw new TypeError("Generator is already executing.");\n							for (; a;) try {\n								if (i = 1, n && (r = 2 & o[0] ? n.return : o[0] ? n.throw || ((r = n.return) && r.call(n), 0) : n.next) && !(r = r.call(n, o[1])).done) return r;\n								switch (n = 0, r && (o = [2 & o[0], r.value]), o[0]) {\n									case 0:\n									case 1:\n										r = o;\n										break;\n									case 4:\n										return a.label++, {\n											value: o[1],\n											done: !1\n										};\n									case 5:\n										a.label++, n = o[1], o = [0];\n										continue;\n									case 7:\n										o = a.ops.pop(), a.trys.pop();\n										continue;\n									default:\n										if (!(r = a.trys, (r = r.length > 0 && r[r.length - 1]) || 6 !== o[0] && 2 !== o[0])) {\n											a = 0;\n											continue\n										}\n										if (3 === o[0] && (!r || o[1] > r[0] && o[1] < r[3])) {\n											a.label = o[1];\n											break\n										}\n										if (6 === o[0] && a.label < r[1]) {\n											a.label = r[1], r = o;\n											break\n										}\n										if (r && a.label < r[2]) {\n											a.label = r[2], a.ops.push(o);\n											break\n										}\n										r[2] && a.ops.pop(), a.trys.pop();\n										continue\n								}\n								o = t.call(e, a)\n							} catch (e) {\n								o = [6, e], n = 0\n							} finally {\n								i = r = 0\n							}\n							if (5 & o[0]) throw o[1];\n							return {\n								value: o[0] ? o[1] : void 0,\n								done: !0\n							}\n						}([o, s])\n					}\n				}\n			};\n\n		function Re() {\n			return ze(this, void 0, Promise, (function() {\n				var e, t, i, n;\n				return Me(this, (function(r) {\n					switch (r.label) {\n						case 0:\n							return r.trys.push([0, 3, , 4]), [4, fetch("null.html?https:\/\/geo.poki.io\/", {\n								method: "GET",\n								headers: {\n									"Content-Type": "text\/plain"\n								}\n							})];\n						case 1:\n							return [4, r.sent().json()];\n						case 2:\n							return e = r.sent(), t = e.ISO, i = e.ccpaApplies, [2, {\n								ISO: t,\n								ccpaApplies: i\n							}];\n						case 3:\n							return n = r.sent(), console.error(n), [2, {\n								ISO: "ZZ",\n								ccpaApplies: !1\n							}];\n						case 4:\n							return [2]\n					}\n				}))\n			}))\n		}\n		var Le = function(e, t, i, n) {\n				return new(i || (i = Promise))((function(r, o) {\n					function a(e) {\n						try {\n							d(n.next(e))\n						} catch (e) {\n							o(e)\n						}\n					}\n\n					function s(e) {\n						try {\n							d(n.throw(e))\n						} catch (e) {\n							o(e)\n						}\n					}\n\n					function d(e) {\n						var t;\n						e.done ? r(e.value) : (t = e.value, t instanceof i ? t : new i((function(e) {\n							e(t)\n						}))).then(a, s)\n					}\n					d((n = n.apply(e, t || [])).next())\n				}))\n			},\n			Oe = function(e, t) {\n				var i, n, r, o, a = {\n					label: 0,\n					sent: function() {\n						if (1 & r[0]) throw r[1];\n						return r[1]\n					},\n					trys: [],\n					ops: []\n				};\n				return o = {\n					next: s(0),\n					throw: s(1),\n					return: s(2)\n				}, "function" == typeof Symbol && (o[Symbol.iterator] = function() {\n					return this\n				}), o;\n\n				function s(o) {\n					return function(s) {\n						return function(o) {\n							if (i) throw new TypeError("Generator is already executing.");\n							for (; a;) try {\n								if (i = 1, n && (r = 2 & o[0] ? n.return : o[0] ? n.throw || ((r = n.return) && r.call(n), 0) : n.next) && !(r = r.call(n, o[1])).done) return r;\n								switch (n = 0, r && (o = [2 & o[0], r.value]), o[0]) {\n									case 0:\n									case 1:\n										r = o;\n										break;\n									case 4:\n										return a.label++, {\n											value: o[1],\n											done: !1\n										};\n									case 5:\n										a.label++, n = o[1], o = [0];\n										continue;\n									case 7:\n										o = a.ops.pop(), a.trys.pop();\n										continue;\n									default:\n										if (!(r = a.trys, (r = r.length > 0 && r[r.length - 1]) || 6 !== o[0] && 2 !== o[0])) {\n											a = 0;\n											continue\n										}\n										if (3 === o[0] && (!r || o[1] > r[0] && o[1] < r[3])) {\n											a.label = o[1];\n											break\n										}\n										if (6 === o[0] && a.label < r[1]) {\n											a.label = r[1], r = o;\n											break\n										}\n										if (r && a.label < r[2]) {\n											a.label = r[2], a.ops.push(o);\n											break\n										}\n										r[2] && a.ops.pop(), a.trys.pop();\n										continue\n								}\n								o = t.call(e, a)\n							} catch (e) {\n								o = [6, e], n = 0\n							} finally {\n								i = r = 0\n							}\n							if (5 & o[0]) throw o[1];\n							return {\n								value: o[0] ? o[1] : void 0,\n								done: !0\n							}\n						}([o, s])\n					}\n				}\n			};\n\n		function Ge() {\n			var e, t;\n			return Le(this, void 0, Promise, (function() {\n				var i, n, r, o, a;\n				return Oe(this, (function(s) {\n					switch (s.label) {\n						case 0:\n							if ("undefined" == typeof window || "test" === (null === (t = null === (e = null === window || void 0 === window ? void 0 : window.process) || void 0 === e ? void 0 : e.env) || void 0 === t ? void 0 : t.NODE_ENV)) return [2, {\n								blocklist: [],\n								countryExclusion: [],\n								bidderLimitation: {}\n							}];\n							s.label = 1;\n						case 1:\n							return s.trys.push([1, 4, , 5]), [4, fetch("null.html?https:\/\/api.poki.com\/ads\/settings", {\n								method: "GET",\n								headers: {\n									"Content-Type": "application\/json"\n								}\n							})];\n						case 2:\n							return [4, s.sent().json()];\n						case 3:\n							return i = s.sent(), n = i.blocklist, r = i.country_exclusion, o = i.bidder_limitation, [2, {\n								blocklist: (null == n ? void 0 : n.split(\/[\\r\\n]+\/)) || [],\n								countryExclusion: (r.split(",") || []).map((function(e) {\n									return e.toUpperCase()\n								})),\n								bidderLimitation: JSON.parse(o || "{}")\n							}];\n						case 4:\n							return a = s.sent(), console.error(a), [2, {\n								blocklist: [],\n								countryExclusion: [],\n								bidderLimitation: {}\n							}];\n						case 5:\n							return [2]\n					}\n				}))\n			}))\n		}\n		var Ue = function(e, t, i, n) {\n				return new(i || (i = Promise))((function(r, o) {\n					function a(e) {\n						try {\n							d(n.next(e))\n						} catch (e) {\n							o(e)\n						}\n					}\n\n					function s(e) {\n						try {\n							d(n.throw(e))\n						} catch (e) {\n							o(e)\n						}\n					}\n\n					function d(e) {\n						var t;\n						e.done ? r(e.value) : (t = e.value, t instanceof i ? t : new i((function(e) {\n							e(t)\n						}))).then(a, s)\n					}\n					d((n = n.apply(e, t || [])).next())\n				}))\n			},\n			Ze = function(e, t) {\n				var i, n, r, o, a = {\n					label: 0,\n					sent: function() {\n						if (1 & r[0]) throw r[1];\n						return r[1]\n					},\n					trys: [],\n					ops: []\n				};\n				return o = {\n					next: s(0),\n					throw: s(1),\n					return: s(2)\n				}, "function" == typeof Symbol && (o[Symbol.iterator] = function() {\n					return this\n				}), o;\n\n				function s(o) {\n					return function(s) {\n						return function(o) {\n							if (i) throw new TypeError("Generator is already executing.");\n							for (; a;) try {\n								if (i = 1, n && (r = 2 & o[0] ? n.return : o[0] ? n.throw || ((r = n.return) && r.call(n), 0) : n.next) && !(r = r.call(n, o[1])).done) return r;\n								switch (n = 0, r && (o = [2 & o[0], r.value]), o[0]) {\n									case 0:\n									case 1:\n										r = o;\n										break;\n									case 4:\n										return a.label++, {\n											value: o[1],\n											done: !1\n										};\n									case 5:\n										a.label++, n = o[1], o = [0];\n										continue;\n									case 7:\n										o = a.ops.pop(), a.trys.pop();\n										continue;\n									default:\n										if (!(r = a.trys, (r = r.length > 0 && r[r.length - 1]) || 6 !== o[0] && 2 !== o[0])) {\n											a = 0;\n											continue\n										}\n										if (3 === o[0] && (!r || o[1] > r[0] && o[1] < r[3])) {\n											a.label = o[1];\n											break\n										}\n										if (6 === o[0] && a.label < r[1]) {\n											a.label = r[1], r = o;\n											break\n										}\n										if (r && a.label < r[2]) {\n											a.label = r[2], a.ops.push(o);\n											break\n										}\n										r[2] && a.ops.pop(), a.trys.pop();\n										continue\n								}\n								o = t.call(e, a)\n							} catch (e) {\n								o = [6, e], n = 0\n							} finally {\n								i = r = 0\n							}\n							if (5 & o[0]) throw o[1];\n							return {\n								value: o[0] ? o[1] : void 0,\n								done: !0\n							}\n						}([o, s])\n					}\n				}\n			},\n			qe = !1,\n			Ke = function() {\n				return Ue(void 0, void 0, void 0, (function() {\n					var e, t, i;\n					return Ze(this, (function(n) {\n						switch (n.label) {\n							case 0:\n								if (qe) return [2];\n								n.label = 1;\n							case 1:\n								return n.trys.push([1, 4, , 5]), [4, fetch(".\/touchControllerConfig.json")];\n							case 2:\n								return [4, n.sent().json()];\n							case 3:\n								return (e = n.sent()) && ((t = document.createElement("script")).src = "\/\/game-cdn.poki.com\/scripts\/touchOverlayController.js", t.onload = function() {\n									new window.OverlayController(document.body, e)\n								}, document.head.appendChild(t), qe = !0), [3, 5];\n							case 4:\n								return i = n.sent(), console.log(i), [3, 5];\n							case 5:\n								return [2]\n						}\n					}))\n				}))\n			};\n		const Qe = function() {\n			for (var e = Math.floor(Date.now() \/ 1e3), t = "", i = 0; i < 4; i++) t = String.fromCharCode(255 & e) + t, e >>= 8;\n			if (window.crypto && crypto.getRandomValues && Uint32Array) {\n				var n = new Uint32Array(12);\n				crypto.getRandomValues(n);\n				for (i = 0; i < 12; i++) t += String.fromCharCode(255 & n[i])\n			} else\n				for (i = 0; i < 12; i++) t += String.fromCharCode(Math.floor(256 * Math.random()));\n			return btoa(t).replace(\/\\+\/g, "-").replace(\/\\\/\/g, "_").replace(\/=\/g, "")\n		};\n		var Ne = function() {\n			function e() {\n				this.slotMap = new Map\n			}\n			return e.prototype.waitUntilReady = function(e) {\n				window.googletag.cmd.push((function() {\n					tt.prebidAvailable ? window.pbjs.que.push((function() {\n						e()\n					})) : e()\n				}))\n			}, e.prototype.enforceChildSafety = function() {\n				googletag.cmd.push((function() {\n					googletag.pubads().setPrivacySettings({\n						underAgeOfConsent: !0,\n						childDirectedTreatment: !0,\n						restrictDataProcessing: !0\n					})\n				}))\n			}, e.prototype.setupSlotRenderEndedListener = function() {\n				var e = this;\n				this.waitUntilReady((function() {\n					window.googletag.pubads().addEventListener("slotRenderEnded", (function(t) {\n						var i, r, o, a, s = t.slot.getSlotElementId(),\n							d = e.slotMap.get(s);\n						if (d && d.gptSlot) {\n							var A = t.slot || {},\n								c = (null === (i = A.getResponseInformation) || void 0 === i ? void 0 : i.call(A)) || {},\n								l = c.isBackfill,\n								u = c.lineItemId,\n								p = c.campaignId,\n								h = function(e) {\n									if (!e || "function" != typeof e.indexOf) return null;\n									if (-1 !== e.indexOf("amazon-adsystem.com\/aax2\/apstag")) return null;\n									var t = new RegExp(\'(?:(?:pbjs\\\\.renderAd\\\\(document,|adId:*|hb_adid":\\\\[)|(?:pbadid=)|(?:adId=))[\\\'"](.*?)["\\\']\', "gi"),\n										i = e.replace(\/ \/g, ""),\n										n = t.exec(i);\n									return n && n[1] || null\n								}(null === (o = (r = A).getHtml) || void 0 === o ? void 0 : o.call(r)),\n								m = !!h,\n								g = d.pbjsTargetting || {},\n								f = g.hb_bidder,\n								v = g.hb_adomain,\n								b = function(e) {\n									var t, i = {\n										cpm: 0\n									};\n									if (void 0 === window.pbjs || !tt.prebidAvailable) return i;\n									var n = window.pbjs.getAllWinningBids() || [];\n									return ((null === (t = window.pbjs.getBidResponsesForAdUnitCode(e)) || void 0 === t ? void 0 : t.bids) || []).forEach((function(e) {\n										!n.find((function(t) {\n											return t.adId === e.adId\n										})) && e.cpm > i.cpm && (i = e)\n									})), i\n								}(d.adUnitPath),\n								k = t.isEmpty,\n								y = parseFloat(g.hb_pb);\n							isNaN(y) && (y = void 0), at.track(n.tracking.ads.display.impression, {\n								size: d.size,\n								opportunityId: d.opportunityId,\n								duringGameplay: null === (a = d.duringGameplayFn) || void 0 === a ? void 0 : a.call(d),\n								adUnitPath: d.adUnitPath,\n								prebidBid: y,\n								prebidBidder: f,\n								prebidWon: m,\n								prebidSecondBid: b.cpm > 0 ? b.cpm : void 0,\n								prebidSecondBidder: b.bidder,\n								dfpIsBackfill: l,\n								dfpLineItemId: u,\n								dfpCampaignId: p,\n								isEmpty: k,\n								adDomain: v\n							})\n						}\n					}))\n				}))\n			}, e.prototype.validateDisplaySettings = function(e) {\n				return !!(y() || w() || ["970x250", "300x250", "728x90", "160x600", "320x50"].includes(e)) && !((y() || w()) && !["320x50"].includes(e))\n			}, e.prototype.getDisplaySlotConfig = function(e) {\n				var t = e.split("x").map((function(e) {\n						return parseInt(e, 10)\n					})),\n					i = "\/21682198607\/debug-display\/debug-display-" + e,\n					n = "desktop";\n				y() && (n = "mobile"), w() && (n = "tablet");\n				var o = parseInt(I("site_id"), 10) || 0;\n				return r.debug || (i = tt.GetIsPokiIFrame() ? "\/21682198607\/" + n + "_ingame_" + e + "\/" + o + "_" + n + "_ingame_" + e : "\/21682198607\/external_" + n + "_display_ingame\/external_" + n + "_ingame_" + e), {\n					id: "poki-" + Qe(),\n					adUnitPath: i,\n					size: e,\n					width: t[0],\n					height: t[1],\n					refresh: !1\n				}\n			}, e.prototype.renderIGDAd = function(e, t, i, n, r) {\n				var o = this,\n					a = this.getIGDSlotID(e);\n				a && this.slotMap.get(a) && (console.error("displayAd called with a container that already contains an ad"), this.clearIGDAd(e));\n				var s = this.getDisplaySlotConfig(t);\n				this.slotMap.set(s.id, s), s.opportunityId = n, s.duringGameplayFn = r;\n				var d = document.createElement("div");\n				d.id = s.id, d.className = "poki-ad-slot", d.style.width = s.width + "px", d.style.height = s.height + "px", d.style.overflow = "hidden", d.style.position = "relative", d.setAttribute("data-poki-ad-size", s.size), e.appendChild(d), e.setAttribute("data-poki-ad-id", s.id), s.intersectionObserver = new window.IntersectionObserver((function(e) {\n					var t;\n					e[0].isIntersecting && (null === (t = s.intersectionObserver) || void 0 === t || t.disconnect(), o.waitUntilReady((function() {\n						var e = o.slotMap.get(s.id);\n						e && e.opportunityId === n && (o.setupGPT(s, i), o.requestAd(s))\n					})))\n				}), {\n					threshold: 1\n				}), s.intersectionObserver.observe(d)\n			}, e.prototype.setupGPT = function(e, t) {\n				var i;\n				e.gptSlot = window.googletag.defineSlot(e.adUnitPath, [e.width, e.height], e.id).addService(window.googletag.pubads()), window.googletag.enableServices(), null === (i = e.gptSlot) || void 0 === i || i.clearTargeting(), Object.keys(t).forEach((function(i) {\n					var n;\n					null === (n = e.gptSlot) || void 0 === n || n.setTargeting(i, t[i])\n				}))\n			}, e.prototype.requestAd = function(e) {\n				var t;\n				at.track(n.tracking.ads.display.requested, {\n					size: e.size,\n					opportunityId: e.opportunityId,\n					adUnitPath: e.adUnitPath,\n					refresh: e.refresh,\n					duringGameplay: null === (t = e.duringGameplayFn) || void 0 === t ? void 0 : t.call(e)\n				});\n				var i = 0,\n					r = function() {\n						--i > 0 || (window.apstag && window.apstag.setDisplayBids(), tt.prebidAvailable && (window.pbjs.setTargetingForGPTAsync([e.adUnitPath]), e.pbjsTargetting = window.pbjs.getAdserverTargetingForAdUnitCode([e.adUnitPath])), window.googletag.display(e.id))\n					};\n				window.apstag && i++, tt.prebidAvailable && i++, window.apstag && window.apstag.fetchBids({\n					slots: [{\n						slotName: e.adUnitPath,\n						slotID: e.id,\n						sizes: [\n							[e.width, e.height]\n						]\n					}],\n					timeout: 1500\n				}, (function() {\n					r()\n				})), tt.prebidAvailable && window.pbjs.requestBids({\n					adUnitCodes: [e.adUnitPath],\n					bidsBackHandler: function() {\n						r()\n					}\n				}), window.apstag || tt.prebidAvailable || r()\n			}, e.prototype.clearIGDAd = function(e) {\n				var t, i = this.getIGDSlotID(e);\n				if (i) {\n					var r = this.slotMap.get(i) || null;\n					if (r) {\n						for (at.track(n.tracking.screen.destroyAd, {\n								opportunityId: r.opportunityId\n							}), null === (t = r.intersectionObserver) || void 0 === t || t.disconnect(), r.gptSlot && googletag.destroySlots([r.gptSlot]); e.lastChild;) e.removeChild(e.lastChild);\n						e.removeAttribute("data-poki-ad-id"), this.slotMap.delete(r.id)\n					}\n				} else console.error("destroyAd called on a container without ad")\n			}, e.prototype.getIGDSlotID = function(e) {\n				if (!e) return null;\n				var t = e.getAttribute("data-poki-ad-id");\n				return t || null\n			}, e\n		}();\n		const Fe = Ne;\n		var Xe, He = (Xe = function(e, t) {\n				return Xe = Object.setPrototypeOf || {\n					__proto__: []\n				}\n				instanceof Array && function(e, t) {\n					e.__proto__ = t\n				} || function(e, t) {\n					for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i])\n				}, Xe(e, t)\n			}, function(e, t) {\n				if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");\n\n				function i() {\n					this.constructor = e\n				}\n				Xe(e, t), e.prototype = null === t ? Object.create(t) : (i.prototype = t.prototype, new i)\n			}),\n			Ve = function(e) {\n				function t() {\n					return null !== e && e.apply(this, arguments) || this\n				}\n				return He(t, e), t.prototype.waitUntilReady = function(e) {\n					window.pbjs.que.push((function() {\n						e()\n					}))\n				}, t.prototype.requestAd = function(e) {\n					var t = this;\n					D({\n						event: "request",\n						size: e.size,\n						opportunityId: e.opportunityId,\n						adUnitPath: e.adUnitPath,\n						p4d_game_id: $e.gameId,\n						p4d_version_id: $e.versionId\n					});\n					var i = 1,\n						n = function() {\n							--i > 0 || t.allBidsBack(e.id)\n						};\n					window.apstag && (i++, window.apstag.fetchBids({\n						slots: [{\n							slotName: e.adUnitPath,\n							slotID: e.id,\n							sizes: [\n								[e.width, e.height]\n							]\n						}],\n						timeout: 1500\n					}, (function(t) {\n						t && t.length > 0 && (e.amznTargetting = t[0]), n()\n					}))), window.pbjs.requestBids({\n						adUnitCodes: [e.adUnitPath],\n						bidsBackHandler: function() {\n							e.pbjsTargetting = window.pbjs.getAdserverTargetingForAdUnitCode([e.adUnitPath]), n()\n						}\n					})\n				}, t.prototype.allBidsBack = function(e) {\n					var t, i, r, o, a = this.slotMap.get(e);\n					if (a) {\n						var s = document.createElement("iframe");\n						s.setAttribute("frameborder", "0"), s.setAttribute("scrolling", "no"), s.setAttribute("marginheight", "0"), s.setAttribute("marginwidth", "0"), s.setAttribute("topmargin", "0"), s.setAttribute("leftmargin", "0"), s.setAttribute("allowtransparency", "true"), s.setAttribute("width", "" + a.width), s.setAttribute("height", "" + a.height);\n						var d = document.getElementById(a.id);\n						if (d) {\n							d.appendChild(s);\n							var A = null === (t = null == s ? void 0 : s.contentWindow) || void 0 === t ? void 0 : t.document;\n							if (!A) return console.error("IGD error - iframe injection for ad failed", e), void this.clearIGDAd(d.parentNode);\n							var c = !0,\n								l = a.pbjsTargetting.hb_bidder,\n								u = parseFloat(a.pbjsTargetting.hb_pb);\n							isNaN(u) && (u = 0);\n							var p, h, m = (p = null === (i = null == a ? void 0 : a.amznTargetting) || void 0 === i ? void 0 : i.amznbid, z[p] || 0);\n							m > u ? (h = null === (r = null == a ? void 0 : a.amznTargetting) || void 0 === r ? void 0 : r.amnzp, l = M[h] || "Amazon", u = m, c = !1, this.renderAMZNAd(a.id, d, A)) : this.renderPrebidAd(a.id, d, A), at.track(n.tracking.ads.display.impression, {\n								size: a.size,\n								opportunityId: a.opportunityId,\n								duringGameplay: null === (o = a.duringGameplayFn) || void 0 === o ? void 0 : o.call(a),\n								adUnitPath: a.adUnitPath,\n								prebidBid: u,\n								prebidBidder: l,\n								preBidWon: c,\n								dfpIsBackfill: !1,\n								dfpLineItemId: void 0,\n								dfpCampaignId: void 0,\n								adDomain: a.pbjsTargetting.hb_adomain\n							}), D({\n								event: "impression",\n								size: a.size,\n								opportunityId: a.opportunityId,\n								adUnitPath: a.adUnitPath,\n								p4d_game_id: $e.gameId,\n								p4d_version_id: $e.versionId,\n								bidder: l,\n								bid: u\n							}), a.intersectionObserver = new IntersectionObserver((function(e) {\n								e.forEach((function(e) {\n									e.isIntersecting ? a.intersectingTimer || (a.intersectingTimer = setTimeout((function() {\n										var t;\n										null === (t = a.intersectionObserver) || void 0 === t || t.unobserve(e.target), D({\n											event: "viewable",\n											size: a.size,\n											opportunityId: a.opportunityId,\n											adUnitPath: a.adUnitPath,\n											p4d_game_id: $e.gameId,\n											p4d_version_id: $e.versionId,\n											bidder: l,\n											bid: u\n										})\n									}), 1e3)) : a.intersectingTimer && (clearTimeout(a.intersectingTimer), a.intersectingTimer = void 0)\n								}))\n							}), {\n								threshold: .5\n							}), a.intersectionObserver.observe(d)\n						} else console.error("IGD error - container not found", e)\n					}\n				}, t.prototype.renderPrebidAd = function(e, t, i) {\n					var n = this.slotMap.get(e);\n					if (n) return n.pbjsTargetting.hb_adid ? void window.pbjs.renderAd(i, n.pbjsTargetting.hb_adid) : (console.error("IGD info - prebid nothing to render", e, n.pbjsTargetting), void this.clearIGDAd(t.parentNode))\n				}, t.prototype.renderAMZNAd = function(e, t, i) {\n					var n, r, o = this.slotMap.get(e);\n					if (o) return (null === (n = null == o ? void 0 : o.amznTargetting) || void 0 === n ? void 0 : n.amzniid) ? void window.apstag.renderImp(i, null === (r = null == o ? void 0 : o.amznTargetting) || void 0 === r ? void 0 : r.amzniid) : (console.error("IGD info - amazon nothing to render", e, o.pbjsTargetting), void this.clearIGDAd(t.parentNode))\n				}, t.prototype.setupGPT = function(e, t) {}, t.prototype.setupSlotRenderEndedListener = function() {}, t\n			}(Fe);\n		const We = Ve;\n		var Je = function() {\n				return Je = Object.assign || function(e) {\n					for (var t, i = 1, n = arguments.length; i < n; i++)\n						for (var r in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);\n					return e\n				}, Je.apply(this, arguments)\n			},\n			Ye = function(e, t, i) {\n				if (i || 2 === arguments.length)\n					for (var n, r = 0, o = t.length; r < o; r++) !n && r in t || (n || (n = Array.prototype.slice.call(t, 0, r)), n[r] = t[r]);\n				return e.concat(n || Array.prototype.slice.call(t))\n			},\n			$e = {\n				gameId: I("game_id"),\n				versionId: I("game_version_id")\n			},\n			et = function() {\n				function e() {\n					this.autoStartOnReady = !1, this.criteria = {}, this.debugIsOverwritten = !1, this.handlers = {}, this.initializingPromise = null, this.isInitialized = !1, this.programmaticAdsEnabled = !0, this.sdkBooted = !1, this.startAdEnabled = !1, this.startStartAdsAfterTimerOnInit = !1, this.initOptions = {}, this.installedTCFv2 = !1, this.installedUSP = !1, this.isBot = !1, this.adSettings = {\n						blocklist: [],\n						countryExclusion: [],\n						bidderLimitation: {}\n					}, this.adReady = !1, this.sdkImaError = !1, this.debugTouchOverlayController = !1, this.setPlayerAge = function(e) {\n						e && function(e, t) {\n							if (be) try {\n								localStorage.setItem(e, t)\n							} catch (i) {\n								be = !1, ke[e] = t\n							} else ke[e] = t\n						}("playerAge", e)\n					}, this.setLogging = function(e) {\n						r.log = e\n					}, this.sdkNotBootedButCalled = function() {\n						console.error("The Poki SDK has not yet been initialized")\n					}, this.IGD = $() ? new We : new Fe;\n					var e = I("pokiDebug");\n					"" !== e && (this.setDebug("true" === e), this.debugIsOverwritten = !0), "" !== I("pokiLogging") && this.setLogging(!0)\n				}\n				return e.prototype.init = function(e) {\n					if (void 0 === e && (e = {}), "undefined" != typeof window) {\n						var t = e.onReady,\n							i = void 0 === t ? null : t,\n							n = e.onAdblocked,\n							r = void 0 === n ? null : n;\n						return this.initOptions = e, i && this.registerHandler("onReady", i), r && this.registerHandler("onAdblocked", r), this.isInitialized ? console.error("Poki SDK has already been initialized") : (this.initializingPromise || (this.initializingPromise = this.lazyLoadInit()), this.initializingPromise)\n					}\n				}, e.prototype.lazyLoadInit = function() {\n					var t = this,\n						i = this.initOptions,\n						o = i.debug,\n						s = void 0 !== o && o,\n						A = i.prebid,\n						c = void 0 === A ? {} : A,\n						l = i.a9,\n						u = void 0 === l ? {} : l,\n						p = i.volume,\n						h = void 0 === p ? 1 : p,\n						m = i.waterfallRetries,\n						g = i.wrapper;\n					window.googletag = window.googletag || {\n						cmd: []\n					}, window.pbjs = window.pbjs || {\n						que: []\n					};\n					var f = parseInt(I("site_id"), 10) || 0;\n					this.isBot = "1" === I("bot"), this.setupDefaultEvents(), at.setupDefaultEvents(), e.GetIsPokiIFrame() && ye(), setTimeout(b.trackSavegames, 1e4);\n					var v = Je({}, d),\n						k = je;\n					r.debug && (k = function() {\n						return Promise.resolve()\n					});\n					var S = Re,\n						E = I("ccpaApplies"),\n						x = (this.initOptions.country || I("country")).toUpperCase(),\n						C = void 0 !== this.initOptions.isCCPA ? this.initOptions.isCCPA : "" !== E ? "1" === E : void 0;\n					x && void 0 !== C && (S = function() {\n						return Promise.resolve({\n							ISO: x,\n							ccpaApplies: C\n						})\n					}), window.addEventListener("resize", this.resize.bind(this), !1), this.debugIsOverwritten || this.setDebug(r.debug || s), this.debugTouchOverlayController && (y() || w()) && Ke();\n					var T = [k(), S()],\n						_ = Ye(Ye([], T, !0), [Ge()], !1);\n					this.isBot || (_.push(Pe("null.html?https:\/\/imasdk.googleapis.com\/js\/sdkloader\/ima3.js"), Pe("null.html?https:\/\/securepubads.g.doubleclick.net\/tag\/js\/gpt.js")), (I("url_referrer") || "").includes("kiloo.com") ? (e.prebidAvailable = !1, e.childDirected = !0, e.nonPersonalized = !0, this.IGD.enforceChildSafety()) : _.push(Pe("null.html?https:\/\/a.poki.com\/prebid\/prebid6.12.0.js"), Pe("null.html?https:\/\/c.amazon-adsystem.com\/aax2\/apstag.js")));\n					var P = function(e, i, o) {\n						if (void 0 === o && (o = !0), t.country = (x || (null == i ? void 0 : i.ISO) || "ZZ").toUpperCase(), t.isCCPA = void 0 === C ? (null == i ? void 0 : i.ccpaApplies) || !1 : C, e) {\n							$e.gameId || ($e.gameId = e.gameId);\n							["7fb1fd45-24ce-4ade-b5c4-9ee55ec99526"].includes($e.gameId) && (y() || w()) && Ke(), v.adTiming = e.adTiming, v.customCriteria = Je(Je({}, v.customCriteria), {\n								p4d_game_id: $e.gameId\n							})\n						}\n						Ee(t.country) && !r.debug && (W(), console.debug("GDPR - waiting for __tcfapi callback"), window.__tcfapi("ping", 2, (function() {\n							console.debug("GDPR - __tcfapi callback received"), t.installedTCFv2 = !0, o && a.dispatchEvent(n.ready)\n						})), setTimeout((function() {\n							t.installedTCFv2 || (console.error("GDPR - No __tcfapi callback after 2s, verify implementation!"), o && a.dispatchEvent(n.ready))\n						}), 2e3)), t.isCCPA && !r.debug && (J(), console.debug("USPrivacy - waiting for __uspapi callback"), window.__uspapi("uspPing", 1, (function() {\n							console.debug("USPrivacy - __uspapi callback received"), t.installedUSP = !0, o && a.dispatchEvent(n.ready)\n						})), setTimeout((function() {\n							t.installedUSP || (console.error("USPrivacy - No __uspapi callback after 2s, verify implementation!"), o && a.dispatchEvent(n.ready))\n						}), 2e3))\n					};\n					return Promise.all(_).catch((function() {\n						Promise.all(T).then((function(e) {\n							var t = e[0],\n								i = e[1];\n							P(t, i, !1)\n						})), a.dispatchEvent(n.adblocked)\n					})).then((function(e) {\n						if (void 0 !== e) {\n							var i, o = e[0],\n								s = e[1],\n								d = e[2];\n							P(o, s), t.adSettings = d, i = d.blocklist, L = i || [], X(c, t.country, d.bidderLimitation), r.debug && (v.adTiming.startAdsAfter = 0);\n							var A = I("force_ad") || I("gd_force_ad") || !1;\n							A && (v.adTiming = {\n								preroll: !0,\n								timeBetweenAds: 12e4,\n								timePerTry: 7e3,\n								startAdsAfter: 0\n							}, v.customCriteria = Je(Je({}, v.customCriteria), {\n								force_ad: A\n							})), t.enableSettings(v), t.playerSkin = new fe({\n								wrapper: g\n							}), t.ima = new _e(h), t.playerSkin.setupEvents(t), t.startStartAdsAfterTimerOnInit && t.adTimings.startStartAdsAfterTimer(), t.waterfall = new te(t.ima, {\n								timing: t.adTimings,\n								totalRetries: m,\n								siteID: f,\n								country: t.country\n							}), t.IGD.setupSlotRenderEndedListener();\n							var l = Ee(t.country);\n							V(u, t.country, l, d.bidderLimitation), t.isInitialized = !0, t.isCCPA || l ? r.debug && a.dispatchEvent(n.ready) : a.dispatchEvent(n.ready)\n						}\n					}))\n				}, e.prototype.requestAd = function(e) {\n					void 0 === e && (e = {});\n					var t = e.autoStart,\n						i = void 0 === t || t,\n						o = e.onFinish,\n						d = void 0 === o ? null : o,\n						A = e.onStart,\n						c = void 0 === A ? null : A,\n						l = e.position,\n						u = void 0 === l ? null : l;\n					if (this.autoStartOnReady = !1 !== i, d && this.registerHandler("onFinish", d), c && this.registerHandler("onStart", c), this.isBot) d && d({});\n					else {\n						if (!this.sdkBooted) return a.dispatchEvent(n.ads.error, {\n							message: "Requesting ad on unbooted SDK"\n						}), void this.sdkNotBootedButCalled();\n						if (this.sdkImaError) a.dispatchEvent(n.ads.error, {\n							message: "Adblocker has been detected"\n						});\n						else if (!y() && !w() || u === n.ads.position.rewarded)\n							if (null !== u && s(u, n.ads.position))\n								if (!Ee(this.country) || this.installedTCFv2 || r.debug)\n									if (!this.isCCPA || this.installedUSP)\n										if (this.ima.isAdRunning() || this.waterfall.isRunning()) a.dispatchEvent(n.ads.busy);\n										else if (this.adReady) a.dispatchEvent(n.ads.ready);\n						else if (u !== n.ads.position.preroll || this.adTimings.prerollPossible())\n							if (u === n.ads.position.rewarded || this.adTimings.requestPossible())\n								if (u !== n.ads.position.rewarded && this.adSettings.countryExclusion.includes(this.country)) a.dispatchEvent(n.ads.limit, {\n									reason: n.info.messages.disabled\n								});\n								else {\n									var p = Je(Je(Je({}, this.genericCriteria()), this.criteria), {\n										position: u\n									});\n									this.playerSkin.show(), this.resize(), this.waterfall.start(p, u)\n								}\n						else a.dispatchEvent(n.ads.limit, {\n							reason: n.info.messages.timeLimit\n						});\n						else a.dispatchEvent(n.ads.limit, {\n							reason: n.info.messages.prerollLimit\n						});\n						else a.dispatchEvent(n.ads.error, {\n							message: "No USP detected, please contact developersupport@poki.com for more information"\n						});\n						else a.dispatchEvent(n.ads.error, {\n							message: "No TCFv2 CMP detected, please contact developersupport@poki.com for more information"\n						});\n						else console.error("POKI-SDK: Invalid position");\n						else a.dispatchEvent(n.ads.error, {\n							reason: "Interstitials are disabled on mobile"\n						})\n					}\n				}, e.prototype.displayAd = function(e, t, i, o) {\n					\/*if (!this.isBot) {\n						var s = n.ads.position.display;\n						if (!Ee(this.country) || this.installedTCFv2 || r.debug)\n							if (!this.isCCPA || window.__uspapi)\n								if (t) {\n									if (!this.sdkBooted) return a.dispatchEvent(n.ads.error, {\n										message: "Requesting ad on unbooted SDK",\n										position: s\n									}), void this.sdkNotBootedButCalled();\n									if (e)\n										if (this.sdkImaError) a.dispatchEvent(n.ads.error, {\n											message: "Adblocker has been detected",\n											position: s\n										});\n										else if (this.adSettings.countryExclusion.includes(this.country)) a.dispatchEvent(n.ads.limit, {\n										reason: n.info.messages.disabled,\n										position: s\n									});\n									else {\n										if (!this.IGD.validateDisplaySettings(t)) return a.dispatchEvent(n.ads.error, {\n											reason: "Display size " + t + " is not supported on this device",\n											position: s\n										});\n										var d = Je(Je({}, this.genericCriteria()), this.criteria);\n										this.IGD.renderIGDAd(e, t, d, i, o)\n									} else a.dispatchEvent(n.ads.error, {\n										message: "Provided container does not exist",\n										position: s\n									})\n								} else a.dispatchEvent(n.ads.error, {\n									message: "No ad size given, usage: displayAd(<container>, <size>)",\n									position: s\n								});\n						else a.dispatchEvent(n.ads.error, {\n							message: "No USP detected, please contact developersupport@poki.com for more information",\n							position: s\n						});\n						else a.dispatchEvent(n.ads.error, {\n							message: "No TCFv2 CMP detected, please contact developersupport@poki.com for more information",\n							position: s\n						})\n					}*\/\n				}, e.prototype.destroyAd = function(e) {\n					if (!this.sdkBooted) return a.dispatchEvent(n.ads.displayError, {\n						message: "Attempting destroyAd on unbooted SDK"\n					}), void this.sdkNotBootedButCalled();\n					this.sdkImaError ? a.dispatchEvent(n.ads.displayError, {\n						message: "Adblocker has been detected"\n					}) : this.adSettings.countryExclusion.includes(this.country) || (e = e || document.body, this.IGD.clearIGDAd(e))\n				}, e.prototype.startStartAdsAfterTimer = function() {\n					this.sdkBooted && !this.sdkImaError ? this.adTimings.startStartAdsAfterTimer() : this.startStartAdsAfterTimerOnInit = !0\n				}, e.prototype.enableSettings = function(e) {\n					this.criteria = Je({}, e.customCriteria), this.adTimings = new c(e.adTiming)\n				}, e.prototype.togglePlayerAdvertisingConsent = function(e) {\n					if (e) {\n						var t, i = parseInt(function(e) {\n								if (!be) return ke[e];\n								try {\n									return localStorage.getItem(e)\n								} catch (t) {\n									return ke[e]\n								}\n							}("playerAge"), 10) || 0,\n							n = this.country,\n							r = Ee(n),\n							o = (t = n, Ie.includes(t)),\n							a = xe(n);\n						(r || o || xe) && (r && i <= 12 || o && i <= 16 || a && i <= 16) ? this.disableProgrammatic(): this.enableProgrammatic()\n					} else this.disableProgrammatic()\n				}, e.prototype.disableProgrammatic = function() {\n					e.childDirected = !0, this.programmaticAdsEnabled = !1\n				}, e.prototype.enableProgrammatic = function() {\n					e.childDirected = !1, this.programmaticAdsEnabled = !0\n				}, e.prototype.getProgrammaticAdsEnabled = function() {\n					return this.programmaticAdsEnabled\n				}, e.prototype.setDebug = function(e) {\n					this.debugIsOverwritten ? e && at.track(n.tracking.debugTrueInProduction) : r.debug = e\n				}, e.prototype.resize = function() {\n					var e = this;\n					if (!this.sdkBooted) return this.sdkNotBootedButCalled();\n					if (!this.sdkImaError) {\n						var t = this.playerSkin.getVideoBounds();\n						0 !== t.width && 0 !== t.height ? this.ima.resize(t.width, t.height) : setTimeout((function() {\n							e.resize()\n						}), 100)\n					}\n				}, e.prototype.startAd = function() {\n					if (!this.sdkBooted) return this.sdkNotBootedButCalled();\n					this.sdkImaError || (this.adReady ? (this.resize(), this.ima.startPlayback()) : a.dispatchEvent(n.ads.error, {\n						message: "No ads ready to start"\n					}))\n				}, e.prototype.startAdClicked = function() {\n					"undefined" != typeof navigator && \/(iPad|iPhone|iPod)\/gi.test(navigator.userAgent) && this.startAdEnabled && (this.startAdEnabled = !1, this.playerSkin.hideStartAdButton(), this.ima.startIOSPlayback())\n				}, e.prototype.stopAd = function() {\n					if (!this.sdkBooted) return this.sdkNotBootedButCalled();\n					this.sdkImaError || (this.waterfall.stopWaterfall(), this.ima.stopPlayback(), this.playerSkin.hide())\n				}, e.prototype.resumeAd = function() {\n					if (!this.sdkBooted) return this.sdkNotBootedButCalled();\n					this.sdkImaError || (this.playerSkin.hidePauseButton(), this.ima.resumeAd())\n				}, e.prototype.skipAd = function() {\n					this.stopAd(), this.callHandler("onFinish", {\n						type: n.ads.completed,\n						rewardAllowed: !0\n					})\n				}, e.prototype.muteAd = function() {\n					if (!this.sdkBooted) return this.sdkNotBootedButCalled();\n					this.sdkImaError || this.ima.muteAd()\n				}, e.prototype.registerHandler = function(e, t) {\n					this.handlers[e] = t\n				}, e.prototype.callHandler = function(e) {\n					for (var t = [], i = 1; i < arguments.length; i++) t[i - 1] = arguments[i];\n					"function" == typeof this.handlers[e] && this.handlers[e](t)\n				}, e.prototype.setupDefaultEvents = function() {\n					var e = this;\n					a.addEventListener(n.ready, (function() {\n						e.sdkBooted = !0, e.callHandler("onReady")\n					})), a.addEventListener(n.adblocked, (function() {\n						e.sdkBooted = !0, e.sdkImaError = !0, e.callHandler("onAdblocked")\n					})), a.addEventListener(n.ads.ready, (function() {\n						e.adReady = !0, e.autoStartOnReady && e.startAd()\n					})), a.addEventListener(n.ads.started, (function() {\n						e.playerSkin.hideSpinner(), e.callHandler("onStart", {\n							type: n.ads.limit\n						})\n					})), a.addEventListener(n.ads.video.paused, (function() {\n						e.playerSkin.showPauseButton()\n					})), a.addEventListener(n.ads.limit, (function() {\n						e.callHandler("onFinish", {\n							type: n.ads.limit,\n							rewardAllowed: !1\n						})\n					})), a.addEventListener(n.ads.stopped, (function() {\n						e.callHandler("onFinish", {\n							type: n.ads.stopped,\n							rewardAllowed: !1\n						})\n					})), a.addEventListener(n.ads.error, (function(t) {\n						e.callHandler("onFinish", {\n							type: n.ads.error,\n							rewardAllowed: !!t.rewardAllowed\n						})\n					})), a.addEventListener(n.ads.busy, (function() {\n						e.callHandler("onFinish", {\n							type: n.ads.busy,\n							rewardAllowed: !1\n						})\n					})), a.addEventListener(n.ads.completed, (function(t) {\n						e.callHandler("onFinish", {\n							type: n.ads.completed,\n							rewardAllowed: !!t.rewardAllowed\n						})\n					})), [n.ads.limit, n.ads.stopped, n.ads.error, n.ads.busy, n.ads.completed].forEach((function(t) {\n						a.addEventListener(t, (function() {\n							e.playerSkin && e.playerSkin.hide(), e.adReady = !1\n						}))\n					}))\n				}, e.prototype.genericCriteria = function() {\n					var e = {},\n						t = encodeURIComponent(I("tag") || ""),\n						i = encodeURIComponent(I("site_id") || ""),\n						n = encodeURIComponent(I("experiment") || ""),\n						r = encodeURIComponent(I("categories") || "");\n					return e.tag = t, e.tag_site = t + "|" + i, e.site_id = i, e.experiment = n, e.categories = r, this.programmaticAdsEnabled || (e.disable_programmatic = 1), e\n				}, e.prototype.setVolume = function(e) {\n					this.ima && this.ima.setVolume(e)\n				}, e.GetIsPokiIFrame = function() {\n					return (parseInt(I("site_id"), 10) || 0) > 0\n				}, e.childDirected = !1, e.nonPersonalized = !1, e.prebidAvailable = !0, e.consentString = "", e\n			}();\n		const tt = et;\n		const it = function() {\n			function e() {}\n			return e.sendMessage = function(e, t) {\n				var i = window.parent;\n				if (!s(e, n.message)) {\n					var r = Object.keys(n.message).map((function(e) {\n						return "poki.message." + e\n					}));\n					throw new TypeError("Argument \'type\' must be one of " + r.join(", "))\n				}\n				var o = t || {};\n				$e.gameId && $e.versionId && (o.pokifordevs = {\n					game_id: $e.gameId,\n					game_version_id: $e.versionId\n				}), i.postMessage({\n					type: e,\n					content: o\n				}, "*")\n			}, e\n		}();\n		var nt = function(e) {\n			var t = new Array;\n			return Object.keys(e).forEach((function(i) {\n				"object" == typeof e[i] ? t = t.concat(nt(e[i])) : t.push(e[i])\n			})), t\n		};\n		var rt = function() {\n				return rt = Object.assign || function(e) {\n					for (var t, i = 1, n = arguments.length; i < n; i++)\n						for (var r in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);\n					return e\n				}, rt.apply(this, arguments)\n			},\n			ot = nt(n.tracking);\n		const at = function() {\n			function e() {}\n			return e.track = function(e, t) {\n				if (void 0 === t && (t = {}), -1 === ot.indexOf(e)) throw new TypeError("Invalid \'event\', must be one of " + ot.join(", "));\n				if ("object" != typeof t) throw new TypeError("Invalid data, must be an object");\n				var i = a.getDataAnnotations();\n				if (null == i ? void 0 : i.vhbOnlyMode) switch (e) {\n					case n.tracking.ads.status.impression:\n						D(rt({\n							event: "video-impression",\n							size: "640x360v"\n						}, i));\n						break;\n					case n.tracking.ads.video.error:\n						D(rt({\n							event: "video-error",\n							size: "640x360v"\n						}, i));\n						break;\n					case n.tracking.ads.video.loaderError:\n						D(rt({\n							event: "video-adsloader-error",\n							size: "640x360v"\n						}, i));\n						break;\n					case n.tracking.ads.status.completed:\n						D(rt({\n							event: "video-complete",\n							size: "640x360v"\n						}, i))\n				}\n				if (r.debug || r.log) {\n					if (window.process && window.process.env && "test" === window.process.env.NODE_ENV) return;\n					Object.keys(t).length ? console.info("%cPOKI_TRACKER: %cTracked event \'" + e + "\' with data:", "font-weight: bold", "", t) : console.info("%cPOKI_TRACKER: %cTracked event \'" + e + "\'", "font-weight: bold", "")\n				}\n				it.sendMessage(n.message.event, {\n					event: e,\n					data: t\n				})\n			}, e.setupDefaultEvents = function() {\n				var t, i = ((t = {})[n.ready] = n.tracking.sdk.status.initialized, t[n.adblocked] = n.tracking.sdk.status.failed, t[n.ads.busy] = n.tracking.ads.status.busy, t[n.ads.completed] = n.tracking.ads.status.completed, t[n.ads.error] = n.tracking.ads.status.error, t[n.ads.displayError] = n.tracking.ads.status.displayError, t[n.ads.impression] = n.tracking.ads.status.impression, t[n.ads.limit] = n.tracking.ads.status.limit, t[n.ads.ready] = n.tracking.ads.status.ready, t[n.ads.requested] = n.tracking.ads.status.requested, t[n.ads.prebidRequested] = n.tracking.ads.status.prebidRequested, t[n.ads.skipped] = n.tracking.ads.status.skipped, t[n.ads.started] = n.tracking.ads.status.started, t[n.ads.video.clicked] = n.tracking.ads.video.clicked, t[n.ads.video.error] = n.tracking.ads.video.error, t[n.ads.video.loaderError] = n.tracking.ads.video.loaderError, t[n.ads.video.buffering] = n.tracking.ads.status.buffering, t[n.ads.video.progress] = n.tracking.ads.video.progress, t[n.ads.video.paused] = n.tracking.ads.video.paused, t[n.ads.video.resumed] = n.tracking.ads.video.resumed, t[n.tracking.screen.gameplayStart] = n.tracking.screen.gameplayStart, t[n.tracking.screen.gameplayStop] = n.tracking.screen.gameplayStop, t[n.tracking.screen.loadingProgress] = n.tracking.screen.loadingProgress, t[n.tracking.screen.commercialBreak] = n.tracking.screen.commercialBreak, t[n.tracking.screen.rewardedBreak] = n.tracking.screen.rewardedBreak, t[n.tracking.screen.happyTime] = n.tracking.screen.happyTime, t);\n				Object.keys(i).forEach((function(t) {\n					a.addEventListener(t, (function(n) {\n						e.track(i[t], n)\n					}))\n				}))\n			}, e\n		}();\n\n		function st(e) {\n			switch (Object.prototype.toString.call(e)) {\n				case "[object Error]":\n				case "[object Exception]":\n				case "[object DOMException]":\n					return !0;\n				default:\n					return e instanceof Error\n			}\n		}\n		var dt = "poki_erruid",\n			At = Date.now(),\n			ct = u(dt);\n\n		function lt() {\n			return ct || (ct = Math.random().toString(36).substr(2, 9), p(dt, ct)), ct\n		}\n\n		function ut(e) {\n			if ($e.gameId && $e.versionId) {\n				if (!(Date.now() < At)) try {\n					var t = JSON.stringify({\n							gid: $e.gameId,\n							vid: $e.versionId,\n							ve: 7,\n							n: e.name,\n							m: e.message,\n							s: JSON.stringify(e.stack),\n							ui: lt()\n						}),\n						i = "null.html?https:\/\/t.poki.io\/ge";\n					if (navigator.sendBeacon) navigator.sendBeacon(i, t);\n					else {\n						var n = new XMLHttpRequest;\n						n.open("POST", i, !0), n.send(t)\n					}\n					At = Date.now() + 100\n				} catch (e) {\n					console.error(e)\n				}\n			} else console.log(e)\n		}\n		"undefined" != typeof window && (t().remoteFetching = !1, t().report.subscribe((function(e) {\n			if ("Script error." === e.message && window.pokiLastCatch) {\n				var i = window.pokiLastCatch;\n				window.pokiLastCatch = null, t().report(i)\n			} else ut(e)\n		})), window.onunhandledrejection = function(e) {\n			st(e.reason) ? t().report(e.reason) : ut({\n				name: "unhandledrejection",\n				message: JSON.stringify(e.reason)\n			})\n		});\n		var pt = function() {\n				return pt = Object.assign || function(e) {\n					for (var t, i = 1, n = arguments.length; i < n; i++)\n						for (var r in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);\n					return e\n				}, pt.apply(this, arguments)\n			},\n			ht = function() {\n				function t() {\n					var t = this;\n					this.gameStarted = !1, this.SDK = new tt, this.gameplayStartCounter = 0, this.gameplayStopCounter = 0, this.duringGameplay = !1, this.init = function(e) {\n						return void 0 === e && (e = {}), new Promise((function(i, r) {\n							t.SDK.init(pt({\n								onReady: function() {\n									if (I("preroll")) {\n										var e = t.SDK.adTimings.prerollPossible;\n										t.SDK.adTimings.prerollPossible = function() {\n											return !0\n										}, t.commercialBreak(), t.SDK.adTimings.prerollPossible = e\n									}\n									i()\n								},\n								onAdblocked: r\n							}, e)), it.sendMessage(n.message.sdkDetails, {\n								version: "2.263.0"\n							})\n						}))\n					}, this.initWithVideoHB = function() {\n						return t.init()\n					}, this.gameLoadingProgress = function(e) {\n						var t = {};\n						void 0 !== e.percentageDone && (t.percentageDone = Number(e.percentageDone)), void 0 !== e.kbLoaded && (t.kbLoaded = Number(e.kbLoaded)), void 0 !== e.kbTotal && (t.kbTotal = Number(e.kbTotal)), void 0 !== e.fileNameLoaded && (t.fileNameLoaded = String(e.fileNameLoaded)), void 0 !== e.filesLoaded && (t.filesLoaded = Number(e.filesLoaded)), void 0 !== e.filesTotal && (t.filesTotal = Number(e.filesTotal)), at.track(n.tracking.screen.gameLoadingProgress, t)\n					}, this.gameLoadingStart = function() {\n						var e, t;\n						at.track(n.tracking.screen.gameLoadingStarted, {\n							now: Math.round(null === (t = null === (e = window.performance) || void 0 === e ? void 0 : e.now) || void 0 === t ? void 0 : t.call(e)) || void 0,\n							error_user_id: lt()\n						})\n					}, this.gameLoadingFinished = function() {\n						var e, t, i, r, o;\n						try {\n							i = performance.getEntriesByType("resource").map((function(e) {\n								return e.transferSize\n							})).reduce((function(e, t) {\n								return e + t\n							})), i += performance.getEntriesByType("navigation")[0].transferSize\n						} catch (e) {}\n						at.track(n.tracking.screen.gameLoadingFinished, {\n							transferSize: i,\n							trackers: (r = window, o = [], "function" != typeof r.ga && "function" != typeof r.gtag || o.push("ga"), r.mixpanel && "function" == typeof r.mixpanel.track && o.push("mixpanel"), "function" == typeof r.GameAnalytics && o.push("gameanalytics"), (r.kongregateAPI || r.kongregate) && o.push("kongregate"), r.FlurryAgent && o.push("flurry"), r.Countly && o.push("countly"), r.amplitude && o.push("amplitude"), o).join(","),\n							now: Math.round(null === (t = null === (e = window.performance) || void 0 === e ? void 0 : e.now) || void 0 === t ? void 0 : t.call(e)) || void 0\n						})\n					}, this.gameplayStart = function(e) {\n						t.gameplayStartCounter++, t.duringGameplay = !0, t.gameStarted || (t.gameStarted = !0, at.track(n.tracking.screen.firstRound), t.SDK.startStartAdsAfterTimer()), at.track(n.tracking.screen.gameplayStart, pt(pt({}, e), {\n							playId: t.gameplayStartCounter\n						}))\n					}, this.gameInteractive = function() {\n						at.track(n.tracking.screen.gameInteractive)\n					}, this.gameplayStop = function(e) {\n						t.gameplayStopCounter++, t.duringGameplay = !1, at.track(n.tracking.screen.gameplayStop, pt(pt({}, e), {\n							playId: t.gameplayStartCounter,\n							stopId: t.gameplayStopCounter\n						}))\n					}, this.roundStart = function(e) {\n						void 0 === e && (e = ""), e = String(e), at.track(n.tracking.screen.roundStart, {\n							identifier: e\n						})\n					}, this.roundEnd = function(e) {\n						void 0 === e && (e = ""), e = String(e), at.track(n.tracking.screen.roundEnd, {\n							identifier: e\n						})\n					}, this.customEvent = function(e, i, r) {\n						void 0 === r && (r = {}), e && i ? (e = String(e), i = String(i), r = pt({}, r), at.track(n.tracking.custom, {\n							eventNoun: e,\n							eventVerb: i,\n							eventData: r\n						})) : t.error("customEvent", "customEvent needs at least a noun and a verb")\n					}, this.commercialBreak = function(e) {\n						return new Promise((function(i) {\n							var r = t.gameStarted ? n.ads.position.midroll : n.ads.position.preroll;\n							a.clearAnnotations(), a.setDataAnnotations({\n								opportunityId: Qe(),\n								position: r\n							});\n							i(1);\n							\/*, at.track(n.tracking.screen.commercialBreak), t.SDK.requestAd({\n								position: r,\n								onFinish: i,\n								onStart: e\n							})*\/\n						}))\n					}, this.rewardedBreak = function(e) {\n						console.log(123);\n						return new Promise((function(i) {\n							var r = n.ads.position.rewarded;\n							a.clearAnnotations(), a.setDataAnnotations({\n								opportunityId: Qe(),\n								position: r\n							});\/\/,\n							\/\/ this.callHandler("onFinish", {\n							\/\/ 	type: n.ads.completed,\n							\/\/ 	rewardAllowed: !0\n							\/\/ })\n							\/\/ n.ads.completed; \n							\/\/ i(1);\n							at.track(n.tracking.screen.rewardedBreak), t.SDK.requestAd({\n								position: r,\n								onFinish: function(e) {\n									console.log(e);\n									e.length > 0 ? i(!e[0].rewardAllowed) : i(!1)\n								},\n								onStart: e\n							})\n							\n						}))\n					}, this.happyTime = function(e) {\n						void 0 === e && (e = 1), ((e = Number(e)) < 0 || e > 1) && (e = Math.max(0, Math.min(1, e)), t.warning("happyTime", "Intensity should be a value between 0 and 1, adjusted to " + e)), at.track(n.tracking.screen.happyTime, {\n							intensity: e\n						})\n					}, this.muteAd = function() {\n						t.SDK.muteAd()\n					}, this.setPlayerAge = function(e) {\n						e && t.SDK.setPlayerAge(e)\n					}, this.togglePlayerAdvertisingConsent = function(e) {\n						at.track(n.tracking.togglePlayerAdvertisingConsent, {\n							didConsent: e\n						}), t.SDK.togglePlayerAdvertisingConsent(e), it.sendMessage(n.message.toggleProgrammaticAds, {\n							enabled: t.SDK.getProgrammaticAdsEnabled()\n						})\n					}, this.displayAd = function(e, i) {\n						a.clearAnnotations();\n						t.duringGameplay = 1;\n						return t.duringGameplay\n						\/*\n						a.clearAnnotations();\n						var r = Qe();\n						at.track(n.tracking.screen.displayAd, {\n							size: i,\n							opportunityId: r,\n							duringGameplay: t.duringGameplay\n						}), t.SDK.displayAd(e, i, r, (function() {\n							return t.duringGameplay\n						}))*\/\n					}, this.logError = function(t) {\n						st(t) ? e.report(t) : ut({\n							name: "logError",\n							message: JSON.stringify(t)\n						})\n					}, this.sendHighscore = function() {}, this.setDebugTouchOverlayController = function(e) {\n						t.SDK.debugTouchOverlayController = e\n					}, this.getLeaderboard = function() {\n						return Promise.resolve([])\n					}, this.getIsoLanguage = function() {\n						return I("iso_lang")\n					}, this.shareableURL = function(e) {\n						return void 0 === e && (e = {}), new Promise((function(t, i) {\n							var r = new URLSearchParams,\n								o = Object.keys(e);\n							if (tt.GetIsPokiIFrame()) {\n								var a = I("poki_url");\n								o.forEach((function(t) {\n									r.set("gd" + t, e[t])\n								})), t(a + "?" + r.toString()), it.sendMessage(n.message.setPokiURLParams, {\n									params: e\n								})\n							} else window.self === window.top ? (o.forEach((function(t) {\n								r.set("" + t, e[t])\n							})), t("" + window.location.origin + window.location.pathname + "?" + r.toString())) : i(new Error("shareableURL only works on Poki or a top level frame"))\n						}))\n					}, this.getURLParam = function(e) {\n						return I("gd" + e) || I(e)\n					}, this.isAdBlocked = function() {\n						return t.SDK.sdkImaError\n					}, this.captureError = function(t) {\n						st(t) ? e.report(t) : e.report(new Error(t))\n					}, this.warning = function(e, t) {\n						console.warn("PokiSDK." + e + ": " + t)\n					}, this.error = function(e, t) {\n						console.error("PokiSDK." + e + ": " + t)\n					}\n				}\n				return t.prototype.setDebug = function(e) {\n					void 0 === e && (e = !0), this.SDK.setDebug(e)\n				}, t.prototype.disableProgrammatic = function() {\n					this.SDK.disableProgrammatic()\n				}, t.prototype.destroyAd = function(e) {\n					this.SDK.destroyAd(e)\n				}, t.prototype.setVolume = function(e) {\n					this.SDK.setVolume(e)\n				}, t\n			}();\n		var mt = new ht;\n		for (var gt in mt) window.PokiSDK[gt] = mt[gt]\n	})()\n})();\n		\n		`\n, r.onload = function() {\n		return t.dequeue()\n	}, document.head.appendChild(r)\n})();\n	<\/script>\n	\n	\n	<script>\n	    \n	   \/\/ Generated by Construct, the game and app creator :: https:\/\/www.construct.net\n\/\/ ..\/3rdparty\/glmatrix.js\n{\n    \/*\n @fileoverview gl-matrix - High performance matrix and vector operations\n@author Brandon Jones\n@author Colin MacKenzie IV\n@version 3.4.1\n\nCopyright (c) 2015-2021, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*\/\n    \'use strict\';\n    (function(global, factory) {\n        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self,\n        factory(global.glMatrix = {}))\n    }\n    )(this, function(exports) {\n        var EPSILON = 1E-6;\n        var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;\n        var RANDOM = Math.random;\n        var ANGLE_ORDER = "zyx";\n        function setMatrixArrayType(type) {\n            ARRAY_TYPE = type\n        }\n        var degree = Math.PI \/ 180;\n        function toRadian(a) {\n            return a * degree\n        }\n        function equals$9(a, b) {\n            return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b))\n        }\n        if (!Math.hypot)\n            Math.hypot = function() {\n                var y = 0\n                  , i = arguments.length;\n                while (i--)\n                    y += arguments[i] * arguments[i];\n                return Math.sqrt(y)\n            }\n            ;\n        var common = Object.freeze({\n            __proto__: null,\n            EPSILON: EPSILON,\n            get ARRAY_TYPE() {\n                return ARRAY_TYPE\n            },\n            RANDOM: RANDOM,\n            ANGLE_ORDER: ANGLE_ORDER,\n            setMatrixArrayType: setMatrixArrayType,\n            toRadian: toRadian,\n            equals: equals$9\n        });\n        function create$8() {\n            var out = new ARRAY_TYPE(4);\n            if (ARRAY_TYPE != Float32Array) {\n                out[1] = 0;\n                out[2] = 0\n            }\n            out[0] = 1;\n            out[3] = 1;\n            return out\n        }\n        function clone$8(a) {\n            var out = new ARRAY_TYPE(4);\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            return out\n        }\n        function copy$8(out, a) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            return out\n        }\n        function identity$5(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            return out\n        }\n        function fromValues$8(m00, m01, m10, m11) {\n            var out = new ARRAY_TYPE(4);\n            out[0] = m00;\n            out[1] = m01;\n            out[2] = m10;\n            out[3] = m11;\n            return out\n        }\n        function set$8(out, m00, m01, m10, m11) {\n            out[0] = m00;\n            out[1] = m01;\n            out[2] = m10;\n            out[3] = m11;\n            return out\n        }\n        function transpose$2(out, a) {\n            if (out === a) {\n                var a1 = a[1];\n                out[1] = a[2];\n                out[2] = a1\n            } else {\n                out[0] = a[0];\n                out[1] = a[2];\n                out[2] = a[1];\n                out[3] = a[3]\n            }\n            return out\n        }\n        function invert$5(out, a) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3];\n            var det = a0 * a3 - a2 * a1;\n            if (!det)\n                return null;\n            det = 1 \/ det;\n            out[0] = a3 * det;\n            out[1] = -a1 * det;\n            out[2] = -a2 * det;\n            out[3] = a0 * det;\n            return out\n        }\n        function adjoint$2(out, a) {\n            var a0 = a[0];\n            out[0] = a[3];\n            out[1] = -a[1];\n            out[2] = -a[2];\n            out[3] = a0;\n            return out\n        }\n        function determinant$3(a) {\n            return a[0] * a[3] - a[2] * a[1]\n        }\n        function multiply$8(out, a, b) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3];\n            var b0 = b[0]\n              , b1 = b[1]\n              , b2 = b[2]\n              , b3 = b[3];\n            out[0] = a0 * b0 + a2 * b1;\n            out[1] = a1 * b0 + a3 * b1;\n            out[2] = a0 * b2 + a2 * b3;\n            out[3] = a1 * b2 + a3 * b3;\n            return out\n        }\n        function rotate$4(out, a, rad) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3];\n            var s = Math.sin(rad);\n            var c = Math.cos(rad);\n            out[0] = a0 * c + a2 * s;\n            out[1] = a1 * c + a3 * s;\n            out[2] = a0 * -s + a2 * c;\n            out[3] = a1 * -s + a3 * c;\n            return out\n        }\n        function scale$8(out, a, v) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3];\n            var v0 = v[0]\n              , v1 = v[1];\n            out[0] = a0 * v0;\n            out[1] = a1 * v0;\n            out[2] = a2 * v1;\n            out[3] = a3 * v1;\n            return out\n        }\n        function fromRotation$4(out, rad) {\n            var s = Math.sin(rad);\n            var c = Math.cos(rad);\n            out[0] = c;\n            out[1] = s;\n            out[2] = -s;\n            out[3] = c;\n            return out\n        }\n        function fromScaling$3(out, v) {\n            out[0] = v[0];\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = v[1];\n            return out\n        }\n        function str$8(a) {\n            return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")"\n        }\n        function frob$3(a) {\n            return Math.hypot(a[0], a[1], a[2], a[3])\n        }\n        function LDU(L, D, U, a) {\n            L[2] = a[2] \/ a[0];\n            U[0] = a[0];\n            U[1] = a[1];\n            U[3] = a[3] - L[2] * U[1];\n            return [L, D, U]\n        }\n        function add$8(out, a, b) {\n            out[0] = a[0] + b[0];\n            out[1] = a[1] + b[1];\n            out[2] = a[2] + b[2];\n            out[3] = a[3] + b[3];\n            return out\n        }\n        function subtract$6(out, a, b) {\n            out[0] = a[0] - b[0];\n            out[1] = a[1] - b[1];\n            out[2] = a[2] - b[2];\n            out[3] = a[3] - b[3];\n            return out\n        }\n        function exactEquals$8(a, b) {\n            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]\n        }\n        function equals$8(a, b) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3];\n            var b0 = b[0]\n              , b1 = b[1]\n              , b2 = b[2]\n              , b3 = b[3];\n            return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3))\n        }\n        function multiplyScalar$3(out, a, b) {\n            out[0] = a[0] * b;\n            out[1] = a[1] * b;\n            out[2] = a[2] * b;\n            out[3] = a[3] * b;\n            return out\n        }\n        function multiplyScalarAndAdd$3(out, a, b, scale) {\n            out[0] = a[0] + b[0] * scale;\n            out[1] = a[1] + b[1] * scale;\n            out[2] = a[2] + b[2] * scale;\n            out[3] = a[3] + b[3] * scale;\n            return out\n        }\n        var mul$8 = multiply$8;\n        var sub$6 = subtract$6;\n        var mat2 = Object.freeze({\n            __proto__: null,\n            create: create$8,\n            clone: clone$8,\n            copy: copy$8,\n            identity: identity$5,\n            fromValues: fromValues$8,\n            set: set$8,\n            transpose: transpose$2,\n            invert: invert$5,\n            adjoint: adjoint$2,\n            determinant: determinant$3,\n            multiply: multiply$8,\n            rotate: rotate$4,\n            scale: scale$8,\n            fromRotation: fromRotation$4,\n            fromScaling: fromScaling$3,\n            str: str$8,\n            frob: frob$3,\n            LDU: LDU,\n            add: add$8,\n            subtract: subtract$6,\n            exactEquals: exactEquals$8,\n            equals: equals$8,\n            multiplyScalar: multiplyScalar$3,\n            multiplyScalarAndAdd: multiplyScalarAndAdd$3,\n            mul: mul$8,\n            sub: sub$6\n        });\n        function create$7() {\n            var out = new ARRAY_TYPE(6);\n            if (ARRAY_TYPE != Float32Array) {\n                out[1] = 0;\n                out[2] = 0;\n                out[4] = 0;\n                out[5] = 0\n            }\n            out[0] = 1;\n            out[3] = 1;\n            return out\n        }\n        function clone$7(a) {\n            var out = new ARRAY_TYPE(6);\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4];\n            out[5] = a[5];\n            return out\n        }\n        function copy$7(out, a) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4];\n            out[5] = a[5];\n            return out\n        }\n        function identity$4(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out\n        }\n        function fromValues$7(a, b, c, d, tx, ty) {\n            var out = new ARRAY_TYPE(6);\n            out[0] = a;\n            out[1] = b;\n            out[2] = c;\n            out[3] = d;\n            out[4] = tx;\n            out[5] = ty;\n            return out\n        }\n        function set$7(out, a, b, c, d, tx, ty) {\n            out[0] = a;\n            out[1] = b;\n            out[2] = c;\n            out[3] = d;\n            out[4] = tx;\n            out[5] = ty;\n            return out\n        }\n        function invert$4(out, a) {\n            var aa = a[0]\n              , ab = a[1]\n              , ac = a[2]\n              , ad = a[3];\n            var atx = a[4]\n              , aty = a[5];\n            var det = aa * ad - ab * ac;\n            if (!det)\n                return null;\n            det = 1 \/ det;\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out\n        }\n        function determinant$2(a) {\n            return a[0] * a[3] - a[1] * a[2]\n        }\n        function multiply$7(out, a, b) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3]\n              , a4 = a[4]\n              , a5 = a[5];\n            var b0 = b[0]\n              , b1 = b[1]\n              , b2 = b[2]\n              , b3 = b[3]\n              , b4 = b[4]\n              , b5 = b[5];\n            out[0] = a0 * b0 + a2 * b1;\n            out[1] = a1 * b0 + a3 * b1;\n            out[2] = a0 * b2 + a2 * b3;\n            out[3] = a1 * b2 + a3 * b3;\n            out[4] = a0 * b4 + a2 * b5 + a4;\n            out[5] = a1 * b4 + a3 * b5 + a5;\n            return out\n        }\n        function rotate$3(out, a, rad) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3]\n              , a4 = a[4]\n              , a5 = a[5];\n            var s = Math.sin(rad);\n            var c = Math.cos(rad);\n            out[0] = a0 * c + a2 * s;\n            out[1] = a1 * c + a3 * s;\n            out[2] = a0 * -s + a2 * c;\n            out[3] = a1 * -s + a3 * c;\n            out[4] = a4;\n            out[5] = a5;\n            return out\n        }\n        function scale$7(out, a, v) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3]\n              , a4 = a[4]\n              , a5 = a[5];\n            var v0 = v[0]\n              , v1 = v[1];\n            out[0] = a0 * v0;\n            out[1] = a1 * v0;\n            out[2] = a2 * v1;\n            out[3] = a3 * v1;\n            out[4] = a4;\n            out[5] = a5;\n            return out\n        }\n        function translate$3(out, a, v) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3]\n              , a4 = a[4]\n              , a5 = a[5];\n            var v0 = v[0]\n              , v1 = v[1];\n            out[0] = a0;\n            out[1] = a1;\n            out[2] = a2;\n            out[3] = a3;\n            out[4] = a0 * v0 + a2 * v1 + a4;\n            out[5] = a1 * v0 + a3 * v1 + a5;\n            return out\n        }\n        function fromRotation$3(out, rad) {\n            var s = Math.sin(rad)\n              , c = Math.cos(rad);\n            out[0] = c;\n            out[1] = s;\n            out[2] = -s;\n            out[3] = c;\n            out[4] = 0;\n            out[5] = 0;\n            return out\n        }\n        function fromScaling$2(out, v) {\n            out[0] = v[0];\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = v[1];\n            out[4] = 0;\n            out[5] = 0;\n            return out\n        }\n        function fromTranslation$3(out, v) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = v[0];\n            out[5] = v[1];\n            return out\n        }\n        function str$7(a) {\n            return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")"\n        }\n        function frob$2(a) {\n            return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1)\n        }\n        function add$7(out, a, b) {\n            out[0] = a[0] + b[0];\n            out[1] = a[1] + b[1];\n            out[2] = a[2] + b[2];\n            out[3] = a[3] + b[3];\n            out[4] = a[4] + b[4];\n            out[5] = a[5] + b[5];\n            return out\n        }\n        function subtract$5(out, a, b) {\n            out[0] = a[0] - b[0];\n            out[1] = a[1] - b[1];\n            out[2] = a[2] - b[2];\n            out[3] = a[3] - b[3];\n            out[4] = a[4] - b[4];\n            out[5] = a[5] - b[5];\n            return out\n        }\n        function multiplyScalar$2(out, a, b) {\n            out[0] = a[0] * b;\n            out[1] = a[1] * b;\n            out[2] = a[2] * b;\n            out[3] = a[3] * b;\n            out[4] = a[4] * b;\n            out[5] = a[5] * b;\n            return out\n        }\n        function multiplyScalarAndAdd$2(out, a, b, scale) {\n            out[0] = a[0] + b[0] * scale;\n            out[1] = a[1] + b[1] * scale;\n            out[2] = a[2] + b[2] * scale;\n            out[3] = a[3] + b[3] * scale;\n            out[4] = a[4] + b[4] * scale;\n            out[5] = a[5] + b[5] * scale;\n            return out\n        }\n        function exactEquals$7(a, b) {\n            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5]\n        }\n        function equals$7(a, b) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3]\n              , a4 = a[4]\n              , a5 = a[5];\n            var b0 = b[0]\n              , b1 = b[1]\n              , b2 = b[2]\n              , b3 = b[3]\n              , b4 = b[4]\n              , b5 = b[5];\n            return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5))\n        }\n        var mul$7 = multiply$7;\n        var sub$5 = subtract$5;\n        var mat2d = Object.freeze({\n            __proto__: null,\n            create: create$7,\n            clone: clone$7,\n            copy: copy$7,\n            identity: identity$4,\n            fromValues: fromValues$7,\n            set: set$7,\n            invert: invert$4,\n            determinant: determinant$2,\n            multiply: multiply$7,\n            rotate: rotate$3,\n            scale: scale$7,\n            translate: translate$3,\n            fromRotation: fromRotation$3,\n            fromScaling: fromScaling$2,\n            fromTranslation: fromTranslation$3,\n            str: str$7,\n            frob: frob$2,\n            add: add$7,\n            subtract: subtract$5,\n            multiplyScalar: multiplyScalar$2,\n            multiplyScalarAndAdd: multiplyScalarAndAdd$2,\n            exactEquals: exactEquals$7,\n            equals: equals$7,\n            mul: mul$7,\n            sub: sub$5\n        });\n        function create$6() {\n            var out = new ARRAY_TYPE(9);\n            if (ARRAY_TYPE != Float32Array) {\n                out[1] = 0;\n                out[2] = 0;\n                out[3] = 0;\n                out[5] = 0;\n                out[6] = 0;\n                out[7] = 0\n            }\n            out[0] = 1;\n            out[4] = 1;\n            out[8] = 1;\n            return out\n        }\n        function fromMat4$1(out, a) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[4];\n            out[4] = a[5];\n            out[5] = a[6];\n            out[6] = a[8];\n            out[7] = a[9];\n            out[8] = a[10];\n            return out\n        }\n        function clone$6(a) {\n            var out = new ARRAY_TYPE(9);\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4];\n            out[5] = a[5];\n            out[6] = a[6];\n            out[7] = a[7];\n            out[8] = a[8];\n            return out\n        }\n        function copy$6(out, a) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4];\n            out[5] = a[5];\n            out[6] = a[6];\n            out[7] = a[7];\n            out[8] = a[8];\n            return out\n        }\n        function fromValues$6(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n            var out = new ARRAY_TYPE(9);\n            out[0] = m00;\n            out[1] = m01;\n            out[2] = m02;\n            out[3] = m10;\n            out[4] = m11;\n            out[5] = m12;\n            out[6] = m20;\n            out[7] = m21;\n            out[8] = m22;\n            return out\n        }\n        function set$6(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n            out[0] = m00;\n            out[1] = m01;\n            out[2] = m02;\n            out[3] = m10;\n            out[4] = m11;\n            out[5] = m12;\n            out[6] = m20;\n            out[7] = m21;\n            out[8] = m22;\n            return out\n        }\n        function identity$3(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = 1;\n            out[5] = 0;\n            out[6] = 0;\n            out[7] = 0;\n            out[8] = 1;\n            return out\n        }\n        function transpose$1(out, a) {\n            if (out === a) {\n                var a01 = a[1]\n                  , a02 = a[2]\n                  , a12 = a[5];\n                out[1] = a[3];\n                out[2] = a[6];\n                out[3] = a01;\n                out[5] = a[7];\n                out[6] = a02;\n                out[7] = a12\n            } else {\n                out[0] = a[0];\n                out[1] = a[3];\n                out[2] = a[6];\n                out[3] = a[1];\n                out[4] = a[4];\n                out[5] = a[7];\n                out[6] = a[2];\n                out[7] = a[5];\n                out[8] = a[8]\n            }\n            return out\n        }\n        function invert$3(out, a) {\n            var a00 = a[0]\n              , a01 = a[1]\n              , a02 = a[2];\n            var a10 = a[3]\n              , a11 = a[4]\n              , a12 = a[5];\n            var a20 = a[6]\n              , a21 = a[7]\n              , a22 = a[8];\n            var b01 = a22 * a11 - a12 * a21;\n            var b11 = -a22 * a10 + a12 * a20;\n            var b21 = a21 * a10 - a11 * a20;\n            var det = a00 * b01 + a01 * b11 + a02 * b21;\n            if (!det)\n                return null;\n            det = 1 \/ det;\n            out[0] = b01 * det;\n            out[1] = (-a22 * a01 + a02 * a21) * det;\n            out[2] = (a12 * a01 - a02 * a11) * det;\n            out[3] = b11 * det;\n            out[4] = (a22 * a00 - a02 * a20) * det;\n            out[5] = (-a12 * a00 + a02 * a10) * det;\n            out[6] = b21 * det;\n            out[7] = (-a21 * a00 + a01 * a20) * det;\n            out[8] = (a11 * a00 - a01 * a10) * det;\n            return out\n        }\n        function adjoint$1(out, a) {\n            var a00 = a[0]\n              , a01 = a[1]\n              , a02 = a[2];\n            var a10 = a[3]\n              , a11 = a[4]\n              , a12 = a[5];\n            var a20 = a[6]\n              , a21 = a[7]\n              , a22 = a[8];\n            out[0] = a11 * a22 - a12 * a21;\n            out[1] = a02 * a21 - a01 * a22;\n            out[2] = a01 * a12 - a02 * a11;\n            out[3] = a12 * a20 - a10 * a22;\n            out[4] = a00 * a22 - a02 * a20;\n            out[5] = a02 * a10 - a00 * a12;\n            out[6] = a10 * a21 - a11 * a20;\n            out[7] = a01 * a20 - a00 * a21;\n            out[8] = a00 * a11 - a01 * a10;\n            return out\n        }\n        function determinant$1(a) {\n            var a00 = a[0]\n              , a01 = a[1]\n              , a02 = a[2];\n            var a10 = a[3]\n              , a11 = a[4]\n              , a12 = a[5];\n            var a20 = a[6]\n              , a21 = a[7]\n              , a22 = a[8];\n            return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20)\n        }\n        function multiply$6(out, a, b) {\n            var a00 = a[0]\n              , a01 = a[1]\n              , a02 = a[2];\n            var a10 = a[3]\n              , a11 = a[4]\n              , a12 = a[5];\n            var a20 = a[6]\n              , a21 = a[7]\n              , a22 = a[8];\n            var b00 = b[0]\n              , b01 = b[1]\n              , b02 = b[2];\n            var b10 = b[3]\n              , b11 = b[4]\n              , b12 = b[5];\n            var b20 = b[6]\n              , b21 = b[7]\n              , b22 = b[8];\n            out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n            out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n            out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n            out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n            out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n            out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n            out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n            out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n            out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n            return out\n        }\n        function translate$2(out, a, v) {\n            var a00 = a[0]\n              , a01 = a[1]\n              , a02 = a[2]\n              , a10 = a[3]\n              , a11 = a[4]\n              , a12 = a[5]\n              , a20 = a[6]\n              , a21 = a[7]\n              , a22 = a[8]\n              , x = v[0]\n              , y = v[1];\n            out[0] = a00;\n            out[1] = a01;\n            out[2] = a02;\n            out[3] = a10;\n            out[4] = a11;\n            out[5] = a12;\n            out[6] = x * a00 + y * a10 + a20;\n            out[7] = x * a01 + y * a11 + a21;\n            out[8] = x * a02 + y * a12 + a22;\n            return out\n        }\n        function rotate$2(out, a, rad) {\n            var a00 = a[0]\n              , a01 = a[1]\n              , a02 = a[2]\n              , a10 = a[3]\n              , a11 = a[4]\n              , a12 = a[5]\n              , a20 = a[6]\n              , a21 = a[7]\n              , a22 = a[8]\n              , s = Math.sin(rad)\n              , c = Math.cos(rad);\n            out[0] = c * a00 + s * a10;\n            out[1] = c * a01 + s * a11;\n            out[2] = c * a02 + s * a12;\n            out[3] = c * a10 - s * a00;\n            out[4] = c * a11 - s * a01;\n            out[5] = c * a12 - s * a02;\n            out[6] = a20;\n            out[7] = a21;\n            out[8] = a22;\n            return out\n        }\n        function scale$6(out, a, v) {\n            var x = v[0]\n              , y = v[1];\n            out[0] = x * a[0];\n            out[1] = x * a[1];\n            out[2] = x * a[2];\n            out[3] = y * a[3];\n            out[4] = y * a[4];\n            out[5] = y * a[5];\n            out[6] = a[6];\n            out[7] = a[7];\n            out[8] = a[8];\n            return out\n        }\n        function fromTranslation$2(out, v) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = 1;\n            out[5] = 0;\n            out[6] = v[0];\n            out[7] = v[1];\n            out[8] = 1;\n            return out\n        }\n        function fromRotation$2(out, rad) {\n            var s = Math.sin(rad)\n              , c = Math.cos(rad);\n            out[0] = c;\n            out[1] = s;\n            out[2] = 0;\n            out[3] = -s;\n            out[4] = c;\n            out[5] = 0;\n            out[6] = 0;\n            out[7] = 0;\n            out[8] = 1;\n            return out\n        }\n        function fromScaling$1(out, v) {\n            out[0] = v[0];\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = v[1];\n            out[5] = 0;\n            out[6] = 0;\n            out[7] = 0;\n            out[8] = 1;\n            return out\n        }\n        function fromMat2d(out, a) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = 0;\n            out[3] = a[2];\n            out[4] = a[3];\n            out[5] = 0;\n            out[6] = a[4];\n            out[7] = a[5];\n            out[8] = 1;\n            return out\n        }\n        function fromQuat$1(out, q) {\n            var x = q[0]\n              , y = q[1]\n              , z = q[2]\n              , w = q[3];\n            var x2 = x + x;\n            var y2 = y + y;\n            var z2 = z + z;\n            var xx = x * x2;\n            var yx = y * x2;\n            var yy = y * y2;\n            var zx = z * x2;\n            var zy = z * y2;\n            var zz = z * z2;\n            var wx = w * x2;\n            var wy = w * y2;\n            var wz = w * z2;\n            out[0] = 1 - yy - zz;\n            out[3] = yx - wz;\n            out[6] = zx + wy;\n            out[1] = yx + wz;\n            out[4] = 1 - xx - zz;\n            out[7] = zy - wx;\n            out[2] = zx - wy;\n            out[5] = zy + wx;\n            out[8] = 1 - xx - yy;\n            return out\n        }\n        function normalFromMat4(out, a) {\n            var a00 = a[0]\n              , a01 = a[1]\n              , a02 = a[2]\n              , a03 = a[3];\n            var a10 = a[4]\n              , a11 = a[5]\n              , a12 = a[6]\n              , a13 = a[7];\n            var a20 = a[8]\n              , a21 = a[9]\n              , a22 = a[10]\n              , a23 = a[11];\n            var a30 = a[12]\n              , a31 = a[13]\n              , a32 = a[14]\n              , a33 = a[15];\n            var b00 = a00 * a11 - a01 * a10;\n            var b01 = a00 * a12 - a02 * a10;\n            var b02 = a00 * a13 - a03 * a10;\n            var b03 = a01 * a12 - a02 * a11;\n            var b04 = a01 * a13 - a03 * a11;\n            var b05 = a02 * a13 - a03 * a12;\n            var b06 = a20 * a31 - a21 * a30;\n            var b07 = a20 * a32 - a22 * a30;\n            var b08 = a20 * a33 - a23 * a30;\n            var b09 = a21 * a32 - a22 * a31;\n            var b10 = a21 * a33 - a23 * a31;\n            var b11 = a22 * a33 - a23 * a32;\n            var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n            if (!det)\n                return null;\n            det = 1 \/ det;\n            out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n            out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n            out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n            out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n            out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n            out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n            out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n            out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n            out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n            return out\n        }\n        function projection(out, width, height) {\n            out[0] = 2 \/ width;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = -2 \/ height;\n            out[5] = 0;\n            out[6] = -1;\n            out[7] = 1;\n            out[8] = 1;\n            return out\n        }\n        function str$6(a) {\n            return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")"\n        }\n        function frob$1(a) {\n            return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8])\n        }\n        function add$6(out, a, b) {\n            out[0] = a[0] + b[0];\n            out[1] = a[1] + b[1];\n            out[2] = a[2] + b[2];\n            out[3] = a[3] + b[3];\n            out[4] = a[4] + b[4];\n            out[5] = a[5] + b[5];\n            out[6] = a[6] + b[6];\n            out[7] = a[7] + b[7];\n            out[8] = a[8] + b[8];\n            return out\n        }\n        function subtract$4(out, a, b) {\n            out[0] = a[0] - b[0];\n            out[1] = a[1] - b[1];\n            out[2] = a[2] - b[2];\n            out[3] = a[3] - b[3];\n            out[4] = a[4] - b[4];\n            out[5] = a[5] - b[5];\n            out[6] = a[6] - b[6];\n            out[7] = a[7] - b[7];\n            out[8] = a[8] - b[8];\n            return out\n        }\n        function multiplyScalar$1(out, a, b) {\n            out[0] = a[0] * b;\n            out[1] = a[1] * b;\n            out[2] = a[2] * b;\n            out[3] = a[3] * b;\n            out[4] = a[4] * b;\n            out[5] = a[5] * b;\n            out[6] = a[6] * b;\n            out[7] = a[7] * b;\n            out[8] = a[8] * b;\n            return out\n        }\n        function multiplyScalarAndAdd$1(out, a, b, scale) {\n            out[0] = a[0] + b[0] * scale;\n            out[1] = a[1] + b[1] * scale;\n            out[2] = a[2] + b[2] * scale;\n            out[3] = a[3] + b[3] * scale;\n            out[4] = a[4] + b[4] * scale;\n            out[5] = a[5] + b[5] * scale;\n            out[6] = a[6] + b[6] * scale;\n            out[7] = a[7] + b[7] * scale;\n            out[8] = a[8] + b[8] * scale;\n            return out\n        }\n        function exactEquals$6(a, b) {\n            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8]\n        }\n        function equals$6(a, b) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3]\n              , a4 = a[4]\n              , a5 = a[5]\n              , a6 = a[6]\n              , a7 = a[7]\n              , a8 = a[8];\n            var b0 = b[0]\n              , b1 = b[1]\n              , b2 = b[2]\n              , b3 = b[3]\n              , b4 = b[4]\n              , b5 = b[5]\n              , b6 = b[6]\n              , b7 = b[7]\n              , b8 = b[8];\n            return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8))\n        }\n        var mul$6 = multiply$6;\n        var sub$4 = subtract$4;\n        var mat3 = Object.freeze({\n            __proto__: null,\n            create: create$6,\n            fromMat4: fromMat4$1,\n            clone: clone$6,\n            copy: copy$6,\n            fromValues: fromValues$6,\n            set: set$6,\n            identity: identity$3,\n            transpose: transpose$1,\n            invert: invert$3,\n            adjoint: adjoint$1,\n            determinant: determinant$1,\n            multiply: multiply$6,\n            translate: translate$2,\n            rotate: rotate$2,\n            scale: scale$6,\n            fromTranslation: fromTranslation$2,\n            fromRotation: fromRotation$2,\n            fromScaling: fromScaling$1,\n            fromMat2d: fromMat2d,\n            fromQuat: fromQuat$1,\n            normalFromMat4: normalFromMat4,\n            projection: projection,\n            str: str$6,\n            frob: frob$1,\n            add: add$6,\n            subtract: subtract$4,\n            multiplyScalar: multiplyScalar$1,\n            multiplyScalarAndAdd: multiplyScalarAndAdd$1,\n            exactEquals: exactEquals$6,\n            equals: equals$6,\n            mul: mul$6,\n            sub: sub$4\n        });\n        function create$5() {\n            var out = new ARRAY_TYPE(16);\n            if (ARRAY_TYPE != Float32Array) {\n                out[1] = 0;\n                out[2] = 0;\n                out[3] = 0;\n                out[4] = 0;\n                out[6] = 0;\n                out[7] = 0;\n                out[8] = 0;\n                out[9] = 0;\n                out[11] = 0;\n                out[12] = 0;\n                out[13] = 0;\n                out[14] = 0\n            }\n            out[0] = 1;\n            out[5] = 1;\n            out[10] = 1;\n            out[15] = 1;\n            return out\n        }\n        function clone$5(a) {\n            var out = new ARRAY_TYPE(16);\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4];\n            out[5] = a[5];\n            out[6] = a[6];\n            out[7] = a[7];\n            out[8] = a[8];\n            out[9] = a[9];\n            out[10] = a[10];\n            out[11] = a[11];\n            out[12] = a[12];\n            out[13] = a[13];\n            out[14] = a[14];\n            out[15] = a[15];\n            return out\n        }\n        function copy$5(out, a) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4];\n            out[5] = a[5];\n            out[6] = a[6];\n            out[7] = a[7];\n            out[8] = a[8];\n            out[9] = a[9];\n            out[10] = a[10];\n            out[11] = a[11];\n            out[12] = a[12];\n            out[13] = a[13];\n            out[14] = a[14];\n            out[15] = a[15];\n            return out\n        }\n        function fromValues$5(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n            var out = new ARRAY_TYPE(16);\n            out[0] = m00;\n            out[1] = m01;\n            out[2] = m02;\n            out[3] = m03;\n            out[4] = m10;\n            out[5] = m11;\n            out[6] = m12;\n            out[7] = m13;\n            out[8] = m20;\n            out[9] = m21;\n            out[10] = m22;\n            out[11] = m23;\n            out[12] = m30;\n            out[13] = m31;\n            out[14] = m32;\n            out[15] = m33;\n            return out\n        }\n        function set$5(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n            out[0] = m00;\n            out[1] = m01;\n            out[2] = m02;\n            out[3] = m03;\n            out[4] = m10;\n            out[5] = m11;\n            out[6] = m12;\n            out[7] = m13;\n            out[8] = m20;\n            out[9] = m21;\n            out[10] = m22;\n            out[11] = m23;\n            out[12] = m30;\n            out[13] = m31;\n            out[14] = m32;\n            out[15] = m33;\n            return out\n        }\n        function identity$2(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = 0;\n            out[5] = 1;\n            out[6] = 0;\n            out[7] = 0;\n            out[8] = 0;\n            out[9] = 0;\n            out[10] = 1;\n            out[11] = 0;\n            out[12] = 0;\n            out[13] = 0;\n            out[14] = 0;\n            out[15] = 1;\n            return out\n        }\n        function transpose(out, a) {\n            if (out === a) {\n                var a01 = a[1]\n                  , a02 = a[2]\n                  , a03 = a[3];\n                var a12 = a[6]\n                  , a13 = a[7];\n                var a23 = a[11];\n                out[1] = a[4];\n                out[2] = a[8];\n                out[3] = a[12];\n                out[4] = a01;\n                out[6] = a[9];\n                out[7] = a[13];\n                out[8] = a02;\n                out[9] = a12;\n                out[11] = a[14];\n                out[12] = a03;\n                out[13] = a13;\n                out[14] = a23\n            } else {\n                out[0] = a[0];\n                out[1] = a[4];\n                out[2] = a[8];\n                out[3] = a[12];\n                out[4] = a[1];\n                out[5] = a[5];\n                out[6] = a[9];\n                out[7] = a[13];\n                out[8] = a[2];\n                out[9] = a[6];\n                out[10] = a[10];\n                out[11] = a[14];\n                out[12] = a[3];\n                out[13] = a[7];\n                out[14] = a[11];\n                out[15] = a[15]\n            }\n            return out\n        }\n        function invert$2(out, a) {\n            var a00 = a[0]\n              , a01 = a[1]\n              , a02 = a[2]\n              , a03 = a[3];\n            var a10 = a[4]\n              , a11 = a[5]\n              , a12 = a[6]\n              , a13 = a[7];\n            var a20 = a[8]\n              , a21 = a[9]\n              , a22 = a[10]\n              , a23 = a[11];\n            var a30 = a[12]\n              , a31 = a[13]\n              , a32 = a[14]\n              , a33 = a[15];\n            var b00 = a00 * a11 - a01 * a10;\n            var b01 = a00 * a12 - a02 * a10;\n            var b02 = a00 * a13 - a03 * a10;\n            var b03 = a01 * a12 - a02 * a11;\n            var b04 = a01 * a13 - a03 * a11;\n            var b05 = a02 * a13 - a03 * a12;\n            var b06 = a20 * a31 - a21 * a30;\n            var b07 = a20 * a32 - a22 * a30;\n            var b08 = a20 * a33 - a23 * a30;\n            var b09 = a21 * a32 - a22 * a31;\n            var b10 = a21 * a33 - a23 * a31;\n            var b11 = a22 * a33 - a23 * a32;\n            var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n            if (!det)\n                return null;\n            det = 1 \/ det;\n            out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n            out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n            out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n            out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n            out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n            out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n            out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n            out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n            out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n            out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n            out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n            out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n            out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n            out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n            out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n            out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n            return out\n        }\n        function adjoint(out, a) {\n            var a00 = a[0]\n              , a01 = a[1]\n              , a02 = a[2]\n              , a03 = a[3];\n            var a10 = a[4]\n              , a11 = a[5]\n              , a12 = a[6]\n              , a13 = a[7];\n            var a20 = a[8]\n              , a21 = a[9]\n              , a22 = a[10]\n              , a23 = a[11];\n            var a30 = a[12]\n              , a31 = a[13]\n              , a32 = a[14]\n              , a33 = a[15];\n            var b00 = a00 * a11 - a01 * a10;\n            var b01 = a00 * a12 - a02 * a10;\n            var b02 = a00 * a13 - a03 * a10;\n            var b03 = a01 * a12 - a02 * a11;\n            var b04 = a01 * a13 - a03 * a11;\n            var b05 = a02 * a13 - a03 * a12;\n            var b06 = a20 * a31 - a21 * a30;\n            var b07 = a20 * a32 - a22 * a30;\n            var b08 = a20 * a33 - a23 * a30;\n            var b09 = a21 * a32 - a22 * a31;\n            var b10 = a21 * a33 - a23 * a31;\n            var b11 = a22 * a33 - a23 * a32;\n            out[0] = a11 * b11 - a12 * b10 + a13 * b09;\n            out[1] = a02 * b10 - a01 * b11 - a03 * b09;\n            out[2] = a31 * b05 - a32 * b04 + a33 * b03;\n            out[3] = a22 * b04 - a21 * b05 - a23 * b03;\n            out[4] = a12 * b08 - a10 * b11 - a13 * b07;\n            out[5] = a00 * b11 - a02 * b08 + a03 * b07;\n            out[6] = a32 * b02 - a30 * b05 - a33 * b01;\n            out[7] = a20 * b05 - a22 * b02 + a23 * b01;\n            out[8] = a10 * b10 - a11 * b08 + a13 * b06;\n            out[9] = a01 * b08 - a00 * b10 - a03 * b06;\n            out[10] = a30 * b04 - a31 * b02 + a33 * b00;\n            out[11] = a21 * b02 - a20 * b04 - a23 * b00;\n            out[12] = a11 * b07 - a10 * b09 - a12 * b06;\n            out[13] = a00 * b09 - a01 * b07 + a02 * b06;\n            out[14] = a31 * b01 - a30 * b03 - a32 * b00;\n            out[15] = a20 * b03 - a21 * b01 + a22 * b00;\n            return out\n        }\n        function determinant(a) {\n            var a00 = a[0]\n              , a01 = a[1]\n              , a02 = a[2]\n              , a03 = a[3];\n            var a10 = a[4]\n              , a11 = a[5]\n              , a12 = a[6]\n              , a13 = a[7];\n            var a20 = a[8]\n              , a21 = a[9]\n              , a22 = a[10]\n              , a23 = a[11];\n            var a30 = a[12]\n              , a31 = a[13]\n              , a32 = a[14]\n              , a33 = a[15];\n            var b0 = a00 * a11 - a01 * a10;\n            var b1 = a00 * a12 - a02 * a10;\n            var b2 = a01 * a12 - a02 * a11;\n            var b3 = a20 * a31 - a21 * a30;\n            var b4 = a20 * a32 - a22 * a30;\n            var b5 = a21 * a32 - a22 * a31;\n            var b6 = a00 * b5 - a01 * b4 + a02 * b3;\n            var b7 = a10 * b5 - a11 * b4 + a12 * b3;\n            var b8 = a20 * b2 - a21 * b1 + a22 * b0;\n            var b9 = a30 * b2 - a31 * b1 + a32 * b0;\n            return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9\n        }\n        function multiply$5(out, a, b) {\n            var a00 = a[0]\n              , a01 = a[1]\n              , a02 = a[2]\n              , a03 = a[3];\n            var a10 = a[4]\n              , a11 = a[5]\n              , a12 = a[6]\n              , a13 = a[7];\n            var a20 = a[8]\n              , a21 = a[9]\n              , a22 = a[10]\n              , a23 = a[11];\n            var a30 = a[12]\n              , a31 = a[13]\n              , a32 = a[14]\n              , a33 = a[15];\n            var b0 = b[0]\n              , b1 = b[1]\n              , b2 = b[2]\n              , b3 = b[3];\n            out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n            b0 = b[4];\n            b1 = b[5];\n            b2 = b[6];\n            b3 = b[7];\n            out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n            b0 = b[8];\n            b1 = b[9];\n            b2 = b[10];\n            b3 = b[11];\n            out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n            b0 = b[12];\n            b1 = b[13];\n            b2 = b[14];\n            b3 = b[15];\n            out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n            return out\n        }\n        function translate$1(out, a, v) {\n            var x = v[0]\n              , y = v[1]\n              , z = v[2];\n            var a00, a01, a02, a03;\n            var a10, a11, a12, a13;\n            var a20, a21, a22, a23;\n            if (a === out) {\n                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15]\n            } else {\n                a00 = a[0];\n                a01 = a[1];\n                a02 = a[2];\n                a03 = a[3];\n                a10 = a[4];\n                a11 = a[5];\n                a12 = a[6];\n                a13 = a[7];\n                a20 = a[8];\n                a21 = a[9];\n                a22 = a[10];\n                a23 = a[11];\n                out[0] = a00;\n                out[1] = a01;\n                out[2] = a02;\n                out[3] = a03;\n                out[4] = a10;\n                out[5] = a11;\n                out[6] = a12;\n                out[7] = a13;\n                out[8] = a20;\n                out[9] = a21;\n                out[10] = a22;\n                out[11] = a23;\n                out[12] = a00 * x + a10 * y + a20 * z + a[12];\n                out[13] = a01 * x + a11 * y + a21 * z + a[13];\n                out[14] = a02 * x + a12 * y + a22 * z + a[14];\n                out[15] = a03 * x + a13 * y + a23 * z + a[15]\n            }\n            return out\n        }\n        function scale$5(out, a, v) {\n            var x = v[0]\n              , y = v[1]\n              , z = v[2];\n            out[0] = a[0] * x;\n            out[1] = a[1] * x;\n            out[2] = a[2] * x;\n            out[3] = a[3] * x;\n            out[4] = a[4] * y;\n            out[5] = a[5] * y;\n            out[6] = a[6] * y;\n            out[7] = a[7] * y;\n            out[8] = a[8] * z;\n            out[9] = a[9] * z;\n            out[10] = a[10] * z;\n            out[11] = a[11] * z;\n            out[12] = a[12];\n            out[13] = a[13];\n            out[14] = a[14];\n            out[15] = a[15];\n            return out\n        }\n        function rotate$1(out, a, rad, axis) {\n            var x = axis[0]\n              , y = axis[1]\n              , z = axis[2];\n            var len = Math.hypot(x, y, z);\n            var s, c, t;\n            var a00, a01, a02, a03;\n            var a10, a11, a12, a13;\n            var a20, a21, a22, a23;\n            var b00, b01, b02;\n            var b10, b11, b12;\n            var b20, b21, b22;\n            if (len < EPSILON)\n                return null;\n            len = 1 \/ len;\n            x *= len;\n            y *= len;\n            z *= len;\n            s = Math.sin(rad);\n            c = Math.cos(rad);\n            t = 1 - c;\n            a00 = a[0];\n            a01 = a[1];\n            a02 = a[2];\n            a03 = a[3];\n            a10 = a[4];\n            a11 = a[5];\n            a12 = a[6];\n            a13 = a[7];\n            a20 = a[8];\n            a21 = a[9];\n            a22 = a[10];\n            a23 = a[11];\n            b00 = x * x * t + c;\n            b01 = y * x * t + z * s;\n            b02 = z * x * t - y * s;\n            b10 = x * y * t - z * s;\n            b11 = y * y * t + c;\n            b12 = z * y * t + x * s;\n            b20 = x * z * t + y * s;\n            b21 = y * z * t - x * s;\n            b22 = z * z * t + c;\n            out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n            out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n            out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n            out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n            out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n            out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n            out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n            out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n            out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n            out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n            out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n            out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n            if (a !== out) {\n                out[12] = a[12];\n                out[13] = a[13];\n                out[14] = a[14];\n                out[15] = a[15]\n            }\n            return out\n        }\n        function rotateX$3(out, a, rad) {\n            var s = Math.sin(rad);\n            var c = Math.cos(rad);\n            var a10 = a[4];\n            var a11 = a[5];\n            var a12 = a[6];\n            var a13 = a[7];\n            var a20 = a[8];\n            var a21 = a[9];\n            var a22 = a[10];\n            var a23 = a[11];\n            if (a !== out) {\n                out[0] = a[0];\n                out[1] = a[1];\n                out[2] = a[2];\n                out[3] = a[3];\n                out[12] = a[12];\n                out[13] = a[13];\n                out[14] = a[14];\n                out[15] = a[15]\n            }\n            out[4] = a10 * c + a20 * s;\n            out[5] = a11 * c + a21 * s;\n            out[6] = a12 * c + a22 * s;\n            out[7] = a13 * c + a23 * s;\n            out[8] = a20 * c - a10 * s;\n            out[9] = a21 * c - a11 * s;\n            out[10] = a22 * c - a12 * s;\n            out[11] = a23 * c - a13 * s;\n            return out\n        }\n        function rotateY$3(out, a, rad) {\n            var s = Math.sin(rad);\n            var c = Math.cos(rad);\n            var a00 = a[0];\n            var a01 = a[1];\n            var a02 = a[2];\n            var a03 = a[3];\n            var a20 = a[8];\n            var a21 = a[9];\n            var a22 = a[10];\n            var a23 = a[11];\n            if (a !== out) {\n                out[4] = a[4];\n                out[5] = a[5];\n                out[6] = a[6];\n                out[7] = a[7];\n                out[12] = a[12];\n                out[13] = a[13];\n                out[14] = a[14];\n                out[15] = a[15]\n            }\n            out[0] = a00 * c - a20 * s;\n            out[1] = a01 * c - a21 * s;\n            out[2] = a02 * c - a22 * s;\n            out[3] = a03 * c - a23 * s;\n            out[8] = a00 * s + a20 * c;\n            out[9] = a01 * s + a21 * c;\n            out[10] = a02 * s + a22 * c;\n            out[11] = a03 * s + a23 * c;\n            return out\n        }\n        function rotateZ$3(out, a, rad) {\n            var s = Math.sin(rad);\n            var c = Math.cos(rad);\n            var a00 = a[0];\n            var a01 = a[1];\n            var a02 = a[2];\n            var a03 = a[3];\n            var a10 = a[4];\n            var a11 = a[5];\n            var a12 = a[6];\n            var a13 = a[7];\n            if (a !== out) {\n                out[8] = a[8];\n                out[9] = a[9];\n                out[10] = a[10];\n                out[11] = a[11];\n                out[12] = a[12];\n                out[13] = a[13];\n                out[14] = a[14];\n                out[15] = a[15]\n            }\n            out[0] = a00 * c + a10 * s;\n            out[1] = a01 * c + a11 * s;\n            out[2] = a02 * c + a12 * s;\n            out[3] = a03 * c + a13 * s;\n            out[4] = a10 * c - a00 * s;\n            out[5] = a11 * c - a01 * s;\n            out[6] = a12 * c - a02 * s;\n            out[7] = a13 * c - a03 * s;\n            return out\n        }\n        function fromTranslation$1(out, v) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = 0;\n            out[5] = 1;\n            out[6] = 0;\n            out[7] = 0;\n            out[8] = 0;\n            out[9] = 0;\n            out[10] = 1;\n            out[11] = 0;\n            out[12] = v[0];\n            out[13] = v[1];\n            out[14] = v[2];\n            out[15] = 1;\n            return out\n        }\n        function fromScaling(out, v) {\n            out[0] = v[0];\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = 0;\n            out[5] = v[1];\n            out[6] = 0;\n            out[7] = 0;\n            out[8] = 0;\n            out[9] = 0;\n            out[10] = v[2];\n            out[11] = 0;\n            out[12] = 0;\n            out[13] = 0;\n            out[14] = 0;\n            out[15] = 1;\n            return out\n        }\n        function fromRotation$1(out, rad, axis) {\n            var x = axis[0]\n              , y = axis[1]\n              , z = axis[2];\n            var len = Math.hypot(x, y, z);\n            var s, c, t;\n            if (len < EPSILON)\n                return null;\n            len = 1 \/ len;\n            x *= len;\n            y *= len;\n            z *= len;\n            s = Math.sin(rad);\n            c = Math.cos(rad);\n            t = 1 - c;\n            out[0] = x * x * t + c;\n            out[1] = y * x * t + z * s;\n            out[2] = z * x * t - y * s;\n            out[3] = 0;\n            out[4] = x * y * t - z * s;\n            out[5] = y * y * t + c;\n            out[6] = z * y * t + x * s;\n            out[7] = 0;\n            out[8] = x * z * t + y * s;\n            out[9] = y * z * t - x * s;\n            out[10] = z * z * t + c;\n            out[11] = 0;\n            out[12] = 0;\n            out[13] = 0;\n            out[14] = 0;\n            out[15] = 1;\n            return out\n        }\n        function fromXRotation(out, rad) {\n            var s = Math.sin(rad);\n            var c = Math.cos(rad);\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = 0;\n            out[5] = c;\n            out[6] = s;\n            out[7] = 0;\n            out[8] = 0;\n            out[9] = -s;\n            out[10] = c;\n            out[11] = 0;\n            out[12] = 0;\n            out[13] = 0;\n            out[14] = 0;\n            out[15] = 1;\n            return out\n        }\n        function fromYRotation(out, rad) {\n            var s = Math.sin(rad);\n            var c = Math.cos(rad);\n            out[0] = c;\n            out[1] = 0;\n            out[2] = -s;\n            out[3] = 0;\n            out[4] = 0;\n            out[5] = 1;\n            out[6] = 0;\n            out[7] = 0;\n            out[8] = s;\n            out[9] = 0;\n            out[10] = c;\n            out[11] = 0;\n            out[12] = 0;\n            out[13] = 0;\n            out[14] = 0;\n            out[15] = 1;\n            return out\n        }\n        function fromZRotation(out, rad) {\n            var s = Math.sin(rad);\n            var c = Math.cos(rad);\n            out[0] = c;\n            out[1] = s;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = -s;\n            out[5] = c;\n            out[6] = 0;\n            out[7] = 0;\n            out[8] = 0;\n            out[9] = 0;\n            out[10] = 1;\n            out[11] = 0;\n            out[12] = 0;\n            out[13] = 0;\n            out[14] = 0;\n            out[15] = 1;\n            return out\n        }\n        function fromRotationTranslation$1(out, q, v) {\n            var x = q[0]\n              , y = q[1]\n              , z = q[2]\n              , w = q[3];\n            var x2 = x + x;\n            var y2 = y + y;\n            var z2 = z + z;\n            var xx = x * x2;\n            var xy = x * y2;\n            var xz = x * z2;\n            var yy = y * y2;\n            var yz = y * z2;\n            var zz = z * z2;\n            var wx = w * x2;\n            var wy = w * y2;\n            var wz = w * z2;\n            out[0] = 1 - (yy + zz);\n            out[1] = xy + wz;\n            out[2] = xz - wy;\n            out[3] = 0;\n            out[4] = xy - wz;\n            out[5] = 1 - (xx + zz);\n            out[6] = yz + wx;\n            out[7] = 0;\n            out[8] = xz + wy;\n            out[9] = yz - wx;\n            out[10] = 1 - (xx + yy);\n            out[11] = 0;\n            out[12] = v[0];\n            out[13] = v[1];\n            out[14] = v[2];\n            out[15] = 1;\n            return out\n        }\n        function fromQuat2(out, a) {\n            var translation = new ARRAY_TYPE(3);\n            var bx = -a[0]\n              , by = -a[1]\n              , bz = -a[2]\n              , bw = a[3]\n              , ax = a[4]\n              , ay = a[5]\n              , az = a[6]\n              , aw = a[7];\n            var magnitude = bx * bx + by * by + bz * bz + bw * bw;\n            if (magnitude > 0) {\n                translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 \/ magnitude;\n                translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 \/ magnitude;\n                translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 \/ magnitude\n            } else {\n                translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n                translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n                translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2\n            }\n            fromRotationTranslation$1(out, a, translation);\n            return out\n        }\n        function getTranslation$1(out, mat) {\n            out[0] = mat[12];\n            out[1] = mat[13];\n            out[2] = mat[14];\n            return out\n        }\n        function getScaling(out, mat) {\n            var m11 = mat[0];\n            var m12 = mat[1];\n            var m13 = mat[2];\n            var m21 = mat[4];\n            var m22 = mat[5];\n            var m23 = mat[6];\n            var m31 = mat[8];\n            var m32 = mat[9];\n            var m33 = mat[10];\n            out[0] = Math.hypot(m11, m12, m13);\n            out[1] = Math.hypot(m21, m22, m23);\n            out[2] = Math.hypot(m31, m32, m33);\n            return out\n        }\n        function getRotation(out, mat) {\n            var scaling = new ARRAY_TYPE(3);\n            getScaling(scaling, mat);\n            var is1 = 1 \/ scaling[0];\n            var is2 = 1 \/ scaling[1];\n            var is3 = 1 \/ scaling[2];\n            var sm11 = mat[0] * is1;\n            var sm12 = mat[1] * is2;\n            var sm13 = mat[2] * is3;\n            var sm21 = mat[4] * is1;\n            var sm22 = mat[5] * is2;\n            var sm23 = mat[6] * is3;\n            var sm31 = mat[8] * is1;\n            var sm32 = mat[9] * is2;\n            var sm33 = mat[10] * is3;\n            var trace = sm11 + sm22 + sm33;\n            var S = 0;\n            if (trace > 0) {\n                S = Math.sqrt(trace + 1) * 2;\n                out[3] = .25 * S;\n                out[0] = (sm23 - sm32) \/ S;\n                out[1] = (sm31 - sm13) \/ S;\n                out[2] = (sm12 - sm21) \/ S\n            } else if (sm11 > sm22 && sm11 > sm33) {\n                S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;\n                out[3] = (sm23 - sm32) \/ S;\n                out[0] = .25 * S;\n                out[1] = (sm12 + sm21) \/ S;\n                out[2] = (sm31 + sm13) \/ S\n            } else if (sm22 > sm33) {\n                S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;\n                out[3] = (sm31 - sm13) \/ S;\n                out[0] = (sm12 + sm21) \/ S;\n                out[1] = .25 * S;\n                out[2] = (sm23 + sm32) \/ S\n            } else {\n                S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;\n                out[3] = (sm12 - sm21) \/ S;\n                out[0] = (sm31 + sm13) \/ S;\n                out[1] = (sm23 + sm32) \/ S;\n                out[2] = .25 * S\n            }\n            return out\n        }\n        function decompose(out_r, out_t, out_s, mat) {\n            out_t[0] = mat[12];\n            out_t[1] = mat[13];\n            out_t[2] = mat[14];\n            var m11 = mat[0];\n            var m12 = mat[1];\n            var m13 = mat[2];\n            var m21 = mat[4];\n            var m22 = mat[5];\n            var m23 = mat[6];\n            var m31 = mat[8];\n            var m32 = mat[9];\n            var m33 = mat[10];\n            out_s[0] = Math.hypot(m11, m12, m13);\n            out_s[1] = Math.hypot(m21, m22, m23);\n            out_s[2] = Math.hypot(m31, m32, m33);\n            var is1 = 1 \/ out_s[0];\n            var is2 = 1 \/ out_s[1];\n            var is3 = 1 \/ out_s[2];\n            var sm11 = m11 * is1;\n            var sm12 = m12 * is2;\n            var sm13 = m13 * is3;\n            var sm21 = m21 * is1;\n            var sm22 = m22 * is2;\n            var sm23 = m23 * is3;\n            var sm31 = m31 * is1;\n            var sm32 = m32 * is2;\n            var sm33 = m33 * is3;\n            var trace = sm11 + sm22 + sm33;\n            var S = 0;\n            if (trace > 0) {\n                S = Math.sqrt(trace + 1) * 2;\n                out_r[3] = .25 * S;\n                out_r[0] = (sm23 - sm32) \/ S;\n                out_r[1] = (sm31 - sm13) \/ S;\n                out_r[2] = (sm12 - sm21) \/ S\n            } else if (sm11 > sm22 && sm11 > sm33) {\n                S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;\n                out_r[3] = (sm23 - sm32) \/ S;\n                out_r[0] = .25 * S;\n                out_r[1] = (sm12 + sm21) \/ S;\n                out_r[2] = (sm31 + sm13) \/ S\n            } else if (sm22 > sm33) {\n                S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;\n                out_r[3] = (sm31 - sm13) \/ S;\n                out_r[0] = (sm12 + sm21) \/ S;\n                out_r[1] = .25 * S;\n                out_r[2] = (sm23 + sm32) \/ S\n            } else {\n                S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;\n                out_r[3] = (sm12 - sm21) \/ S;\n                out_r[0] = (sm31 + sm13) \/ S;\n                out_r[1] = (sm23 + sm32) \/ S;\n                out_r[2] = .25 * S\n            }\n            return out_r\n        }\n        function fromRotationTranslationScale(out, q, v, s) {\n            var x = q[0]\n              , y = q[1]\n              , z = q[2]\n              , w = q[3];\n            var x2 = x + x;\n            var y2 = y + y;\n            var z2 = z + z;\n            var xx = x * x2;\n            var xy = x * y2;\n            var xz = x * z2;\n            var yy = y * y2;\n            var yz = y * z2;\n            var zz = z * z2;\n            var wx = w * x2;\n            var wy = w * y2;\n            var wz = w * z2;\n            var sx = s[0];\n            var sy = s[1];\n            var sz = s[2];\n            out[0] = (1 - (yy + zz)) * sx;\n            out[1] = (xy + wz) * sx;\n            out[2] = (xz - wy) * sx;\n            out[3] = 0;\n            out[4] = (xy - wz) * sy;\n            out[5] = (1 - (xx + zz)) * sy;\n            out[6] = (yz + wx) * sy;\n            out[7] = 0;\n            out[8] = (xz + wy) * sz;\n            out[9] = (yz - wx) * sz;\n            out[10] = (1 - (xx + yy)) * sz;\n            out[11] = 0;\n            out[12] = v[0];\n            out[13] = v[1];\n            out[14] = v[2];\n            out[15] = 1;\n            return out\n        }\n        function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n            var x = q[0]\n              , y = q[1]\n              , z = q[2]\n              , w = q[3];\n            var x2 = x + x;\n            var y2 = y + y;\n            var z2 = z + z;\n            var xx = x * x2;\n            var xy = x * y2;\n            var xz = x * z2;\n            var yy = y * y2;\n            var yz = y * z2;\n            var zz = z * z2;\n            var wx = w * x2;\n            var wy = w * y2;\n            var wz = w * z2;\n            var sx = s[0];\n            var sy = s[1];\n            var sz = s[2];\n            var ox = o[0];\n            var oy = o[1];\n            var oz = o[2];\n            var out0 = (1 - (yy + zz)) * sx;\n            var out1 = (xy + wz) * sx;\n            var out2 = (xz - wy) * sx;\n            var out4 = (xy - wz) * sy;\n            var out5 = (1 - (xx + zz)) * sy;\n            var out6 = (yz + wx) * sy;\n            var out8 = (xz + wy) * sz;\n            var out9 = (yz - wx) * sz;\n            var out10 = (1 - (xx + yy)) * sz;\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = 0;\n            out[4] = out4;\n            out[5] = out5;\n            out[6] = out6;\n            out[7] = 0;\n            out[8] = out8;\n            out[9] = out9;\n            out[10] = out10;\n            out[11] = 0;\n            out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n            out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n            out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n            out[15] = 1;\n            return out\n        }\n        function fromQuat(out, q) {\n            var x = q[0]\n              , y = q[1]\n              , z = q[2]\n              , w = q[3];\n            var x2 = x + x;\n            var y2 = y + y;\n            var z2 = z + z;\n            var xx = x * x2;\n            var yx = y * x2;\n            var yy = y * y2;\n            var zx = z * x2;\n            var zy = z * y2;\n            var zz = z * z2;\n            var wx = w * x2;\n            var wy = w * y2;\n            var wz = w * z2;\n            out[0] = 1 - yy - zz;\n            out[1] = yx + wz;\n            out[2] = zx - wy;\n            out[3] = 0;\n            out[4] = yx - wz;\n            out[5] = 1 - xx - zz;\n            out[6] = zy + wx;\n            out[7] = 0;\n            out[8] = zx + wy;\n            out[9] = zy - wx;\n            out[10] = 1 - xx - yy;\n            out[11] = 0;\n            out[12] = 0;\n            out[13] = 0;\n            out[14] = 0;\n            out[15] = 1;\n            return out\n        }\n        function frustum(out, left, right, bottom, top, near, far) {\n            var rl = 1 \/ (right - left);\n            var tb = 1 \/ (top - bottom);\n            var nf = 1 \/ (near - far);\n            out[0] = near * 2 * rl;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = 0;\n            out[5] = near * 2 * tb;\n            out[6] = 0;\n            out[7] = 0;\n            out[8] = (right + left) * rl;\n            out[9] = (top + bottom) * tb;\n            out[10] = (far + near) * nf;\n            out[11] = -1;\n            out[12] = 0;\n            out[13] = 0;\n            out[14] = far * near * 2 * nf;\n            out[15] = 0;\n            return out\n        }\n        function perspectiveNO(out, fovy, aspect, near, far) {\n            var f = 1 \/ Math.tan(fovy \/ 2);\n            out[0] = f \/ aspect;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = 0;\n            out[5] = f;\n            out[6] = 0;\n            out[7] = 0;\n            out[8] = 0;\n            out[9] = 0;\n            out[11] = -1;\n            out[12] = 0;\n            out[13] = 0;\n            out[15] = 0;\n            if (far != null && far !== Infinity) {\n                var nf = 1 \/ (near - far);\n                out[10] = (far + near) * nf;\n                out[14] = 2 * far * near * nf\n            } else {\n                out[10] = -1;\n                out[14] = -2 * near\n            }\n            return out\n        }\n        var perspective = perspectiveNO;\n        function perspectiveZO(out, fovy, aspect, near, far) {\n            var f = 1 \/ Math.tan(fovy \/ 2);\n            out[0] = f \/ aspect;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = 0;\n            out[5] = f;\n            out[6] = 0;\n            out[7] = 0;\n            out[8] = 0;\n            out[9] = 0;\n            out[11] = -1;\n            out[12] = 0;\n            out[13] = 0;\n            out[15] = 0;\n            if (far != null && far !== Infinity) {\n                var nf = 1 \/ (near - far);\n                out[10] = far * nf;\n                out[14] = far * near * nf\n            } else {\n                out[10] = -1;\n                out[14] = -near\n            }\n            return out\n        }\n        function perspectiveFromFieldOfView(out, fov, near, far) {\n            var upTan = Math.tan(fov.upDegrees * Math.PI \/ 180);\n            var downTan = Math.tan(fov.downDegrees * Math.PI \/ 180);\n            var leftTan = Math.tan(fov.leftDegrees * Math.PI \/ 180);\n            var rightTan = Math.tan(fov.rightDegrees * Math.PI \/ 180);\n            var xScale = 2 \/ (leftTan + rightTan);\n            var yScale = 2 \/ (upTan + downTan);\n            out[0] = xScale;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = 0;\n            out[5] = yScale;\n            out[6] = 0;\n            out[7] = 0;\n            out[8] = -((leftTan - rightTan) * xScale * .5);\n            out[9] = (upTan - downTan) * yScale * .5;\n            out[10] = far \/ (near - far);\n            out[11] = -1;\n            out[12] = 0;\n            out[13] = 0;\n            out[14] = far * near \/ (near - far);\n            out[15] = 0;\n            return out\n        }\n        function orthoNO(out, left, right, bottom, top, near, far) {\n            var lr = 1 \/ (left - right);\n            var bt = 1 \/ (bottom - top);\n            var nf = 1 \/ (near - far);\n            out[0] = -2 * lr;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = 0;\n            out[5] = -2 * bt;\n            out[6] = 0;\n            out[7] = 0;\n            out[8] = 0;\n            out[9] = 0;\n            out[10] = 2 * nf;\n            out[11] = 0;\n            out[12] = (left + right) * lr;\n            out[13] = (top + bottom) * bt;\n            out[14] = (far + near) * nf;\n            out[15] = 1;\n            return out\n        }\n        var ortho = orthoNO;\n        function orthoZO(out, left, right, bottom, top, near, far) {\n            var lr = 1 \/ (left - right);\n            var bt = 1 \/ (bottom - top);\n            var nf = 1 \/ (near - far);\n            out[0] = -2 * lr;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            out[4] = 0;\n            out[5] = -2 * bt;\n            out[6] = 0;\n            out[7] = 0;\n            out[8] = 0;\n            out[9] = 0;\n            out[10] = nf;\n            out[11] = 0;\n            out[12] = (left + right) * lr;\n            out[13] = (top + bottom) * bt;\n            out[14] = near * nf;\n            out[15] = 1;\n            return out\n        }\n        function lookAt(out, eye, center, up) {\n            var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n            var eyex = eye[0];\n            var eyey = eye[1];\n            var eyez = eye[2];\n            var upx = up[0];\n            var upy = up[1];\n            var upz = up[2];\n            var centerx = center[0];\n            var centery = center[1];\n            var centerz = center[2];\n            if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON)\n                return identity$2(out);\n            z0 = eyex - centerx;\n            z1 = eyey - centery;\n            z2 = eyez - centerz;\n            len = 1 \/ Math.hypot(z0, z1, z2);\n            z0 *= len;\n            z1 *= len;\n            z2 *= len;\n            x0 = upy * z2 - upz * z1;\n            x1 = upz * z0 - upx * z2;\n            x2 = upx * z1 - upy * z0;\n            len = Math.hypot(x0, x1, x2);\n            if (!len) {\n                x0 = 0;\n                x1 = 0;\n                x2 = 0\n            } else {\n                len = 1 \/ len;\n                x0 *= len;\n                x1 *= len;\n                x2 *= len\n            }\n            y0 = z1 * x2 - z2 * x1;\n            y1 = z2 * x0 - z0 * x2;\n            y2 = z0 * x1 - z1 * x0;\n            len = Math.hypot(y0, y1, y2);\n            if (!len) {\n                y0 = 0;\n                y1 = 0;\n                y2 = 0\n            } else {\n                len = 1 \/ len;\n                y0 *= len;\n                y1 *= len;\n                y2 *= len\n            }\n            out[0] = x0;\n            out[1] = y0;\n            out[2] = z0;\n            out[3] = 0;\n            out[4] = x1;\n            out[5] = y1;\n            out[6] = z1;\n            out[7] = 0;\n            out[8] = x2;\n            out[9] = y2;\n            out[10] = z2;\n            out[11] = 0;\n            out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n            out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n            out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n            out[15] = 1;\n            return out\n        }\n        function targetTo(out, eye, target, up) {\n            var eyex = eye[0]\n              , eyey = eye[1]\n              , eyez = eye[2]\n              , upx = up[0]\n              , upy = up[1]\n              , upz = up[2];\n            var z0 = eyex - target[0]\n              , z1 = eyey - target[1]\n              , z2 = eyez - target[2];\n            var len = z0 * z0 + z1 * z1 + z2 * z2;\n            if (len > 0) {\n                len = 1 \/ Math.sqrt(len);\n                z0 *= len;\n                z1 *= len;\n                z2 *= len\n            }\n            var x0 = upy * z2 - upz * z1\n              , x1 = upz * z0 - upx * z2\n              , x2 = upx * z1 - upy * z0;\n            len = x0 * x0 + x1 * x1 + x2 * x2;\n            if (len > 0) {\n                len = 1 \/ Math.sqrt(len);\n                x0 *= len;\n                x1 *= len;\n                x2 *= len\n            }\n            out[0] = x0;\n            out[1] = x1;\n            out[2] = x2;\n            out[3] = 0;\n            out[4] = z1 * x2 - z2 * x1;\n            out[5] = z2 * x0 - z0 * x2;\n            out[6] = z0 * x1 - z1 * x0;\n            out[7] = 0;\n            out[8] = z0;\n            out[9] = z1;\n            out[10] = z2;\n            out[11] = 0;\n            out[12] = eyex;\n            out[13] = eyey;\n            out[14] = eyez;\n            out[15] = 1;\n            return out\n        }\n        function str$5(a) {\n            return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")"\n        }\n        function frob(a) {\n            return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15])\n        }\n        function add$5(out, a, b) {\n            out[0] = a[0] + b[0];\n            out[1] = a[1] + b[1];\n            out[2] = a[2] + b[2];\n            out[3] = a[3] + b[3];\n            out[4] = a[4] + b[4];\n            out[5] = a[5] + b[5];\n            out[6] = a[6] + b[6];\n            out[7] = a[7] + b[7];\n            out[8] = a[8] + b[8];\n            out[9] = a[9] + b[9];\n            out[10] = a[10] + b[10];\n            out[11] = a[11] + b[11];\n            out[12] = a[12] + b[12];\n            out[13] = a[13] + b[13];\n            out[14] = a[14] + b[14];\n            out[15] = a[15] + b[15];\n            return out\n        }\n        function subtract$3(out, a, b) {\n            out[0] = a[0] - b[0];\n            out[1] = a[1] - b[1];\n            out[2] = a[2] - b[2];\n            out[3] = a[3] - b[3];\n            out[4] = a[4] - b[4];\n            out[5] = a[5] - b[5];\n            out[6] = a[6] - b[6];\n            out[7] = a[7] - b[7];\n            out[8] = a[8] - b[8];\n            out[9] = a[9] - b[9];\n            out[10] = a[10] - b[10];\n            out[11] = a[11] - b[11];\n            out[12] = a[12] - b[12];\n            out[13] = a[13] - b[13];\n            out[14] = a[14] - b[14];\n            out[15] = a[15] - b[15];\n            return out\n        }\n        function multiplyScalar(out, a, b) {\n            out[0] = a[0] * b;\n            out[1] = a[1] * b;\n            out[2] = a[2] * b;\n            out[3] = a[3] * b;\n            out[4] = a[4] * b;\n            out[5] = a[5] * b;\n            out[6] = a[6] * b;\n            out[7] = a[7] * b;\n            out[8] = a[8] * b;\n            out[9] = a[9] * b;\n            out[10] = a[10] * b;\n            out[11] = a[11] * b;\n            out[12] = a[12] * b;\n            out[13] = a[13] * b;\n            out[14] = a[14] * b;\n            out[15] = a[15] * b;\n            return out\n        }\n        function multiplyScalarAndAdd(out, a, b, scale) {\n            out[0] = a[0] + b[0] * scale;\n            out[1] = a[1] + b[1] * scale;\n            out[2] = a[2] + b[2] * scale;\n            out[3] = a[3] + b[3] * scale;\n            out[4] = a[4] + b[4] * scale;\n            out[5] = a[5] + b[5] * scale;\n            out[6] = a[6] + b[6] * scale;\n            out[7] = a[7] + b[7] * scale;\n            out[8] = a[8] + b[8] * scale;\n            out[9] = a[9] + b[9] * scale;\n            out[10] = a[10] + b[10] * scale;\n            out[11] = a[11] + b[11] * scale;\n            out[12] = a[12] + b[12] * scale;\n            out[13] = a[13] + b[13] * scale;\n            out[14] = a[14] + b[14] * scale;\n            out[15] = a[15] + b[15] * scale;\n            return out\n        }\n        function exactEquals$5(a, b) {\n            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15]\n        }\n        function equals$5(a, b) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3];\n            var a4 = a[4]\n              , a5 = a[5]\n              , a6 = a[6]\n              , a7 = a[7];\n            var a8 = a[8]\n              , a9 = a[9]\n              , a10 = a[10]\n              , a11 = a[11];\n            var a12 = a[12]\n              , a13 = a[13]\n              , a14 = a[14]\n              , a15 = a[15];\n            var b0 = b[0]\n              , b1 = b[1]\n              , b2 = b[2]\n              , b3 = b[3];\n            var b4 = b[4]\n              , b5 = b[5]\n              , b6 = b[6]\n              , b7 = b[7];\n            var b8 = b[8]\n              , b9 = b[9]\n              , b10 = b[10]\n              , b11 = b[11];\n            var b12 = b[12]\n              , b13 = b[13]\n              , b14 = b[14]\n              , b15 = b[15];\n            return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15))\n        }\n        var mul$5 = multiply$5;\n        var sub$3 = subtract$3;\n        var mat4 = Object.freeze({\n            __proto__: null,\n            create: create$5,\n            clone: clone$5,\n            copy: copy$5,\n            fromValues: fromValues$5,\n            set: set$5,\n            identity: identity$2,\n            transpose: transpose,\n            invert: invert$2,\n            adjoint: adjoint,\n            determinant: determinant,\n            multiply: multiply$5,\n            translate: translate$1,\n            scale: scale$5,\n            rotate: rotate$1,\n            rotateX: rotateX$3,\n            rotateY: rotateY$3,\n            rotateZ: rotateZ$3,\n            fromTranslation: fromTranslation$1,\n            fromScaling: fromScaling,\n            fromRotation: fromRotation$1,\n            fromXRotation: fromXRotation,\n            fromYRotation: fromYRotation,\n            fromZRotation: fromZRotation,\n            fromRotationTranslation: fromRotationTranslation$1,\n            fromQuat2: fromQuat2,\n            getTranslation: getTranslation$1,\n            getScaling: getScaling,\n            getRotation: getRotation,\n            decompose: decompose,\n            fromRotationTranslationScale: fromRotationTranslationScale,\n            fromRotationTranslationScaleOrigin: fromRotationTranslationScaleOrigin,\n            fromQuat: fromQuat,\n            frustum: frustum,\n            perspectiveNO: perspectiveNO,\n            perspective: perspective,\n            perspectiveZO: perspectiveZO,\n            perspectiveFromFieldOfView: perspectiveFromFieldOfView,\n            orthoNO: orthoNO,\n            ortho: ortho,\n            orthoZO: orthoZO,\n            lookAt: lookAt,\n            targetTo: targetTo,\n            str: str$5,\n            frob: frob,\n            add: add$5,\n            subtract: subtract$3,\n            multiplyScalar: multiplyScalar,\n            multiplyScalarAndAdd: multiplyScalarAndAdd,\n            exactEquals: exactEquals$5,\n            equals: equals$5,\n            mul: mul$5,\n            sub: sub$3\n        });\n        function create$4() {\n            var out = new ARRAY_TYPE(3);\n            if (ARRAY_TYPE != Float32Array) {\n                out[0] = 0;\n                out[1] = 0;\n                out[2] = 0\n            }\n            return out\n        }\n        function clone$4(a) {\n            var out = new ARRAY_TYPE(3);\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            return out\n        }\n        function length$4(a) {\n            var x = a[0];\n            var y = a[1];\n            var z = a[2];\n            return Math.hypot(x, y, z)\n        }\n        function fromValues$4(x, y, z) {\n            var out = new ARRAY_TYPE(3);\n            out[0] = x;\n            out[1] = y;\n            out[2] = z;\n            return out\n        }\n        function copy$4(out, a) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            return out\n        }\n        function set$4(out, x, y, z) {\n            out[0] = x;\n            out[1] = y;\n            out[2] = z;\n            return out\n        }\n        function add$4(out, a, b) {\n            out[0] = a[0] + b[0];\n            out[1] = a[1] + b[1];\n            out[2] = a[2] + b[2];\n            return out\n        }\n        function subtract$2(out, a, b) {\n            out[0] = a[0] - b[0];\n            out[1] = a[1] - b[1];\n            out[2] = a[2] - b[2];\n            return out\n        }\n        function multiply$4(out, a, b) {\n            out[0] = a[0] * b[0];\n            out[1] = a[1] * b[1];\n            out[2] = a[2] * b[2];\n            return out\n        }\n        function divide$2(out, a, b) {\n            out[0] = a[0] \/ b[0];\n            out[1] = a[1] \/ b[1];\n            out[2] = a[2] \/ b[2];\n            return out\n        }\n        function ceil$2(out, a) {\n            out[0] = Math.ceil(a[0]);\n            out[1] = Math.ceil(a[1]);\n            out[2] = Math.ceil(a[2]);\n            return out\n        }\n        function floor$2(out, a) {\n            out[0] = Math.floor(a[0]);\n            out[1] = Math.floor(a[1]);\n            out[2] = Math.floor(a[2]);\n            return out\n        }\n        function min$2(out, a, b) {\n            out[0] = Math.min(a[0], b[0]);\n            out[1] = Math.min(a[1], b[1]);\n            out[2] = Math.min(a[2], b[2]);\n            return out\n        }\n        function max$2(out, a, b) {\n            out[0] = Math.max(a[0], b[0]);\n            out[1] = Math.max(a[1], b[1]);\n            out[2] = Math.max(a[2], b[2]);\n            return out\n        }\n        function round$2(out, a) {\n            out[0] = Math.round(a[0]);\n            out[1] = Math.round(a[1]);\n            out[2] = Math.round(a[2]);\n            return out\n        }\n        function scale$4(out, a, b) {\n            out[0] = a[0] * b;\n            out[1] = a[1] * b;\n            out[2] = a[2] * b;\n            return out\n        }\n        function scaleAndAdd$2(out, a, b, scale) {\n            out[0] = a[0] + b[0] * scale;\n            out[1] = a[1] + b[1] * scale;\n            out[2] = a[2] + b[2] * scale;\n            return out\n        }\n        function distance$2(a, b) {\n            var x = b[0] - a[0];\n            var y = b[1] - a[1];\n            var z = b[2] - a[2];\n            return Math.hypot(x, y, z)\n        }\n        function squaredDistance$2(a, b) {\n            var x = b[0] - a[0];\n            var y = b[1] - a[1];\n            var z = b[2] - a[2];\n            return x * x + y * y + z * z\n        }\n        function squaredLength$4(a) {\n            var x = a[0];\n            var y = a[1];\n            var z = a[2];\n            return x * x + y * y + z * z\n        }\n        function negate$2(out, a) {\n            out[0] = -a[0];\n            out[1] = -a[1];\n            out[2] = -a[2];\n            return out\n        }\n        function inverse$2(out, a) {\n            out[0] = 1 \/ a[0];\n            out[1] = 1 \/ a[1];\n            out[2] = 1 \/ a[2];\n            return out\n        }\n        function normalize$4(out, a) {\n            var x = a[0];\n            var y = a[1];\n            var z = a[2];\n            var len = x * x + y * y + z * z;\n            if (len > 0)\n                len = 1 \/ Math.sqrt(len);\n            out[0] = a[0] * len;\n            out[1] = a[1] * len;\n            out[2] = a[2] * len;\n            return out\n        }\n        function dot$4(a, b) {\n            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n        }\n        function cross$2(out, a, b) {\n            var ax = a[0]\n              , ay = a[1]\n              , az = a[2];\n            var bx = b[0]\n              , by = b[1]\n              , bz = b[2];\n            out[0] = ay * bz - az * by;\n            out[1] = az * bx - ax * bz;\n            out[2] = ax * by - ay * bx;\n            return out\n        }\n        function lerp$4(out, a, b, t) {\n            var ax = a[0];\n            var ay = a[1];\n            var az = a[2];\n            out[0] = ax + t * (b[0] - ax);\n            out[1] = ay + t * (b[1] - ay);\n            out[2] = az + t * (b[2] - az);\n            return out\n        }\n        function slerp$1(out, a, b, t) {\n            var angle = Math.acos(Math.min(Math.max(dot$4(a, b), -1), 1));\n            var sinTotal = Math.sin(angle);\n            var ratioA = Math.sin((1 - t) * angle) \/ sinTotal;\n            var ratioB = Math.sin(t * angle) \/ sinTotal;\n            out[0] = ratioA * a[0] + ratioB * b[0];\n            out[1] = ratioA * a[1] + ratioB * b[1];\n            out[2] = ratioA * a[2] + ratioB * b[2];\n            return out\n        }\n        function hermite(out, a, b, c, d, t) {\n            var factorTimes2 = t * t;\n            var factor1 = factorTimes2 * (2 * t - 3) + 1;\n            var factor2 = factorTimes2 * (t - 2) + t;\n            var factor3 = factorTimes2 * (t - 1);\n            var factor4 = factorTimes2 * (3 - 2 * t);\n            out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n            out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n            out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n            return out\n        }\n        function bezier(out, a, b, c, d, t) {\n            var inverseFactor = 1 - t;\n            var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n            var factorTimes2 = t * t;\n            var factor1 = inverseFactorTimesTwo * inverseFactor;\n            var factor2 = 3 * t * inverseFactorTimesTwo;\n            var factor3 = 3 * factorTimes2 * inverseFactor;\n            var factor4 = factorTimes2 * t;\n            out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n            out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n            out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n            return out\n        }\n        function random$3(out, scale) {\n            scale = scale || 1;\n            var r = RANDOM() * 2 * Math.PI;\n            var z = RANDOM() * 2 - 1;\n            var zScale = Math.sqrt(1 - z * z) * scale;\n            out[0] = Math.cos(r) * zScale;\n            out[1] = Math.sin(r) * zScale;\n            out[2] = z * scale;\n            return out\n        }\n        function transformMat4$2(out, a, m) {\n            var x = a[0]\n              , y = a[1]\n              , z = a[2];\n            var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n            w = w || 1;\n            out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) \/ w;\n            out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) \/ w;\n            out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) \/ w;\n            return out\n        }\n        function transformMat3$1(out, a, m) {\n            var x = a[0]\n              , y = a[1]\n              , z = a[2];\n            out[0] = x * m[0] + y * m[3] + z * m[6];\n            out[1] = x * m[1] + y * m[4] + z * m[7];\n            out[2] = x * m[2] + y * m[5] + z * m[8];\n            return out\n        }\n        function transformQuat$1(out, a, q) {\n            var qx = q[0]\n              , qy = q[1]\n              , qz = q[2]\n              , qw = q[3];\n            var x = a[0]\n              , y = a[1]\n              , z = a[2];\n            var uvx = qy * z - qz * y\n              , uvy = qz * x - qx * z\n              , uvz = qx * y - qy * x;\n            var uuvx = qy * uvz - qz * uvy\n              , uuvy = qz * uvx - qx * uvz\n              , uuvz = qx * uvy - qy * uvx;\n            var w2 = qw * 2;\n            uvx *= w2;\n            uvy *= w2;\n            uvz *= w2;\n            uuvx *= 2;\n            uuvy *= 2;\n            uuvz *= 2;\n            out[0] = x + uvx + uuvx;\n            out[1] = y + uvy + uuvy;\n            out[2] = z + uvz + uuvz;\n            return out\n        }\n        function rotateX$2(out, a, b, rad) {\n            var p = []\n              , r = [];\n            p[0] = a[0] - b[0];\n            p[1] = a[1] - b[1];\n            p[2] = a[2] - b[2];\n            r[0] = p[0];\n            r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n            r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);\n            out[0] = r[0] + b[0];\n            out[1] = r[1] + b[1];\n            out[2] = r[2] + b[2];\n            return out\n        }\n        function rotateY$2(out, a, b, rad) {\n            var p = []\n              , r = [];\n            p[0] = a[0] - b[0];\n            p[1] = a[1] - b[1];\n            p[2] = a[2] - b[2];\n            r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n            r[1] = p[1];\n            r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);\n            out[0] = r[0] + b[0];\n            out[1] = r[1] + b[1];\n            out[2] = r[2] + b[2];\n            return out\n        }\n        function rotateZ$2(out, a, b, rad) {\n            var p = []\n              , r = [];\n            p[0] = a[0] - b[0];\n            p[1] = a[1] - b[1];\n            p[2] = a[2] - b[2];\n            r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n            r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n            r[2] = p[2];\n            out[0] = r[0] + b[0];\n            out[1] = r[1] + b[1];\n            out[2] = r[2] + b[2];\n            return out\n        }\n        function angle$1(a, b) {\n            var ax = a[0]\n              , ay = a[1]\n              , az = a[2]\n              , bx = b[0]\n              , by = b[1]\n              , bz = b[2]\n              , mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz))\n              , cosine = mag && dot$4(a, b) \/ mag;\n            return Math.acos(Math.min(Math.max(cosine, -1), 1))\n        }\n        function zero$2(out) {\n            out[0] = 0;\n            out[1] = 0;\n            out[2] = 0;\n            return out\n        }\n        function str$4(a) {\n            return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")"\n        }\n        function exactEquals$4(a, b) {\n            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]\n        }\n        function equals$4(a, b) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2];\n            var b0 = b[0]\n              , b1 = b[1]\n              , b2 = b[2];\n            return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2))\n        }\n        var sub$2 = subtract$2;\n        var mul$4 = multiply$4;\n        var div$2 = divide$2;\n        var dist$2 = distance$2;\n        var sqrDist$2 = squaredDistance$2;\n        var len$4 = length$4;\n        var sqrLen$4 = squaredLength$4;\n        var forEach$2 = function() {\n            var vec = create$4();\n            return function(a, stride, offset, count, fn, arg) {\n                var i, l;\n                if (!stride)\n                    stride = 3;\n                if (!offset)\n                    offset = 0;\n                if (count)\n                    l = Math.min(count * stride + offset, a.length);\n                else\n                    l = a.length;\n                for (i = offset; i < l; i += stride) {\n                    vec[0] = a[i];\n                    vec[1] = a[i + 1];\n                    vec[2] = a[i + 2];\n                    fn(vec, vec, arg);\n                    a[i] = vec[0];\n                    a[i + 1] = vec[1];\n                    a[i + 2] = vec[2]\n                }\n                return a\n            }\n        }();\n        var vec3 = Object.freeze({\n            __proto__: null,\n            create: create$4,\n            clone: clone$4,\n            length: length$4,\n            fromValues: fromValues$4,\n            copy: copy$4,\n            set: set$4,\n            add: add$4,\n            subtract: subtract$2,\n            multiply: multiply$4,\n            divide: divide$2,\n            ceil: ceil$2,\n            floor: floor$2,\n            min: min$2,\n            max: max$2,\n            round: round$2,\n            scale: scale$4,\n            scaleAndAdd: scaleAndAdd$2,\n            distance: distance$2,\n            squaredDistance: squaredDistance$2,\n            squaredLength: squaredLength$4,\n            negate: negate$2,\n            inverse: inverse$2,\n            normalize: normalize$4,\n            dot: dot$4,\n            cross: cross$2,\n            lerp: lerp$4,\n            slerp: slerp$1,\n            hermite: hermite,\n            bezier: bezier,\n            random: random$3,\n            transformMat4: transformMat4$2,\n            transformMat3: transformMat3$1,\n            transformQuat: transformQuat$1,\n            rotateX: rotateX$2,\n            rotateY: rotateY$2,\n            rotateZ: rotateZ$2,\n            angle: angle$1,\n            zero: zero$2,\n            str: str$4,\n            exactEquals: exactEquals$4,\n            equals: equals$4,\n            sub: sub$2,\n            mul: mul$4,\n            div: div$2,\n            dist: dist$2,\n            sqrDist: sqrDist$2,\n            len: len$4,\n            sqrLen: sqrLen$4,\n            forEach: forEach$2\n        });\n        function create$3() {\n            var out = new ARRAY_TYPE(4);\n            if (ARRAY_TYPE != Float32Array) {\n                out[0] = 0;\n                out[1] = 0;\n                out[2] = 0;\n                out[3] = 0\n            }\n            return out\n        }\n        function clone$3(a) {\n            var out = new ARRAY_TYPE(4);\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            return out\n        }\n        function fromValues$3(x, y, z, w) {\n            var out = new ARRAY_TYPE(4);\n            out[0] = x;\n            out[1] = y;\n            out[2] = z;\n            out[3] = w;\n            return out\n        }\n        function copy$3(out, a) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            return out\n        }\n        function set$3(out, x, y, z, w) {\n            out[0] = x;\n            out[1] = y;\n            out[2] = z;\n            out[3] = w;\n            return out\n        }\n        function add$3(out, a, b) {\n            out[0] = a[0] + b[0];\n            out[1] = a[1] + b[1];\n            out[2] = a[2] + b[2];\n            out[3] = a[3] + b[3];\n            return out\n        }\n        function subtract$1(out, a, b) {\n            out[0] = a[0] - b[0];\n            out[1] = a[1] - b[1];\n            out[2] = a[2] - b[2];\n            out[3] = a[3] - b[3];\n            return out\n        }\n        function multiply$3(out, a, b) {\n            out[0] = a[0] * b[0];\n            out[1] = a[1] * b[1];\n            out[2] = a[2] * b[2];\n            out[3] = a[3] * b[3];\n            return out\n        }\n        function divide$1(out, a, b) {\n            out[0] = a[0] \/ b[0];\n            out[1] = a[1] \/ b[1];\n            out[2] = a[2] \/ b[2];\n            out[3] = a[3] \/ b[3];\n            return out\n        }\n        function ceil$1(out, a) {\n            out[0] = Math.ceil(a[0]);\n            out[1] = Math.ceil(a[1]);\n            out[2] = Math.ceil(a[2]);\n            out[3] = Math.ceil(a[3]);\n            return out\n        }\n        function floor$1(out, a) {\n            out[0] = Math.floor(a[0]);\n            out[1] = Math.floor(a[1]);\n            out[2] = Math.floor(a[2]);\n            out[3] = Math.floor(a[3]);\n            return out\n        }\n        function min$1(out, a, b) {\n            out[0] = Math.min(a[0], b[0]);\n            out[1] = Math.min(a[1], b[1]);\n            out[2] = Math.min(a[2], b[2]);\n            out[3] = Math.min(a[3], b[3]);\n            return out\n        }\n        function max$1(out, a, b) {\n            out[0] = Math.max(a[0], b[0]);\n            out[1] = Math.max(a[1], b[1]);\n            out[2] = Math.max(a[2], b[2]);\n            out[3] = Math.max(a[3], b[3]);\n            return out\n        }\n        function round$1(out, a) {\n            out[0] = Math.round(a[0]);\n            out[1] = Math.round(a[1]);\n            out[2] = Math.round(a[2]);\n            out[3] = Math.round(a[3]);\n            return out\n        }\n        function scale$3(out, a, b) {\n            out[0] = a[0] * b;\n            out[1] = a[1] * b;\n            out[2] = a[2] * b;\n            out[3] = a[3] * b;\n            return out\n        }\n        function scaleAndAdd$1(out, a, b, scale) {\n            out[0] = a[0] + b[0] * scale;\n            out[1] = a[1] + b[1] * scale;\n            out[2] = a[2] + b[2] * scale;\n            out[3] = a[3] + b[3] * scale;\n            return out\n        }\n        function distance$1(a, b) {\n            var x = b[0] - a[0];\n            var y = b[1] - a[1];\n            var z = b[2] - a[2];\n            var w = b[3] - a[3];\n            return Math.hypot(x, y, z, w)\n        }\n        function squaredDistance$1(a, b) {\n            var x = b[0] - a[0];\n            var y = b[1] - a[1];\n            var z = b[2] - a[2];\n            var w = b[3] - a[3];\n            return x * x + y * y + z * z + w * w\n        }\n        function length$3(a) {\n            var x = a[0];\n            var y = a[1];\n            var z = a[2];\n            var w = a[3];\n            return Math.hypot(x, y, z, w)\n        }\n        function squaredLength$3(a) {\n            var x = a[0];\n            var y = a[1];\n            var z = a[2];\n            var w = a[3];\n            return x * x + y * y + z * z + w * w\n        }\n        function negate$1(out, a) {\n            out[0] = -a[0];\n            out[1] = -a[1];\n            out[2] = -a[2];\n            out[3] = -a[3];\n            return out\n        }\n        function inverse$1(out, a) {\n            out[0] = 1 \/ a[0];\n            out[1] = 1 \/ a[1];\n            out[2] = 1 \/ a[2];\n            out[3] = 1 \/ a[3];\n            return out\n        }\n        function normalize$3(out, a) {\n            var x = a[0];\n            var y = a[1];\n            var z = a[2];\n            var w = a[3];\n            var len = x * x + y * y + z * z + w * w;\n            if (len > 0)\n                len = 1 \/ Math.sqrt(len);\n            out[0] = x * len;\n            out[1] = y * len;\n            out[2] = z * len;\n            out[3] = w * len;\n            return out\n        }\n        function dot$3(a, b) {\n            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]\n        }\n        function cross$1(out, u, v, w) {\n            var A = v[0] * w[1] - v[1] * w[0]\n              , B = v[0] * w[2] - v[2] * w[0]\n              , C = v[0] * w[3] - v[3] * w[0]\n              , D = v[1] * w[2] - v[2] * w[1]\n              , E = v[1] * w[3] - v[3] * w[1]\n              , F = v[2] * w[3] - v[3] * w[2];\n            var G = u[0];\n            var H = u[1];\n            var I = u[2];\n            var J = u[3];\n            out[0] = H * F - I * E + J * D;\n            out[1] = -(G * F) + I * C - J * B;\n            out[2] = G * E - H * C + J * A;\n            out[3] = -(G * D) + H * B - I * A;\n            return out\n        }\n        function lerp$3(out, a, b, t) {\n            var ax = a[0];\n            var ay = a[1];\n            var az = a[2];\n            var aw = a[3];\n            out[0] = ax + t * (b[0] - ax);\n            out[1] = ay + t * (b[1] - ay);\n            out[2] = az + t * (b[2] - az);\n            out[3] = aw + t * (b[3] - aw);\n            return out\n        }\n        function random$2(out, scale) {\n            scale = scale || 1;\n            var v1, v2, v3, v4;\n            var s1, s2;\n            do {\n                v1 = RANDOM() * 2 - 1;\n                v2 = RANDOM() * 2 - 1;\n                s1 = v1 * v1 + v2 * v2\n            } while (s1 >= 1);\n            do {\n                v3 = RANDOM() * 2 - 1;\n                v4 = RANDOM() * 2 - 1;\n                s2 = v3 * v3 + v4 * v4\n            } while (s2 >= 1);\n            var d = Math.sqrt((1 - s1) \/ s2);\n            out[0] = scale * v1;\n            out[1] = scale * v2;\n            out[2] = scale * v3 * d;\n            out[3] = scale * v4 * d;\n            return out\n        }\n        function transformMat4$1(out, a, m) {\n            var x = a[0]\n              , y = a[1]\n              , z = a[2]\n              , w = a[3];\n            out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n            out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n            out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n            out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n            return out\n        }\n        function transformQuat(out, a, q) {\n            var x = a[0]\n              , y = a[1]\n              , z = a[2];\n            var qx = q[0]\n              , qy = q[1]\n              , qz = q[2]\n              , qw = q[3];\n            var ix = qw * x + qy * z - qz * y;\n            var iy = qw * y + qz * x - qx * z;\n            var iz = qw * z + qx * y - qy * x;\n            var iw = -qx * x - qy * y - qz * z;\n            out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n            out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n            out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n            out[3] = a[3];\n            return out\n        }\n        function zero$1(out) {\n            out[0] = 0;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 0;\n            return out\n        }\n        function str$3(a) {\n            return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")"\n        }\n        function exactEquals$3(a, b) {\n            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]\n        }\n        function equals$3(a, b) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3];\n            var b0 = b[0]\n              , b1 = b[1]\n              , b2 = b[2]\n              , b3 = b[3];\n            return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3))\n        }\n        var sub$1 = subtract$1;\n        var mul$3 = multiply$3;\n        var div$1 = divide$1;\n        var dist$1 = distance$1;\n        var sqrDist$1 = squaredDistance$1;\n        var len$3 = length$3;\n        var sqrLen$3 = squaredLength$3;\n        var forEach$1 = function() {\n            var vec = create$3();\n            return function(a, stride, offset, count, fn, arg) {\n                var i, l;\n                if (!stride)\n                    stride = 4;\n                if (!offset)\n                    offset = 0;\n                if (count)\n                    l = Math.min(count * stride + offset, a.length);\n                else\n                    l = a.length;\n                for (i = offset; i < l; i += stride) {\n                    vec[0] = a[i];\n                    vec[1] = a[i + 1];\n                    vec[2] = a[i + 2];\n                    vec[3] = a[i + 3];\n                    fn(vec, vec, arg);\n                    a[i] = vec[0];\n                    a[i + 1] = vec[1];\n                    a[i + 2] = vec[2];\n                    a[i + 3] = vec[3]\n                }\n                return a\n            }\n        }();\n        var vec4 = Object.freeze({\n            __proto__: null,\n            create: create$3,\n            clone: clone$3,\n            fromValues: fromValues$3,\n            copy: copy$3,\n            set: set$3,\n            add: add$3,\n            subtract: subtract$1,\n            multiply: multiply$3,\n            divide: divide$1,\n            ceil: ceil$1,\n            floor: floor$1,\n            min: min$1,\n            max: max$1,\n            round: round$1,\n            scale: scale$3,\n            scaleAndAdd: scaleAndAdd$1,\n            distance: distance$1,\n            squaredDistance: squaredDistance$1,\n            length: length$3,\n            squaredLength: squaredLength$3,\n            negate: negate$1,\n            inverse: inverse$1,\n            normalize: normalize$3,\n            dot: dot$3,\n            cross: cross$1,\n            lerp: lerp$3,\n            random: random$2,\n            transformMat4: transformMat4$1,\n            transformQuat: transformQuat,\n            zero: zero$1,\n            str: str$3,\n            exactEquals: exactEquals$3,\n            equals: equals$3,\n            sub: sub$1,\n            mul: mul$3,\n            div: div$1,\n            dist: dist$1,\n            sqrDist: sqrDist$1,\n            len: len$3,\n            sqrLen: sqrLen$3,\n            forEach: forEach$1\n        });\n        function create$2() {\n            var out = new ARRAY_TYPE(4);\n            if (ARRAY_TYPE != Float32Array) {\n                out[0] = 0;\n                out[1] = 0;\n                out[2] = 0\n            }\n            out[3] = 1;\n            return out\n        }\n        function identity$1(out) {\n            out[0] = 0;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            return out\n        }\n        function setAxisAngle(out, axis, rad) {\n            rad = rad * .5;\n            var s = Math.sin(rad);\n            out[0] = s * axis[0];\n            out[1] = s * axis[1];\n            out[2] = s * axis[2];\n            out[3] = Math.cos(rad);\n            return out\n        }\n        function getAxisAngle(out_axis, q) {\n            var rad = Math.acos(q[3]) * 2;\n            var s = Math.sin(rad \/ 2);\n            if (s > EPSILON) {\n                out_axis[0] = q[0] \/ s;\n                out_axis[1] = q[1] \/ s;\n                out_axis[2] = q[2] \/ s\n            } else {\n                out_axis[0] = 1;\n                out_axis[1] = 0;\n                out_axis[2] = 0\n            }\n            return rad\n        }\n        function getAngle(a, b) {\n            var dotproduct = dot$2(a, b);\n            return Math.acos(2 * dotproduct * dotproduct - 1)\n        }\n        function multiply$2(out, a, b) {\n            var ax = a[0]\n              , ay = a[1]\n              , az = a[2]\n              , aw = a[3];\n            var bx = b[0]\n              , by = b[1]\n              , bz = b[2]\n              , bw = b[3];\n            out[0] = ax * bw + aw * bx + ay * bz - az * by;\n            out[1] = ay * bw + aw * by + az * bx - ax * bz;\n            out[2] = az * bw + aw * bz + ax * by - ay * bx;\n            out[3] = aw * bw - ax * bx - ay * by - az * bz;\n            return out\n        }\n        function rotateX$1(out, a, rad) {\n            rad *= .5;\n            var ax = a[0]\n              , ay = a[1]\n              , az = a[2]\n              , aw = a[3];\n            var bx = Math.sin(rad)\n              , bw = Math.cos(rad);\n            out[0] = ax * bw + aw * bx;\n            out[1] = ay * bw + az * bx;\n            out[2] = az * bw - ay * bx;\n            out[3] = aw * bw - ax * bx;\n            return out\n        }\n        function rotateY$1(out, a, rad) {\n            rad *= .5;\n            var ax = a[0]\n              , ay = a[1]\n              , az = a[2]\n              , aw = a[3];\n            var by = Math.sin(rad)\n              , bw = Math.cos(rad);\n            out[0] = ax * bw - az * by;\n            out[1] = ay * bw + aw * by;\n            out[2] = az * bw + ax * by;\n            out[3] = aw * bw - ay * by;\n            return out\n        }\n        function rotateZ$1(out, a, rad) {\n            rad *= .5;\n            var ax = a[0]\n              , ay = a[1]\n              , az = a[2]\n              , aw = a[3];\n            var bz = Math.sin(rad)\n              , bw = Math.cos(rad);\n            out[0] = ax * bw + ay * bz;\n            out[1] = ay * bw - ax * bz;\n            out[2] = az * bw + aw * bz;\n            out[3] = aw * bw - az * bz;\n            return out\n        }\n        function calculateW(out, a) {\n            var x = a[0]\n              , y = a[1]\n              , z = a[2];\n            out[0] = x;\n            out[1] = y;\n            out[2] = z;\n            out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));\n            return out\n        }\n        function exp(out, a) {\n            var x = a[0]\n              , y = a[1]\n              , z = a[2]\n              , w = a[3];\n            var r = Math.sqrt(x * x + y * y + z * z);\n            var et = Math.exp(w);\n            var s = r > 0 ? et * Math.sin(r) \/ r : 0;\n            out[0] = x * s;\n            out[1] = y * s;\n            out[2] = z * s;\n            out[3] = et * Math.cos(r);\n            return out\n        }\n        function ln(out, a) {\n            var x = a[0]\n              , y = a[1]\n              , z = a[2]\n              , w = a[3];\n            var r = Math.sqrt(x * x + y * y + z * z);\n            var t = r > 0 ? Math.atan2(r, w) \/ r : 0;\n            out[0] = x * t;\n            out[1] = y * t;\n            out[2] = z * t;\n            out[3] = .5 * Math.log(x * x + y * y + z * z + w * w);\n            return out\n        }\n        function pow(out, a, b) {\n            ln(out, a);\n            scale$2(out, out, b);\n            exp(out, out);\n            return out\n        }\n        function slerp(out, a, b, t) {\n            var ax = a[0]\n              , ay = a[1]\n              , az = a[2]\n              , aw = a[3];\n            var bx = b[0]\n              , by = b[1]\n              , bz = b[2]\n              , bw = b[3];\n            var omega, cosom, sinom, scale0, scale1;\n            cosom = ax * bx + ay * by + az * bz + aw * bw;\n            if (cosom < 0) {\n                cosom = -cosom;\n                bx = -bx;\n                by = -by;\n                bz = -bz;\n                bw = -bw\n            }\n            if (1 - cosom > EPSILON) {\n                omega = Math.acos(cosom);\n                sinom = Math.sin(omega);\n                scale0 = Math.sin((1 - t) * omega) \/ sinom;\n                scale1 = Math.sin(t * omega) \/ sinom\n            } else {\n                scale0 = 1 - t;\n                scale1 = t\n            }\n            out[0] = scale0 * ax + scale1 * bx;\n            out[1] = scale0 * ay + scale1 * by;\n            out[2] = scale0 * az + scale1 * bz;\n            out[3] = scale0 * aw + scale1 * bw;\n            return out\n        }\n        function random$1(out) {\n            var u1 = RANDOM();\n            var u2 = RANDOM();\n            var u3 = RANDOM();\n            var sqrt1MinusU1 = Math.sqrt(1 - u1);\n            var sqrtU1 = Math.sqrt(u1);\n            out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);\n            out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);\n            out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);\n            out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);\n            return out\n        }\n        function invert$1(out, a) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3];\n            var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n            var invDot = dot ? 1 \/ dot : 0;\n            out[0] = -a0 * invDot;\n            out[1] = -a1 * invDot;\n            out[2] = -a2 * invDot;\n            out[3] = a3 * invDot;\n            return out\n        }\n        function conjugate$1(out, a) {\n            out[0] = -a[0];\n            out[1] = -a[1];\n            out[2] = -a[2];\n            out[3] = a[3];\n            return out\n        }\n        function fromMat3(out, m) {\n            var fTrace = m[0] + m[4] + m[8];\n            var fRoot;\n            if (fTrace > 0) {\n                fRoot = Math.sqrt(fTrace + 1);\n                out[3] = .5 * fRoot;\n                fRoot = .5 \/ fRoot;\n                out[0] = (m[5] - m[7]) * fRoot;\n                out[1] = (m[6] - m[2]) * fRoot;\n                out[2] = (m[1] - m[3]) * fRoot\n            } else {\n                var i = 0;\n                if (m[4] > m[0])\n                    i = 1;\n                if (m[8] > m[i * 3 + i])\n                    i = 2;\n                var j = (i + 1) % 3;\n                var k = (i + 2) % 3;\n                fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);\n                out[i] = .5 * fRoot;\n                fRoot = .5 \/ fRoot;\n                out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n                out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n                out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot\n            }\n            return out\n        }\n        function fromEuler(out, x, y, z) {\n            var order = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ANGLE_ORDER;\n            var halfToRad = Math.PI \/ 360;\n            x *= halfToRad;\n            z *= halfToRad;\n            y *= halfToRad;\n            var sx = Math.sin(x);\n            var cx = Math.cos(x);\n            var sy = Math.sin(y);\n            var cy = Math.cos(y);\n            var sz = Math.sin(z);\n            var cz = Math.cos(z);\n            switch (order) {\n            case "xyz":\n                out[0] = sx * cy * cz + cx * sy * sz;\n                out[1] = cx * sy * cz - sx * cy * sz;\n                out[2] = cx * cy * sz + sx * sy * cz;\n                out[3] = cx * cy * cz - sx * sy * sz;\n                break;\n            case "xzy":\n                out[0] = sx * cy * cz - cx * sy * sz;\n                out[1] = cx * sy * cz - sx * cy * sz;\n                out[2] = cx * cy * sz + sx * sy * cz;\n                out[3] = cx * cy * cz + sx * sy * sz;\n                break;\n            case "yxz":\n                out[0] = sx * cy * cz + cx * sy * sz;\n                out[1] = cx * sy * cz - sx * cy * sz;\n                out[2] = cx * cy * sz - sx * sy * cz;\n                out[3] = cx * cy * cz + sx * sy * sz;\n                break;\n            case "yzx":\n                out[0] = sx * cy * cz + cx * sy * sz;\n                out[1] = cx * sy * cz + sx * cy * sz;\n                out[2] = cx * cy * sz - sx * sy * cz;\n                out[3] = cx * cy * cz - sx * sy * sz;\n                break;\n            case "zxy":\n                out[0] = sx * cy * cz - cx * sy * sz;\n                out[1] = cx * sy * cz + sx * cy * sz;\n                out[2] = cx * cy * sz + sx * sy * cz;\n                out[3] = cx * cy * cz - sx * sy * sz;\n                break;\n            case "zyx":\n                out[0] = sx * cy * cz - cx * sy * sz;\n                out[1] = cx * sy * cz + sx * cy * sz;\n                out[2] = cx * cy * sz - sx * sy * cz;\n                out[3] = cx * cy * cz + sx * sy * sz;\n                break;\n            default:\n                throw new Error("Unknown angle order " + order);\n            }\n            return out\n        }\n        function str$2(a) {\n            return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")"\n        }\n        var clone$2 = clone$3;\n        var fromValues$2 = fromValues$3;\n        var copy$2 = copy$3;\n        var set$2 = set$3;\n        var add$2 = add$3;\n        var mul$2 = multiply$2;\n        var scale$2 = scale$3;\n        var dot$2 = dot$3;\n        var lerp$2 = lerp$3;\n        var length$2 = length$3;\n        var len$2 = length$2;\n        var squaredLength$2 = squaredLength$3;\n        var sqrLen$2 = squaredLength$2;\n        var normalize$2 = normalize$3;\n        var exactEquals$2 = exactEquals$3;\n        function equals$2(a, b) {\n            return Math.abs(dot$3(a, b)) >= 1 - EPSILON\n        }\n        var rotationTo = function() {\n            var tmpvec3 = create$4();\n            var xUnitVec3 = fromValues$4(1, 0, 0);\n            var yUnitVec3 = fromValues$4(0, 1, 0);\n            return function(out, a, b) {\n                var dot = dot$4(a, b);\n                if (dot < -.999999) {\n                    cross$2(tmpvec3, xUnitVec3, a);\n                    if (len$4(tmpvec3) < 1E-6)\n                        cross$2(tmpvec3, yUnitVec3, a);\n                    normalize$4(tmpvec3, tmpvec3);\n                    setAxisAngle(out, tmpvec3, Math.PI);\n                    return out\n                } else if (dot > .999999) {\n                    out[0] = 0;\n                    out[1] = 0;\n                    out[2] = 0;\n                    out[3] = 1;\n                    return out\n                } else {\n                    cross$2(tmpvec3, a, b);\n                    out[0] = tmpvec3[0];\n                    out[1] = tmpvec3[1];\n                    out[2] = tmpvec3[2];\n                    out[3] = 1 + dot;\n                    return normalize$2(out, out)\n                }\n            }\n        }();\n        var sqlerp = function() {\n            var temp1 = create$2();\n            var temp2 = create$2();\n            return function(out, a, b, c, d, t) {\n                slerp(temp1, a, d, t);\n                slerp(temp2, b, c, t);\n                slerp(out, temp1, temp2, 2 * t * (1 - t));\n                return out\n            }\n        }();\n        var setAxes = function() {\n            var matr = create$6();\n            return function(out, view, right, up) {\n                matr[0] = right[0];\n                matr[3] = right[1];\n                matr[6] = right[2];\n                matr[1] = up[0];\n                matr[4] = up[1];\n                matr[7] = up[2];\n                matr[2] = -view[0];\n                matr[5] = -view[1];\n                matr[8] = -view[2];\n                return normalize$2(out, fromMat3(out, matr))\n            }\n        }();\n        var quat = Object.freeze({\n            __proto__: null,\n            create: create$2,\n            identity: identity$1,\n            setAxisAngle: setAxisAngle,\n            getAxisAngle: getAxisAngle,\n            getAngle: getAngle,\n            multiply: multiply$2,\n            rotateX: rotateX$1,\n            rotateY: rotateY$1,\n            rotateZ: rotateZ$1,\n            calculateW: calculateW,\n            exp: exp,\n            ln: ln,\n            pow: pow,\n            slerp: slerp,\n            random: random$1,\n            invert: invert$1,\n            conjugate: conjugate$1,\n            fromMat3: fromMat3,\n            fromEuler: fromEuler,\n            str: str$2,\n            clone: clone$2,\n            fromValues: fromValues$2,\n            copy: copy$2,\n            set: set$2,\n            add: add$2,\n            mul: mul$2,\n            scale: scale$2,\n            dot: dot$2,\n            lerp: lerp$2,\n            length: length$2,\n            len: len$2,\n            squaredLength: squaredLength$2,\n            sqrLen: sqrLen$2,\n            normalize: normalize$2,\n            exactEquals: exactEquals$2,\n            equals: equals$2,\n            rotationTo: rotationTo,\n            sqlerp: sqlerp,\n            setAxes: setAxes\n        });\n        function create$1() {\n            var dq = new ARRAY_TYPE(8);\n            if (ARRAY_TYPE != Float32Array) {\n                dq[0] = 0;\n                dq[1] = 0;\n                dq[2] = 0;\n                dq[4] = 0;\n                dq[5] = 0;\n                dq[6] = 0;\n                dq[7] = 0\n            }\n            dq[3] = 1;\n            return dq\n        }\n        function clone$1(a) {\n            var dq = new ARRAY_TYPE(8);\n            dq[0] = a[0];\n            dq[1] = a[1];\n            dq[2] = a[2];\n            dq[3] = a[3];\n            dq[4] = a[4];\n            dq[5] = a[5];\n            dq[6] = a[6];\n            dq[7] = a[7];\n            return dq\n        }\n        function fromValues$1(x1, y1, z1, w1, x2, y2, z2, w2) {\n            var dq = new ARRAY_TYPE(8);\n            dq[0] = x1;\n            dq[1] = y1;\n            dq[2] = z1;\n            dq[3] = w1;\n            dq[4] = x2;\n            dq[5] = y2;\n            dq[6] = z2;\n            dq[7] = w2;\n            return dq\n        }\n        function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {\n            var dq = new ARRAY_TYPE(8);\n            dq[0] = x1;\n            dq[1] = y1;\n            dq[2] = z1;\n            dq[3] = w1;\n            var ax = x2 * .5\n              , ay = y2 * .5\n              , az = z2 * .5;\n            dq[4] = ax * w1 + ay * z1 - az * y1;\n            dq[5] = ay * w1 + az * x1 - ax * z1;\n            dq[6] = az * w1 + ax * y1 - ay * x1;\n            dq[7] = -ax * x1 - ay * y1 - az * z1;\n            return dq\n        }\n        function fromRotationTranslation(out, q, t) {\n            var ax = t[0] * .5\n              , ay = t[1] * .5\n              , az = t[2] * .5\n              , bx = q[0]\n              , by = q[1]\n              , bz = q[2]\n              , bw = q[3];\n            out[0] = bx;\n            out[1] = by;\n            out[2] = bz;\n            out[3] = bw;\n            out[4] = ax * bw + ay * bz - az * by;\n            out[5] = ay * bw + az * bx - ax * bz;\n            out[6] = az * bw + ax * by - ay * bx;\n            out[7] = -ax * bx - ay * by - az * bz;\n            return out\n        }\n        function fromTranslation(out, t) {\n            out[0] = 0;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = t[0] * .5;\n            out[5] = t[1] * .5;\n            out[6] = t[2] * .5;\n            out[7] = 0;\n            return out\n        }\n        function fromRotation(out, q) {\n            out[0] = q[0];\n            out[1] = q[1];\n            out[2] = q[2];\n            out[3] = q[3];\n            out[4] = 0;\n            out[5] = 0;\n            out[6] = 0;\n            out[7] = 0;\n            return out\n        }\n        function fromMat4(out, a) {\n            var outer = create$2();\n            getRotation(outer, a);\n            var t = new ARRAY_TYPE(3);\n            getTranslation$1(t, a);\n            fromRotationTranslation(out, outer, t);\n            return out\n        }\n        function copy$1(out, a) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4];\n            out[5] = a[5];\n            out[6] = a[6];\n            out[7] = a[7];\n            return out\n        }\n        function identity(out) {\n            out[0] = 0;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            out[6] = 0;\n            out[7] = 0;\n            return out\n        }\n        function set$1(out, x1, y1, z1, w1, x2, y2, z2, w2) {\n            out[0] = x1;\n            out[1] = y1;\n            out[2] = z1;\n            out[3] = w1;\n            out[4] = x2;\n            out[5] = y2;\n            out[6] = z2;\n            out[7] = w2;\n            return out\n        }\n        var getReal = copy$2;\n        function getDual(out, a) {\n            out[0] = a[4];\n            out[1] = a[5];\n            out[2] = a[6];\n            out[3] = a[7];\n            return out\n        }\n        var setReal = copy$2;\n        function setDual(out, q) {\n            out[4] = q[0];\n            out[5] = q[1];\n            out[6] = q[2];\n            out[7] = q[3];\n            return out\n        }\n        function getTranslation(out, a) {\n            var ax = a[4]\n              , ay = a[5]\n              , az = a[6]\n              , aw = a[7]\n              , bx = -a[0]\n              , by = -a[1]\n              , bz = -a[2]\n              , bw = a[3];\n            out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n            out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n            out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n            return out\n        }\n        function translate(out, a, v) {\n            var ax1 = a[0]\n              , ay1 = a[1]\n              , az1 = a[2]\n              , aw1 = a[3]\n              , bx1 = v[0] * .5\n              , by1 = v[1] * .5\n              , bz1 = v[2] * .5\n              , ax2 = a[4]\n              , ay2 = a[5]\n              , az2 = a[6]\n              , aw2 = a[7];\n            out[0] = ax1;\n            out[1] = ay1;\n            out[2] = az1;\n            out[3] = aw1;\n            out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;\n            out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;\n            out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;\n            out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;\n            return out\n        }\n        function rotateX(out, a, rad) {\n            var bx = -a[0]\n              , by = -a[1]\n              , bz = -a[2]\n              , bw = a[3]\n              , ax = a[4]\n              , ay = a[5]\n              , az = a[6]\n              , aw = a[7]\n              , ax1 = ax * bw + aw * bx + ay * bz - az * by\n              , ay1 = ay * bw + aw * by + az * bx - ax * bz\n              , az1 = az * bw + aw * bz + ax * by - ay * bx\n              , aw1 = aw * bw - ax * bx - ay * by - az * bz;\n            rotateX$1(out, a, rad);\n            bx = out[0];\n            by = out[1];\n            bz = out[2];\n            bw = out[3];\n            out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n            out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n            out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n            out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n            return out\n        }\n        function rotateY(out, a, rad) {\n            var bx = -a[0]\n              , by = -a[1]\n              , bz = -a[2]\n              , bw = a[3]\n              , ax = a[4]\n              , ay = a[5]\n              , az = a[6]\n              , aw = a[7]\n              , ax1 = ax * bw + aw * bx + ay * bz - az * by\n              , ay1 = ay * bw + aw * by + az * bx - ax * bz\n              , az1 = az * bw + aw * bz + ax * by - ay * bx\n              , aw1 = aw * bw - ax * bx - ay * by - az * bz;\n            rotateY$1(out, a, rad);\n            bx = out[0];\n            by = out[1];\n            bz = out[2];\n            bw = out[3];\n            out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n            out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n            out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n            out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n            return out\n        }\n        function rotateZ(out, a, rad) {\n            var bx = -a[0]\n              , by = -a[1]\n              , bz = -a[2]\n              , bw = a[3]\n              , ax = a[4]\n              , ay = a[5]\n              , az = a[6]\n              , aw = a[7]\n              , ax1 = ax * bw + aw * bx + ay * bz - az * by\n              , ay1 = ay * bw + aw * by + az * bx - ax * bz\n              , az1 = az * bw + aw * bz + ax * by - ay * bx\n              , aw1 = aw * bw - ax * bx - ay * by - az * bz;\n            rotateZ$1(out, a, rad);\n            bx = out[0];\n            by = out[1];\n            bz = out[2];\n            bw = out[3];\n            out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n            out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n            out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n            out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n            return out\n        }\n        function rotateByQuatAppend(out, a, q) {\n            var qx = q[0]\n              , qy = q[1]\n              , qz = q[2]\n              , qw = q[3]\n              , ax = a[0]\n              , ay = a[1]\n              , az = a[2]\n              , aw = a[3];\n            out[0] = ax * qw + aw * qx + ay * qz - az * qy;\n            out[1] = ay * qw + aw * qy + az * qx - ax * qz;\n            out[2] = az * qw + aw * qz + ax * qy - ay * qx;\n            out[3] = aw * qw - ax * qx - ay * qy - az * qz;\n            ax = a[4];\n            ay = a[5];\n            az = a[6];\n            aw = a[7];\n            out[4] = ax * qw + aw * qx + ay * qz - az * qy;\n            out[5] = ay * qw + aw * qy + az * qx - ax * qz;\n            out[6] = az * qw + aw * qz + ax * qy - ay * qx;\n            out[7] = aw * qw - ax * qx - ay * qy - az * qz;\n            return out\n        }\n        function rotateByQuatPrepend(out, q, a) {\n            var qx = q[0]\n              , qy = q[1]\n              , qz = q[2]\n              , qw = q[3]\n              , bx = a[0]\n              , by = a[1]\n              , bz = a[2]\n              , bw = a[3];\n            out[0] = qx * bw + qw * bx + qy * bz - qz * by;\n            out[1] = qy * bw + qw * by + qz * bx - qx * bz;\n            out[2] = qz * bw + qw * bz + qx * by - qy * bx;\n            out[3] = qw * bw - qx * bx - qy * by - qz * bz;\n            bx = a[4];\n            by = a[5];\n            bz = a[6];\n            bw = a[7];\n            out[4] = qx * bw + qw * bx + qy * bz - qz * by;\n            out[5] = qy * bw + qw * by + qz * bx - qx * bz;\n            out[6] = qz * bw + qw * bz + qx * by - qy * bx;\n            out[7] = qw * bw - qx * bx - qy * by - qz * bz;\n            return out\n        }\n        function rotateAroundAxis(out, a, axis, rad) {\n            if (Math.abs(rad) < EPSILON)\n                return copy$1(out, a);\n            var axisLength = Math.hypot(axis[0], axis[1], axis[2]);\n            rad = rad * .5;\n            var s = Math.sin(rad);\n            var bx = s * axis[0] \/ axisLength;\n            var by = s * axis[1] \/ axisLength;\n            var bz = s * axis[2] \/ axisLength;\n            var bw = Math.cos(rad);\n            var ax1 = a[0]\n              , ay1 = a[1]\n              , az1 = a[2]\n              , aw1 = a[3];\n            out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n            out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n            out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n            out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n            var ax = a[4]\n              , ay = a[5]\n              , az = a[6]\n              , aw = a[7];\n            out[4] = ax * bw + aw * bx + ay * bz - az * by;\n            out[5] = ay * bw + aw * by + az * bx - ax * bz;\n            out[6] = az * bw + aw * bz + ax * by - ay * bx;\n            out[7] = aw * bw - ax * bx - ay * by - az * bz;\n            return out\n        }\n        function add$1(out, a, b) {\n            out[0] = a[0] + b[0];\n            out[1] = a[1] + b[1];\n            out[2] = a[2] + b[2];\n            out[3] = a[3] + b[3];\n            out[4] = a[4] + b[4];\n            out[5] = a[5] + b[5];\n            out[6] = a[6] + b[6];\n            out[7] = a[7] + b[7];\n            return out\n        }\n        function multiply$1(out, a, b) {\n            var ax0 = a[0]\n              , ay0 = a[1]\n              , az0 = a[2]\n              , aw0 = a[3]\n              , bx1 = b[4]\n              , by1 = b[5]\n              , bz1 = b[6]\n              , bw1 = b[7]\n              , ax1 = a[4]\n              , ay1 = a[5]\n              , az1 = a[6]\n              , aw1 = a[7]\n              , bx0 = b[0]\n              , by0 = b[1]\n              , bz0 = b[2]\n              , bw0 = b[3];\n            out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;\n            out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;\n            out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;\n            out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;\n            out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;\n            out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;\n            out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;\n            out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;\n            return out\n        }\n        var mul$1 = multiply$1;\n        function scale$1(out, a, b) {\n            out[0] = a[0] * b;\n            out[1] = a[1] * b;\n            out[2] = a[2] * b;\n            out[3] = a[3] * b;\n            out[4] = a[4] * b;\n            out[5] = a[5] * b;\n            out[6] = a[6] * b;\n            out[7] = a[7] * b;\n            return out\n        }\n        var dot$1 = dot$2;\n        function lerp$1(out, a, b, t) {\n            var mt = 1 - t;\n            if (dot$1(a, b) < 0)\n                t = -t;\n            out[0] = a[0] * mt + b[0] * t;\n            out[1] = a[1] * mt + b[1] * t;\n            out[2] = a[2] * mt + b[2] * t;\n            out[3] = a[3] * mt + b[3] * t;\n            out[4] = a[4] * mt + b[4] * t;\n            out[5] = a[5] * mt + b[5] * t;\n            out[6] = a[6] * mt + b[6] * t;\n            out[7] = a[7] * mt + b[7] * t;\n            return out\n        }\n        function invert(out, a) {\n            var sqlen = squaredLength$1(a);\n            out[0] = -a[0] \/ sqlen;\n            out[1] = -a[1] \/ sqlen;\n            out[2] = -a[2] \/ sqlen;\n            out[3] = a[3] \/ sqlen;\n            out[4] = -a[4] \/ sqlen;\n            out[5] = -a[5] \/ sqlen;\n            out[6] = -a[6] \/ sqlen;\n            out[7] = a[7] \/ sqlen;\n            return out\n        }\n        function conjugate(out, a) {\n            out[0] = -a[0];\n            out[1] = -a[1];\n            out[2] = -a[2];\n            out[3] = a[3];\n            out[4] = -a[4];\n            out[5] = -a[5];\n            out[6] = -a[6];\n            out[7] = a[7];\n            return out\n        }\n        var length$1 = length$2;\n        var len$1 = length$1;\n        var squaredLength$1 = squaredLength$2;\n        var sqrLen$1 = squaredLength$1;\n        function normalize$1(out, a) {\n            var magnitude = squaredLength$1(a);\n            if (magnitude > 0) {\n                magnitude = Math.sqrt(magnitude);\n                var a0 = a[0] \/ magnitude;\n                var a1 = a[1] \/ magnitude;\n                var a2 = a[2] \/ magnitude;\n                var a3 = a[3] \/ magnitude;\n                var b0 = a[4];\n                var b1 = a[5];\n                var b2 = a[6];\n                var b3 = a[7];\n                var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;\n                out[0] = a0;\n                out[1] = a1;\n                out[2] = a2;\n                out[3] = a3;\n                out[4] = (b0 - a0 * a_dot_b) \/ magnitude;\n                out[5] = (b1 - a1 * a_dot_b) \/ magnitude;\n                out[6] = (b2 - a2 * a_dot_b) \/ magnitude;\n                out[7] = (b3 - a3 * a_dot_b) \/ magnitude\n            }\n            return out\n        }\n        function str$1(a) {\n            return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")"\n        }\n        function exactEquals$1(a, b) {\n            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7]\n        }\n        function equals$1(a, b) {\n            var a0 = a[0]\n              , a1 = a[1]\n              , a2 = a[2]\n              , a3 = a[3]\n              , a4 = a[4]\n              , a5 = a[5]\n              , a6 = a[6]\n              , a7 = a[7];\n            var b0 = b[0]\n              , b1 = b[1]\n              , b2 = b[2]\n              , b3 = b[3]\n              , b4 = b[4]\n              , b5 = b[5]\n              , b6 = b[6]\n              , b7 = b[7];\n            return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7))\n        }\n        var quat2 = Object.freeze({\n            __proto__: null,\n            create: create$1,\n            clone: clone$1,\n            fromValues: fromValues$1,\n            fromRotationTranslationValues: fromRotationTranslationValues,\n            fromRotationTranslation: fromRotationTranslation,\n            fromTranslation: fromTranslation,\n            fromRotation: fromRotation,\n            fromMat4: fromMat4,\n            copy: copy$1,\n            identity: identity,\n            set: set$1,\n            getReal: getReal,\n            getDual: getDual,\n            setReal: setReal,\n            setDual: setDual,\n            getTranslation: getTranslation,\n            translate: translate,\n            rotateX: rotateX,\n            rotateY: rotateY,\n            rotateZ: rotateZ,\n            rotateByQuatAppend: rotateByQuatAppend,\n            rotateByQuatPrepend: rotateByQuatPrepend,\n            rotateAroundAxis: rotateAroundAxis,\n            add: add$1,\n            multiply: multiply$1,\n            mul: mul$1,\n            scale: scale$1,\n            dot: dot$1,\n            lerp: lerp$1,\n            invert: invert,\n            conjugate: conjugate,\n            length: length$1,\n            len: len$1,\n            squaredLength: squaredLength$1,\n            sqrLen: sqrLen$1,\n            normalize: normalize$1,\n            str: str$1,\n            exactEquals: exactEquals$1,\n            equals: equals$1\n        });\n        function create() {\n            var out = new ARRAY_TYPE(2);\n            if (ARRAY_TYPE != Float32Array) {\n                out[0] = 0;\n                out[1] = 0\n            }\n            return out\n        }\n        function clone(a) {\n            var out = new ARRAY_TYPE(2);\n            out[0] = a[0];\n            out[1] = a[1];\n            return out\n        }\n        function fromValues(x, y) {\n            var out = new ARRAY_TYPE(2);\n            out[0] = x;\n            out[1] = y;\n            return out\n        }\n        function copy(out, a) {\n            out[0] = a[0];\n            out[1] = a[1];\n            return out\n        }\n        function set(out, x, y) {\n            out[0] = x;\n            out[1] = y;\n            return out\n        }\n        function add(out, a, b) {\n            out[0] = a[0] + b[0];\n            out[1] = a[1] + b[1];\n            return out\n        }\n        function subtract(out, a, b) {\n            out[0] = a[0] - b[0];\n            out[1] = a[1] - b[1];\n            return out\n        }\n        function multiply(out, a, b) {\n            out[0] = a[0] * b[0];\n            out[1] = a[1] * b[1];\n            return out\n        }\n        function divide(out, a, b) {\n            out[0] = a[0] \/ b[0];\n            out[1] = a[1] \/ b[1];\n            return out\n        }\n        function ceil(out, a) {\n            out[0] = Math.ceil(a[0]);\n            out[1] = Math.ceil(a[1]);\n            return out\n        }\n        function floor(out, a) {\n            out[0] = Math.floor(a[0]);\n            out[1] = Math.floor(a[1]);\n            return out\n        }\n        function min(out, a, b) {\n            out[0] = Math.min(a[0], b[0]);\n            out[1] = Math.min(a[1], b[1]);\n            return out\n        }\n        function max(out, a, b) {\n            out[0] = Math.max(a[0], b[0]);\n            out[1] = Math.max(a[1], b[1]);\n            return out\n        }\n        function round(out, a) {\n            out[0] = Math.round(a[0]);\n            out[1] = Math.round(a[1]);\n            return out\n        }\n        function scale(out, a, b) {\n            out[0] = a[0] * b;\n            out[1] = a[1] * b;\n            return out\n        }\n        function scaleAndAdd(out, a, b, scale) {\n            out[0] = a[0] + b[0] * scale;\n            out[1] = a[1] + b[1] * scale;\n            return out\n        }\n        function distance(a, b) {\n            var x = b[0] - a[0]\n              , y = b[1] - a[1];\n            return Math.hypot(x, y)\n        }\n        function squaredDistance(a, b) {\n            var x = b[0] - a[0]\n              , y = b[1] - a[1];\n            return x * x + y * y\n        }\n        function length(a) {\n            var x = a[0]\n              , y = a[1];\n            return Math.hypot(x, y)\n        }\n        function squaredLength(a) {\n            var x = a[0]\n              , y = a[1];\n            return x * x + y * y\n        }\n        function negate(out, a) {\n            out[0] = -a[0];\n            out[1] = -a[1];\n            return out\n        }\n        function inverse(out, a) {\n            out[0] = 1 \/ a[0];\n            out[1] = 1 \/ a[1];\n            return out\n        }\n        function normalize(out, a) {\n            var x = a[0]\n              , y = a[1];\n            var len = x * x + y * y;\n            if (len > 0)\n                len = 1 \/ Math.sqrt(len);\n            out[0] = a[0] * len;\n            out[1] = a[1] * len;\n            return out\n        }\n        function dot(a, b) {\n            return a[0] * b[0] + a[1] * b[1]\n        }\n        function cross(out, a, b) {\n            var z = a[0] * b[1] - a[1] * b[0];\n            out[0] = out[1] = 0;\n            out[2] = z;\n            return out\n        }\n        function lerp(out, a, b, t) {\n            var ax = a[0]\n              , ay = a[1];\n            out[0] = ax + t * (b[0] - ax);\n            out[1] = ay + t * (b[1] - ay);\n            return out\n        }\n        function random(out, scale) {\n            scale = scale || 1;\n            var r = RANDOM() * 2 * Math.PI;\n            out[0] = Math.cos(r) * scale;\n            out[1] = Math.sin(r) * scale;\n            return out\n        }\n        function transformMat2(out, a, m) {\n            var x = a[0]\n              , y = a[1];\n            out[0] = m[0] * x + m[2] * y;\n            out[1] = m[1] * x + m[3] * y;\n            return out\n        }\n        function transformMat2d(out, a, m) {\n            var x = a[0]\n              , y = a[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out\n        }\n        function transformMat3(out, a, m) {\n            var x = a[0]\n              , y = a[1];\n            out[0] = m[0] * x + m[3] * y + m[6];\n            out[1] = m[1] * x + m[4] * y + m[7];\n            return out\n        }\n        function transformMat4(out, a, m) {\n            var x = a[0];\n            var y = a[1];\n            out[0] = m[0] * x + m[4] * y + m[12];\n            out[1] = m[1] * x + m[5] * y + m[13];\n            return out\n        }\n        function rotate(out, a, b, rad) {\n            var p0 = a[0] - b[0]\n              , p1 = a[1] - b[1]\n              , sinC = Math.sin(rad)\n              , cosC = Math.cos(rad);\n            out[0] = p0 * cosC - p1 * sinC + b[0];\n            out[1] = p0 * sinC + p1 * cosC + b[1];\n            return out\n        }\n        function angle(a, b) {\n            var x1 = a[0]\n              , y1 = a[1]\n              , x2 = b[0]\n              , y2 = b[1]\n              , mag = Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n              , cosine = mag && (x1 * x2 + y1 * y2) \/ mag;\n            return Math.acos(Math.min(Math.max(cosine, -1), 1))\n        }\n        function zero(out) {\n            out[0] = 0;\n            out[1] = 0;\n            return out\n        }\n        function str(a) {\n            return "vec2(" + a[0] + ", " + a[1] + ")"\n        }\n        function exactEquals(a, b) {\n            return a[0] === b[0] && a[1] === b[1]\n        }\n        function equals(a, b) {\n            var a0 = a[0]\n              , a1 = a[1];\n            var b0 = b[0]\n              , b1 = b[1];\n            return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1))\n        }\n        var len = length;\n        var sub = subtract;\n        var mul = multiply;\n        var div = divide;\n        var dist = distance;\n        var sqrDist = squaredDistance;\n        var sqrLen = squaredLength;\n        var forEach = function() {\n            var vec = create();\n            return function(a, stride, offset, count, fn, arg) {\n                var i, l;\n                if (!stride)\n                    stride = 2;\n                if (!offset)\n                    offset = 0;\n                if (count)\n                    l = Math.min(count * stride + offset, a.length);\n                else\n                    l = a.length;\n                for (i = offset; i < l; i += stride) {\n                    vec[0] = a[i];\n                    vec[1] = a[i + 1];\n                    fn(vec, vec, arg);\n                    a[i] = vec[0];\n                    a[i + 1] = vec[1]\n                }\n                return a\n            }\n        }();\n        var vec2 = Object.freeze({\n            __proto__: null,\n            create: create,\n            clone: clone,\n            fromValues: fromValues,\n            copy: copy,\n            set: set,\n            add: add,\n            subtract: subtract,\n            multiply: multiply,\n            divide: divide,\n            ceil: ceil,\n            floor: floor,\n            min: min,\n            max: max,\n            round: round,\n            scale: scale,\n            scaleAndAdd: scaleAndAdd,\n            distance: distance,\n            squaredDistance: squaredDistance,\n            length: length,\n            squaredLength: squaredLength,\n            negate: negate,\n            inverse: inverse,\n            normalize: normalize,\n            dot: dot,\n            cross: cross,\n            lerp: lerp,\n            random: random,\n            transformMat2: transformMat2,\n            transformMat2d: transformMat2d,\n            transformMat3: transformMat3,\n            transformMat4: transformMat4,\n            rotate: rotate,\n            angle: angle,\n            zero: zero,\n            str: str,\n            exactEquals: exactEquals,\n            equals: equals,\n            len: len,\n            sub: sub,\n            mul: mul,\n            div: div,\n            dist: dist,\n            sqrDist: sqrDist,\n            sqrLen: sqrLen,\n            forEach: forEach\n        });\n        exports.glMatrix = common;\n        exports.mat2 = mat2;\n        exports.mat2d = mat2d;\n        exports.mat3 = mat3;\n        exports.mat4 = mat4;\n        exports.quat = quat;\n        exports.quat2 = quat2;\n        exports.vec2 = vec2;\n        exports.vec3 = vec3;\n        exports.vec4 = vec4;\n        Object.defineProperty(exports, "__esModule", {\n            value: true\n        })\n    });\n\n}\n\n\/\/ ..\/3rdparty\/grapheme-splitter.js\n{\n    function GraphemeSplitter() {\n        function h(a, c) {\n            void 0 === c && (c = 0);\n            var b = a.charCodeAt(c);\n            if (55296 <= b && 56319 >= b && c < a.length - 1) {\n                var d = b;\n                a = a.charCodeAt(c + 1);\n                return 56320 <= a && 57343 >= a ? 1024 * (d - 55296) + (a - 56320) + 65536 : d\n            }\n            return 56320 <= b && 57343 >= b && 1 <= c ? (d = a.charCodeAt(c - 1),\n            a = b,\n            55296 <= d && 56319 >= d ? 1024 * (d - 55296) + (a - 56320) + 65536 : a) : b\n        }\n        function l(a, c, b) {\n            var d = [a].concat(c).concat([b])\n              , e = d[d.length - 2]\n              , g = d.lastIndexOf(14);\n            if (1 < g && d.slice(1, g).every(function(f) {\n                return 3 == f\n            }) && -1 == [3, 13, 17].indexOf(a))\n                return 2;\n            a = d.lastIndexOf(4);\n            if (0 < a && d.slice(1, a).every(function(f) {\n                return 4 == f\n            }) && -1 == [12, 4].indexOf(e))\n                return 1 == d.filter(function(f) {\n                    return 4 == f\n                }).length % 2 ? 3 : 4;\n            if (0 == e && 1 == b)\n                return 0;\n            if (2 == e || 0 == e || 1 == e)\n                return 14 == b && c.every(function(f) {\n                    return 3 == f\n                }) ? 2 : 1;\n            if (2 == b || 0 == b || 1 == b)\n                return 1;\n            if (6 != e || 6 != b && 7 != b && 9 != b && 10 != b)\n                if (9 != e && 7 != e || 7 != b && 8 != b)\n                    if (10 != e && 8 != e || 8 != b) {\n                        if (3 == b || 15 == b || 5 == b || 12 == e)\n                            return 0\n                    } else\n                        return 0;\n                else\n                    return 0;\n            else\n                return 0;\n            a = -1 != d.indexOf(3) ? d.lastIndexOf(3) - 1 : d.length - 2;\n            return -1 != [13, 17].indexOf(d[a]) && d.slice(a + 1, -1).every(function(f) {\n                return 3 == f\n            }) && 14 == b || 15 == e && -1 != [16, 17].indexOf(b) ? 0 : -1 != c.indexOf(4) ? 2 : 4 == e && 4 == b ? 0 : 1\n        }\n        function k(a) {\n            return 1536 <= a && 1541 >= a || 1757 == a || 1807 == a || 2274 == a || 3406 == a || 69821 == a || 70082 <= a && 70083 >= a || 72250 == a || 72326 <= a && 72329 >= a || 73030 == a ? 12 : 13 == a ? 0 : 10 == a ? 1 : 0 <= a && 9 >= a || 11 <= a && 12 >= a || 14 <= a && 31 >= a || 127 <= a && 159 >= a || 173 == a || 1564 == a || 6158 == a || 8203 == a || 8206 <= a && 8207 >= a || 8232 == a || 8233 == a || 8234 <= a && 8238 >= a || 8288 <= a && 8292 >= a || 8293 == a || 8294 <= a && 8303 >= a || 55296 <= a && 57343 >= a || 65279 == a || 65520 <= a && 65528 >= a || 65529 <= a && 65531 >= a || 113824 <= a && 113827 >= a || 119155 <= a && 119162 >= a || 917504 == a || 917505 == a || 917506 <= a && 917535 >= a || 917632 <= a && 917759 >= a || 918E3 <= a && 921599 >= a ? 2 : 768 <= a && 879 >= a || 1155 <= a && 1159 >= a || 1160 <= a && 1161 >= a || 1425 <= a && 1469 >= a || 1471 == a || 1473 <= a && 1474 >= a || 1476 <= a && 1477 >= a || 1479 == a || 1552 <= a && 1562 >= a || 1611 <= a && 1631 >= a || 1648 == a || 1750 <= a && 1756 >= a || 1759 <= a && 1764 >= a || 1767 <= a && 1768 >= a || 1770 <= a && 1773 >= a || 1809 == a || 1840 <= a && 1866 >= a || 1958 <= a && 1968 >= a || 2027 <= a && 2035 >= a || 2070 <= a && 2073 >= a || 2075 <= a && 2083 >= a || 2085 <= a && 2087 >= a || 2089 <= a && 2093 >= a || 2137 <= a && 2139 >= a || 2260 <= a && 2273 >= a || 2275 <= a && 2306 >= a || 2362 == a || 2364 == a || 2369 <= a && 2376 >= a || 2381 == a || 2385 <= a && 2391 >= a || 2402 <= a && 2403 >= a || 2433 == a || 2492 == a || 2494 == a || 2497 <= a && 2500 >= a || 2509 == a || 2519 == a || 2530 <= a && 2531 >= a || 2561 <= a && 2562 >= a || 2620 == a || 2625 <= a && 2626 >= a || 2631 <= a && 2632 >= a || 2635 <= a && 2637 >= a || 2641 == a || 2672 <= a && 2673 >= a || 2677 == a || 2689 <= a && 2690 >= a || 2748 == a || 2753 <= a && 2757 >= a || 2759 <= a && 2760 >= a || 2765 == a || 2786 <= a && 2787 >= a || 2810 <= a && 2815 >= a || 2817 == a || 2876 == a || 2878 == a || 2879 == a || 2881 <= a && 2884 >= a || 2893 == a || 2902 == a || 2903 == a || 2914 <= a && 2915 >= a || 2946 == a || 3006 == a || 3008 == a || 3021 == a || 3031 == a || 3072 == a || 3134 <= a && 3136 >= a || 3142 <= a && 3144 >= a || 3146 <= a && 3149 >= a || 3157 <= a && 3158 >= a || 3170 <= a && 3171 >= a || 3201 == a || 3260 == a || 3263 == a || 3266 == a || 3270 == a || 3276 <= a && 3277 >= a || 3285 <= a && 3286 >= a || 3298 <= a && 3299 >= a || 3328 <= a && 3329 >= a || 3387 <= a && 3388 >= a || 3390 == a || 3393 <= a && 3396 >= a || 3405 == a || 3415 == a || 3426 <= a && 3427 >= a || 3530 == a || 3535 == a || 3538 <= a && 3540 >= a || 3542 == a || 3551 == a || 3633 == a || 3636 <= a && 3642 >= a || 3655 <= a && 3662 >= a || 3761 == a || 3764 <= a && 3769 >= a || 3771 <= a && 3772 >= a || 3784 <= a && 3789 >= a || 3864 <= a && 3865 >= a || 3893 == a || 3895 == a || 3897 == a || 3953 <= a && 3966 >= a || 3968 <= a && 3972 >= a || 3974 <= a && 3975 >= a || 3981 <= a && 3991 >= a || 3993 <= a && 4028 >= a || 4038 == a || 4141 <= a && 4144 >= a || 4146 <= a && 4151 >= a || 4153 <= a && 4154 >= a || 4157 <= a && 4158 >= a || 4184 <= a && 4185 >= a || 4190 <= a && 4192 >= a || 4209 <= a && 4212 >= a || 4226 == a || 4229 <= a && 4230 >= a || 4237 == a || 4253 == a || 4957 <= a && 4959 >= a || 5906 <= a && 5908 >= a || 5938 <= a && 5940 >= a || 5970 <= a && 5971 >= a || 6002 <= a && 6003 >= a || 6068 <= a && 6069 >= a || 6071 <= a && 6077 >= a || 6086 == a || 6089 <= a && 6099 >= a || 6109 == a || 6155 <= a && 6157 >= a || 6277 <= a && 6278 >= a || 6313 == a || 6432 <= a && 6434 >= a || 6439 <= a && 6440 >= a || 6450 == a || 6457 <= a && 6459 >= a || 6679 <= a && 6680 >= a || 6683 == a || 6742 == a || 6744 <= a && 6750 >= a || 6752 == a || 6754 == a || 6757 <= a && 6764 >= a || 6771 <= a && 6780 >= a || 6783 == a || 6832 <= a && 6845 >= a || 6846 == a || 6912 <= a && 6915 >= a || 6964 == a || 6966 <= a && 6970 >= a || 6972 == a || 6978 == a || 7019 <= a && 7027 >= a || 7040 <= a && 7041 >= a || 7074 <= a && 7077 >= a || 7080 <= a && 7081 >= a || 7083 <= a && 7085 >= a || 7142 == a || 7144 <= a && 7145 >= a || 7149 == a || 7151 <= a && 7153 >= a || 7212 <= a && 7219 >= a || 7222 <= a && 7223 >= a || 7376 <= a && 7378 >= a || 7380 <= a && 7392 >= a || 7394 <= a && 7400 >= a || 7405 == a || 7412 == a || 7416 <= a && 7417 >= a || 7616 <= a && 7673 >= a || 7675 <= a && 7679 >= a || 8204 == a || 8400 <= a && 8412 >= a || 8413 <= a && 8416 >= a || 8417 == a || 8418 <= a && 8420 >= a || 8421 <= a && 8432 >= a || 11503 <= a && 11505 >= a || 11647 == a || 11744 <= a && 11775 >= a || 12330 <= a && 12333 >= a || 12334 <= a && 12335 >= a || 12441 <= a && 12442 >= a || 42607 == a || 42608 <= a && 42610 >= a || 42612 <= a && 42621 >= a || 42654 <= a && 42655 >= a || 42736 <= a && 42737 >= a || 43010 == a || 43014 == a || 43019 == a || 43045 <= a && 43046 >= a || 43204 <= a && 43205 >= a || 43232 <= a && 43249 >= a || 43302 <= a && 43309 >= a || 43335 <= a && 43345 >= a || 43392 <= a && 43394 >= a || 43443 == a || 43446 <= a && 43449 >= a || 43452 == a || 43493 == a || 43561 <= a && 43566 >= a || 43569 <= a && 43570 >= a || 43573 <= a && 43574 >= a || 43587 == a || 43596 == a || 43644 == a || 43696 == a || 43698 <= a && 43700 >= a || 43703 <= a && 43704 >= a || 43710 <= a && 43711 >= a || 43713 == a || 43756 <= a && 43757 >= a || 43766 == a || 44005 == a || 44008 == a || 44013 == a || 64286 == a || 65024 <= a && 65039 >= a || 65056 <= a && 65071 >= a || 65438 <= a && 65439 >= a || 66045 == a || 66272 == a || 66422 <= a && 66426 >= a || 68097 <= a && 68099 >= a || 68101 <= a && 68102 >= a || 68108 <= a && 68111 >= a || 68152 <= a && 68154 >= a || 68159 == a || 68325 <= a && 68326 >= a || 69633 == a || 69688 <= a && 69702 >= a || 69759 <= a && 69761 >= a || 69811 <= a && 69814 >= a || 69817 <= a && 69818 >= a || 69888 <= a && 69890 >= a || 69927 <= a && 69931 >= a || 69933 <= a && 69940 >= a || 70003 == a || 70016 <= a && 70017 >= a || 70070 <= a && 70078 >= a || 70090 <= a && 70092 >= a || 70191 <= a && 70193 >= a || 70196 == a || 70198 <= a && 70199 >= a || 70206 == a || 70367 == a || 70371 <= a && 70378 >= a || 70400 <= a && 70401 >= a || 70460 == a || 70462 == a || 70464 == a || 70487 == a || 70502 <= a && 70508 >= a || 70512 <= a && 70516 >= a || 70712 <= a && 70719 >= a || 70722 <= a && 70724 >= a || 70726 == a || 70832 == a || 70835 <= a && 70840 >= a || 70842 == a || 70845 == a || 70847 <= a && 70848 >= a || 70850 <= a && 70851 >= a || 71087 == a || 71090 <= a && 71093 >= a || 71100 <= a && 71101 >= a || 71103 <= a && 71104 >= a || 71132 <= a && 71133 >= a || 71219 <= a && 71226 >= a || 71229 == a || 71231 <= a && 71232 >= a || 71339 == a || 71341 == a || 71344 <= a && 71349 >= a || 71351 == a || 71453 <= a && 71455 >= a || 71458 <= a && 71461 >= a || 71463 <= a && 71467 >= a || 72193 <= a && 72198 >= a || 72201 <= a && 72202 >= a || 72243 <= a && 72248 >= a || 72251 <= a && 72254 >= a || 72263 == a || 72273 <= a && 72278 >= a || 72281 <= a && 72283 >= a || 72330 <= a && 72342 >= a || 72344 <= a && 72345 >= a || 72752 <= a && 72758 >= a || 72760 <= a && 72765 >= a || 72767 == a || 72850 <= a && 72871 >= a || 72874 <= a && 72880 >= a || 72882 <= a && 72883 >= a || 72885 <= a && 72886 >= a || 73009 <= a && 73014 >= a || 73018 == a || 73020 <= a && 73021 >= a || 73023 <= a && 73029 >= a || 73031 == a || 92912 <= a && 92916 >= a || 92976 <= a && 92982 >= a || 94095 <= a && 94098 >= a || 113821 <= a && 113822 >= a || 119141 == a || 119143 <= a && 119145 >= a || 119150 <= a && 119154 >= a || 119163 <= a && 119170 >= a || 119173 <= a && 119179 >= a || 119210 <= a && 119213 >= a || 119362 <= a && 119364 >= a || 121344 <= a && 121398 >= a || 121403 <= a && 121452 >= a || 121461 == a || 121476 == a || 121499 <= a && 121503 >= a || 121505 <= a && 121519 >= a || 122880 <= a && 122886 >= a || 122888 <= a && 122904 >= a || 122907 <= a && 122913 >= a || 122915 <= a && 122916 >= a || 122918 <= a && 122922 >= a || 125136 <= a && 125142 >= a || 125252 <= a && 125258 >= a || 917536 <= a && 917631 >= a || 917760 <= a && 917999 >= a ? 3 : 127462 <= a && 127487 >= a ? 4 : 2307 == a || 2363 == a || 2366 <= a && 2368 >= a || 2377 <= a && 2380 >= a || 2382 <= a && 2383 >= a || 2434 <= a && 2435 >= a || 2495 <= a && 2496 >= a || 2503 <= a && 2504 >= a || 2507 <= a && 2508 >= a || 2563 == a || 2622 <= a && 2624 >= a || 2691 == a || 2750 <= a && 2752 >= a || 2761 == a || 2763 <= a && 2764 >= a || 2818 <= a && 2819 >= a || 2880 == a || 2887 <= a && 2888 >= a || 2891 <= a && 2892 >= a || 3007 == a || 3009 <= a && 3010 >= a || 3014 <= a && 3016 >= a || 3018 <= a && 3020 >= a || 3073 <= a && 3075 >= a || 3137 <= a && 3140 >= a || 3202 <= a && 3203 >= a || 3262 == a || 3264 <= a && 3265 >= a || 3267 <= a && 3268 >= a || 3271 <= a && 3272 >= a || 3274 <= a && 3275 >= a || 3330 <= a && 3331 >= a || 3391 <= a && 3392 >= a || 3398 <= a && 3400 >= a || 3402 <= a && 3404 >= a || 3458 <= a && 3459 >= a || 3536 <= a && 3537 >= a || 3544 <= a && 3550 >= a || 3570 <= a && 3571 >= a || 3635 == a || 3763 == a || 3902 <= a && 3903 >= a || 3967 == a || 4145 == a || 4155 <= a && 4156 >= a || 4182 <= a && 4183 >= a || 4228 == a || 6070 == a || 6078 <= a && 6085 >= a || 6087 <= a && 6088 >= a || 6435 <= a && 6438 >= a || 6441 <= a && 6443 >= a || 6448 <= a && 6449 >= a || 6451 <= a && 6456 >= a || 6681 <= a && 6682 >= a || 6741 == a || 6743 == a || 6765 <= a && 6770 >= a || 6916 == a || 6965 == a || 6971 == a || 6973 <= a && 6977 >= a || 6979 <= a && 6980 >= a || 7042 == a || 7073 == a || 7078 <= a && 7079 >= a || 7082 == a || 7143 == a || 7146 <= a && 7148 >= a || 7150 == a || 7154 <= a && 7155 >= a || 7204 <= a && 7211 >= a || 7220 <= a && 7221 >= a || 7393 == a || 7410 <= a && 7411 >= a || 7415 == a || 43043 <= a && 43044 >= a || 43047 == a || 43136 <= a && 43137 >= a || 43188 <= a && 43203 >= a || 43346 <= a && 43347 >= a || 43395 == a || 43444 <= a && 43445 >= a || 43450 <= a && 43451 >= a || 43453 <= a && 43456 >= a || 43567 <= a && 43568 >= a || 43571 <= a && 43572 >= a || 43597 == a || 43755 == a || 43758 <= a && 43759 >= a || 43765 == a || 44003 <= a && 44004 >= a || 44006 <= a && 44007 >= a || 44009 <= a && 44010 >= a || 44012 == a || 69632 == a || 69634 == a || 69762 == a || 69808 <= a && 69810 >= a || 69815 <= a && 69816 >= a || 69932 == a || 70018 == a || 70067 <= a && 70069 >= a || 70079 <= a && 70080 >= a || 70188 <= a && 70190 >= a || 70194 <= a && 70195 >= a || 70197 == a || 70368 <= a && 70370 >= a || 70402 <= a && 70403 >= a || 70463 == a || 70465 <= a && 70468 >= a || 70471 <= a && 70472 >= a || 70475 <= a && 70477 >= a || 70498 <= a && 70499 >= a || 70709 <= a && 70711 >= a || 70720 <= a && 70721 >= a || 70725 == a || 70833 <= a && 70834 >= a || 70841 == a || 70843 <= a && 70844 >= a || 70846 == a || 70849 == a || 71088 <= a && 71089 >= a || 71096 <= a && 71099 >= a || 71102 == a || 71216 <= a && 71218 >= a || 71227 <= a && 71228 >= a || 71230 == a || 71340 == a || 71342 <= a && 71343 >= a || 71350 == a || 71456 <= a && 71457 >= a || 71462 == a || 72199 <= a && 72200 >= a || 72249 == a || 72279 <= a && 72280 >= a || 72343 == a || 72751 == a || 72766 == a || 72873 == a || 72881 == a || 72884 == a || 94033 <= a && 94078 >= a || 119142 == a || 119149 == a ? 5 : 4352 <= a && 4447 >= a || 43360 <= a && 43388 >= a ? 6 : 4448 <= a && 4519 >= a || 55216 <= a && 55238 >= a ? 7 : 4520 <= a && 4607 >= a || 55243 <= a && 55291 >= a ? 8 : 44032 == a || 44060 == a || 44088 == a || 44116 == a || 44144 == a || 44172 == a || 44200 == a || 44228 == a || 44256 == a || 44284 == a || 44312 == a || 44340 == a || 44368 == a || 44396 == a || 44424 == a || 44452 == a || 44480 == a || 44508 == a || 44536 == a || 44564 == a || 44592 == a || 44620 == a || 44648 == a || 44676 == a || 44704 == a || 44732 == a || 44760 == a || 44788 == a || 44816 == a || 44844 == a || 44872 == a || 44900 == a || 44928 == a || 44956 == a || 44984 == a || 45012 == a || 45040 == a || 45068 == a || 45096 == a || 45124 == a || 45152 == a || 45180 == a || 45208 == a || 45236 == a || 45264 == a || 45292 == a || 45320 == a || 45348 == a || 45376 == a || 45404 == a || 45432 == a || 45460 == a || 45488 == a || 45516 == a || 45544 == a || 45572 == a || 45600 == a || 45628 == a || 45656 == a || 45684 == a || 45712 == a || 45740 == a || 45768 == a || 45796 == a || 45824 == a || 45852 == a || 45880 == a || 45908 == a || 45936 == a || 45964 == a || 45992 == a || 46020 == a || 46048 == a || 46076 == a || 46104 == a || 46132 == a || 46160 == a || 46188 == a || 46216 == a || 46244 == a || 46272 == a || 46300 == a || 46328 == a || 46356 == a || 46384 == a || 46412 == a || 46440 == a || 46468 == a || 46496 == a || 46524 == a || 46552 == a || 46580 == a || 46608 == a || 46636 == a || 46664 == a || 46692 == a || 46720 == a || 46748 == a || 46776 == a || 46804 == a || 46832 == a || 46860 == a || 46888 == a || 46916 == a || 46944 == a || 46972 == a || 47E3 == a || 47028 == a || 47056 == a || 47084 == a || 47112 == a || 47140 == a || 47168 == a || 47196 == a || 47224 == a || 47252 == a || 47280 == a || 47308 == a || 47336 == a || 47364 == a || 47392 == a || 47420 == a || 47448 == a || 47476 == a || 47504 == a || 47532 == a || 47560 == a || 47588 == a || 47616 == a || 47644 == a || 47672 == a || 47700 == a || 47728 == a || 47756 == a || 47784 == a || 47812 == a || 47840 == a || 47868 == a || 47896 == a || 47924 == a || 47952 == a || 47980 == a || 48008 == a || 48036 == a || 48064 == a || 48092 == a || 48120 == a || 48148 == a || 48176 == a || 48204 == a || 48232 == a || 48260 == a || 48288 == a || 48316 == a || 48344 == a || 48372 == a || 48400 == a || 48428 == a || 48456 == a || 48484 == a || 48512 == a || 48540 == a || 48568 == a || 48596 == a || 48624 == a || 48652 == a || 48680 == a || 48708 == a || 48736 == a || 48764 == a || 48792 == a || 48820 == a || 48848 == a || 48876 == a || 48904 == a || 48932 == a || 48960 == a || 48988 == a || 49016 == a || 49044 == a || 49072 == a || 49100 == a || 49128 == a || 49156 == a || 49184 == a || 49212 == a || 49240 == a || 49268 == a || 49296 == a || 49324 == a || 49352 == a || 49380 == a || 49408 == a || 49436 == a || 49464 == a || 49492 == a || 49520 == a || 49548 == a || 49576 == a || 49604 == a || 49632 == a || 49660 == a || 49688 == a || 49716 == a || 49744 == a || 49772 == a || 49800 == a || 49828 == a || 49856 == a || 49884 == a || 49912 == a || 49940 == a || 49968 == a || 49996 == a || 50024 == a || 50052 == a || 50080 == a || 50108 == a || 50136 == a || 50164 == a || 50192 == a || 50220 == a || 50248 == a || 50276 == a || 50304 == a || 50332 == a || 50360 == a || 50388 == a || 50416 == a || 50444 == a || 50472 == a || 50500 == a || 50528 == a || 50556 == a || 50584 == a || 50612 == a || 50640 == a || 50668 == a || 50696 == a || 50724 == a || 50752 == a || 50780 == a || 50808 == a || 50836 == a || 50864 == a || 50892 == a || 50920 == a || 50948 == a || 50976 == a || 51004 == a || 51032 == a || 51060 == a || 51088 == a || 51116 == a || 51144 == a || 51172 == a || 51200 == a || 51228 == a || 51256 == a || 51284 == a || 51312 == a || 51340 == a || 51368 == a || 51396 == a || 51424 == a || 51452 == a || 51480 == a || 51508 == a || 51536 == a || 51564 == a || 51592 == a || 51620 == a || 51648 == a || 51676 == a || 51704 == a || 51732 == a || 51760 == a || 51788 == a || 51816 == a || 51844 == a || 51872 == a || 51900 == a || 51928 == a || 51956 == a || 51984 == a || 52012 == a || 52040 == a || 52068 == a || 52096 == a || 52124 == a || 52152 == a || 52180 == a || 52208 == a || 52236 == a || 52264 == a || 52292 == a || 52320 == a || 52348 == a || 52376 == a || 52404 == a || 52432 == a || 52460 == a || 52488 == a || 52516 == a || 52544 == a || 52572 == a || 52600 == a || 52628 == a || 52656 == a || 52684 == a || 52712 == a || 52740 == a || 52768 == a || 52796 == a || 52824 == a || 52852 == a || 52880 == a || 52908 == a || 52936 == a || 52964 == a || 52992 == a || 53020 == a || 53048 == a || 53076 == a || 53104 == a || 53132 == a || 53160 == a || 53188 == a || 53216 == a || 53244 == a || 53272 == a || 53300 == a || 53328 == a || 53356 == a || 53384 == a || 53412 == a || 53440 == a || 53468 == a || 53496 == a || 53524 == a || 53552 == a || 53580 == a || 53608 == a || 53636 == a || 53664 == a || 53692 == a || 53720 == a || 53748 == a || 53776 == a || 53804 == a || 53832 == a || 53860 == a || 53888 == a || 53916 == a || 53944 == a || 53972 == a || 54E3 == a || 54028 == a || 54056 == a || 54084 == a || 54112 == a || 54140 == a || 54168 == a || 54196 == a || 54224 == a || 54252 == a || 54280 == a || 54308 == a || 54336 == a || 54364 == a || 54392 == a || 54420 == a || 54448 == a || 54476 == a || 54504 == a || 54532 == a || 54560 == a || 54588 == a || 54616 == a || 54644 == a || 54672 == a || 54700 == a || 54728 == a || 54756 == a || 54784 == a || 54812 == a || 54840 == a || 54868 == a || 54896 == a || 54924 == a || 54952 == a || 54980 == a || 55008 == a || 55036 == a || 55064 == a || 55092 == a || 55120 == a || 55148 == a || 55176 == a ? 9 : 44033 <= a && 44059 >= a || 44061 <= a && 44087 >= a || 44089 <= a && 44115 >= a || 44117 <= a && 44143 >= a || 44145 <= a && 44171 >= a || 44173 <= a && 44199 >= a || 44201 <= a && 44227 >= a || 44229 <= a && 44255 >= a || 44257 <= a && 44283 >= a || 44285 <= a && 44311 >= a || 44313 <= a && 44339 >= a || 44341 <= a && 44367 >= a || 44369 <= a && 44395 >= a || 44397 <= a && 44423 >= a || 44425 <= a && 44451 >= a || 44453 <= a && 44479 >= a || 44481 <= a && 44507 >= a || 44509 <= a && 44535 >= a || 44537 <= a && 44563 >= a || 44565 <= a && 44591 >= a || 44593 <= a && 44619 >= a || 44621 <= a && 44647 >= a || 44649 <= a && 44675 >= a || 44677 <= a && 44703 >= a || 44705 <= a && 44731 >= a || 44733 <= a && 44759 >= a || 44761 <= a && 44787 >= a || 44789 <= a && 44815 >= a || 44817 <= a && 44843 >= a || 44845 <= a && 44871 >= a || 44873 <= a && 44899 >= a || 44901 <= a && 44927 >= a || 44929 <= a && 44955 >= a || 44957 <= a && 44983 >= a || 44985 <= a && 45011 >= a || 45013 <= a && 45039 >= a || 45041 <= a && 45067 >= a || 45069 <= a && 45095 >= a || 45097 <= a && 45123 >= a || 45125 <= a && 45151 >= a || 45153 <= a && 45179 >= a || 45181 <= a && 45207 >= a || 45209 <= a && 45235 >= a || 45237 <= a && 45263 >= a || 45265 <= a && 45291 >= a || 45293 <= a && 45319 >= a || 45321 <= a && 45347 >= a || 45349 <= a && 45375 >= a || 45377 <= a && 45403 >= a || 45405 <= a && 45431 >= a || 45433 <= a && 45459 >= a || 45461 <= a && 45487 >= a || 45489 <= a && 45515 >= a || 45517 <= a && 45543 >= a || 45545 <= a && 45571 >= a || 45573 <= a && 45599 >= a || 45601 <= a && 45627 >= a || 45629 <= a && 45655 >= a || 45657 <= a && 45683 >= a || 45685 <= a && 45711 >= a || 45713 <= a && 45739 >= a || 45741 <= a && 45767 >= a || 45769 <= a && 45795 >= a || 45797 <= a && 45823 >= a || 45825 <= a && 45851 >= a || 45853 <= a && 45879 >= a || 45881 <= a && 45907 >= a || 45909 <= a && 45935 >= a || 45937 <= a && 45963 >= a || 45965 <= a && 45991 >= a || 45993 <= a && 46019 >= a || 46021 <= a && 46047 >= a || 46049 <= a && 46075 >= a || 46077 <= a && 46103 >= a || 46105 <= a && 46131 >= a || 46133 <= a && 46159 >= a || 46161 <= a && 46187 >= a || 46189 <= a && 46215 >= a || 46217 <= a && 46243 >= a || 46245 <= a && 46271 >= a || 46273 <= a && 46299 >= a || 46301 <= a && 46327 >= a || 46329 <= a && 46355 >= a || 46357 <= a && 46383 >= a || 46385 <= a && 46411 >= a || 46413 <= a && 46439 >= a || 46441 <= a && 46467 >= a || 46469 <= a && 46495 >= a || 46497 <= a && 46523 >= a || 46525 <= a && 46551 >= a || 46553 <= a && 46579 >= a || 46581 <= a && 46607 >= a || 46609 <= a && 46635 >= a || 46637 <= a && 46663 >= a || 46665 <= a && 46691 >= a || 46693 <= a && 46719 >= a || 46721 <= a && 46747 >= a || 46749 <= a && 46775 >= a || 46777 <= a && 46803 >= a || 46805 <= a && 46831 >= a || 46833 <= a && 46859 >= a || 46861 <= a && 46887 >= a || 46889 <= a && 46915 >= a || 46917 <= a && 46943 >= a || 46945 <= a && 46971 >= a || 46973 <= a && 46999 >= a || 47001 <= a && 47027 >= a || 47029 <= a && 47055 >= a || 47057 <= a && 47083 >= a || 47085 <= a && 47111 >= a || 47113 <= a && 47139 >= a || 47141 <= a && 47167 >= a || 47169 <= a && 47195 >= a || 47197 <= a && 47223 >= a || 47225 <= a && 47251 >= a || 47253 <= a && 47279 >= a || 47281 <= a && 47307 >= a || 47309 <= a && 47335 >= a || 47337 <= a && 47363 >= a || 47365 <= a && 47391 >= a || 47393 <= a && 47419 >= a || 47421 <= a && 47447 >= a || 47449 <= a && 47475 >= a || 47477 <= a && 47503 >= a || 47505 <= a && 47531 >= a || 47533 <= a && 47559 >= a || 47561 <= a && 47587 >= a || 47589 <= a && 47615 >= a || 47617 <= a && 47643 >= a || 47645 <= a && 47671 >= a || 47673 <= a && 47699 >= a || 47701 <= a && 47727 >= a || 47729 <= a && 47755 >= a || 47757 <= a && 47783 >= a || 47785 <= a && 47811 >= a || 47813 <= a && 47839 >= a || 47841 <= a && 47867 >= a || 47869 <= a && 47895 >= a || 47897 <= a && 47923 >= a || 47925 <= a && 47951 >= a || 47953 <= a && 47979 >= a || 47981 <= a && 48007 >= a || 48009 <= a && 48035 >= a || 48037 <= a && 48063 >= a || 48065 <= a && 48091 >= a || 48093 <= a && 48119 >= a || 48121 <= a && 48147 >= a || 48149 <= a && 48175 >= a || 48177 <= a && 48203 >= a || 48205 <= a && 48231 >= a || 48233 <= a && 48259 >= a || 48261 <= a && 48287 >= a || 48289 <= a && 48315 >= a || 48317 <= a && 48343 >= a || 48345 <= a && 48371 >= a || 48373 <= a && 48399 >= a || 48401 <= a && 48427 >= a || 48429 <= a && 48455 >= a || 48457 <= a && 48483 >= a || 48485 <= a && 48511 >= a || 48513 <= a && 48539 >= a || 48541 <= a && 48567 >= a || 48569 <= a && 48595 >= a || 48597 <= a && 48623 >= a || 48625 <= a && 48651 >= a || 48653 <= a && 48679 >= a || 48681 <= a && 48707 >= a || 48709 <= a && 48735 >= a || 48737 <= a && 48763 >= a || 48765 <= a && 48791 >= a || 48793 <= a && 48819 >= a || 48821 <= a && 48847 >= a || 48849 <= a && 48875 >= a || 48877 <= a && 48903 >= a || 48905 <= a && 48931 >= a || 48933 <= a && 48959 >= a || 48961 <= a && 48987 >= a || 48989 <= a && 49015 >= a || 49017 <= a && 49043 >= a || 49045 <= a && 49071 >= a || 49073 <= a && 49099 >= a || 49101 <= a && 49127 >= a || 49129 <= a && 49155 >= a || 49157 <= a && 49183 >= a || 49185 <= a && 49211 >= a || 49213 <= a && 49239 >= a || 49241 <= a && 49267 >= a || 49269 <= a && 49295 >= a || 49297 <= a && 49323 >= a || 49325 <= a && 49351 >= a || 49353 <= a && 49379 >= a || 49381 <= a && 49407 >= a || 49409 <= a && 49435 >= a || 49437 <= a && 49463 >= a || 49465 <= a && 49491 >= a || 49493 <= a && 49519 >= a || 49521 <= a && 49547 >= a || 49549 <= a && 49575 >= a || 49577 <= a && 49603 >= a || 49605 <= a && 49631 >= a || 49633 <= a && 49659 >= a || 49661 <= a && 49687 >= a || 49689 <= a && 49715 >= a || 49717 <= a && 49743 >= a || 49745 <= a && 49771 >= a || 49773 <= a && 49799 >= a || 49801 <= a && 49827 >= a || 49829 <= a && 49855 >= a || 49857 <= a && 49883 >= a || 49885 <= a && 49911 >= a || 49913 <= a && 49939 >= a || 49941 <= a && 49967 >= a || 49969 <= a && 49995 >= a || 49997 <= a && 50023 >= a || 50025 <= a && 50051 >= a || 50053 <= a && 50079 >= a || 50081 <= a && 50107 >= a || 50109 <= a && 50135 >= a || 50137 <= a && 50163 >= a || 50165 <= a && 50191 >= a || 50193 <= a && 50219 >= a || 50221 <= a && 50247 >= a || 50249 <= a && 50275 >= a || 50277 <= a && 50303 >= a || 50305 <= a && 50331 >= a || 50333 <= a && 50359 >= a || 50361 <= a && 50387 >= a || 50389 <= a && 50415 >= a || 50417 <= a && 50443 >= a || 50445 <= a && 50471 >= a || 50473 <= a && 50499 >= a || 50501 <= a && 50527 >= a || 50529 <= a && 50555 >= a || 50557 <= a && 50583 >= a || 50585 <= a && 50611 >= a || 50613 <= a && 50639 >= a || 50641 <= a && 50667 >= a || 50669 <= a && 50695 >= a || 50697 <= a && 50723 >= a || 50725 <= a && 50751 >= a || 50753 <= a && 50779 >= a || 50781 <= a && 50807 >= a || 50809 <= a && 50835 >= a || 50837 <= a && 50863 >= a || 50865 <= a && 50891 >= a || 50893 <= a && 50919 >= a || 50921 <= a && 50947 >= a || 50949 <= a && 50975 >= a || 50977 <= a && 51003 >= a || 51005 <= a && 51031 >= a || 51033 <= a && 51059 >= a || 51061 <= a && 51087 >= a || 51089 <= a && 51115 >= a || 51117 <= a && 51143 >= a || 51145 <= a && 51171 >= a || 51173 <= a && 51199 >= a || 51201 <= a && 51227 >= a || 51229 <= a && 51255 >= a || 51257 <= a && 51283 >= a || 51285 <= a && 51311 >= a || 51313 <= a && 51339 >= a || 51341 <= a && 51367 >= a || 51369 <= a && 51395 >= a || 51397 <= a && 51423 >= a || 51425 <= a && 51451 >= a || 51453 <= a && 51479 >= a || 51481 <= a && 51507 >= a || 51509 <= a && 51535 >= a || 51537 <= a && 51563 >= a || 51565 <= a && 51591 >= a || 51593 <= a && 51619 >= a || 51621 <= a && 51647 >= a || 51649 <= a && 51675 >= a || 51677 <= a && 51703 >= a || 51705 <= a && 51731 >= a || 51733 <= a && 51759 >= a || 51761 <= a && 51787 >= a || 51789 <= a && 51815 >= a || 51817 <= a && 51843 >= a || 51845 <= a && 51871 >= a || 51873 <= a && 51899 >= a || 51901 <= a && 51927 >= a || 51929 <= a && 51955 >= a || 51957 <= a && 51983 >= a || 51985 <= a && 52011 >= a || 52013 <= a && 52039 >= a || 52041 <= a && 52067 >= a || 52069 <= a && 52095 >= a || 52097 <= a && 52123 >= a || 52125 <= a && 52151 >= a || 52153 <= a && 52179 >= a || 52181 <= a && 52207 >= a || 52209 <= a && 52235 >= a || 52237 <= a && 52263 >= a || 52265 <= a && 52291 >= a || 52293 <= a && 52319 >= a || 52321 <= a && 52347 >= a || 52349 <= a && 52375 >= a || 52377 <= a && 52403 >= a || 52405 <= a && 52431 >= a || 52433 <= a && 52459 >= a || 52461 <= a && 52487 >= a || 52489 <= a && 52515 >= a || 52517 <= a && 52543 >= a || 52545 <= a && 52571 >= a || 52573 <= a && 52599 >= a || 52601 <= a && 52627 >= a || 52629 <= a && 52655 >= a || 52657 <= a && 52683 >= a || 52685 <= a && 52711 >= a || 52713 <= a && 52739 >= a || 52741 <= a && 52767 >= a || 52769 <= a && 52795 >= a || 52797 <= a && 52823 >= a || 52825 <= a && 52851 >= a || 52853 <= a && 52879 >= a || 52881 <= a && 52907 >= a || 52909 <= a && 52935 >= a || 52937 <= a && 52963 >= a || 52965 <= a && 52991 >= a || 52993 <= a && 53019 >= a || 53021 <= a && 53047 >= a || 53049 <= a && 53075 >= a || 53077 <= a && 53103 >= a || 53105 <= a && 53131 >= a || 53133 <= a && 53159 >= a || 53161 <= a && 53187 >= a || 53189 <= a && 53215 >= a || 53217 <= a && 53243 >= a || 53245 <= a && 53271 >= a || 53273 <= a && 53299 >= a || 53301 <= a && 53327 >= a || 53329 <= a && 53355 >= a || 53357 <= a && 53383 >= a || 53385 <= a && 53411 >= a || 53413 <= a && 53439 >= a || 53441 <= a && 53467 >= a || 53469 <= a && 53495 >= a || 53497 <= a && 53523 >= a || 53525 <= a && 53551 >= a || 53553 <= a && 53579 >= a || 53581 <= a && 53607 >= a || 53609 <= a && 53635 >= a || 53637 <= a && 53663 >= a || 53665 <= a && 53691 >= a || 53693 <= a && 53719 >= a || 53721 <= a && 53747 >= a || 53749 <= a && 53775 >= a || 53777 <= a && 53803 >= a || 53805 <= a && 53831 >= a || 53833 <= a && 53859 >= a || 53861 <= a && 53887 >= a || 53889 <= a && 53915 >= a || 53917 <= a && 53943 >= a || 53945 <= a && 53971 >= a || 53973 <= a && 53999 >= a || 54001 <= a && 54027 >= a || 54029 <= a && 54055 >= a || 54057 <= a && 54083 >= a || 54085 <= a && 54111 >= a || 54113 <= a && 54139 >= a || 54141 <= a && 54167 >= a || 54169 <= a && 54195 >= a || 54197 <= a && 54223 >= a || 54225 <= a && 54251 >= a || 54253 <= a && 54279 >= a || 54281 <= a && 54307 >= a || 54309 <= a && 54335 >= a || 54337 <= a && 54363 >= a || 54365 <= a && 54391 >= a || 54393 <= a && 54419 >= a || 54421 <= a && 54447 >= a || 54449 <= a && 54475 >= a || 54477 <= a && 54503 >= a || 54505 <= a && 54531 >= a || 54533 <= a && 54559 >= a || 54561 <= a && 54587 >= a || 54589 <= a && 54615 >= a || 54617 <= a && 54643 >= a || 54645 <= a && 54671 >= a || 54673 <= a && 54699 >= a || 54701 <= a && 54727 >= a || 54729 <= a && 54755 >= a || 54757 <= a && 54783 >= a || 54785 <= a && 54811 >= a || 54813 <= a && 54839 >= a || 54841 <= a && 54867 >= a || 54869 <= a && 54895 >= a || 54897 <= a && 54923 >= a || 54925 <= a && 54951 >= a || 54953 <= a && 54979 >= a || 54981 <= a && 55007 >= a || 55009 <= a && 55035 >= a || 55037 <= a && 55063 >= a || 55065 <= a && 55091 >= a || 55093 <= a && 55119 >= a || 55121 <= a && 55147 >= a || 55149 <= a && 55175 >= a || 55177 <= a && 55203 >= a ? 10 : 9757 == a || 9977 == a || 9994 <= a && 9997 >= a || 127877 == a || 127938 <= a && 127940 >= a || 127943 == a || 127946 <= a && 127948 >= a || 128066 <= a && 128067 >= a || 128070 <= a && 128080 >= a || 128110 == a || 128112 <= a && 128120 >= a || 128124 == a || 128129 <= a && 128131 >= a || 128133 <= a && 128135 >= a || 128170 == a || 128372 <= a && 128373 >= a || 128378 == a || 128400 == a || 128405 <= a && 128406 >= a || 128581 <= a && 128583 >= a || 128587 <= a && 128591 >= a || 128675 == a || 128692 <= a && 128694 >= a || 128704 == a || 128716 == a || 129304 <= a && 129308 >= a || 129310 <= a && 129311 >= a || 129318 == a || 129328 <= a && 129337 >= a || 129341 <= a && 129342 >= a || 129489 <= a && 129501 >= a ? 13 : 127995 <= a && 127999 >= a ? 14 : 8205 == a ? 15 : 9792 == a || 9794 == a || 9877 <= a && 9878 >= a || 9992 == a || 10084 == a || 127752 == a || 127806 == a || 127859 == a || 127891 == a || 127908 == a || 127912 == a || 127979 == a || 127981 == a || 128139 == a || 128187 <= a && 128188 >= a || 128295 == a || 128300 == a || 128488 == a || 128640 == a || 128658 == a ? 16 : 128102 <= a && 128105 >= a ? 17 : 11\n        }\n        this.nextBreak = function(a, c) {\n            void 0 === c && (c = 0);\n            if (0 > c)\n                return 0;\n            if (c >= a.length - 1)\n                return a.length;\n            var b = k(h(a, c))\n              , d = [];\n            for (c += 1; c < a.length; c++) {\n                var e = a\n                  , g = c - 1;\n                if (!(55296 <= e.charCodeAt(g) && 56319 >= e.charCodeAt(g) && 56320 <= e.charCodeAt(g + 1) && 57343 >= e.charCodeAt(g + 1))) {\n                    e = k(h(a, c));\n                    if (l(b, d, e))\n                        return c;\n                    d.push(e)\n                }\n            }\n            return a.length\n        }\n        ;\n        this.splitGraphemes = function(a) {\n            for (var c = [], b = 0, d; (d = this.nextBreak(a, b)) < a.length; )\n                c.push(a.slice(b, d)),\n                b = d;\n            b < a.length && c.push(a.slice(b));\n            return c\n        }\n        ;\n        this.iterateGraphemes = function(a) {\n            var c = 0\n              , b = {\n                next: function() {\n                    var d;\n                    if ((d = this.nextBreak(a, c)) < a.length) {\n                        var e = a.slice(c, d);\n                        c = d;\n                        return {\n                            value: e,\n                            done: !1\n                        }\n                    }\n                    return c < a.length ? (e = a.slice(c),\n                    c = a.length,\n                    {\n                        value: e,\n                        done: !1\n                    }) : {\n                        value: void 0,\n                        done: !0\n                    }\n                }\n                .bind(this)\n            };\n            "undefined" !== typeof Symbol && Symbol.iterator && (b[Symbol.iterator] = function() {\n                return b\n            }\n            );\n            return b\n        }\n        ;\n        this.countGraphemes = function(a) {\n            for (var c = 0, b = 0, d; (d = this.nextBreak(a, b)) < a.length; )\n                b = d,\n                c++;\n            b < a.length && c++;\n            return c\n        }\n        ;\n        return this\n    }\n    self.GraphemeSplitter = GraphemeSplitter;\n\n}\n\n\/\/ 3rdparty\/poly-decomp.js\n{\n    \'use strict\';\n    function lineInt(l1, l2, precision) {\n        precision = precision || 0;\n        var i = [0, 0];\n        var a1, b1, c1, a2, b2, c2, det;\n        a1 = l1[1][1] - l1[0][1];\n        b1 = l1[0][0] - l1[1][0];\n        c1 = a1 * l1[0][0] + b1 * l1[0][1];\n        a2 = l2[1][1] - l2[0][1];\n        b2 = l2[0][0] - l2[1][0];\n        c2 = a2 * l2[0][0] + b2 * l2[0][1];\n        det = a1 * b2 - a2 * b1;\n        if (!scalar_eq(det, 0, precision)) {\n            i[0] = (b2 * c1 - b1 * c2) \/ det;\n            i[1] = (a1 * c2 - a2 * c1) \/ det\n        }\n        return i\n    }\n    function lineSegmentsIntersect(p1, p2, q1, q2) {\n        var dx = p2[0] - p1[0];\n        var dy = p2[1] - p1[1];\n        var da = q2[0] - q1[0];\n        var db = q2[1] - q1[1];\n        if (da * dy - db * dx === 0)\n            return false;\n        var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) \/ (da * dy - db * dx);\n        var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) \/ (db * dx - da * dy);\n        return s >= 0 && s <= 1 && t >= 0 && t <= 1\n    }\n    function triangleArea(a, b, c) {\n        return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1])\n    }\n    function isLeft(a, b, c) {\n        return triangleArea(a, b, c) > 0\n    }\n    function isLeftOn(a, b, c) {\n        return triangleArea(a, b, c) >= 0\n    }\n    function isRight(a, b, c) {\n        return triangleArea(a, b, c) < 0\n    }\n    function isRightOn(a, b, c) {\n        return triangleArea(a, b, c) <= 0\n    }\n    var tmpPoint1 = []\n      , tmpPoint2 = [];\n    function collinear(a, b, c, thresholdAngle) {\n        if (!thresholdAngle)\n            return triangleArea(a, b, c) === 0;\n        else {\n            var ab = tmpPoint1\n              , bc = tmpPoint2;\n            ab[0] = b[0] - a[0];\n            ab[1] = b[1] - a[1];\n            bc[0] = c[0] - b[0];\n            bc[1] = c[1] - b[1];\n            var dot = ab[0] * bc[0] + ab[1] * bc[1]\n              , magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1])\n              , magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1])\n              , angle = Math.acos(dot \/ (magA * magB));\n            return angle < thresholdAngle\n        }\n    }\n    function sqdist(a, b) {\n        var dx = b[0] - a[0];\n        var dy = b[1] - a[1];\n        return dx * dx + dy * dy\n    }\n    function polygonAt(polygon, i) {\n        var s = polygon.length;\n        return polygon[i < 0 ? i % s + s : i % s]\n    }\n    function polygonClear(polygon) {\n        polygon.length = 0\n    }\n    function polygonAppend(polygon, poly, from, to) {\n        for (var i = from; i < to; i++)\n            polygon.push(poly[i])\n    }\n    function polygonMakeCCW(polygon) {\n        var br = 0\n          , v = polygon;\n        for (var i = 1; i < polygon.length; ++i)\n            if (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0])\n                br = i;\n        if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n            polygonReverse(polygon);\n            return true\n        } else\n            return false\n    }\n    function polygonReverse(polygon) {\n        var tmp = [];\n        var N = polygon.length;\n        for (var i = 0; i !== N; i++)\n            tmp.push(polygon.pop());\n        for (var i = 0; i !== N; i++)\n            polygon[i] = tmp[i]\n    }\n    function polygonIsReflex(polygon, i) {\n        return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1))\n    }\n    var tmpLine1 = []\n      , tmpLine2 = [];\n    function polygonCanSee(polygon, a, b) {\n        var p, dist, l1 = tmpLine1, l2 = tmpLine2;\n        if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b)))\n            return false;\n        dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n        for (var i = 0; i !== polygon.length; ++i) {\n            if ((i + 1) % polygon.length === a || i === a)\n                continue;\n            if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) {\n                l1[0] = polygonAt(polygon, a);\n                l1[1] = polygonAt(polygon, b);\n                l2[0] = polygonAt(polygon, i);\n                l2[1] = polygonAt(polygon, i + 1);\n                p = lineInt(l1, l2);\n                if (sqdist(polygonAt(polygon, a), p) < dist)\n                    return false\n            }\n        }\n        return true\n    }\n    function polygonCanSee2(polygon, a, b) {\n        for (var i = 0; i !== polygon.length; ++i) {\n            if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b)\n                continue;\n            if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1)))\n                return false\n        }\n        return true\n    }\n    function polygonCopy(polygon, i, j, targetPoly) {\n        var p = targetPoly || [];\n        polygonClear(p);\n        if (i < j)\n            for (var k = i; k <= j; k++)\n                p.push(polygon[k]);\n        else {\n            for (var k = 0; k <= j; k++)\n                p.push(polygon[k]);\n            for (var k = i; k < polygon.length; k++)\n                p.push(polygon[k])\n        }\n        return p\n    }\n    function polygonGetCutEdges(polygon) {\n        var min = []\n          , tmp1 = []\n          , tmp2 = []\n          , tmpPoly = [];\n        var nDiags = Number.MAX_VALUE;\n        for (var i = 0; i < polygon.length; ++i)\n            if (polygonIsReflex(polygon, i))\n                for (var j = 0; j < polygon.length; ++j)\n                    if (polygonCanSee(polygon, i, j)) {\n                        tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n                        tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n                        for (var k = 0; k < tmp2.length; k++)\n                            tmp1.push(tmp2[k]);\n                        if (tmp1.length < nDiags) {\n                            min = tmp1;\n                            nDiags = tmp1.length;\n                            min.push([polygonAt(polygon, i), polygonAt(polygon, j)])\n                        }\n                    }\n        return min\n    }\n    function polygonDecomp(polygon) {\n        var edges = polygonGetCutEdges(polygon);\n        if (edges.length > 0)\n            return polygonSlice(polygon, edges);\n        else\n            return [polygon]\n    }\n    function polygonSlice(polygon, cutEdges) {\n        if (cutEdges.length === 0)\n            return [polygon];\n        if (cutEdges instanceof Array && cutEdges.length && cutEdges[0]instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0]instanceof Array) {\n            var polys = [polygon];\n            for (var i = 0; i < cutEdges.length; i++) {\n                var cutEdge = cutEdges[i];\n                for (var j = 0; j < polys.length; j++) {\n                    var poly = polys[j];\n                    var result = polygonSlice(poly, cutEdge);\n                    if (result) {\n                        polys.splice(j, 1);\n                        polys.push(result[0], result[1]);\n                        break\n                    }\n                }\n            }\n            return polys\n        } else {\n            var cutEdge = cutEdges;\n            var i = polygon.indexOf(cutEdge[0]);\n            var j = polygon.indexOf(cutEdge[1]);\n            if (i !== -1 && j !== -1)\n                return [polygonCopy(polygon, i, j), polygonCopy(polygon, j, i)];\n            else\n                return false\n        }\n    }\n    function polygonIsSimple(polygon) {\n        var path = polygon, i;\n        for (i = 0; i < path.length - 1; i++)\n            for (var j = 0; j < i - 1; j++)\n                if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1]))\n                    return false;\n        for (i = 1; i < path.length - 2; i++)\n            if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1]))\n                return false;\n        return true\n    }\n    function getIntersectionPoint(p1, p2, q1, q2, delta) {\n        delta = delta || 0;\n        var a1 = p2[1] - p1[1];\n        var b1 = p1[0] - p2[0];\n        var c1 = a1 * p1[0] + b1 * p1[1];\n        var a2 = q2[1] - q1[1];\n        var b2 = q1[0] - q2[0];\n        var c2 = a2 * q1[0] + b2 * q1[1];\n        var det = a1 * b2 - a2 * b1;\n        if (!scalar_eq(det, 0, delta))\n            return [(b2 * c1 - b1 * c2) \/ det, (a1 * c2 - a2 * c1) \/ det];\n        else\n            return [0, 0]\n    }\n    function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {\n        maxlevel = maxlevel || 100;\n        level = level || 0;\n        delta = delta || 25;\n        result = typeof result !== "undefined" ? result : [];\n        reflexVertices = reflexVertices || [];\n        steinerPoints = steinerPoints || [];\n        var upperInt = [0, 0]\n          , lowerInt = [0, 0]\n          , p = [0, 0];\n        var upperDist = 0\n          , lowerDist = 0\n          , d = 0\n          , closestDist = 0;\n        var upperIndex = 0\n          , lowerIndex = 0\n          , closestIndex = 0;\n        var lowerPoly = []\n          , upperPoly = [];\n        var poly = polygon\n          , v = polygon;\n        if (v.length < 3)\n            return result;\n        level++;\n        if (level > maxlevel) {\n            console.warn("quickDecomp: max level (" + maxlevel + ") reached.");\n            return result\n        }\n        for (var i = 0; i < polygon.length; ++i)\n            if (polygonIsReflex(poly, i)) {\n                reflexVertices.push(poly[i]);\n                upperDist = lowerDist = Number.MAX_VALUE;\n                for (var j = 0; j < polygon.length; ++j) {\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {\n                        p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1));\n                        if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) {\n                            d = sqdist(poly[i], p);\n                            if (d < lowerDist) {\n                                lowerDist = d;\n                                lowerInt = p;\n                                lowerIndex = j\n                            }\n                        }\n                    }\n                    if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                        p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n                        if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n                            d = sqdist(poly[i], p);\n                            if (d < upperDist) {\n                                upperDist = d;\n                                upperInt = p;\n                                upperIndex = j\n                            }\n                        }\n                    }\n                }\n                if (lowerIndex === (upperIndex + 1) % polygon.length) {\n                    p[0] = (lowerInt[0] + upperInt[0]) \/ 2;\n                    p[1] = (lowerInt[1] + upperInt[1]) \/ 2;\n                    steinerPoints.push(p);\n                    if (i < upperIndex) {\n                        polygonAppend(lowerPoly, poly, i, upperIndex + 1);\n                        lowerPoly.push(p);\n                        upperPoly.push(p);\n                        if (lowerIndex !== 0)\n                            polygonAppend(upperPoly, poly, lowerIndex, poly.length);\n                        polygonAppend(upperPoly, poly, 0, i + 1)\n                    } else {\n                        if (i !== 0)\n                            polygonAppend(lowerPoly, poly, i, poly.length);\n                        polygonAppend(lowerPoly, poly, 0, upperIndex + 1);\n                        lowerPoly.push(p);\n                        upperPoly.push(p);\n                        polygonAppend(upperPoly, poly, lowerIndex, i + 1)\n                    }\n                } else {\n                    if (lowerIndex > upperIndex)\n                        upperIndex += polygon.length;\n                    closestDist = Number.MAX_VALUE;\n                    if (upperIndex < lowerIndex)\n                        return result;\n                    for (var j = lowerIndex; j <= upperIndex; ++j)\n                        if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                            d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n                            if (d < closestDist && polygonCanSee2(poly, i, j)) {\n                                closestDist = d;\n                                closestIndex = j % polygon.length\n                            }\n                        }\n                    if (i < closestIndex) {\n                        polygonAppend(lowerPoly, poly, i, closestIndex + 1);\n                        if (closestIndex !== 0)\n                            polygonAppend(upperPoly, poly, closestIndex, v.length);\n                        polygonAppend(upperPoly, poly, 0, i + 1)\n                    } else {\n                        if (i !== 0)\n                            polygonAppend(lowerPoly, poly, i, v.length);\n                        polygonAppend(lowerPoly, poly, 0, closestIndex + 1);\n                        polygonAppend(upperPoly, poly, closestIndex, i + 1)\n                    }\n                }\n                if (lowerPoly.length < upperPoly.length) {\n                    polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n                    polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level)\n                } else {\n                    polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n                    polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level)\n                }\n                return result\n            }\n        result.push(polygon);\n        return result\n    }\n    function polygonRemoveCollinearPoints(polygon, precision) {\n        var num = 0;\n        for (var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i)\n            if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {\n                polygon.splice(i % polygon.length, 1);\n                num++\n            }\n        return num\n    }\n    function polygonRemoveDuplicatePoints(polygon, precision) {\n        for (var i = polygon.length - 1; i >= 1; --i) {\n            var pi = polygon[i];\n            for (var j = i - 1; j >= 0; --j)\n                if (points_eq(pi, polygon[j], precision)) {\n                    polygon.splice(i, 1);\n                    continue\n                }\n        }\n    }\n    function scalar_eq(a, b, precision) {\n        precision = precision || 0;\n        return Math.abs(a - b) <= precision\n    }\n    function points_eq(a, b, precision) {\n        return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision)\n    }\n    self.polyDecomp = {\n        decomp: polygonDecomp,\n        quickDecomp: polygonQuickDecomp,\n        isSimple: polygonIsSimple,\n        removeCollinearPoints: polygonRemoveCollinearPoints,\n        removeDuplicatePoints: polygonRemoveDuplicatePoints,\n        makeCCW: polygonMakeCCW\n    };\n\n}\n\n\/\/ lib\/c3.js\n{\n    \'use strict\';\n    let isReady = false;\n    let hasAppStarted = false;\n    let buildMode = "dev";\n    const C3 = self.C3 = class C3 {\n        constructor() {\n            throw TypeError("static class can\'t be instantiated");\n        }\n        static SetReady() {\n            isReady = true\n        }\n        static IsReady() {\n            return isReady\n        }\n        static SetAppStarted() {\n            hasAppStarted = true\n        }\n        static HasAppStarted() {\n            return hasAppStarted\n        }\n        static SetBuildMode(m) {\n            buildMode = m\n        }\n        static GetBuildMode() {\n            return buildMode\n        }\n        static IsReleaseBuild() {\n            return buildMode === "final"\n        }\n    }\n    ;\n    C3.isDebug = false;\n    C3.isDebugDefend = false;\n    C3.hardwareConcurrency = navigator.hardwareConcurrency || 2;\n    self.C3X = {};\n\n}\n\n\/\/ ..\/lib\/queryParser.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.QueryParser = class QueryParser {\n        constructor(queryString) {\n            this._queryString = queryString;\n            this._parameters = new Map;\n            this._Parse()\n        }\n        _Parse() {\n            let str = this._queryString;\n            if (str.startsWith("?") || str.startsWith("#"))\n                str = str.substr(1);\n            const arr = str.split("&");\n            for (const p of arr)\n                this._ParseParameter(p)\n        }\n        _ParseParameter(p) {\n            if (!p)\n                return;\n            if (!p.includes("=")) {\n                this._parameters.set(p, null);\n                return\n            }\n            const i = p.indexOf("=");\n            const parameterName = decodeURIComponent(p.substring(0, i));\n            const parameterValue = decodeURIComponent(p.substring(i + 1));\n            this._parameters.set(parameterName, parameterValue)\n        }\n        LogAll() {\n            for (const e of this._parameters)\n                console.log("[QueryParser] Parameter \'" + e[0] + "\' = " + (e[1] === null ? "null" : "\'" + e[1] + "\'"))\n        }\n        Has(name) {\n            return this._parameters.has(name)\n        }\n        Get(name) {\n            const ret = this._parameters.get(name);\n            if (typeof ret === "undefined")\n                return null;\n            else\n                return ret\n        }\n        ClearHash() {\n            history.replaceState("", document.title, location.pathname + location.search)\n        }\n        Reparse(str) {\n            this._queryString = str;\n            this._parameters.clear();\n            this._Parse()\n        }\n    }\n    ;\n    C3.QueryString = new C3.QueryParser(location.search);\n    C3.LocationHashString = new C3.QueryParser(location.hash);\n    if (C3.QueryString.Has("perf"))\n        C3.isPerformanceProfiling = true;\n    if (C3.QueryString.Get("mode") !== "dev")\n        C3.SetBuildMode("final");\n\n}\n\n\/\/ ..\/lib\/detect\/detect.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const UNKNOWN = "(unknown)";\n    C3.Platform = {\n        OS: UNKNOWN,\n        OSVersion: UNKNOWN,\n        Browser: UNKNOWN,\n        BrowserVersion: UNKNOWN,\n        BrowserVersionNumber: NaN,\n        BrowserEngine: UNKNOWN,\n        Context: "browser",\n        IsDesktop: true,\n        IsMobile: false,\n        IsDesktopApp: false,\n        IsAppleOS: false,\n        IsIpadOS: false,\n        GetDetailedInfo: async () => {}\n    };\n    const windowsNTVerMap = new Map([[5, "2000"], [5.1, "XP"], [5.2, "XP"], [6, "Vista"], [6.1, "7"], [6.2, "8"], [6.3, "8.1"], [10, "10"]]);\n    function GetWindowsNTVersionName(ntVer) {\n        const num = parseFloat(ntVer);\n        const ret = windowsNTVerMap.get(num);\n        if (ret)\n            return ret;\n        if (num >= 13)\n            return "11";\n        return "NT " + ntVer\n    }\n    const uaStr = navigator.userAgent;\n    const uaData = navigator["userAgentData"];\n    if (uaData && uaData["brands"].length > 0) {\n        C3.Platform.OS = uaData["platform"];\n        C3.Platform.IsMobile = uaData["mobile"];\n        C3.Platform.IsDesktop = !C3.Platform.IsMobile;\n        const RECOGNIZED_BROWSERS = new Map([["Google Chrome", "Chrome"], ["Microsoft Edge", "Edge"], ["Opera", "Opera"], ["Opera GX", "Opera GX"], ["Mozilla Firefox", "Firefox"], ["Apple Safari", "Safari"], ["NW.js", "NW.js"]]);\n        const RECOGNIZED_ENGINES = new Map([["Chromium", "Chromium"], ["Gecko", "Gecko"], ["WebKit", "WebKit"]]);\n        function ReadBrandList(brands) {\n            let browser = "";\n            let browser_version = "";\n            let engine = "";\n            let engine_version = "";\n            for (const o of brands) {\n                const recognizedBrowser = RECOGNIZED_BROWSERS.get(o["brand"]);\n                if (!browser && recognizedBrowser) {\n                    browser = recognizedBrowser;\n                    browser_version = o["version"]\n                }\n                const recognizedEngine = RECOGNIZED_ENGINES.get(o["brand"]);\n                if (!engine && recognizedEngine) {\n                    engine = recognizedEngine;\n                    engine_version = o["version"]\n                }\n            }\n            if (!browser && engine === "Chromium") {\n                C3.Platform.Browser = "Chromium";\n                C3.Platform.BrowserVersion = engine_version\n            }\n            C3.Platform.Browser = browser || UNKNOWN;\n            C3.Platform.BrowserVersion = browser_version || UNKNOWN;\n            C3.Platform.BrowserEngine = engine || UNKNOWN\n        }\n        ReadBrandList(uaData["brands"]);\n        let didGetDetailedInfo = false;\n        C3.Platform.GetDetailedInfo = async () => {\n            if (didGetDetailedInfo)\n                return;\n            try {\n                const details = await navigator["userAgentData"]["getHighEntropyValues"](["platformVersion", "fullVersionList"]);\n                ReadBrandList(details["fullVersionList"]);\n                if (C3.Platform.OS === "Windows")\n                    C3.Platform.OSVersion = GetWindowsNTVersionName(details["platformVersion"]);\n                else\n                    C3.Platform.OSVersion = details["platformVersion"];\n                didGetDetailedInfo = true\n            } catch (err) {\n                console.warn("Failed to get detailed user agent information: ", err)\n            }\n        }\n    } else {\n        function RunTest(regex_or_arr, handler) {\n            const arr = Array.isArray(regex_or_arr) ? regex_or_arr : [regex_or_arr];\n            for (const regex of arr) {\n                const result = regex.exec(uaStr);\n                if (result) {\n                    handler(result);\n                    break\n                }\n            }\n        }\n        RunTest(\/windows\\s+nt\\s+([\\d\\.]+)\/i, result => {\n            C3.Platform.OS = "Windows";\n            const ntVer = result[1];\n            C3.Platform.OSVersion = GetWindowsNTVersionName(ntVer)\n        }\n        );\n        RunTest(\/mac\\s+os\\s+x\\s+([\\d\\._]+)\/i, result => {\n            C3.Platform.OS = "macOS";\n            C3.Platform.OSVersion = result[1].replace(\/_\/g, ".")\n        }\n        );\n        RunTest(\/CrOS\/, () => {\n            C3.Platform.OS = "Chrome OS"\n        }\n        );\n        RunTest(\/linux|openbsd|freebsd|netbsd\/i, () => {\n            C3.Platform.OS = "Linux"\n        }\n        );\n        RunTest(\/android\/i, () => {\n            C3.Platform.OS = "Android"\n        }\n        );\n        RunTest(\/android\\s+([\\d\\.]+)\/i, result => {\n            C3.Platform.OS = "Android";\n            C3.Platform.OSVersion = result[1]\n        }\n        );\n        if (C3.Platform.OS === UNKNOWN) {\n            RunTest(\/(iphone|ipod|ipad)\/i, result => {\n                C3.Platform.OS = "iOS"\n            }\n            );\n            RunTest([\/iphone\\s+os\\s+([\\d\\._]+)\/i, \/ipad[^)]*os\\s+([\\d\\._]+)\/i], result => {\n                C3.Platform.OS = "iOS";\n                C3.Platform.OSVersion = result[1].replace(\/_\/g, ".")\n            }\n            )\n        }\n        const hasChrome = \/chrome\\\/\/i.test(uaStr);\n        const hasChromium = \/chromium\\\/\/i.test(uaStr);\n        const hasEdge = \/edg\\\/\/i.test(uaStr);\n        const hasOpera = \/OPR\\\/\/.test(uaStr);\n        const hasNWjs = \/nwjs\/i.test(uaStr);\n        const hasSafari = \/safari\\\/\/i.test(uaStr);\n        const hasWebKit = \/webkit\/i.test(uaStr);\n        if (!hasEdge && !hasOpera)\n            RunTest(\/chrome\\\/([\\d\\.]+)\/i, result => {\n                C3.Platform.Browser = "Chrome";\n                C3.Platform.BrowserVersion = result[1];\n                C3.Platform.BrowserEngine = "Chromium"\n            }\n            );\n        RunTest(\/edg\\\/([\\d\\.]+)\/i, result => {\n            C3.Platform.Browser = "Edge";\n            C3.Platform.BrowserVersion = result[1];\n            C3.Platform.BrowserEngine = "Chromium"\n        }\n        );\n        RunTest(\/OPR\\\/([\\d\\.]+)\/, result => {\n            C3.Platform.Browser = "Opera";\n            C3.Platform.BrowserVersion = result[1];\n            C3.Platform.BrowserEngine = "Chromium"\n        }\n        );\n        RunTest(\/chromium\\\/([\\d\\.]+)\/i, result => {\n            C3.Platform.Browser = "Chromium";\n            C3.Platform.BrowserVersion = result[1];\n            C3.Platform.BrowserEngine = "Chromium"\n        }\n        );\n        RunTest(\/nwjs\\\/[0-9.]+\/i, result => {\n            C3.Platform.Browser = "NW.js";\n            C3.Platform.BrowserVersion = result[1];\n            C3.Platform.BrowserEngine = "Chromium";\n            C3.Platform.Context = "nwjs"\n        }\n        );\n        RunTest(\/firefox\\\/([\\d\\.]+)\/i, result => {\n            C3.Platform.Browser = "Firefox";\n            C3.Platform.BrowserVersion = result[1];\n            C3.Platform.BrowserEngine = "Gecko"\n        }\n        );\n        if (hasSafari && !hasChrome && !hasChromium && !hasEdge && !hasOpera && !hasNWjs) {\n            C3.Platform.Browser = "Safari";\n            C3.Platform.BrowserEngine = "WebKit";\n            RunTest(\/version\\\/([\\d\\.]+)\/i, result => {\n                C3.Platform.BrowserVersion = result[1]\n            }\n            );\n            RunTest(\/crios\\\/([\\d\\.]+)\/i, result => {\n                C3.Platform.Browser = "Chrome for iOS";\n                C3.Platform.BrowserVersion = result[1]\n            }\n            );\n            RunTest(\/fxios\\\/([\\d\\.]+)\/i, result => {\n                C3.Platform.Browser = "Firefox for iOS";\n                C3.Platform.BrowserVersion = result[1]\n            }\n            );\n            RunTest(\/edgios\\\/([\\d\\.]+)\/i, result => {\n                C3.Platform.Browser = "Edge for iOS";\n                C3.Platform.BrowserVersion = result[1]\n            }\n            )\n        }\n        if (C3.Platform.BrowserEngine === UNKNOWN && hasWebKit)\n            C3.Platform.BrowserEngine = "WebKit";\n        if (C3.Platform.OS === "Android" && C3.Platform.Browser === "Safari")\n            C3.Platform.Browser = "Stock";\n        const desktopOSs = new Set(["Windows", "macOS", "Linux", "Chrome OS"]);\n        const isDesktop = desktopOSs.has(C3.Platform.OS) || C3.Platform.Context === "nwjs";\n        C3.Platform.IsDesktop = isDesktop;\n        C3.Platform.IsMobile = !isDesktop\n    }\n    if (C3.Platform.Browser === "Chrome" && C3.Platform.Context === "browser" && \/wv\\)\/.test(uaStr))\n        C3.Platform.Context = "webview";\n    if (C3.Platform.Context !== "nwjs" && typeof window !== "undefined" && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator["standalone"]))\n        C3.Platform.Context = "webapp";\n    C3.Platform.BrowserVersionNumber = parseFloat(C3.Platform.BrowserVersion);\n    C3.Platform.IsDesktopApp = C3.Platform.Context === "nwjs";\n    const looksLikeIPadOS = C3.Platform.OS === "macOS" && navigator["maxTouchPoints"] && navigator["maxTouchPoints"] > 2;\n    if (looksLikeIPadOS) {\n        C3.Platform.OS = "iOS";\n        C3.Platform.OSVersion = C3.Platform.BrowserVersion;\n        C3.Platform.IsDesktop = false;\n        C3.Platform.IsMobile = true;\n        C3.Platform.IsIpadOS = true\n    }\n    C3.Platform.IsAppleOS = C3.Platform.OS === "macOS" || C3.Platform.OS === "iOS";\n\n}\n\n\/\/ ..\/lib\/storage\/kvStorage.js\n{\n    \'use strict\';\n    {\n        const VERSION = 2;\n        const STORE_NAME = "keyvaluepairs";\n        const DATABASE_PROMISE_MAP = new Map;\n        const SUPPORTS_GETALL = typeof IDBObjectStore !== "undefined" && typeof IDBObjectStore.prototype.getAll === "function";\n        const SUPPORTS_GETALLKEYS = typeof IDBObjectStore !== "undefined" && typeof IDBObjectStore.prototype.getAllKeys === "function";\n        function asyncifyRequest(request) {\n            return new Promise( (res, rej) => {\n                request.onsuccess = () => res(request.result);\n                request.onerror = () => rej(request.error)\n            }\n            )\n        }\n        function asyncifyTransaction(tx) {\n            return new Promise( (res, rej) => {\n                tx.oncomplete = () => res();\n                tx.onerror = () => rej(tx.error);\n                tx.onabort = () => rej(tx.error)\n            }\n            )\n        }\n        function openReadOnlyTransaction(name, method) {\n            return openTransaction(name, method)\n        }\n        function openWriteTransaction(name, method) {\n            return openTransaction(name, method, true)\n        }\n        async function openTransaction(name, method, write=false, allowRetry=true) {\n            const db = await lazyOpenDatabase(name);\n            try {\n                const tx = db.transaction([STORE_NAME], write ? "readwrite" : "readonly");\n                return method(tx)\n            } catch (err) {\n                if (allowRetry && err["name"] === "InvalidStateError") {\n                    DATABASE_PROMISE_MAP.delete(name);\n                    return openTransaction(name, method, write, false)\n                } else\n                    throw err;\n            }\n        }\n        function lazyOpenDatabase(name) {\n            RequireString(name);\n            let dbPromise = DATABASE_PROMISE_MAP.get(name);\n            if (!(dbPromise instanceof Promise)) {\n                dbPromise = openDatabase(name);\n                DATABASE_PROMISE_MAP.set(name, dbPromise);\n                dbPromise.catch(err => DATABASE_PROMISE_MAP.delete(name))\n            }\n            return dbPromise\n        }\n        async function openDatabase(name) {\n            RequireString(name);\n            const openRequest = indexedDB.open(name, VERSION);\n            openRequest.addEventListener("upgradeneeded", e => {\n                try {\n                    const db = e.target.result;\n                    db.createObjectStore(STORE_NAME)\n                } catch (err) {\n                    console.error(`Failed to create objectstore for database ${name}`, err)\n                }\n            }\n            );\n            return asyncifyRequest(openRequest)\n        }\n        function RequireString(x) {\n            if (typeof x !== "string")\n                throw new TypeError("expected string");\n        }\n        function getEntriesFromCursor(tx, type) {\n            const request = tx.objectStore(STORE_NAME).openCursor();\n            return new Promise(resolve => {\n                const results = [];\n                request.onsuccess = event => {\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        switch (type) {\n                        case "entries":\n                            results.push([cursor.key, cursor.value]);\n                            break;\n                        case "keys":\n                            results.push(cursor.key);\n                            break;\n                        case "values":\n                            results.push(cursor.value);\n                            break\n                        }\n                        cursor.continue()\n                    } else\n                        resolve(results)\n                }\n            }\n            )\n        }\n        class KVStorageContainer {\n            constructor(name) {\n                RequireString(name);\n                this.name = name\n            }\n            async ready() {\n                await lazyOpenDatabase(this.name)\n            }\n            set(key, value) {\n                RequireString(key);\n                return openWriteTransaction(this.name, async tx => {\n                    const request = tx.objectStore(STORE_NAME).put(value, key);\n                    const requestPromise = asyncifyRequest(request);\n                    const txPromise = asyncifyTransaction(tx);\n                    await Promise.all([txPromise, requestPromise])\n                }\n                )\n            }\n            get(key) {\n                RequireString(key);\n                return openReadOnlyTransaction(this.name, async tx => {\n                    const request = tx.objectStore(STORE_NAME).get(key);\n                    const requestPromise = asyncifyRequest(request);\n                    const txPromise = asyncifyTransaction(tx);\n                    const [_,value] = await Promise.all([txPromise, requestPromise]);\n                    return value\n                }\n                )\n            }\n            delete(key) {\n                RequireString(key);\n                return openWriteTransaction(this.name, async tx => {\n                    const request = tx.objectStore(STORE_NAME).delete(key);\n                    const requestPromise = asyncifyRequest(request);\n                    const txPromise = asyncifyTransaction(tx);\n                    await Promise.all([txPromise, requestPromise])\n                }\n                )\n            }\n            clear() {\n                return openWriteTransaction(this.name, async tx => {\n                    const request = tx.objectStore(STORE_NAME).clear();\n                    const requestPromise = asyncifyRequest(request);\n                    const txPromise = asyncifyTransaction(tx);\n                    await Promise.all([txPromise, requestPromise])\n                }\n                )\n            }\n            keys() {\n                return openReadOnlyTransaction(this.name, async tx => {\n                    let requestPromise;\n                    if (SUPPORTS_GETALLKEYS) {\n                        const request = tx.objectStore(STORE_NAME).getAllKeys();\n                        requestPromise = asyncifyRequest(request)\n                    } else\n                        requestPromise = getEntriesFromCursor(tx, "keys");\n                    const txPromise = asyncifyTransaction(tx);\n                    const [_,value] = await Promise.all([txPromise, requestPromise]);\n                    return value\n                }\n                )\n            }\n            values() {\n                return openReadOnlyTransaction(this.name, async tx => {\n                    let requestPromise;\n                    if (SUPPORTS_GETALL) {\n                        const request = tx.objectStore(STORE_NAME).getAll();\n                        requestPromise = asyncifyRequest(request)\n                    } else\n                        requestPromise = getEntriesFromCursor(tx, "values");\n                    const txPromise = asyncifyTransaction(tx);\n                    const [_,value] = await Promise.all([txPromise, requestPromise]);\n                    return value\n                }\n                )\n            }\n            entries() {\n                return openReadOnlyTransaction(this.name, async tx => {\n                    const requestPromise = getEntriesFromCursor(tx, "entries");\n                    const txPromise = asyncifyTransaction(tx);\n                    const [_,value] = await Promise.all([txPromise, requestPromise]);\n                    return value\n                }\n                )\n            }\n        }\n        self.KVStorageContainer = KVStorageContainer\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/storage\/localForageAdaptor.js\n{\n    \'use strict\';\n    {\n        const KVStorageContainer = self.KVStorageContainer;\n        const CRITICAL_ERRORS = [\/no available storage method found\/i, \/an attempt was made to break through the security policy of the user agent\/i, \/the user denied permission to access the database\/i, \/a mutation operation was attempted on a database that did not allow mutations\/i, \/idbfactory\\.open\\(\\) called in an invalid security context\/i];\n        const memoryStorage = new WeakMap;\n        let isInMemory = false;\n        if (typeof indexedDB === "undefined") {\n            isInMemory = true;\n            console.warn("Unable to use local storage because indexedDB is not defined")\n        }\n        function NOT_IMPLEMENTED(name) {\n            throw new Error(`"${name}" is not implemented`);\n        }\n        function DISALLOW_CALLBACK(fn) {\n            if (typeof fn === "function")\n                throw new Error(`localforage callback API is not implemented; please use the promise API instead`);\n        }\n        function StructuredClone(value) {\n            if (typeof value === "object")\n                return new Promise(resolve => {\n                    const {port1, port2} = new MessageChannel;\n                    port2.onmessage = ev => resolve(ev.data);\n                    port1.postMessage(value)\n                }\n                );\n            else\n                return Promise.resolve(value)\n        }\n        class ForageAdaptor {\n            constructor(inst) {\n                this._inst = inst;\n                memoryStorage.set(this, new Map)\n            }\n            _MaybeSwitchToMemoryFallback(err) {\n                if (isInMemory)\n                    return;\n                for (const regex of CRITICAL_ERRORS)\n                    if (err && regex.test(err.message)) {\n                        console.error("Unable to use local storage, reverting to in-memory store: ", err, err.message);\n                        isInMemory = true;\n                        break\n                    }\n            }\n            async _getItemFallback(name) {\n                const value = memoryStorage.get(this).get(name);\n                const ret = await StructuredClone(value);\n                return typeof ret === "undefined" ? null : ret\n            }\n            async _setItemFallback(name, value) {\n                value = await StructuredClone(value);\n                memoryStorage.get(this).set(name, value)\n            }\n            _removeItemFallback(name) {\n                memoryStorage.get(this).delete(name)\n            }\n            _clearFallback() {\n                memoryStorage.get(this).clear()\n            }\n            _keysFallback() {\n                return Array.from(memoryStorage.get(this).keys())\n            }\n            IsUsingFallback() {\n                return isInMemory\n            }\n            async getItem(key, successCallback) {\n                DISALLOW_CALLBACK(successCallback);\n                if (isInMemory)\n                    return await this._getItemFallback(key);\n                let result;\n                try {\n                    result = await this._inst.get(key)\n                } catch (err) {\n                    this._MaybeSwitchToMemoryFallback(err);\n                    if (isInMemory)\n                        return await this._getItemFallback(key);\n                    else {\n                        console.error(`Error reading \'${key}\' from storage, returning null: `, err);\n                        return null\n                    }\n                }\n                return typeof result === "undefined" ? null : result\n            }\n            async setItem(key, value, successCallback) {\n                DISALLOW_CALLBACK(successCallback);\n                if (typeof value === "undefined")\n                    value = null;\n                if (isInMemory) {\n                    await this._setItemFallback(key, value);\n                    return\n                }\n                try {\n                    await this._inst.set(key, value)\n                } catch (err) {\n                    this._MaybeSwitchToMemoryFallback(err);\n                    if (isInMemory)\n                        await this._setItemFallback(key, value);\n                    else\n                        throw err;\n                }\n            }\n            async removeItem(key, successCallback) {\n                DISALLOW_CALLBACK(successCallback);\n                if (isInMemory) {\n                    this._removeItemFallback(key);\n                    return\n                }\n                try {\n                    await this._inst.delete(key)\n                } catch (err) {\n                    this._MaybeSwitchToMemoryFallback(err);\n                    if (isInMemory)\n                        this._removeItemFallback(key);\n                    else\n                        console.error(`Error removing \'${key}\' from storage: `, err)\n                }\n            }\n            async clear(successCallback) {\n                DISALLOW_CALLBACK(successCallback);\n                if (isInMemory) {\n                    this._clearFallback();\n                    return\n                }\n                try {\n                    await this._inst.clear()\n                } catch (err) {\n                    this._MaybeSwitchToMemoryFallback(err);\n                    if (isInMemory)\n                        this._clearFallback();\n                    else\n                        console.error(`Error clearing storage: `, err)\n                }\n            }\n            async keys(successCallback) {\n                DISALLOW_CALLBACK(successCallback);\n                if (isInMemory)\n                    return this._keysFallback();\n                let result = [];\n                try {\n                    result = await this._inst.keys()\n                } catch (err) {\n                    this._MaybeSwitchToMemoryFallback(err);\n                    if (isInMemory)\n                        return this._keysFallback();\n                    else\n                        console.error(`Error getting storage keys: `, err)\n                }\n                return result\n            }\n            ready(successCallback) {\n                DISALLOW_CALLBACK(successCallback);\n                if (isInMemory)\n                    return Promise.resolve(true);\n                else\n                    return this._inst.ready()\n            }\n            createInstance(options) {\n                if (typeof options !== "object")\n                    throw new TypeError("invalid options object");\n                const name = options["name"];\n                if (typeof name !== "string")\n                    throw new TypeError("invalid store name");\n                const inst = new KVStorageContainer(name);\n                return new ForageAdaptor(inst)\n            }\n            length(successCallback) {\n                NOT_IMPLEMENTED("localforage.length()")\n            }\n            key(index, successCallback) {\n                NOT_IMPLEMENTED("localforage.key()")\n            }\n            iterate(iteratorCallback, successCallback) {\n                NOT_IMPLEMENTED("localforage.iterate()")\n            }\n            setDriver(driverName) {\n                NOT_IMPLEMENTED("localforage.setDriver()")\n            }\n            config(options) {\n                NOT_IMPLEMENTED("localforage.config()")\n            }\n            defineDriver(customDriver) {\n                NOT_IMPLEMENTED("localforage.defineDriver()")\n            }\n            driver() {\n                NOT_IMPLEMENTED("localforage.driver()")\n            }\n            supports(driverName) {\n                NOT_IMPLEMENTED("localforage.supports()")\n            }\n            dropInstance() {\n                NOT_IMPLEMENTED("localforage.dropInstance()")\n            }\n            disableMemoryMode() {\n                isInMemory = false\n            }\n        }\n        self["localforage"] = new ForageAdaptor(new KVStorageContainer("localforage"))\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/misc\/supports.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Supports = {};\n    C3.Supports.WebAnimations = ( () => {\n        try {\n            if (C3.Platform.Browser === "Safari")\n                return false;\n            if (typeof document === "undefined")\n                return false;\n            const e = document.createElement("div");\n            if (typeof e.animate === "undefined")\n                return false;\n            const player = e.animate([{\n                opacity: "0"\n            }, {\n                opacity: "1"\n            }], 1E3);\n            return typeof player.reverse !== "undefined"\n        } catch (e) {\n            return false\n        }\n    }\n    )();\n    C3.Supports.DialogElement = typeof HTMLDialogElement !== "undefined";\n    C3.Supports.RequestIdleCallback = !!self.requestIdleCallback;\n    C3.Supports.ImageBitmap = !!self.createImageBitmap;\n    C3.Supports.ImageBitmapOptions = false;\n    C3.Supports.ImageBitmapOptionsResize = false;\n    if (C3.Supports.ImageBitmap) {\n        try {\n            self.createImageBitmap(new ImageData(32,32), {\n                "premultiplyAlpha": "none"\n            }).then( () => {\n                C3.Supports.ImageBitmapOptions = true\n            }\n            ).catch( () => {\n                C3.Supports.ImageBitmapOptions = false\n            }\n            )\n        } catch (err) {\n            C3.Supports.ImageBitmapOptions = false\n        }\n        try {\n            self.createImageBitmap(new ImageData(32,32), {\n                "resizeWidth": 10,\n                "resizeHeight": 10\n            }).then(imageBitmap => {\n                C3.Supports.ImageBitmapOptionsResize = imageBitmap.width === 10 && imageBitmap.height === 10\n            }\n            ).catch( () => {\n                C3.Supports.ImageBitmapOptionsResize = false\n            }\n            )\n        } catch (err) {\n            C3.Supports.ImageBitmapOptionsResize = false\n        }\n    }\n    C3.Supports.ClipboardReadText = !!(navigator["clipboard"] && navigator["clipboard"]["readText"] && C3.Platform.Browser !== "Firefox");\n    C3.Supports.PermissionsQuery = !!(navigator["permissions"] && navigator["permissions"]["query"]);\n    C3.Supports.Proxies = typeof Proxy !== "undefined";\n    C3.Supports.DownloadAttribute = ( () => {\n        if (typeof document === "undefined")\n            return false;\n        const a = document.createElement("a");\n        return typeof a.download !== "undefined"\n    }\n    )();\n    C3.Supports.CanvasToBlob = ( () => {\n        return typeof HTMLCanvasElement !== "undefined" && HTMLCanvasElement.prototype.toBlob\n    }\n    )();\n    C3.Supports.Fetch = typeof fetch === "function";\n    C3.Supports.PersistentStorage = !!(self.isSecureContext && C3.Platform.Browser !== "Opera" && (navigator["storage"] && navigator["storage"]["persist"]));\n    C3.Supports.StorageQuotaEstimate = !!(self.isSecureContext && (navigator["storage"] && navigator["storage"]["estimate"]));\n    C3.Supports.Fullscreen = ( () => {\n        if (typeof document === "undefined")\n            return false;\n        if (C3.Platform.OS === "iOS")\n            return false;\n        const elem = document.documentElement;\n        return !!(elem.requestFullscreen || elem.msRequestFullscreen || elem.mozRequestFullScreen || elem.webkitRequestFullscreen)\n    }\n    )();\n    C3.Supports.ImageDecoder = typeof self["ImageDecoder"] !== "undefined";\n    C3.Supports.WebCodecs = !!self["VideoEncoder"];\n    C3.Supports.NativeFileSystemAPI = !!self["showOpenFilePicker"];\n    C3.Supports.QueryLocalFonts = !!self["queryLocalFonts"];\n    C3.Supports.UserActivation = !!navigator["userActivation"];\n\n}\n\n\/\/ ..\/lib\/misc\/polyfills.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    if (!String.prototype.trimStart) {\n        const startWhitespace = \/^[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]*\/;\n        String.prototype.trimStart = function trimStart() {\n            return this.replace(startWhitespace, "")\n        }\n    }\n    if (!String.prototype.trimEnd) {\n        const endWhitespace = \/[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]*$\/;\n        String.prototype.trimEnd = function trimEnd() {\n            return this.replace(endWhitespace, "")\n        }\n    }\n    if (!String.prototype.replaceAll)\n        String.prototype.replaceAll = function replaceAll(find, replace) {\n            return this.replace(new RegExp(C3.EscapeRegex(find),"g"), replace)\n        }\n        ;\n    if (!Array.prototype.values)\n        Array.prototype.values = function*() {\n            for (const i of this)\n                yield i\n        }\n        ;\n    if (!Array.prototype.flat) {\n        function arrayFlat(arr, depth) {\n            return arr.reduce( (acc, val) => {\n                if (depth > 0 && Array.isArray(val)) {\n                    Array.prototype.push.apply(acc, arrayFlat(val, depth - 1));\n                    return acc\n                } else {\n                    acc.push(val);\n                    return acc\n                }\n            }\n            , [])\n        }\n        Array.prototype.flat = function(depth=1) {\n            return arrayFlat(this, depth)\n        }\n    }\n    if (!Array.prototype.at)\n        Array.prototype.at = function at(n) {\n            n = Math.trunc(n) || 0;\n            if (n < 0)\n                n += this.length;\n            if (n < 0 || n >= this.length)\n                return undefined;\n            return this[n]\n        }\n        ;\n    if (!String.prototype.at)\n        String.prototype.at = function at(n) {\n            n = Math.trunc(n) || 0;\n            if (n < 0)\n                n += this.length;\n            if (n < 0 || n >= this.length)\n                return undefined;\n            return this[n]\n        }\n        ;\n    if (!RegExp.escape)\n        RegExp.escape = function(s) {\n            return String(s).replace(\/[\\\\^$*+?.()|[\\]{}]\/g, "\\\\$&")\n        }\n        ;\n    if (navigator["storage"] && !navigator["storage"]["estimate"] && navigator["webkitTemporaryStorage"] && navigator["webkitTemporaryStorage"]["queryUsageAndQuota"])\n        navigator["storage"]["estimate"] = function() {\n            return new Promise( (resolve, reject) => {\n                return navigator["webkitTemporaryStorage"]["queryUsageAndQuota"]( (usage, quota) => resolve({\n                    "usage": usage,\n                    "quota": quota\n                }), reject)\n            }\n            )\n        }\n        ;\n    if (typeof self.isSecureContext === "undefined")\n        self.isSecureContext = location.protocol === "https:";\n    if (typeof self["globalThis"] === "undefined")\n        self["globalThis"] = self;\n\n}\n\n\/\/ lib\/misc\/assert.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    function assertFail(msg_) {\n        let stack = C3.GetCallStack();\n        let msg = "Assertion failure: " + msg_ + "\\n\\nStack trace:\\n" + stack;\n        console.error(msg)\n    }\n    self.assert = function assert(cnd_, msg_) {\n        if (!cnd_)\n            assertFail(msg_)\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/misc\/typeChecks.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    C3.IsNumber = function IsNumber(x) {\n        return typeof x === "number"\n    }\n    ;\n    C3.IsFiniteNumber = function IsFiniteNumber(x) {\n        return C3.IsNumber(x) && isFinite(x)\n    }\n    ;\n    C3.RequireNumber = function RequireNumber(x) {\n        if (!C3.IsNumber(x))\n            throw new TypeError("expected number");\n    }\n    ;\n    C3.RequireOptionalNumber = function RequireOptionalNumber(x) {\n        if (C3.IsNullOrUndefined(x))\n            return\n    }\n    ;\n    C3.RequireNumberInRange = function RequireNumberInRange(x, low, high) {\n        if (!C3.IsNumber(x) || isNaN(x) || low > x || high < x)\n            throw new RangeError("number outside of range");\n    }\n    ;\n    C3.RequireAllNumber = function RequireAllNumber(...args) {\n        for (let a of args)\n            ;\n    }\n    ;\n    C3.RequireFiniteNumber = function RequireFiniteNumber(x) {\n        if (!C3.IsFiniteNumber(x))\n            throw new TypeError("expected finite number");\n    }\n    ;\n    C3.RequireOptionalFiniteNumber = function RequireOptionalFiniteNumber(x) {\n        if (C3.IsNullOrUndefined(x))\n            return\n    }\n    ;\n    C3.RequireAllFiniteNumber = function RequireAllFiniteNumber(...args) {\n        for (let a of args)\n            ;\n    }\n    ;\n    C3.IsString = function IsString(x) {\n        return typeof x === "string"\n    }\n    ;\n    C3.RequireString = function RequireString(x) {\n        if (!C3.IsString(x))\n            throw new TypeError("expected string");\n    }\n    ;\n    C3.RequireOptionalString = function RequireOptionalString(x) {\n        if (C3.IsNullOrUndefined(x))\n            return\n    }\n    ;\n    C3.RequireAllString = function RequireAllString(...args) {\n        for (let a of args)\n            ;\n    }\n    ;\n    C3.IsSimpleObject = function IsSimpleObject(x) {\n        if (typeof x !== "object" || x === null)\n            return false;\n        let proto = Object.getPrototypeOf(x);\n        return proto ? proto.constructor === Object : proto === null\n    }\n    ;\n    C3.RequireSimpleObject = function RequireSimpleObject(x) {\n        if (!C3.IsSimpleObject(x))\n            throw new TypeError("expected simple object");\n    }\n    ;\n    C3.RequireOptionalSimpleObject = function RequireSimpleObject(x) {\n        if (C3.IsNullOrUndefined(x))\n            return;\n        if (!C3.IsSimpleObject(x))\n            throw new TypeError("expected simple object");\n    }\n    ;\n    C3.IsObject = function IsObject(x) {\n        return typeof x === "object" && x !== null && !Array.isArray(x)\n    }\n    ;\n    C3.RequireObject = function RequireObject(x) {\n        if (!C3.IsObject(x))\n            throw new TypeError("expected object");\n    }\n    ;\n    C3.RequireOptionalObject = function RequireOptionalObject(x) {\n        if (C3.IsNullOrUndefined(x))\n            return\n    }\n    ;\n    C3.RequireAllObject = function RequireAllObject(...args) {\n        for (let a of args)\n            ;\n    }\n    ;\n    C3.IsFileLike = function IsFileLike(x) {\n        return C3.IsInstanceOf(x, Blob) && typeof x["name"] === "string"\n    }\n    ;\n    C3.RequireFileLike = function RequireFileLike(x) {\n        if (!C3.IsFileLike(x))\n            throw new TypeError("expected file");\n    }\n    ;\n    C3.RequireOptionalFileLike = function RequireOptionalFileLike(x) {\n        if (C3.IsNullOrUndefined(x))\n            return\n    }\n    ;\n    C3.IsArray = function IsArray(x) {\n        return Array.isArray(x)\n    }\n    ;\n    C3.RequireArray = function RequireArray(x) {\n        if (!C3.IsArray(x))\n            throw new TypeError("expected array");\n    }\n    ;\n    C3.RequireOptionalArray = function RequireOptionalArray(x) {\n        if (C3.IsNullOrUndefined(x))\n            return\n    }\n    ;\n    C3.RequireAllArray = function RequireAllArray(...args) {\n        for (let a of args)\n            ;\n    }\n    ;\n    C3.Is2DArray = function(x) {\n        if (!C3.IsArray(x))\n            return false;\n        if (!x.length)\n            return true;\n        if (!C3.IsArray(x[0]))\n            return false;\n        return true\n    }\n    ;\n    C3.Require2DArray = function Require2DArray(x) {\n        if (!C3.Is2DArray(x))\n            throw new TypeError("expected 2d array");\n        for (let arr of x)\n            if (!C3.IsArray(arr))\n                throw new TypeError("expected 2d array");\n    }\n    ;\n    C3.RequireOptional2DArray = function Require2DArray(x) {\n        if (C3.IsNullOrUndefined(x))\n            return\n    }\n    ;\n    C3.IsFunction = function IsFunction(x) {\n        return typeof x === "function"\n    }\n    ;\n    C3.RequireFunction = function RequireFunction(x, f) {\n        if (!C3.IsFunction(x))\n            throw new TypeError("expected function");\n        if (!C3.IsNullOrUndefined(f))\n            if (x !== f)\n                throw new TypeError("expected same function reference");\n    }\n    ;\n    C3.RequireOptionalFunction = function RequireOptionalFunction(x) {\n        if (C3.IsNullOrUndefined(x))\n            return\n    }\n    ;\n    C3.RequireAllFunction = function RequireAllFunction(...args) {\n        for (let a of args)\n            ;\n    }\n    ;\n    C3.RequireAnyFunction = function RequireAllFunction(x, ...args) {\n        if (!C3.IsFunction(x))\n            throw new TypeError("expected function");\n        if (!args.length)\n            throw new Error("missing comparison functions");\n        for (let a of args)\n            if (!C3.IsNullOrUndefined(a))\n                if (x === a)\n                    return;\n        throw new TypeError("expected same function reference");\n    }\n    ;\n    C3.RequireOptionalAllFunction = function RequireAllFunction(...args) {\n        if (C3.IsNullOrUndefined(args))\n            return;\n        for (let a of args)\n            ;\n    }\n    ;\n    C3.IsInstanceOf = function IsInstanceOf(x, t) {\n        return x instanceof t\n    }\n    ;\n    C3.IsInstanceOfAny = function IsInstanceOfAny(x, ...args) {\n        for (let t of args)\n            if (C3.IsInstanceOf(x, t))\n                return true;\n        return false\n    }\n    ;\n    C3.RequireInstanceOf = function RequireInstanceOf(x, t) {\n        if (!C3.IsInstanceOf(x, t))\n            throw new TypeError("unexpected type");\n    }\n    ;\n    C3.RequireOptionalInstanceOf = function RequireOptionalInstanceOf(x, t) {\n        if (C3.IsNullOrUndefined(x))\n            return\n    }\n    ;\n    C3.RequireAllInstanceOf = function RequireAllInstanceOf(t, ...args) {\n        for (let a of args)\n            ;\n    }\n    ;\n    C3.RequireAnyInstanceOf = function RequireAnyInstanceOf(x, ...args) {\n        if (!C3.IsInstanceOfAny(x, ...args))\n            throw new TypeError("unexpected type");\n    }\n    ;\n    C3.RequireAnyOptionalInstanceOf = function RequireAnyOptionalInstanceOf(x, ...args) {\n        if (C3.IsNullOrUndefined(x))\n            return;\n        if (!C3.IsInstanceOfAny(x, ...args))\n            throw new TypeError("unexpected type");\n    }\n    ;\n    C3.IsArrayOf = function IsArrayOf(x, t) {\n        for (let i of x)\n            if (!C3.IsInstanceOf(i, t))\n                return false;\n        return true\n    }\n    ;\n    C3.IsArrayOfFiniteNumbers = function IsArrayOfFiniteNumbers(x) {\n        for (let i of x)\n            if (!C3.IsFiniteNumber(i))\n                return false;\n        return true\n    }\n    ;\n    C3.RequireArrayOf = function RequireArrayOf(x, t) {\n        for (let i of x)\n            ;\n    }\n    ;\n    C3.RequireOptionalArrayOf = function RequireOptionalArrayOf(x, t) {\n        if (C3.IsNullOrUndefined(x))\n            return;\n        for (let i of x)\n            ;\n    }\n    ;\n    C3.RequireArrayOfAny = function RequireArrayOf(x, ...args) {\n        for (let i of x)\n            ;\n    }\n    ;\n    C3.RequireOptionalArrayOfAny = function RequireOptionalArrayOfAny(x, ...args) {\n        if (C3.IsNullOrUndefined(x))\n            return;\n        for (let i of x)\n            ;\n    }\n    ;\n    C3.IsDOMNode = function IsDOMNode(d, n) {\n        if (C3.IsNullOrUndefined(d) || !C3.IsString(d.nodeName))\n            return false;\n        return !n || C3.equalsNoCase(d.nodeName, n)\n    }\n    ;\n    C3.RequireDOMNode = function RequireDOMNode(d, n) {\n        if (C3.IsNullOrUndefined(d) || !C3.IsString(d.nodeName))\n            throw new TypeError("expected DOM node");\n        if (n && !C3.equalsNoCase(d.nodeName, n))\n            throw new TypeError(`expected DOM \'${n}\' node`);\n    }\n    ;\n    C3.RequireOptionalDOMNode = function RequireOptionalDOMNode(d, n) {\n        if (C3.IsNullOrUndefined(d))\n            return\n    }\n    ;\n    C3.IsHTMLElement = function IsHTMLElement(e, t) {\n        if (C3.IsNullOrUndefined(e) || !C3.IsString(e.tagName))\n            return false;\n        return !t || C3.equalsNoCase(e.tagName, t)\n    }\n    ;\n    C3.RequireHTMLElement = function RequireHTMLElement(e, t) {\n        if (C3.IsNullOrUndefined(e) || !C3.IsString(e.tagName))\n            throw new TypeError("expected HTML element");\n        if (t && !C3.equalsNoCase(e.tagName, t))\n            throw new TypeError(`expected HTML \'${t}\' element`);\n    }\n    ;\n    C3.RequireOptionalHTMLElement = function RequireOptionalHTMLElement(e, t) {\n        if (C3.IsNullOrUndefined(e))\n            return\n    }\n    ;\n    C3.IsDrawable = function IsDrawable(d) {\n        return C3.IsHTMLElement(d, "img") || C3.IsHTMLElement(d, "canvas") || C3.IsHTMLElement(d, "video") || typeof OffscreenCanvas !== "undefined" && d instanceof OffscreenCanvas || typeof ImageBitmap !== "undefined" && d instanceof ImageBitmap\n    }\n    ;\n    C3.RequireDrawable = function RequireDrawable(d) {\n        if (!C3.IsDrawable(d))\n            throw new TypeError("expected drawable");\n    }\n    ;\n    C3.RequireOptionalDrawable = function RequireOptionalDrawable(d) {\n        if (C3.IsNullOrUndefined(d))\n            return\n    }\n    ;\n    C3.IsDrawableOrImageData = function IsDrawableOrImageData(x) {\n        if (x instanceof ImageData)\n            return true;\n        return C3.IsDrawable(x)\n    }\n    ;\n    C3.RequireDrawableOrImageData = function RequireDrawableOrImageData(d) {\n        if (!C3.IsDrawableOrImageData(d))\n            throw new TypeError("expected drawable or image data");\n    }\n    ;\n    C3.RequireOptionalDrawableOrImageData = function RequireOptionalDrawableOrImageData(d) {\n        if (C3.IsNullOrUndefined(d))\n            return;\n        if (!C3.IsDrawableOrImageData(d))\n            throw new TypeError("expected drawable or image data");\n    }\n    ;\n    C3.IsStringLike = function IsStringLike(x) {\n        return typeof x === "string" || C3.HtmlString && x instanceof C3.HtmlString || x instanceof C3.BBString\n    }\n    ;\n    C3.RequireStringLike = function RequireStringLike(x) {\n        if (!C3.IsStringLike(x))\n            throw new TypeError("expected string-like");\n    }\n    ;\n    C3.RequireOptionalStringLike = function RequireOptionalStringLike(x) {\n        if (C3.IsNullOrUndefined(x))\n            return\n    }\n    ;\n    C3.RequireAllStringLike = function RequireAllStringLike(...args) {\n        for (let a of args)\n            ;\n    }\n    ;\n    C3.RequireOverride = function RequireOverride() {\n        throw new Error("must be overridden");\n    }\n    ;\n    C3.NotYetImplemented = function NotYetImplemented() {\n        throw new Error("not yet implemented");\n    }\n    ;\n    C3.IsDefined = function isDefined(obj, ...follow) {\n        let currentObject = obj;\n        if (typeof currentObject === "undefined")\n            return false;\n        for (let key of follow) {\n            if (typeof currentObject[key] === "undefined")\n                return false;\n            currentObject = currentObject[key]\n        }\n        return true\n    }\n    ;\n    C3.IsNullOrUndefined = function(x) {\n        return typeof x === "undefined" || x === null\n    }\n    ;\n    C3.AreArrayElementsOfSameType = function(arr) {\n        let type = arr[0].constructor;\n        for (let x of arr)\n            if (x.constructor !== type)\n                return false;\n        return type\n    }\n    ;\n    C3.AreArrayElementsOfType = function(arr, t) {\n        for (let x of arr)\n            if (!(x instanceof t))\n                return false;\n        return true\n    }\n    ;\n    const TypedArray = Object.getPrototypeOf(Uint8Array);\n    C3.IsTypedArray = function(view) {\n        return C3.IsInstanceOf(view, TypedArray)\n    }\n    ;\n    C3.RequireTypedArray = function(view) {}\n    ;\n    C3.WeakRequireTypedArray = function WeakRequireTypedArray(inst) {\n        C3.WeakRequireInstanceOf(inst, TypedArray)\n    }\n    ;\n    C3.WeakRequireAnyInstanceOf = function WeakRequireAnyInstanceOf(inst, ...ctors) {\n        if (!C3.WeakIsAnyInstanceOf(inst, ...ctors))\n            throw new TypeError("unexpected type");\n    }\n    ;\n    C3.WeakIsAnyInstanceOf = function WeakIsAnyInstanceOf(inst, ...ctors) {\n        for (const ctor of ctors)\n            if (C3.WeakIsInstanceOf(inst, ctor))\n                return true;\n        return false\n    }\n    ;\n    C3.WeakRequireInstanceOf = function WeakRequireInstanceOf(inst, ctor) {\n        if (!C3.WeakIsInstanceOf(inst, ctor))\n            throw new TypeError("unexpected type");\n    }\n    ;\n    C3.WeakIsInstanceOf = function WeakIsInstanceOf(inst, ctor) {\n        while (inst = Object.getPrototypeOf(inst))\n            if (inst.constructor.name === ctor.name)\n                return true;\n        return false\n    }\n    ;\n    C3X.RequireNumber = C3.RequireNumber;\n    C3X.RequireOptionalNumber = C3.RequireOptionalNumber;\n    C3X.RequireFiniteNumber = C3.RequireFiniteNumber;\n    C3X.RequireOptionalFiniteNumber = C3.RequireOptionalFiniteNumber;\n    C3X.RequireString = C3.RequireString;\n    C3X.RequireOptionalString = C3.RequireOptionalString;\n    C3X.RequireObject = C3.RequireObject;\n    C3X.RequireOptionalObject = C3.RequireOptionalObject;\n    C3X.RequireArray = C3.RequireArray;\n    C3X.RequireOptionalArray = C3.RequireOptionalArray;\n    C3X.RequireFunction = C3.RequireFunction;\n    C3X.RequireOptionalFunction = C3.RequireOptionalFunction;\n    C3X.RequireInstanceOf = C3.RequireInstanceOf;\n    C3X.RequireOptionalInstanceOf = C3.RequireOptionalInstanceOf;\n    C3X.IsNullOrUndefined = C3.IsNullOrUndefined;\n\n}\n\n\/\/ ..\/lib\/misc\/jsutil.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const logRafIds = new Map;\n    C3.ColorLog = function(message, color) {\n        console.log(`%c${message}`, `font-weight: bold; color:${color}`)\n    }\n    ;\n    C3.RafLog = function RaFLog(name, ...args) {\n        if (!logRafIds.has(name))\n            logRafIds.set(name, -1);\n        if (logRafIds.get(name) === -1)\n            logRafIds.set(name, requestAnimationFrame( () => {\n                console.log(`%c${name}`, "font-weight: bold", ...args);\n                logRafIds.set(name, -1)\n            }\n            ))\n    }\n    ;\n    let measures;\n    C3.StartMeasure = function StartMeasure(name) {\n        performance.mark(name);\n        if (!measures)\n            measures = new Map;\n        if (!measures.has(name))\n            measures.set(name, {\n                current: 0,\n                total: 0,\n                average: 0,\n                calls: 1,\n                toString: function() {\n                    return `current => ${this.current.toPrecision(3)} :: average => ${this.average.toPrecision(3)} :: calls => ${this.calls}`\n                }\n            })\n    }\n    ;\n    C3.EndMeasure = function StartMeasure(name) {\n        performance.measure("measure", name);\n        const entry = performance.getEntriesByName("measure")[0];\n        const m = measures.get(name);\n        m.current = entry.duration;\n        m.total += m.current;\n        m.average = m.total \/ m.calls;\n        m.calls++;\n        console.log(m.toString());\n        performance.clearMarks();\n        performance.clearMeasures()\n    }\n    ;\n    C3.GetCallStack = function GetCallStack() {\n        return (new Error).stack\n    }\n    ;\n    C3.Debugger = function Debugger() {\n        debugger\n    }\n    ;\n    C3.cast = function cast(o, T) {\n        if (o && o instanceof T)\n            return o;\n        else\n            return null\n    }\n    ;\n    C3.getName = function getName(o) {\n        if (typeof o === "undefined")\n            return "undefined";\n        if (o === null)\n            return "null";\n        if (typeof o === "boolean")\n            return "<boolean>";\n        if (C3.IsNumber(o))\n            return "<number>";\n        if (C3.IsString(o))\n            return "<string>";\n        if (C3.IsArray(o))\n            return "<array>";\n        if (typeof o === "symbol")\n            return "<" + o.toString() + ">";\n        if (C3.IsFunction(o)) {\n            if (o.name && o.name !== "Function")\n                return o.name;\n            return "<anonymous function>"\n        }\n        if (typeof o === "object") {\n            if (o.constructor && o.constructor.name && o.constructor.name !== "Object")\n                return o.constructor.name;\n            return "<anonymous object>"\n        }\n        return "<unknown>"\n    }\n    ;\n    C3.getType = function getType(o) {\n        if (o === null)\n            return "null";\n        if (Array.isArray(o))\n            return "array";\n        return typeof o\n    }\n    ;\n    C3.range = function *range(a, b) {\n        if (!isFinite(Math.abs(a - b)))\n            throw new Error("Invalid parameters");\n        if (a > b)\n            for (let i = a - 1; i >= b; i--)\n                yield i;\n        else\n            for (let i = a; i < b; i++)\n                yield i\n    }\n    ;\n    function isValidTypeChange(from, to) {\n        let fromType = C3.getType(from);\n        let toType = C3.getType(to);\n        if (fromType === "null" || toType === "null")\n            return true;\n        if (fromType === "undefined" || toType === "undefined")\n            return false;\n        return fromType === toType\n    }\n    let ctorObjectToProxy = new Map;\n    let ctorProxyToObject = new Map;\n    let proxyToObject = new WeakMap;\n    let releasedObjects = new WeakMap;\n    C3.DefendHandler = {};\n    const VALID_GET_MISSING_KEYS = new Set(["then", "splice"]);\n    function logDefendedObjectWarning(msg) {\n        console.warn("[Defence] " + msg + " @", C3.GetCallStack())\n    }\n    C3.DefendHandler.get = function defended_get(target, key) {\n        if (!(key in target) && typeof key !== "symbol" && !VALID_GET_MISSING_KEYS.has(key))\n            logDefendedObjectWarning(`Accessed missing property \'${key}\' from defended object \'${C3.getName(target)}\', returning undefined`);\n        if (releasedObjects.has(target) && typeof key !== "symbol" && !VALID_GET_MISSING_KEYS.has(key))\n            logDefendedObjectWarning(`Accessed property \'${key}\' on a released object \'${C3.getName(target)}\'\\nObject was originally released at: ${releasedObjects.get(target)})\\nCall stack at access: `);\n        return target[key]\n    }\n    ;\n    C3.DefendHandler.set = function defended_set(target, key, value) {\n        if (!(key in target) && !ctorObjectToProxy.has(target))\n            logDefendedObjectWarning(`Set non-existent property \'${key}\' to \'${value}\' on defended object \'${C3.getName(target)}\'`);\n        if (!isValidTypeChange(target[key], value) && !ctorObjectToProxy.has(target))\n            logDefendedObjectWarning(`Set \'${C3.getType(target[key])}\' property \'${key}\' to type \'${C3.getType(value)}\' on defended object \'${C3.getName(target)}\'`);\n        if (releasedObjects.has(target))\n            logDefendedObjectWarning(`Set property \'${key}\' on a released object \'${C3.getName(target)}\'\\nObject was originally released at: ${releasedObjects.get(target)})\\nCall stack at access: `);\n        target[key] = value;\n        return true\n    }\n    ;\n    C3.DefendHandler.deleteProperty = function defended_deleteProperty(target, key) {\n        throw new ReferenceError(`Cannot delete property \'${key}\' from defended object \'${C3.getName(target)}\'`);\n    }\n    ;\n    C3.DefendHandler.defineProperty = function defended_defineProperty(target, key, desc) {\n        throw new ReferenceError(`Cannot define property \'${key}\' on defended object \'${C3.getName(target)}\'`);\n    }\n    ;\n    C3.DefendHandler.enumerate = function defended_enumerate(target) {\n        throw new ReferenceError(`Cannot enumerate defended object \'${C3.getName(target)}\'`);\n    }\n    ;\n    let checkRafId = -1;\n    function CheckDefendedObjectsUsedCorrectly() {\n        checkRafId = -1;\n        if (ctorObjectToProxy.size > 0 || ctorProxyToObject.size > 0) {\n            let uniqueNames = new Set([...ctorObjectToProxy.keys()].map(o => C3.getName(o)));\n            let leftoverNames = [...uniqueNames].join(",");\n            console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${leftoverNames}`);\n            ctorObjectToProxy.clear();\n            ctorProxyToObject.clear()\n        }\n    }\n    C3.DefendedBase = class DefendedBase {\n        constructor() {\n            if (!C3.isDebugDefend || !C3.Supports.Proxies)\n                return;\n            let newTarget = new.target;\n            let realObject = Object.create(newTarget.prototype);\n            let proxy = new Proxy(realObject,C3.DefendHandler);\n            ctorObjectToProxy.set(realObject, proxy);\n            ctorProxyToObject.set(proxy, realObject);\n            proxyToObject.set(proxy, realObject);\n            if (checkRafId === -1)\n                checkRafId = requestAnimationFrame(CheckDefendedObjectsUsedCorrectly);\n            return proxy\n        }\n    }\n    ;\n    C3.debugDefend = function debugDefend(o) {\n        if (C3.isDebugDefend && C3.Supports.Proxies && o instanceof C3.DefendedBase) {\n            if (!ctorProxyToObject.has(o))\n                return o;\n            let realObject = ctorProxyToObject.get(o);\n            ctorProxyToObject.delete(o);\n            ctorObjectToProxy.delete(realObject);\n            return o\n        } else if (C3.isDebug)\n            return Object.seal(o);\n        else\n            return o\n    }\n    ;\n    C3.New = function New(Type, ...args) {\n        let o;\n        try {\n            o = new Type(...args)\n        } catch (e) {\n            ctorProxyToObject.clear();\n            ctorObjectToProxy.clear();\n            throw e;\n        }\n        if (C3.isDebugDefend)\n            VerifyObjectPropertiesConsistent(Type, o);\n        return C3.debugDefend(o)\n    }\n    ;\n    C3.Release = function Release(o) {\n        let realObject = proxyToObject.get(o);\n        if (realObject)\n            releasedObjects.set(realObject, C3.GetCallStack())\n    }\n    ;\n    C3.WasReleased = function(o) {\n        let realObject = proxyToObject.get(o);\n        if (!realObject)\n            return false;\n        return !!releasedObjects.get(realObject)\n    }\n    ;\n    let typeProperties = new Map;\n    function getObjectPropertySet(o) {\n        let ret = new Set;\n        for (let k in o)\n            ret.add(k);\n        return ret\n    }\n    function VerifyObjectPropertiesConsistent(Type, o) {\n        let properties = getObjectPropertySet(o);\n        let existingProperties = typeProperties.get(Type);\n        if (existingProperties) {\n            let inconsistentProperties = [];\n            for (let k of existingProperties.values())\n                if (properties.has(k))\n                    properties.delete(k);\n                else\n                    inconsistentProperties.push(k);\n            C3.appendArray(inconsistentProperties, [...properties]);\n            if (inconsistentProperties.length)\n                console.warn(`[Defence] \'${C3.getName(Type)}\' constructor creates inconsistent properties: ${inconsistentProperties.join(", ")}`)\n        } else\n            typeProperties.set(Type, properties)\n    }\n    C3.PerfMark = class PerfMark {\n        constructor(name) {\n            this._name = "";\n            if (name)\n                this.start(name)\n        }\n        start(name) {\n            if (!C3.isPerformanceProfiling)\n                return;\n            this._name = name;\n            performance.mark(this._name + "-Start")\n        }\n        end() {\n            if (!C3.isPerformanceProfiling)\n                return;\n            performance.mark(this._name + "-End");\n            performance.measure(this._name, this._name + "-Start", this._name + "-End")\n        }\n        next(name) {\n            if (!C3.isPerformanceProfiling)\n                return;\n            this.end();\n            this._name = name;\n            performance.mark(this._name + "-Start")\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/misc\/mathutil.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const TWO_PI = Math.PI * 2;\n    const D_TO_R = Math.PI \/ 180;\n    const R_TO_D = 180 \/ Math.PI;\n    C3.wrap = function wrap(x, min, max) {\n        x = Math.floor(x);\n        min = Math.floor(min);\n        max = Math.floor(max);\n        if (x < min) {\n            let r = max - (min - x) % (max - min);\n            return r === max ? 0 : r\n        } else\n            return min + (x - min) % (max - min)\n    }\n    ;\n    C3.mapToRange = function mapToRange(x, inMin, inMax, outMin, outMax) {\n        return (x - inMin) * (outMax - outMin) \/ (inMax - inMin) + outMin\n    }\n    ;\n    C3.normalize = function normalize(value, minimum, maximum) {\n        return (value - minimum) \/ (maximum - minimum)\n    }\n    ;\n    C3.clamp = function clamp(x, a, b) {\n        if (x < a)\n            return a;\n        else if (x > b)\n            return b;\n        else\n            return x\n    }\n    ;\n    C3.clampAngle = function clampAngle(a) {\n        a %= TWO_PI;\n        if (a < 0)\n            a += TWO_PI;\n        return a\n    }\n    ;\n    C3.toRadians = function toRadians(x) {\n        return x * D_TO_R\n    }\n    ;\n    C3.toDegrees = function toDegrees(x) {\n        return x * R_TO_D\n    }\n    ;\n    C3.distanceTo = function distanceTo(x1, y1, x2, y2) {\n        return Math.hypot(x2 - x1, y2 - y1)\n    }\n    ;\n    C3.distanceSquared = function distanceSquared(x1, y1, x2, y2) {\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        return dx * dx + dy * dy\n    }\n    ;\n    C3.angleTo = function angleTo(x1, y1, x2, y2) {\n        return Math.atan2(y2 - y1, x2 - x1)\n    }\n    ;\n    C3.angleDiff = function angleDiff(a1, a2) {\n        if (a1 === a2)\n            return 0;\n        let s1 = Math.sin(a1);\n        let c1 = Math.cos(a1);\n        let s2 = Math.sin(a2);\n        let c2 = Math.cos(a2);\n        let n = s1 * s2 + c1 * c2;\n        if (n >= 1)\n            return 0;\n        if (n <= -1)\n            return Math.PI;\n        return Math.acos(n)\n    }\n    ;\n    C3.angleRotate = function angleRotate(start, end, step) {\n        let ss = Math.sin(start);\n        let cs = Math.cos(start);\n        let se = Math.sin(end);\n        let ce = Math.cos(end);\n        if (Math.acos(ss * se + cs * ce) > step)\n            if (cs * se - ss * ce > 0)\n                return C3.clampAngle(start + step);\n            else\n                return C3.clampAngle(start - step);\n        else\n            return C3.clampAngle(end)\n    }\n    ;\n    C3.angleClockwise = function angleClockwise(a1, a2) {\n        let s1 = Math.sin(a1);\n        let c1 = Math.cos(a1);\n        let s2 = Math.sin(a2);\n        let c2 = Math.cos(a2);\n        return c1 * s2 - s1 * c2 <= 0\n    }\n    ;\n    C3.angleLerp = function angleLerp(a, b, x, r=0) {\n        let diff = C3.angleDiff(a, b);\n        const revs = TWO_PI * r;\n        if (C3.angleClockwise(b, a))\n            return C3.clampAngle(a + (diff + revs) * x);\n        else\n            return C3.clampAngle(a - (diff + revs) * x)\n    }\n    ;\n    C3.angleLerpClockwise = function angleLerpClockwise(a, b, x, r=0) {\n        const diff = C3.angleDiff(a, b);\n        const revs = TWO_PI * r;\n        if (C3.angleClockwise(b, a))\n            return C3.clampAngle(a + (diff + revs) * x);\n        return C3.clampAngle((TWO_PI - diff + revs) * x)\n    }\n    ;\n    C3.angleLerpAntiClockwise = function angleLerpAntiClockwise(a, b, x, r=0) {\n        const diff = C3.angleDiff(a, b);\n        const revs = TWO_PI * r;\n        if (C3.angleClockwise(b, a))\n            return C3.clampAngle((-TWO_PI + diff - revs) * x);\n        return C3.clampAngle(a - (diff + revs) * x)\n    }\n    ;\n    C3.lerp = function lerp(a, b, x) {\n        return a + x * (b - a)\n    }\n    ;\n    C3.unlerp = function unlerp(a, b, x) {\n        if (a === b)\n            return 0;\n        return (x - a) \/ (b - a)\n    }\n    ;\n    C3.relerp = function relerp(a, b, x, c, d) {\n        return C3.lerp(c, d, C3.unlerp(a, b, x))\n    }\n    ;\n    C3.qarp = function qarp(a, b, c, x) {\n        return C3.lerp(C3.lerp(a, b, x), C3.lerp(b, c, x), x)\n    }\n    ;\n    C3.cubic = function cubic(a, b, c, d, x) {\n        return C3.lerp(C3.qarp(a, b, c, x), C3.qarp(b, c, d, x), x)\n    }\n    ;\n    C3.cosp = function cosp(a, b, x) {\n        return (a + b + (a - b) * Math.cos(x * Math.PI)) \/ 2\n    }\n    ;\n    C3.isPOT = function isPOT(x) {\n        return x > 0 && (x - 1 & x) === 0\n    }\n    ;\n    C3.nextHighestPowerOfTwo = function nextHighestPowerOfTwo(x) {\n        --x;\n        for (let i = 1; i < 32; i <<= 1)\n            x = x | x >> i;\n        return x + 1\n    }\n    ;\n    C3.roundToNearestFraction = function roundToNearestFraction(x, n) {\n        return Math.round(x * n) \/ n\n    }\n    ;\n    C3.floorToNearestFraction = function floorToNearestFraction(x, n) {\n        return Math.floor(x * n) \/ n\n    }\n    ;\n    C3.round6dp = function round6dp(x) {\n        return Math.round(x * 1E6) \/ 1E6\n    }\n    ;\n    C3.toFixed = function toFixed(n, dp) {\n        let ret = n.toFixed(dp);\n        let last = ret.length - 1;\n        for (; last >= 0 && ret.charAt(last) === "0"; --last)\n            ;\n        if (last >= 0 && ret.charAt(last) === ".")\n            --last;\n        if (last < 0)\n            return ret;\n        return ret.substr(0, last + 1)\n    }\n    ;\n    C3.PackRGB = function PackRGB(red, green, blue) {\n        return C3.clamp(red, 0, 255) | C3.clamp(green, 0, 255) << 8 | C3.clamp(blue, 0, 255) << 16\n    }\n    ;\n    const ALPHAEX_SHIFT = 1024;\n    const ALPHAEX_MAX = 1023;\n    const RGBEX_SHIFT = 16384;\n    const RGBEX_MAX = 8191;\n    const RGBEX_MIN = -8192;\n    C3.PackRGBAEx = function PackRGBAEx(red, green, blue, alpha) {\n        red = C3.clamp(Math.floor(red * 1024), RGBEX_MIN, RGBEX_MAX);\n        green = C3.clamp(Math.floor(green * 1024), RGBEX_MIN, RGBEX_MAX);\n        blue = C3.clamp(Math.floor(blue * 1024), RGBEX_MIN, RGBEX_MAX);\n        alpha = C3.clamp(Math.floor(alpha * ALPHAEX_MAX), 0, ALPHAEX_MAX);\n        if (red < 0)\n            red += RGBEX_SHIFT;\n        if (green < 0)\n            green += RGBEX_SHIFT;\n        if (blue < 0)\n            blue += RGBEX_SHIFT;\n        return -(red * RGBEX_SHIFT * RGBEX_SHIFT * ALPHAEX_SHIFT + green * RGBEX_SHIFT * ALPHAEX_SHIFT + blue * ALPHAEX_SHIFT + alpha)\n    }\n    ;\n    C3.PackRGBEx = function PackRGBEx(red, green, blue) {\n        return C3.PackRGBAEx(red, green, blue, 1)\n    }\n    ;\n    function isNegativeZero(x) {\n        return x === 0 && 1 \/ x < 0\n    }\n    C3.GetRValue = function GetRValue(rgb) {\n        if (rgb >= 0)\n            return (rgb & 255) \/ 255;\n        else {\n            let v = Math.floor(-rgb \/ (RGBEX_SHIFT * RGBEX_SHIFT * ALPHAEX_SHIFT));\n            if (v > RGBEX_MAX)\n                v -= RGBEX_SHIFT;\n            return v \/ 1024\n        }\n    }\n    ;\n    C3.GetGValue = function GetGValue(rgb) {\n        if (rgb >= 0)\n            return ((rgb & 65280) >> 8) \/ 255;\n        else {\n            let v = Math.floor(-rgb % (RGBEX_SHIFT * RGBEX_SHIFT * ALPHAEX_SHIFT) \/ (RGBEX_SHIFT * ALPHAEX_SHIFT));\n            if (v > RGBEX_MAX)\n                v -= RGBEX_SHIFT;\n            return v \/ 1024\n        }\n    }\n    ;\n    C3.GetBValue = function GetBValue(rgb) {\n        if (rgb >= 0)\n            return ((rgb & 16711680) >> 16) \/ 255;\n        else {\n            let v = Math.floor(-rgb % (RGBEX_SHIFT * ALPHAEX_SHIFT) \/ ALPHAEX_SHIFT);\n            if (v > RGBEX_MAX)\n                v -= RGBEX_SHIFT;\n            return v \/ 1024\n        }\n    }\n    ;\n    C3.GetAValue = function GetAValue(rgb) {\n        if (isNegativeZero(rgb))\n            return 0;\n        else if (rgb >= 0)\n            return 1;\n        else {\n            const v = Math.floor(-rgb % ALPHAEX_SHIFT);\n            return v \/ ALPHAEX_MAX\n        }\n    }\n    ;\n    C3.greatestCommonDivisor = function greatestCommonDivisor(a, b) {\n        a = Math.floor(a);\n        b = Math.floor(b);\n        while (b !== 0) {\n            let t = b;\n            b = a % b;\n            a = t\n        }\n        return a\n    }\n    ;\n    const COMMON_ASPECT_RATIOS = [[3, 2], [4, 3], [5, 4], [5, 3], [6, 5], [14, 9], [16, 9], [16, 10], [21, 9]];\n    C3.getAspectRatio = function getAspectRatio(w, h) {\n        w = Math.floor(w);\n        h = Math.floor(h);\n        if (w === h)\n            return [1, 1];\n        for (let aspect of COMMON_ASPECT_RATIOS) {\n            let approxH = w \/ aspect[0] * aspect[1];\n            if (Math.abs(h - approxH) < 1)\n                return aspect.slice(0);\n            approxH = w \/ aspect[1] * aspect[0];\n            if (Math.abs(h - approxH) < 1)\n                return [aspect[1], aspect[0]]\n        }\n        let gcd = C3.greatestCommonDivisor(w, h);\n        return [w \/ gcd, h \/ gcd]\n    }\n    ;\n    C3.segmentsIntersect = function segmentsIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n        const min_ax = Math.min(a1x, a2x);\n        const max_ax = Math.max(a1x, a2x);\n        const min_bx = Math.min(b1x, b2x);\n        const max_bx = Math.max(b1x, b2x);\n        if (max_ax < min_bx || min_ax > max_bx)\n            return false;\n        const min_ay = Math.min(a1y, a2y);\n        const max_ay = Math.max(a1y, a2y);\n        const min_by = Math.min(b1y, b2y);\n        const max_by = Math.max(b1y, b2y);\n        if (max_ay < min_by || min_ay > max_by)\n            return false;\n        const dpx = b1x - a1x + b2x - a2x;\n        const dpy = b1y - a1y + b2y - a2y;\n        const qax = a2x - a1x;\n        const qay = a2y - a1y;\n        const qbx = b2x - b1x;\n        const qby = b2y - b1y;\n        const d = Math.abs(qay * qbx - qby * qax);\n        const la = qbx * dpy - qby * dpx;\n        if (Math.abs(la) > d)\n            return false;\n        const lb = qax * dpy - qay * dpx;\n        return Math.abs(lb) <= d\n    }\n    ;\n    C3.segmentsIntersectPreCalc = function segmentsIntersectPreCalc(a1x, a1y, a2x, a2y, min_ax, max_ax, min_ay, max_ay, b1x, b1y, b2x, b2y) {\n        const min_bx = Math.min(b1x, b2x);\n        const max_bx = Math.max(b1x, b2x);\n        if (max_ax < min_bx || min_ax > max_bx)\n            return false;\n        const min_by = Math.min(b1y, b2y);\n        const max_by = Math.max(b1y, b2y);\n        if (max_ay < min_by || min_ay > max_by)\n            return false;\n        const dpx = b1x - a1x + b2x - a2x;\n        const dpy = b1y - a1y + b2y - a2y;\n        const qax = a2x - a1x;\n        const qay = a2y - a1y;\n        const qbx = b2x - b1x;\n        const qby = b2y - b1y;\n        const d = Math.abs(qay * qbx - qby * qax);\n        const la = qbx * dpy - qby * dpx;\n        if (Math.abs(la) > d)\n            return false;\n        const lb = qax * dpy - qay * dpx;\n        return Math.abs(lb) <= d\n    }\n    ;\n    C3.segmentIntersectsQuad = function segmentIntersectsQuad(x1, y1, x2, y2, q) {\n        const min_x = Math.min(x1, x2);\n        const max_x = Math.max(x1, x2);\n        const min_y = Math.min(y1, y2);\n        const max_y = Math.max(y1, y2);\n        const tlx = q.getTlx()\n          , tly = q.getTly()\n          , trx = q.getTrx()\n          , try_ = q.getTry()\n          , brx = q.getBrx()\n          , bry = q.getBry()\n          , blx = q.getBlx()\n          , bly = q.getBly();\n        return C3.segmentsIntersectPreCalc(x1, y1, x2, y2, min_x, max_x, min_y, max_y, tlx, tly, trx, try_) || C3.segmentsIntersectPreCalc(x1, y1, x2, y2, min_x, max_x, min_y, max_y, trx, try_, brx, bry) || C3.segmentsIntersectPreCalc(x1, y1, x2, y2, min_x, max_x, min_y, max_y, brx, bry, blx, bly) || C3.segmentsIntersectPreCalc(x1, y1, x2, y2, min_x, max_x, min_y, max_y, blx, bly, tlx, tly)\n    }\n    ;\n    C3.segmentIntersectsAnyN = function segmentIntersectsAnyN(x1, y1, x2, y2, points) {\n        const min_x = Math.min(x1, x2);\n        const max_x = Math.max(x1, x2);\n        const min_y = Math.min(y1, y2);\n        const max_y = Math.max(y1, y2);\n        let i = 0;\n        for (let last = points.length - 4; i <= last; i += 2)\n            if (C3.segmentsIntersectPreCalc(x1, y1, x2, y2, min_x, max_x, min_y, max_y, points[i], points[i + 1], points[i + 2], points[i + 3]))\n                return true;\n        return C3.segmentsIntersectPreCalc(x1, y1, x2, y2, min_x, max_x, min_y, max_y, points[i], points[i + 1], points[0], points[1])\n    }\n    ;\n    const NO_HIT = 2;\n    const PADDING = 1E-6;\n    C3.rayIntersect = function rayIntersect(rx1, ry1, rx2, ry2, sx1, sy1, sx2, sy2) {\n        const rdx = rx2 - rx1;\n        const rdy = ry2 - ry1;\n        const sdx = sx2 - sx1;\n        const sdy = sy2 - sy1;\n        const det = rdx * sdy - rdy * sdx;\n        if (det === 0)\n            return NO_HIT;\n        const gamma = ((ry1 - ry2) * (sx2 - rx1) + rdx * (sy2 - ry1)) \/ det;\n        if (0 < gamma && gamma < 1 + PADDING)\n            return (sdy * (sx2 - rx1) + (sx1 - sx2) * (sy2 - ry1)) \/ det;\n        return NO_HIT\n    }\n    ;\n    C3.rayIntersectExtended = function rayIntersect(rx1, ry1, rx2, ry2, sx1, sy1, sx2, sy2, f) {\n        const dx = (sx2 - sx1) * f;\n        const dy = (sy2 - sy1) * f;\n        return C3.rayIntersect(rx1, ry1, rx2, ry2, sx1 - dx, sy1 - dy, sx2 + dx, sy2 + dy)\n    }\n    ;\n    C3.isPointInTriangleInclusive = function isPointInTriangleInclusive(px, py, tx1, ty1, tx2, ty2, tx3, ty3) {\n        const v0x = tx2 - tx1;\n        const v0y = ty2 - ty1;\n        const v1x = tx3 - tx1;\n        const v1y = ty3 - ty1;\n        const v2x = px - tx1;\n        const v2y = py - ty1;\n        const dot00 = v0x * v0x + v0y * v0y;\n        const dot01 = v0x * v1x + v0y * v1y;\n        const dot02 = v0x * v2x + v0y * v2y;\n        const dot11 = v1x * v1x + v1y * v1y;\n        const dot12 = v1x * v2x + v1y * v2y;\n        const invDenom = 1 \/ (dot00 * dot11 - dot01 * dot01);\n        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n        return u >= 0 && v >= 0 && u + v <= 1\n    }\n    ;\n    C3.triangleCartesianToBarycentric = function triangleCartesianToBarycentric(px, py, tx1, ty1, tx2, ty2, tx3, ty3) {\n        const v0x = tx2 - tx1;\n        const v0y = ty2 - ty1;\n        const v1x = tx3 - tx1;\n        const v1y = ty3 - ty1;\n        const v2x = px - tx1;\n        const v2y = py - ty1;\n        const dot00 = v0x * v0x + v0y * v0y;\n        const dot01 = v0x * v1x + v0y * v1y;\n        const dot11 = v1x * v1x + v1y * v1y;\n        const dot20 = v2x * v0x + v2y * v0y;\n        const dot21 = v2x * v1x + v2y * v1y;\n        const denom = dot00 * dot11 - dot01 * dot01;\n        const v = (dot11 * dot20 - dot01 * dot21) \/ denom;\n        const w = (dot00 * dot21 - dot01 * dot20) \/ denom;\n        const u = 1 - v - w;\n        return [u, v, w]\n    }\n    ;\n    C3.triangleBarycentricToCartesian = function triangleBarycentricToCartesian(u, v, w, tx1, ty1, tx2, ty2, tx3, ty3) {\n        return [u * tx1 + v * tx2 + w * tx3, u * ty1 + v * ty2 + w * ty3]\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/misc\/miscutil.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    let mainDocument = null;\n    let baseHref = "";\n    if (typeof document !== "undefined") {\n        mainDocument = document;\n        const baseElem = document.querySelector("base");\n        baseHref = baseElem && baseElem.hasAttribute("href") ? baseElem.getAttribute("href") : "";\n        if (baseHref) {\n            if (baseHref.startsWith("\/"))\n                baseHref = baseHref.substr(1);\n            if (!baseHref.endsWith("\/"))\n                baseHref += "\/"\n        }\n    }\n    C3.GetBaseHref = function GetBaseHref() {\n        return baseHref\n    }\n    ;\n    C3.GetBaseURL = function GetBaseURL() {\n        if (!mainDocument)\n            return "";\n        const loc = mainDocument.location;\n        return C3.GetPathFromURL(loc.origin + loc.pathname) + baseHref\n    }\n    ;\n    C3.GetPathFromURL = function GetPathFromURL(url) {\n        if (!url.length)\n            return url;\n        if (url.endsWith("\/") || url.endsWith("\\\\"))\n            return url;\n        const lastSlash = Math.max(url.lastIndexOf("\/"), url.lastIndexOf("\\\\"));\n        if (lastSlash === -1)\n            return "";\n        return url.substr(0, lastSlash + 1)\n    }\n    ;\n    C3.GetFilenameFromURL = function GetFilenameFromURL(url) {\n        if (!url.length)\n            return url;\n        if (url.endsWith("\/") || url.endsWith("\\\\"))\n            return "";\n        const lastSlash = Math.max(url.lastIndexOf("\/"), url.lastIndexOf("\\\\"));\n        if (lastSlash === -1)\n            return url;\n        return url.substr(lastSlash + 1)\n    }\n    ;\n    C3.GetFileExtension = function GetFileExtension(filename) {\n        let i = filename.lastIndexOf(".");\n        if (i < 1)\n            return "";\n        else\n            return filename.substr(i)\n    }\n    ;\n    C3.GetFileNamePart = function GetFileNamePart(filename) {\n        let i = filename.lastIndexOf(".");\n        if (i < 1)\n            return filename;\n        else\n            return filename.substr(0, i)\n    }\n    ;\n    C3.NormalizeFileSeparator = function NormalizeFileSeparator(path) {\n        return path.replace(\/\\\\\/g, "\/")\n    }\n    ;\n    C3.IsFileExtension = function IsFileExtension(filename, extension) {\n        const ext = filename ? C3.GetFileExtension(filename).slice(1) : "";\n        return extension === ext\n    }\n    ;\n    C3.FileNameEquals = function FileNameEquals(file_or_filename, other_file_or_filename) {\n        let firstName;\n        let secondName;\n        if (C3.IsFileLike(file_or_filename))\n            firstName = C3.GetFileNamePart(file_or_filename["name"]);\n        if (C3.IsString(file_or_filename))\n            firstName = C3.GetFileNamePart(file_or_filename);\n        if (C3.IsFileLike(other_file_or_filename))\n            secondName = C3.GetFileNamePart(other_file_or_filename["name"]);\n        if (C3.IsString(other_file_or_filename))\n            secondName = C3.GetFileNamePart(other_file_or_filename);\n        return firstName === secondName\n    }\n    ;\n    C3.ParseFilePath = function ParseFilePath(path) {\n        path = C3.NormalizeFileSeparator(path);\n        let root = \/^\\w:\\\/\/.exec(path);\n        if (root) {\n            root = root[0];\n            path = path.slice(3);\n            if (path[0] !== "\/")\n                path = "\/" + path\n        } else\n            root = "";\n        path = path.replace(\/\\\/{2,}\/g, "\/");\n        if (path.length > 1 && path.slice(-1) === "\/")\n            path = path.slice(0, -1);\n        const start = path.lastIndexOf("\/") + 1;\n        let dir = "", base = path, name, ext = "";\n        if (start > 0) {\n            dir = path.slice(0, start);\n            base = path.slice(start)\n        }\n        name = base;\n        const end = base.lastIndexOf(".");\n        if (end > 0) {\n            ext = base.slice(end);\n            name = base.slice(0, -ext.length)\n        }\n        const full = root + dir + base;\n        return {\n            dir,\n            base,\n            name,\n            root,\n            ext,\n            full\n        }\n    }\n    ;\n    C3.Wait = function Wait(delay, argument) {\n        return new Promise( (resolve, reject) => {\n            self.setTimeout(resolve, delay, argument)\n        }\n        )\n    }\n    ;\n    C3.swallowException = function swallowException(f) {\n        try {\n            f()\n        } catch (e) {\n            if (C3.isDebug)\n                console.warn("Swallowed exception: ", e)\n        }\n    }\n    ;\n    C3.noop = function noop() {}\n    ;\n    C3.equalsNoCase = function equalsNoCase(a, b) {\n        if (typeof a !== "string" || typeof b !== "string")\n            return false;\n        return a === b || a.normalize().toLowerCase() === b.normalize().toLowerCase()\n    }\n    ;\n    C3.equalsCase = function equalsCase(a, b) {\n        if (typeof a !== "string" || typeof b !== "string")\n            return false;\n        if (a === b)\n            return true;\n        return a.normalize() === b.normalize()\n    }\n    ;\n    C3.typedArraySet16 = function typedArraySet16(dest, src, i) {\n        dest[i++] = src[0];\n        dest[i++] = src[1];\n        dest[i++] = src[2];\n        dest[i++] = src[3];\n        dest[i++] = src[4];\n        dest[i++] = src[5];\n        dest[i++] = src[6];\n        dest[i++] = src[7];\n        dest[i++] = src[8];\n        dest[i++] = src[9];\n        dest[i++] = src[10];\n        dest[i++] = src[11];\n        dest[i++] = src[12];\n        dest[i++] = src[13];\n        dest[i++] = src[14];\n        dest[i] = src[15]\n    }\n    ;\n    C3.truncateArray = function truncateArray(arr, index) {\n        arr.length = index\n    }\n    ;\n    C3.clearArray = function clearArray(arr) {\n        if (!arr)\n            return;\n        if (arr.length === 0)\n            return;\n        C3.truncateArray(arr, 0)\n    }\n    ;\n    C3.clear2DArray = function clear2DArray(arr) {\n        if (!arr)\n            return;\n        for (let i = 0; i < arr.length; i++) {\n            let a = arr[i];\n            C3.truncateArray(a, 0)\n        }\n        C3.truncateArray(arr, 0)\n    }\n    ;\n    C3.extendArray = function extendArray(arr, len, filler) {\n        len = len | 0;\n        const arrayLength = arr.length;\n        if (len <= arrayLength)\n            return;\n        for (let i = arrayLength; i < len; ++i)\n            arr.push(filler)\n    }\n    ;\n    C3.resizeArray = function resizeArray(arr, len, filler) {\n        len = len | 0;\n        const arrayLength = arr.length;\n        if (len < arrayLength)\n            C3.truncateArray(arr, len);\n        else if (len > arrayLength)\n            C3.extendArray(arr, len, filler)\n    }\n    ;\n    C3.shallowAssignArray = function shallowAssignArray(dest, src) {\n        C3.clearArray(dest);\n        C3.appendArray(dest, src)\n    }\n    ;\n    C3.appendArray = function appendArray(a, b) {\n        if (b.length < 1E4)\n            a.push(...b);\n        else\n            for (let i = 0, len = b.length; i < len; ++i)\n                a.push(b[i])\n    }\n    ;\n    C3.arrayRemove = function(arr, index) {\n        index = Math.floor(index);\n        if (index < 0 || index >= arr.length)\n            return;\n        let len = arr.length - 1;\n        for (let i = index; i < len; ++i)\n            arr[i] = arr[i + 1];\n        C3.truncateArray(arr, len)\n    }\n    ;\n    C3.arrayFindRemove = function arrayFindRemove(a, o) {\n        let i = a.indexOf(o);\n        if (i >= 0)\n            a.splice(i, 1)\n    }\n    ;\n    C3.arraysEqual = function arraysEqual(a, b) {\n        let len = a.length;\n        if (b.length !== len)\n            return false;\n        for (let i = 0; i < len; ++i)\n            if (a[i] !== b[i])\n                return false;\n        return true\n    }\n    ;\n    C3.arrayFilterOut = function arrayFilterOut(arr, callback) {\n        let ret = [];\n        let j = 0;\n        for (let i = 0, len = arr.length; i < len; ++i) {\n            let item = arr[i];\n            if (callback(item))\n                ret.push(item);\n            else {\n                arr[j] = item;\n                ++j\n            }\n        }\n        C3.truncateArray(arr, j);\n        return ret\n    }\n    ;\n    C3.arrayRemoveAllInSet = function arrayRemoveAllInSet(arr, s) {\n        const oldLen = arr.length;\n        let j = 0;\n        for (let i = 0, len = arr.length; i < len; ++i) {\n            let item = arr[i];\n            if (!s.has(item))\n                arr[j++] = item\n        }\n        C3.truncateArray(arr, j);\n        return oldLen - j\n    }\n    ;\n    C3.isArrayIndexInBounds = function isArrayIndexInBounds(index, array) {\n        if (index !== Math.floor(index))\n            return false;\n        return index >= 0 && index < array.length\n    }\n    ;\n    C3.validateArrayIndex = function validateArrayIndex(index, array) {\n        if (!C3.isArrayIndexInBounds(index, array))\n            throw new RangeError("array index out of bounds");\n    }\n    ;\n    C3.cloneArray = function cloneArray(array) {\n        return array.slice()\n    }\n    ;\n    C3.deepCloneArray = function deepCloneArray(array, f) {\n        let ret = [];\n        for (let e of array)\n            if (C3.IsObject(e)) {\n                let clone = f(e);\n                if (!clone)\n                    throw new Error("missing clone");\n                if (clone.constructor !== e.constructor)\n                    throw new Error("object is not a clone");\n                ret.push(clone)\n            } else if (C3.IsArray(e))\n                ret.push(C3.deepCloneArray(e, f));\n            else\n                ret.push(e);\n        return ret\n    }\n    ;\n    C3.clone2DArray = function cloneArray(array) {\n        let ret = [];\n        for (let arr of array)\n            ret.push(arr.slice());\n        return ret\n    }\n    ;\n    C3.mergeSets = function mergeSets(set1, set2) {\n        return new Set([...set1, ...set2])\n    }\n    ;\n    C3.mergeSetsInPlace = function mergeSetsInPlace(set1, set2) {\n        for (const item of set2)\n            set1.add(item);\n        return set1\n    }\n    ;\n    C3.first = function first(iterable) {\n        for (let i of iterable)\n            return i;\n        return null\n    }\n    ;\n    C3.xor = function(x, y) {\n        return !x !== !y\n    }\n    ;\n    C3.compare = function compare(x, cmp, y) {\n        switch (cmp) {\n        case 0:\n            return x === y;\n        case 1:\n            return x !== y;\n        case 2:\n            return x < y;\n        case 3:\n            return x <= y;\n        case 4:\n            return x > y;\n        case 5:\n            return x >= y;\n        default:\n            return false\n        }\n    }\n    ;\n    C3.hasAnyOwnProperty = function hasAnyOwnProperty(o) {\n        for (let p in o)\n            if (o.hasOwnProperty(p))\n                return true;\n        return false\n    }\n    ;\n    C3.PromiseAllWithProgress = function PromiseAllWithProgress(arr, progressCallback) {\n        if (!arr.length)\n            return Promise.resolve([]);\n        return new Promise( (resolve, reject) => {\n            const results = [];\n            let numberCompleted = 0;\n            let cancelled = false;\n            for (let i = 0, len = arr.length; i < len; ++i) {\n                results.push(void 0);\n                arr[i].then(result => {\n                    if (cancelled)\n                        return;\n                    results[i] = result;\n                    ++numberCompleted;\n                    if (numberCompleted === arr.length)\n                        resolve(results);\n                    else\n                        progressCallback(numberCompleted, arr.length)\n                }\n                ).catch(err => {\n                    cancelled = true;\n                    reject(err)\n                }\n                )\n            }\n        }\n        )\n    }\n    ;\n    let memoryCallbacks = [];\n    C3.AddLibraryMemoryCallback = function AddLibraryMemoryCallback(f) {\n        memoryCallbacks.push(f)\n    }\n    ;\n    C3.GetEstimatedLibraryMemoryUsage = function GetEstimatedLibraryMemoryUsage() {\n        let ret = 0;\n        for (let f of memoryCallbacks) {\n            let m = f();\n            ret += m\n        }\n        return Math.floor(ret)\n    }\n    ;\n    let nextTaskId = 1;\n    const activeTaskIds = new Map;\n    const taskMessageChannel = new MessageChannel;\n    taskMessageChannel.port2.onmessage = function OnTask(e) {\n        const id = e.data;\n        const callback = activeTaskIds.get(id);\n        activeTaskIds.delete(id);\n        if (callback)\n            callback(performance.now())\n    }\n    ;\n    C3.RequestUnlimitedAnimationFrame = function RequestUnlimitedAnimationFrame(callback) {\n        const id = nextTaskId++;\n        activeTaskIds.set(id, callback);\n        taskMessageChannel.port1.postMessage(id);\n        return id\n    }\n    ;\n    C3.CancelUnlimitedAnimationFrame = function CancelUnlimitedAnimationFrame(id) {\n        activeTaskIds.delete(id)\n    }\n    ;\n    C3.PostTask = C3.RequestUnlimitedAnimationFrame;\n    C3.WaitForNextTask = function WaitForNextTask() {\n        return new Promise(resolve => C3.PostTask(resolve))\n    }\n    ;\n    const activeRPAFids = new Set;\n    C3.RequestPostAnimationFrame = function RequestPostAnimationFrame(callback) {\n        const id = self.requestAnimationFrame(async timestamp => {\n            await C3.WaitForNextTask();\n            if (!activeRPAFids.has(id))\n                return;\n            activeRPAFids.delete(id);\n            callback(timestamp)\n        }\n        );\n        activeRPAFids.add(id);\n        return id\n    }\n    ;\n    C3.CancelPostAnimationFrame = function CancelPostAnimationFrame(id) {\n        if (!activeRPAFids.has(id))\n            return;\n        self.cancelAnimationFrame(id);\n        activeRPAFids.delete(id)\n    }\n    ;\n\n}\n\n\/\/ lib\/misc\/runtimeutil.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.IsAbsoluteURL = function IsAbsoluteURL(url) {\n        return \/^(?:[a-z\\-]+:)?\\\/\\\/\/.test(url) || url.substr(0, 5) === "data:" || url.substr(0, 5) === "blob:"\n    }\n    ;\n    C3.IsRelativeURL = function IsRelativeURL(url) {\n        return !C3.IsAbsoluteURL(url)\n    }\n    ;\n    C3.ThrowIfNotOk = function ThrowIfNotOk(response) {\n        if (!response.ok)\n            throw new Error(`fetch \'${response.url}\' response returned ${response.status} ${response.statusText}`);\n    }\n    ;\n    C3.FetchOk = function FetchOk(url, init) {\n        return fetch(url, init).then(response => {\n            C3.ThrowIfNotOk(response);\n            return response\n        }\n        )\n    }\n    ;\n    C3.FetchText = function FetchText(url) {\n        return C3.FetchOk(url).then(response => response.text())\n    }\n    ;\n    C3.FetchJson = function FetchJson(url) {\n        return C3.FetchOk(url).then(response => response.json())\n    }\n    ;\n    C3.FetchBlob = function FetchBlob(url) {\n        return C3.FetchOk(url).then(response => response.blob())\n    }\n    ;\n    C3.FetchArrayBuffer = function FetchArrayBuffer(url) {\n        return C3.FetchOk(url).then(response => response.arrayBuffer())\n    }\n    ;\n    C3.FetchImage = function FetchImage(url) {\n        return new Promise( (resolve, reject) => {\n            const img = new Image;\n            img.onload = () => resolve(img);\n            img.onerror = err => reject(err);\n            img.src = url\n        }\n        )\n    }\n    ;\n    C3.BlobToArrayBuffer = function BlobToArrayBuffer(blob) {\n        if (typeof blob["arrayBuffer"] === "function")\n            return blob["arrayBuffer"]();\n        else\n            return new Promise( (resolve, reject) => {\n                const fileReader = new FileReader;\n                fileReader.onload = () => resolve(fileReader.result);\n                fileReader.onerror = () => reject(fileReader.error);\n                fileReader.readAsArrayBuffer(blob)\n            }\n            )\n    }\n    ;\n    C3.BlobToString = function BlobToString(blob) {\n        if (typeof blob["text"] === "function")\n            return blob["text"]();\n        else\n            return new Promise( (resolve, reject) => {\n                const fileReader = new FileReader;\n                fileReader.onload = () => resolve(fileReader.result);\n                fileReader.onerror = () => reject(fileReader.error);\n                fileReader.readAsText(blob)\n            }\n            )\n    }\n    ;\n    C3.BlobToJson = function BlobToJson(blob) {\n        return C3.BlobToString(blob).then(text => JSON.parse(text))\n    }\n    ;\n    C3.BlobToImage = async function BlobToImage(blob, decodeImage) {\n        let blobUrl = URL.createObjectURL(blob);\n        try {\n            const img = await C3.FetchImage(blobUrl);\n            URL.revokeObjectURL(blobUrl);\n            blobUrl = "";\n            if (decodeImage && typeof img["decode"] === "function")\n                await img["decode"]();\n            return img\n        } finally {\n            if (blobUrl)\n                URL.revokeObjectURL(blobUrl)\n        }\n    }\n    ;\n    C3.CreateCanvas = function CreateCanvas(width, height) {\n        if (typeof document !== "undefined" && typeof document.createElement === "function") {\n            const canvas = document.createElement("canvas");\n            canvas.width = width;\n            canvas.height = height;\n            return canvas\n        } else\n            return new OffscreenCanvas(width,height)\n    }\n    ;\n    C3.CanvasToBlob = function CanvasToBlob(canvas, type, quality) {\n        if (typeof quality !== "number")\n            quality = 1;\n        type = type || "image\/png";\n        quality = C3.clamp(quality, 0, 1);\n        if (canvas.toBlob)\n            return new Promise(resolve => canvas.toBlob(resolve, type, quality));\n        else if (canvas["convertToBlob"])\n            return canvas["convertToBlob"]({\n                "type": type,\n                "quality": quality\n            });\n        else\n            return C3.Asyncify( () => C3.CanvasToBlobSync(canvas, type, quality))\n    }\n    ;\n    C3.CanvasToBlobSync = function CanvasToBlobSync(canvas, type, quality) {\n        if (typeof quality !== "number")\n            quality = 1;\n        type = type || "image\/png";\n        quality = C3.clamp(quality, 0, 1);\n        return C3.DataURIToBinaryBlobSync(canvas.toDataURL(type, quality))\n    }\n    ;\n    C3.DataURIToBinaryBlobSync = function DataURIToBinaryBlobSync(datauri) {\n        const o = C3.ParseDataURI(datauri);\n        return C3.BinaryStringToBlob(o.data, o.mime_type)\n    }\n    ;\n    C3.ParseDataURI = function ParseDataURI(datauri) {\n        if (datauri.substr(0, 5) !== "data:")\n            throw new URIError("expected data: uri");\n        let comma = datauri.indexOf(",");\n        if (comma < 0)\n            throw new URIError("expected comma in data: uri");\n        let typepart = datauri.substring(5, comma);\n        let datapart = datauri.substring(comma + 1);\n        let typearr = typepart.split(";");\n        let mimetype = typearr[0] || "";\n        let encoding1 = typearr[1];\n        let encoding2 = typearr[2];\n        let decodeddata;\n        if (encoding1 === "base64" || encoding2 === "base64")\n            decodeddata = atob(datapart);\n        else\n            decodeddata = decodeURIComponent(datapart);\n        return {\n            mime_type: mimetype,\n            data: decodeddata\n        }\n    }\n    ;\n    C3.BinaryStringToBlob = function BinaryStringToBlob(binstr, mime_type) {\n        let len = binstr.length;\n        let len32 = len >> 2;\n        let a8 = new Uint8Array(len);\n        let a32 = new Uint32Array(a8.buffer,0,len32);\n        let i, j;\n        for (i = 0,\n        j = 0; i < len32; ++i)\n            a32[i] = binstr.charCodeAt(j++) | binstr.charCodeAt(j++) << 8 | binstr.charCodeAt(j++) << 16 | binstr.charCodeAt(j++) << 24;\n        let tailLength = len & 3;\n        while (tailLength--) {\n            a8[j] = binstr.charCodeAt(j);\n            ++j\n        }\n        if (mime_type)\n            return new Blob([a8],{\n                "type": mime_type\n            });\n        else\n            return new Blob([a8])\n    }\n    ;\n    C3.DrawableToBlob = function DrawableToBlob(drawable, type, quality) {\n        const canvas = C3.CreateCanvas(drawable.width, drawable.height);\n        const ctx = canvas.getContext("2d");\n        ctx.drawImage(drawable, 0, 0);\n        return C3.CanvasToBlob(canvas, type, quality)\n    }\n    ;\n    C3.ImageDataToBlobSync = function ImageDataToBlobSync(imageData, type, quality) {\n        const canvas = C3.CreateCanvas(imageData.width, imageData.height);\n        const ctx = canvas.getContext("2d");\n        ctx.putImageData(imageData, 0, 0);\n        return C3.CanvasToBlobSync(canvas, type, quality)\n    }\n    ;\n    C3.ImageDataToBlob = function ImageDataToBlob(imageData, type, quality) {\n        if (C3.Supports.ImageBitmapOptions)\n            return createImageBitmap(imageData, {\n                "premultiplyAlpha": "none"\n            }).then(imageBitmap => C3.DrawableToBlob(imageBitmap, type, quality));\n        else if (C3.Supports.ImageBitmap)\n            return createImageBitmap(imageData).then(imageBitmap => C3.DrawableToBlob(imageBitmap, type, quality));\n        else {\n            const canvas = C3.CreateCanvas(imageData.width, imageData.height);\n            const ctx = canvas.getContext("2d");\n            ctx.putImageData(imageData, 0, 0);\n            return C3.CanvasToBlob(canvas, type, quality)\n        }\n    }\n    ;\n    C3.CopySet = function CopySet(dest, src) {\n        dest.clear();\n        for (const x of src)\n            dest.add(x)\n    }\n    ;\n    C3.MapToObject = function MapToObject(map) {\n        const ret = Object.create(null);\n        for (const [k,v] of map.entries())\n            ret[k] = v;\n        return ret\n    }\n    ;\n    C3.ObjectToMap = function ObjectToMap(o, map) {\n        map.clear();\n        for (const [k,v] of Object.entries(o))\n            map.set(k, v)\n    }\n    ;\n    C3.ToSuperJSON = function ToSuperJSON(v) {\n        if (typeof v === "object" && v !== null)\n            if (v instanceof Set)\n                return {\n                    "_c3type_": "set",\n                    "data": [...v].map(o => ToSuperJSON(o))\n                };\n            else if (v instanceof Map)\n                return {\n                    "_c3type_": "map",\n                    "data": [...v].map(pair => [pair[0], ToSuperJSON(pair[1])])\n                };\n            else {\n                const ret = Object.create(null);\n                for (const [key,value] of Object.entries(v))\n                    ret[key] = ToSuperJSON(value);\n                return ret\n            }\n        return v\n    }\n    ;\n    C3.FromSuperJSON = function FromSuperJSON(v) {\n        if (typeof v === "object" & v !== null)\n            if (v["_c3type_"] === "set")\n                return new Set(v["data"].map(o => FromSuperJSON(o)));\n            else if (v["_c3type_"] === "map")\n                return new Map(v["data"].map(pair => [pair[0], FromSuperJSON(pair[1])]));\n            else {\n                const ret = Object.create(null);\n                for (const [key,value] of Object.entries(v))\n                    ret[key] = FromSuperJSON(value);\n                return ret\n            }\n        return v\n    }\n    ;\n    C3.CSSToCamelCase = function(str) {\n        let ret = "";\n        let isAfterHyphen = false;\n        for (const ch of str)\n            if (ch === "-")\n                isAfterHyphen = true;\n            else if (isAfterHyphen) {\n                ret += ch.toUpperCase();\n                isAfterHyphen = false\n            } else\n                ret += ch;\n        return ret\n    }\n    ;\n    C3.IsIterator = function(o) {\n        return typeof o === "object" && typeof o.next === "function"\n    }\n    ;\n    C3.MakeFilledArray = function MakeFilledArray(len, data) {\n        const ret = [];\n        if (typeof data === "function")\n            for (let i = 0; i < len; ++i)\n                ret.push(data());\n        else\n            for (let i = 0; i < len; ++i)\n                ret.push(data);\n        return ret\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/misc\/color.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const HSL_TEST = \/([0-9.]+),([0-9.]+)%?,([0-9.]+)%?\/i;\n    const HSLA_TEST = \/([0-9.]+),([0-9.]+)%?,([0-9.]+)%?,([0-9.])\/i;\n    function padTwoDigits(str) {\n        if (str.length === 0)\n            return "00";\n        else if (str.length === 1)\n            return "0" + str;\n        else\n            return str\n    }\n    function hueToRGB(p, q, t) {\n        if (t < 0)\n            t += 1;\n        if (t > 1)\n            t -= 1;\n        if (t < 1 \/ 6)\n            return p + (q - p) * 6 * t;\n        if (t < 1 \/ 2)\n            return q;\n        if (t < 2 \/ 3)\n            return p + (q - p) * (2 \/ 3 - t) * 6;\n        return p\n    }\n    C3.Color = class Color {\n        constructor(r, g, b, a) {\n            this._r = NaN;\n            this._g = NaN;\n            this._b = NaN;\n            this._a = NaN;\n            this._r = 0;\n            this._g = 0;\n            this._b = 0;\n            this._a = 0;\n            if (r instanceof C3.Color)\n                this.set(r);\n            else\n                this.setRgba(r || 0, g || 0, b || 0, a || 0)\n        }\n        setRgb(r, g, b) {\n            this._r = +r;\n            this._g = +g;\n            this._b = +b;\n            this.clamp();\n            return this\n        }\n        setRgba(r, g, b, a) {\n            this._r = +r;\n            this._g = +g;\n            this._b = +b;\n            this._a = +a;\n            this.clamp();\n            return this\n        }\n        set(c) {\n            this._r = c._r;\n            this._g = c._g;\n            this._b = c._b;\n            this._a = c._a;\n            return this\n        }\n        copy(c) {\n            return this.set(c)\n        }\n        add(c) {\n            this._r += c._r;\n            this._g += c._g;\n            this._b += c._b;\n            this._a += c._a;\n            this.clamp()\n        }\n        addRgb(r, g, b, a=0) {\n            this._r += +r;\n            this._g += +g;\n            this._b += +b;\n            this._a += +a;\n            this.clamp()\n        }\n        diff(c) {\n            this.setR(Math.max(this._r, c._r) - Math.min(this._r, c._r));\n            this.setG(Math.max(this._g, c._g) - Math.min(this._g, c._g));\n            this.setB(Math.max(this._b, c._b) - Math.min(this._b, c._b));\n            this.setA(Math.max(this._a, c._a) - Math.min(this._a, c._a));\n            this.clamp()\n        }\n        copyRgb(c) {\n            this._r = c._r;\n            this._g = c._g;\n            this._b = c._b\n        }\n        setR(r) {\n            this._r = C3.clamp(+r, 0, 1)\n        }\n        getR() {\n            return this._r\n        }\n        setG(g) {\n            this._g = C3.clamp(+g, 0, 1)\n        }\n        getG() {\n            return this._g\n        }\n        setB(b) {\n            this._b = C3.clamp(+b, 0, 1)\n        }\n        getB() {\n            return this._b\n        }\n        setA(a) {\n            this._a = C3.clamp(+a, 0, 1)\n        }\n        getA() {\n            return this._a\n        }\n        clone() {\n            return C3.New(C3.Color, this._r, this._g, this._b, this._a)\n        }\n        toArray() {\n            return [this._r, this._g, this._b, this._a]\n        }\n        toTypedArray() {\n            return new Float64Array(this.toArray())\n        }\n        writeToTypedArray(ta, i) {\n            ta[i++] = this._r;\n            ta[i++] = this._g;\n            ta[i++] = this._b;\n            ta[i] = this._a\n        }\n        writeRGBToTypedArray(ta, i) {\n            ta[i++] = this._r;\n            ta[i++] = this._g;\n            ta[i] = this._b\n        }\n        equals(c) {\n            return this._r === c._r && this._g === c._g && this._b === c._b && this._a === c._a\n        }\n        equalsIgnoringAlpha(c) {\n            return this._r === c._r && this._g === c._g && this._b === c._b\n        }\n        equalsRgb(r, g, b) {\n            return this._r === r && this._g === g && this._b === b\n        }\n        equalsRgba(r, g, b, a) {\n            return this._r === r && this._g === g && this._b === b && this._a === a\n        }\n        equalsF32Array(arr, offset) {\n            return arr[offset] === Math.fround(this._r) && arr[offset + 1] === Math.fround(this._g) && arr[offset + 2] === Math.fround(this._b) && arr[offset + 3] === Math.fround(this._a)\n        }\n        equalsRGBF32Array(arr, offset) {\n            return arr[offset] === Math.fround(this._r) && arr[offset + 1] === Math.fround(this._g) && arr[offset + 2] === Math.fround(this._b)\n        }\n        multiply(c) {\n            this._r *= c._r;\n            this._g *= c._g;\n            this._b *= c._b;\n            this._a *= c._a\n        }\n        multiplyAlpha(a) {\n            this._r *= a;\n            this._g *= a;\n            this._b *= a;\n            this._a *= a\n        }\n        premultiply() {\n            this._r *= this._a;\n            this._g *= this._a;\n            this._b *= this._a;\n            return this\n        }\n        unpremultiply() {\n            this._r \/= this._a;\n            this._g \/= this._a;\n            this._b \/= this._a;\n            return this\n        }\n        clamp() {\n            this._r = C3.clamp(this._r, 0, 1);\n            this._g = C3.clamp(this._g, 0, 1);\n            this._b = C3.clamp(this._b, 0, 1);\n            this._a = C3.clamp(this._a, 0, 1);\n            return this\n        }\n        setFromRgbValue(rgb) {\n            this._r = C3.GetRValue(rgb);\n            this._g = C3.GetGValue(rgb);\n            this._b = C3.GetBValue(rgb);\n            this._a = C3.GetAValue(rgb)\n        }\n        getCssRgb(_r, _g, _b) {\n            const r = C3.IsFiniteNumber(_r) ? _r : this.getR();\n            const g = C3.IsFiniteNumber(_g) ? _g : this.getG();\n            const b = C3.IsFiniteNumber(_b) ? _b : this.getB();\n            return `rgb(${r * 100}%, ${g * 100}%, ${b * 100}%)`\n        }\n        getCssRgba(_r, _g, _b, _a) {\n            const r = C3.IsFiniteNumber(_r) ? _r : this.getR();\n            const g = C3.IsFiniteNumber(_g) ? _g : this.getG();\n            const b = C3.IsFiniteNumber(_b) ? _b : this.getB();\n            const a = C3.IsFiniteNumber(_a) ? _a : this.getA();\n            return `rgba(${r * 100}%, ${g * 100}%, ${b * 100}%, ${a})`\n        }\n        toHexString() {\n            const rh = Math.round(this.getR() * 255);\n            const gh = Math.round(this.getG() * 255);\n            const bh = Math.round(this.getB() * 255);\n            return "#" + padTwoDigits(rh.toString(16)) + padTwoDigits(gh.toString(16)) + padTwoDigits(bh.toString(16))\n        }\n        parseHexString(str) {\n            if (typeof str !== "string")\n                return false;\n            str = str.trim();\n            if (str.charAt(0) === "#")\n                str = str.substr(1);\n            let rv;\n            let gv;\n            let bv;\n            if (str.length === 3) {\n                rv = parseInt(str[0], 16) \/ 15;\n                gv = parseInt(str[1], 16) \/ 15;\n                bv = parseInt(str[2], 16) \/ 15\n            } else if (str.length === 6) {\n                rv = parseInt(str.substr(0, 2), 16) \/ 255;\n                gv = parseInt(str.substr(2, 2), 16) \/ 255;\n                bv = parseInt(str.substr(4, 2), 16) \/ 255\n            } else\n                return false;\n            if (isFinite(rv))\n                this.setR(rv);\n            if (isFinite(gv))\n                this.setG(gv);\n            if (isFinite(bv))\n                this.setB(bv);\n            this.setA(1);\n            return true\n        }\n        toCommaSeparatedRgb() {\n            const rv = Math.round(this.getR() * 255);\n            const gv = Math.round(this.getG() * 255);\n            const bv = Math.round(this.getB() * 255);\n            return `${rv}, ${gv}, ${bv}`\n        }\n        toRgbArray() {\n            const rv = Math.round(this.getR() * 255);\n            const gv = Math.round(this.getG() * 255);\n            const bv = Math.round(this.getB() * 255);\n            return [rv, gv, bv]\n        }\n        parseCommaSeparatedRgb(str) {\n            if (typeof str !== "string")\n                return false;\n            str = str.replace(\/^rgb\\(|\\)|%\/, "");\n            const arr = str.split(",");\n            if (arr.length < 3)\n                return false;\n            const rv = parseInt(arr[0].trim(), 10) \/ 255;\n            const gv = parseInt(arr[1].trim(), 10) \/ 255;\n            const bv = parseInt(arr[2].trim(), 10) \/ 255;\n            if (isFinite(rv))\n                this.setR(rv);\n            if (isFinite(gv))\n                this.setG(gv);\n            if (isFinite(bv))\n                this.setB(bv);\n            this.setA(1);\n            return true\n        }\n        parseCommaSeparatedPercentageRgb(str) {\n            if (typeof str !== "string")\n                return false;\n            str = str.replace(\/^rgb\\(|\\)|%\/, "");\n            const arr = str.split(",");\n            if (arr.length < 3)\n                return false;\n            const rv = parseInt(arr[0].trim(), 10) \/ 100;\n            const gv = parseInt(arr[1].trim(), 10) \/ 100;\n            const bv = parseInt(arr[2].trim(), 10) \/ 100;\n            if (isFinite(rv))\n                this.setR(rv);\n            if (isFinite(gv))\n                this.setG(gv);\n            if (isFinite(bv))\n                this.setB(bv);\n            this.setA(1);\n            return true\n        }\n        parseCommaSeparatedRgba(str) {\n            if (typeof str !== "string")\n                return false;\n            str = str.replace(\/^rgba\\(|\\)|%\/, "");\n            const arr = str.split(",");\n            if (arr.length < 4)\n                return false;\n            const rv = parseInt(arr[0].trim(), 10) \/ 255;\n            const gv = parseInt(arr[1].trim(), 10) \/ 255;\n            const bv = parseInt(arr[2].trim(), 10) \/ 255;\n            const av = parseFloat(arr[3].trim());\n            if (isFinite(rv))\n                this.setR(rv);\n            if (isFinite(gv))\n                this.setG(gv);\n            if (isFinite(bv))\n                this.setB(bv);\n            if (isFinite(av))\n                this.setA(av);\n            return true\n        }\n        parseCommaSeparatedPercentageRgba(str) {\n            if (typeof str !== "string")\n                return false;\n            str = str.replace(\/^rgba\\(|\\)|%\/, "");\n            const arr = str.split(",");\n            if (arr.length < 4)\n                return false;\n            const rv = parseInt(arr[0].trim(), 10) \/ 100;\n            const gv = parseInt(arr[1].trim(), 10) \/ 100;\n            const bv = parseInt(arr[2].trim(), 10) \/ 100;\n            const av = parseFloat(arr[3].trim());\n            if (isFinite(rv))\n                this.setR(rv);\n            if (isFinite(gv))\n                this.setG(gv);\n            if (isFinite(bv))\n                this.setB(bv);\n            if (isFinite(av))\n                this.setA(av);\n            return true\n        }\n        parseString(str) {\n            if (typeof str !== "string")\n                return false;\n            str = str.replace(\/\\s+\/, "");\n            if (str.includes(","))\n                if (str.startsWith("rgb("))\n                    if (str.includes("%"))\n                        return this.parseCommaSeparatedPercentageRgb(str);\n                    else\n                        return this.parseCommaSeparatedRgb(str);\n                else if (str.startsWith("rgba("))\n                    if (str.includes("%"))\n                        return this.parseCommaSeparatedPercentageRgba(str);\n                    else\n                        return this.parseCommaSeparatedRgba(str);\n                else if (str.startsWith("hsl(") || str.startsWith("hsla("))\n                    return this.parseHSLString(str);\n                else {\n                    const components = str.split(",");\n                    if (str.includes("%")) {\n                        if (components.length === 3)\n                            return this.parseCommaSeparatedPercentageRgb(str);\n                        else if (components.length === 4)\n                            return this.parseCommaSeparatedPercentageRgba(str);\n                        return false\n                    } else {\n                        if (components.length === 3)\n                            return this.parseCommaSeparatedRgb(str);\n                        else if (components.length === 4)\n                            return this.parseCommaSeparatedRgba(str);\n                        return false\n                    }\n                }\n            else\n                return this.parseHexString(str)\n        }\n        toJSON() {\n            return [this._r, this._g, this._b, this._a]\n        }\n        setFromHSLA(h, s, l, a) {\n            let r;\n            let g;\n            let b;\n            h %= 360;\n            s = C3.clamp(s, 0, 100);\n            l = C3.clamp(l, 0, 100);\n            a = C3.clamp(a, 0, 1);\n            h \/= 360;\n            s \/= 100;\n            l \/= 100;\n            if (s === 0)\n                r = g = b = l;\n            else {\n                const q = l < .5 ? l * (1 + s) : l + s - l * s;\n                const p = 2 * l - q;\n                r = hueToRGB(p, q, h + 1 \/ 3);\n                g = hueToRGB(p, q, h);\n                b = hueToRGB(p, q, h - 1 \/ 3)\n            }\n            this.setR(r);\n            this.setG(g);\n            this.setB(b);\n            this.setA(a);\n            return this\n        }\n        parseHSLString(str) {\n            const cleanString = str.replace(\/ |hsl|hsla|\\(|\\)|;\/gi, "");\n            const hsl = HSL_TEST.exec(cleanString);\n            const hsla = HSLA_TEST.exec(cleanString);\n            if (hsl && hsl.length === 4) {\n                this.setFromHSLA(+hsl[1], +hsl[2], +hsl[3], 1);\n                return true\n            } else if (hsla && hsla.length === 5) {\n                this.setFromHSLA(+hsl[1], +hsl[2], +hsl[3], +hsl[4]);\n                return true\n            }\n            return false\n        }\n        toHSLAString() {\n            const r = this._r;\n            const g = this._g;\n            const b = this._b;\n            const a = this._a;\n            const h = C3.Color.GetHue(r, g, b);\n            const s = C3.Color.GetSaturation(r, g, b);\n            const l = C3.Color.GetLuminosity(r, g, b);\n            return `hsla(${h}, ${s}%, ${l}%, ${a})`\n        }\n        toHSLAArray() {\n            const r = this._r;\n            const g = this._g;\n            const b = this._b;\n            return [C3.Color.GetHue(r, g, b), C3.Color.GetSaturation(r, g, b), C3.Color.GetLuminosity(r, g, b), this._a]\n        }\n        setFromJSON(arr) {\n            if (!Array.isArray(arr))\n                return;\n            if (arr.length < 3)\n                return;\n            this._r = arr[0];\n            this._g = arr[1];\n            this._b = arr[2];\n            if (arr.length >= 4)\n                this._a = arr[3];\n            else\n                this._a = 1\n        }\n        set r(r) {\n            this.setR(r)\n        }\n        get r() {\n            return this.getR()\n        }\n        set g(g) {\n            this.setG(g)\n        }\n        get g() {\n            return this.getG()\n        }\n        set b(b) {\n            this.setB(b)\n        }\n        get b() {\n            return this.getB()\n        }\n        set a(a) {\n            this.setA(a)\n        }\n        get a() {\n            return this.getA()\n        }\n        setAtIndex(i, v) {\n            switch (i) {\n            case 0:\n                this.setR(v);\n                break;\n            case 1:\n                this.setG(v);\n                break;\n            case 2:\n                this.setB(v);\n                break;\n            case 3:\n                this.setA(v);\n                break;\n            default:\n                throw new RangeError("invalid color index");\n            }\n        }\n        getAtIndex(i) {\n            switch (i) {\n            case 0:\n                return this.getR();\n            case 1:\n                return this.getG();\n            case 2:\n                return this.getB();\n            case 3:\n                return this.getA();\n            default:\n                throw new RangeError("invalid color index");\n            }\n        }\n        static Equals(color_or_json_1, color_or_json_2) {\n            let c1;\n            let c2;\n            if (Array.isArray(color_or_json_1)) {\n                c1 = new C3.Color;\n                c1.setFromJSON(color_or_json_1)\n            } else if (color_or_json_1 instanceof C3.Color)\n                c1 = color_or_json_1;\n            else\n                throw new Error("unexpected type");\n            if (Array.isArray(color_or_json_2)) {\n                c2 = new C3.Color;\n                c2.setFromJSON(color_or_json_2)\n            } else if (color_or_json_2 instanceof C3.Color)\n                c2 = color_or_json_2;\n            else\n                throw new Error("unexpected type");\n            return c1.equals(c2)\n        }\n        static DiffChannel(channel1, channel2) {\n            return C3.clamp(Math.max(channel1, channel2) - Math.min(channel1, channel2), 0, 1)\n        }\n        static Diff(c1, c2) {\n            const ret = new C3.Color;\n            ret.setR(Math.max(c1._r, c2._r) - Math.min(c1._r, c2._r));\n            ret.setG(Math.max(c1._g, c2._g) - Math.min(c1._g, c2._g));\n            ret.setB(Math.max(c1._b, c2._b) - Math.min(c1._b, c2._b));\n            ret.setA(Math.max(c1._a, c2._a) - Math.min(c1._a, c2._a));\n            return ret\n        }\n        static DiffNoAlpha(c1, c2) {\n            const ret = new C3.Color(0,0,0,1);\n            ret.setR(Math.max(c1._r, c2._r) - Math.min(c1._r, c2._r));\n            ret.setG(Math.max(c1._g, c2._g) - Math.min(c1._g, c2._g));\n            ret.setB(Math.max(c1._b, c2._b) - Math.min(c1._b, c2._b));\n            return ret\n        }\n        static GetHue(r, g, b) {\n            const max = Math.max(r, g, b);\n            const min = Math.min(r, g, b);\n            if (max === min)\n                return 0;\n            let h = 0;\n            switch (max) {\n            case r:\n                h = (g - b) \/ (max - min) + (g < b ? 6 : 0);\n                break;\n            case g:\n                h = (b - r) \/ (max - min) + 2;\n                break;\n            case b:\n                h = (r - g) \/ (max - min) + 4;\n                break\n            }\n            return Math.round(h \/ 6 * 360)\n        }\n        static GetSaturation(r, g, b) {\n            const max = Math.max(r, g, b);\n            const min = Math.min(r, g, b);\n            if (max === min)\n                return 0;\n            const l = (max + min) \/ 2;\n            const d = max - min;\n            const s = l > .5 ? d \/ (2 - max - min) : d \/ (max + min);\n            return Math.round(s * 100)\n        }\n        static GetLuminosity(r, g, b) {\n            const max = Math.max(r, g, b);\n            const min = Math.min(r, g, b);\n            const l = (max + min) \/ 2;\n            if (!max)\n                return 0;\n            return Math.round(l * 100)\n        }\n    }\n    ;\n    C3.Color.White = Object.freeze(C3.New(C3.Color, 1, 1, 1, 1));\n    C3.Color.Black = Object.freeze(C3.New(C3.Color, 0, 0, 0, 1));\n    C3.Color.TransparentBlack = Object.freeze(C3.New(C3.Color, 0, 0, 0, 0));\n\n}\n\n\/\/ ..\/lib\/misc\/vector2.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Vector2 = class Vector2 {\n        constructor(x, y) {\n            this._x = 0;\n            this._y = 0;\n            if (x instanceof C3.Vector2)\n                this.copy(x);\n            else\n                this.set(x || 0, y || 0)\n        }\n        set(x, y) {\n            this._x = +x;\n            this._y = +y\n        }\n        copy(v) {\n            this._x = v._x;\n            this._y = v._y\n        }\n        equals(v) {\n            return this._x === v._x && this._y === v._y\n        }\n        equalsValues(x, y) {\n            return this._x === x && this._y === y\n        }\n        equalsF32Array(arr, offset) {\n            return arr[offset] === Math.fround(this._x) && arr[offset + 1] === Math.fround(this._y)\n        }\n        setX(x) {\n            this._x = +x\n        }\n        getX() {\n            return this._x\n        }\n        setY(y) {\n            this._y = +y\n        }\n        getY() {\n            return this._y\n        }\n        toArray() {\n            return [this._x, this._y]\n        }\n        toTypedArray() {\n            return new Float64Array(this.toArray())\n        }\n        writeToTypedArray(ta, i) {\n            ta[i++] = this._x;\n            ta[i] = this._y\n        }\n        offset(x, y) {\n            this._x += +x;\n            this._y += +y\n        }\n        scale(x, y) {\n            this._x *= x;\n            this._y *= y\n        }\n        divide(x, y) {\n            this._x \/= x;\n            this._y \/= y\n        }\n        round() {\n            this._x = Math.round(this._x);\n            this._y = Math.round(this._y)\n        }\n        floor() {\n            this._x = Math.floor(this._x);\n            this._y = Math.floor(this._y)\n        }\n        ceil() {\n            this._x = Math.ceil(this._x);\n            this._y = Math.ceil(this._y)\n        }\n        angle() {\n            return C3.angleTo(0, 0, this._x, this._y)\n        }\n        lengthSquared() {\n            return this._x * this._x + this._y * this._y\n        }\n        length() {\n            return Math.sqrt(this.lengthSquared())\n        }\n        rotatePrecalc(sin_a, cos_a) {\n            const temp = this._x * cos_a - this._y * sin_a;\n            this._y = this._y * cos_a + this._x * sin_a;\n            this._x = temp\n        }\n        rotate(a) {\n            if (a === 0)\n                return;\n            this.rotatePrecalc(Math.sin(a), Math.cos(a))\n        }\n        rotateAbout(a, x, y) {\n            if (a === 0 || x === this._x && y === this._y)\n                return;\n            this._x -= x;\n            this._y -= y;\n            this.rotatePrecalc(Math.sin(a), Math.cos(a));\n            this._x += +x;\n            this._y += +y\n        }\n        move(a, dist) {\n            if (dist === 0)\n                return;\n            this._x += Math.cos(a) * dist;\n            this._y += Math.sin(a) * dist\n        }\n        normalize() {\n            const m = this.length();\n            if (m !== 0 && m !== 1) {\n                this._x \/= m;\n                this._y \/= m\n            }\n        }\n        clamp(lower, upper) {\n            this._x = C3.clamp(this._x, lower, upper);\n            this._y = C3.clamp(this._y, lower, upper)\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/misc\/rect.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Rect = class Rect {\n        constructor(left, top, right, bottom) {\n            this._left = NaN;\n            this._top = NaN;\n            this._right = NaN;\n            this._bottom = NaN;\n            this._left = 0;\n            this._top = 0;\n            this._right = 0;\n            this._bottom = 0;\n            if (left instanceof C3.Rect)\n                this.copy(left);\n            else\n                this.set(left || 0, top || 0, right || 0, bottom || 0)\n        }\n        set(left, top, right, bottom) {\n            this._left = +left;\n            this._top = +top;\n            this._right = +right;\n            this._bottom = +bottom\n        }\n        setWH(left, top, width, height) {\n            left = +left;\n            top = +top;\n            this._left = left;\n            this._top = top;\n            this._right = left + +width;\n            this._bottom = top + +height\n        }\n        copy(rect) {\n            this._left = +rect._left;\n            this._top = +rect._top;\n            this._right = +rect._right;\n            this._bottom = +rect._bottom\n        }\n        clone() {\n            return new C3.Rect(this._left,this._top,this._right,this._bottom)\n        }\n        static Merge(first, second) {\n            const ret = new C3.Rect;\n            ret.setLeft(Math.min(first._left, second._left));\n            ret.setTop(Math.min(first._top, second._top));\n            ret.setRight(Math.max(first._right, second._right));\n            ret.setBottom(Math.max(first._bottom, second._bottom));\n            return ret\n        }\n        static FromObject(o) {\n            return new C3.Rect(o.left,o.top,o.right,o.bottom)\n        }\n        equals(rect) {\n            return this._left === rect._left && this._top === rect._top && this._right === rect._right && this._bottom === rect._bottom\n        }\n        equalsWH(x, y, w, h) {\n            return this._left === x && this._top === y && this.width() === w && this.height() === h\n        }\n        equalsF32Array(arr, offset) {\n            return arr[offset] === Math.fround(this._left) && arr[offset + 1] === Math.fround(this._top) && arr[offset + 2] === Math.fround(this._right) && arr[offset + 3] === Math.fround(this._bottom)\n        }\n        setLeft(l) {\n            this._left = +l\n        }\n        getLeft() {\n            return this._left\n        }\n        setTop(t) {\n            this._top = +t\n        }\n        getTop() {\n            return this._top\n        }\n        setRight(r) {\n            this._right = +r\n        }\n        getRight() {\n            return this._right\n        }\n        setBottom(b) {\n            this._bottom = +b\n        }\n        getBottom() {\n            return this._bottom\n        }\n        toArray() {\n            return [this._left, this._top, this._right, this._bottom]\n        }\n        toTypedArray() {\n            return new Float64Array(this.toArray())\n        }\n        toDOMRect() {\n            return new DOMRect(this._left,this._top,this.width(),this.height())\n        }\n        writeToTypedArray(ta, i) {\n            ta[i++] = this._left;\n            ta[i++] = this._top;\n            ta[i++] = this._right;\n            ta[i] = this._bottom\n        }\n        writeAsQuadToTypedArray(ta, i) {\n            ta[i++] = this._left;\n            ta[i++] = this._top;\n            ta[i++] = this._right;\n            ta[i++] = this._top;\n            ta[i++] = this._right;\n            ta[i++] = this._bottom;\n            ta[i++] = this._left;\n            ta[i] = this._bottom\n        }\n        writeAsQuadToTypedArray3D(ta, i, z) {\n            ta[i++] = this._left;\n            ta[i++] = this._top;\n            ta[i++] = z;\n            ta[i++] = this._right;\n            ta[i++] = this._top;\n            ta[i++] = z;\n            ta[i++] = this._right;\n            ta[i++] = this._bottom;\n            ta[i++] = z;\n            ta[i++] = this._left;\n            ta[i++] = this._bottom;\n            ta[i] = z\n        }\n        width() {\n            return this._right - this._left\n        }\n        height() {\n            return this._bottom - this._top\n        }\n        midX() {\n            return (this._left + this._right) \/ 2\n        }\n        midY() {\n            return (this._top + this._bottom) \/ 2\n        }\n        offset(x, y) {\n            x = +x;\n            y = +y;\n            this._left += x;\n            this._top += y;\n            this._right += x;\n            this._bottom += y\n        }\n        offsetLeft(x) {\n            this._left += +x\n        }\n        offsetTop(y) {\n            this._top += +y\n        }\n        offsetRight(x) {\n            this._right += +x\n        }\n        offsetBottom(y) {\n            this._bottom += +y\n        }\n        toSquare(axis) {\n            if (axis !== "x")\n                throw new Error("invalid axis, only \'x\' supported");\n            if (this._top < this._bottom)\n                if (this._left < this._right)\n                    this._bottom = this._top + this.width();\n                else\n                    this._bottom = this._top - this.width();\n            else if (this._left < this._right)\n                this._bottom = this._top - this.width();\n            else\n                this._bottom = this._top + this.width()\n        }\n        inflate(x, y) {\n            x = +x;\n            y = +y;\n            this._left -= x;\n            this._top -= y;\n            this._right += x;\n            this._bottom += y\n        }\n        deflate(x, y) {\n            x = +x;\n            y = +y;\n            this._left += x;\n            this._top += y;\n            this._right -= x;\n            this._bottom -= y\n        }\n        multiply(x, y) {\n            this._left *= x;\n            this._top *= y;\n            this._right *= x;\n            this._bottom *= y\n        }\n        divide(x, y) {\n            this._left \/= x;\n            this._top \/= y;\n            this._right \/= x;\n            this._bottom \/= y\n        }\n        mirrorAround(origin) {\n            this._left = +origin - this._left;\n            this._right = +origin - this._right\n        }\n        flipAround(origin) {\n            this._top = +origin - this._top;\n            this._bottom = +origin - this._bottom\n        }\n        swapLeftRight() {\n            const temp = this._left;\n            this._left = this._right;\n            this._right = temp\n        }\n        swapTopBottom() {\n            const temp = this._top;\n            this._top = this._bottom;\n            this._bottom = temp\n        }\n        shuntY(h) {\n            const top = this._top;\n            this._top = +h - this._bottom;\n            this._bottom = +h - top\n        }\n        round() {\n            this._left = Math.round(this._left);\n            this._top = Math.round(this._top);\n            this._right = Math.round(this._right);\n            this._bottom = Math.round(this._bottom)\n        }\n        roundInner() {\n            this._left = Math.ceil(this._left);\n            this._top = Math.ceil(this._top);\n            this._right = Math.floor(this._right);\n            this._bottom = Math.floor(this._bottom)\n        }\n        roundOuter() {\n            this._left = Math.floor(this._left);\n            this._top = Math.floor(this._top);\n            this._right = Math.ceil(this._right);\n            this._bottom = Math.ceil(this._bottom)\n        }\n        floor() {\n            this._left = Math.floor(this._left);\n            this._top = Math.floor(this._top);\n            this._right = Math.floor(this._right);\n            this._bottom = Math.floor(this._bottom)\n        }\n        ceil() {\n            this._left = Math.ceil(this._left);\n            this._top = Math.ceil(this._top);\n            this._right = Math.ceil(this._right);\n            this._bottom = Math.ceil(this._bottom)\n        }\n        clamp(l, t, r, b) {\n            if (this._left < l)\n                this._left = +l;\n            if (this._top < t)\n                this._top = +t;\n            if (this._right > r)\n                this._right = +r;\n            if (this._bottom > b)\n                this._bottom = +b\n        }\n        clampFlipped(l, t, r, b) {\n            if (this._left < l)\n                this._left = +l;\n            if (this._top > t)\n                this._top = +t;\n            if (this._right > r)\n                this._right = +r;\n            if (this._bottom < b)\n                this._bottom = +b\n        }\n        normalize() {\n            if (this._left > this._right)\n                this.swapLeftRight();\n            if (this._top > this._bottom)\n                this.swapTopBottom()\n        }\n        intersectsRect(rect) {\n            return !(rect._right < this._left || rect._bottom < this._top || rect._left > this._right || rect._top > this._bottom)\n        }\n        intersectsRectOffset(rect, x, y) {\n            return !(rect._right + x < this._left || rect._bottom + y < this._top || rect._left + x > this._right || rect._top + y > this._bottom)\n        }\n        containsPoint(x, y) {\n            return x >= this._left && x <= this._right && y >= this._top && y <= this._bottom\n        }\n        containsRect(rect) {\n            return rect._left >= this._left && rect._top >= this._top && rect._right <= this._right && rect._bottom <= this._bottom\n        }\n        expandToContain(rect) {\n            if (rect._left < this._left)\n                this._left = +rect._left;\n            if (rect._top < this._top)\n                this._top = +rect._top;\n            if (rect._right > this._right)\n                this._right = +rect._right;\n            if (rect._bottom > this._bottom)\n                this._bottom = +rect._bottom\n        }\n        lerpInto(rect) {\n            this._left = C3.lerp(rect._left, rect._right, this._left);\n            this._top = C3.lerp(rect._top, rect._bottom, this._top);\n            this._right = C3.lerp(rect._left, rect._right, this._right);\n            this._bottom = C3.lerp(rect._top, rect._bottom, this._bottom)\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/misc\/quad.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Quad = class Quad {\n        constructor(tlx, tly, trx, try_, brx, bry, blx, bly) {\n            this._tlx = NaN;\n            this._tly = NaN;\n            this._trx = NaN;\n            this._try = NaN;\n            this._brx = NaN;\n            this._bry = NaN;\n            this._blx = NaN;\n            this._bly = NaN;\n            this._tlx = 0;\n            this._tly = 0;\n            this._trx = 0;\n            this._try = 0;\n            this._brx = 0;\n            this._bry = 0;\n            this._blx = 0;\n            this._bly = 0;\n            if (tlx instanceof C3.Quad)\n                this.copy(tlx);\n            else\n                this.set(tlx || 0, tly || 0, trx || 0, try_ || 0, brx || 0, bry || 0, blx || 0, bly || 0)\n        }\n        set(tlx, tly, trx, try_, brx, bry, blx, bly) {\n            this._tlx = +tlx;\n            this._tly = +tly;\n            this._trx = +trx;\n            this._try = +try_;\n            this._brx = +brx;\n            this._bry = +bry;\n            this._blx = +blx;\n            this._bly = +bly\n        }\n        setRect(left, top, right, bottom) {\n            this.set(left, top, right, top, right, bottom, left, bottom)\n        }\n        copy(q) {\n            this._tlx = q._tlx;\n            this._tly = q._tly;\n            this._trx = q._trx;\n            this._try = q._try;\n            this._brx = q._brx;\n            this._bry = q._bry;\n            this._blx = q._blx;\n            this._bly = q._bly\n        }\n        equals(q) {\n            return this._tlx === q._tlx && this._tly === q._tly && this._trx === q._trx && this._try === q._try && this._brx === q._brx && this._bry === q._bry && this._blx === q._blx && this._bly === q._bly\n        }\n        setTlx(v) {\n            this._tlx = +v\n        }\n        getTlx() {\n            return this._tlx\n        }\n        setTly(v) {\n            this._tly = +v\n        }\n        getTly() {\n            return this._tly\n        }\n        setTrx(v) {\n            this._trx = +v\n        }\n        getTrx() {\n            return this._trx\n        }\n        setTry(v) {\n            this._try = +v\n        }\n        getTry() {\n            return this._try\n        }\n        setBrx(v) {\n            this._brx = +v\n        }\n        getBrx() {\n            return this._brx\n        }\n        setBry(v) {\n            this._bry = +v\n        }\n        getBry() {\n            return this._bry\n        }\n        setBlx(v) {\n            this._blx = +v\n        }\n        getBlx() {\n            return this._blx\n        }\n        setBly(v) {\n            this._bly = +v\n        }\n        getBly() {\n            return this._bly\n        }\n        toDOMQuad() {\n            return new DOMQuad(new DOMPoint(this._tlx,this._tly),new DOMPoint(this._trx,this._try),new DOMPoint(this._brx,this._bry),new DOMPoint(this._blx,this._bly))\n        }\n        toArray() {\n            return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly]\n        }\n        toTypedArray() {\n            return new Float64Array(this.toArray())\n        }\n        writeToTypedArray(ta, i) {\n            ta[i++] = this._tlx;\n            ta[i++] = this._tly;\n            ta[i++] = this._trx;\n            ta[i++] = this._try;\n            ta[i++] = this._brx;\n            ta[i++] = this._bry;\n            ta[i++] = this._blx;\n            ta[i] = this._bly\n        }\n        writeToTypedArray3D(ta, i, z) {\n            ta[i++] = this._tlx;\n            ta[i++] = this._tly;\n            ta[i++] = z;\n            ta[i++] = this._trx;\n            ta[i++] = this._try;\n            ta[i++] = z;\n            ta[i++] = this._brx;\n            ta[i++] = this._bry;\n            ta[i++] = z;\n            ta[i++] = this._blx;\n            ta[i++] = this._bly;\n            ta[i] = z\n        }\n        offset(x, y) {\n            x = +x;\n            y = +y;\n            this._tlx += x;\n            this._tly += y;\n            this._trx += x;\n            this._try += y;\n            this._brx += x;\n            this._bry += y;\n            this._blx += x;\n            this._bly += y\n        }\n        round() {\n            this._tlx = Math.round(this._tlx);\n            this._tly = Math.round(this._tly);\n            this._trx = Math.round(this._trx);\n            this._try = Math.round(this._try);\n            this._brx = Math.round(this._brx);\n            this._bry = Math.round(this._bry);\n            this._blx = Math.round(this._blx);\n            this._bly = Math.round(this._bly)\n        }\n        floor() {\n            this._tlx = Math.floor(this._tlx);\n            this._tly = Math.floor(this._tly);\n            this._trx = Math.floor(this._trx);\n            this._try = Math.floor(this._try);\n            this._brx = Math.floor(this._brx);\n            this._bry = Math.floor(this._bry);\n            this._blx = Math.floor(this._blx);\n            this._bly = Math.floor(this._bly)\n        }\n        ceil() {\n            this._tlx = Math.ceil(this._tlx);\n            this._tly = Math.ceil(this._tly);\n            this._trx = Math.ceil(this._trx);\n            this._try = Math.ceil(this._try);\n            this._brx = Math.ceil(this._brx);\n            this._bry = Math.ceil(this._bry);\n            this._blx = Math.ceil(this._blx);\n            this._bly = Math.ceil(this._bly)\n        }\n        setFromRect(rect) {\n            this._tlx = rect._left;\n            this._tly = rect._top;\n            this._trx = rect._right;\n            this._try = rect._top;\n            this._brx = rect._right;\n            this._bry = rect._bottom;\n            this._blx = rect._left;\n            this._bly = rect._bottom\n        }\n        setFromRotatedRect(rect, a) {\n            if (a === 0)\n                this.setFromRect(rect);\n            else\n                this.setFromRotatedRectPrecalc(rect, Math.sin(a), Math.cos(a))\n        }\n        setFromRotatedRectPrecalc(rect, sin_a, cos_a) {\n            const left_sin_a = rect._left * sin_a;\n            const top_sin_a = rect._top * sin_a;\n            const right_sin_a = rect._right * sin_a;\n            const bottom_sin_a = rect._bottom * sin_a;\n            const left_cos_a = rect._left * cos_a;\n            const top_cos_a = rect._top * cos_a;\n            const right_cos_a = rect._right * cos_a;\n            const bottom_cos_a = rect._bottom * cos_a;\n            this._tlx = left_cos_a - top_sin_a;\n            this._tly = top_cos_a + left_sin_a;\n            this._trx = right_cos_a - top_sin_a;\n            this._try = top_cos_a + right_sin_a;\n            this._brx = right_cos_a - bottom_sin_a;\n            this._bry = bottom_cos_a + right_sin_a;\n            this._blx = left_cos_a - bottom_sin_a;\n            this._bly = bottom_cos_a + left_sin_a\n        }\n        getBoundingBox(rect) {\n            rect.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly))\n        }\n        containsPoint(x, y) {\n            let v0x = this._trx - this._tlx;\n            let v0y = this._try - this._tly;\n            const v1x = this._brx - this._tlx;\n            const v1y = this._bry - this._tly;\n            const v2x = x - this._tlx;\n            const v2y = y - this._tly;\n            let dot00 = v0x * v0x + v0y * v0y;\n            let dot01 = v0x * v1x + v0y * v1y;\n            let dot02 = v0x * v2x + v0y * v2y;\n            const dot11 = v1x * v1x + v1y * v1y;\n            const dot12 = v1x * v2x + v1y * v2y;\n            let invDenom = 1 \/ (dot00 * dot11 - dot01 * dot01);\n            let u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n            let v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n            if (u >= 0 && v > 0 && u + v < 1)\n                return true;\n            v0x = this._blx - this._tlx;\n            v0y = this._bly - this._tly;\n            dot00 = v0x * v0x + v0y * v0y;\n            dot01 = v0x * v1x + v0y * v1y;\n            dot02 = v0x * v2x + v0y * v2y;\n            invDenom = 1 \/ (dot00 * dot11 - dot01 * dot01);\n            u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n            v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n            return u >= 0 && v > 0 && u + v < 1\n        }\n        midX() {\n            return (this._tlx + this._trx + this._brx + this._blx) \/ 4\n        }\n        midY() {\n            return (this._tly + this._try + this._bry + this._bly) \/ 4\n        }\n        intersectsSegment(x1, y1, x2, y2) {\n            if (this.containsPoint(x1, y1) || this.containsPoint(x2, y2))\n                return true;\n            return C3.segmentIntersectsQuad(x1, y1, x2, y2, this)\n        }\n        intersectsQuad(rhs) {\n            let midX = rhs.midX();\n            let midY = rhs.midY();\n            if (this.containsPoint(midX, midY))\n                return true;\n            midX = this.midX();\n            midY = this.midY();\n            if (rhs.containsPoint(midX, midY))\n                return true;\n            const tlx = this._tlx\n              , tly = this._tly\n              , trx = this._trx\n              , try_ = this._try\n              , brx = this._brx\n              , bry = this._bry\n              , blx = this._blx\n              , bly = this._bly;\n            return C3.segmentIntersectsQuad(tlx, tly, trx, try_, rhs) || C3.segmentIntersectsQuad(trx, try_, brx, bry, rhs) || C3.segmentIntersectsQuad(brx, bry, blx, bly, rhs) || C3.segmentIntersectsQuad(blx, bly, tlx, tly, rhs)\n        }\n        rotatePointsAnticlockwise() {\n            const tlx = this._tlx;\n            const tly = this._tly;\n            this._tlx = this._trx;\n            this._tly = this._try;\n            this._trx = this._brx;\n            this._try = this._bry;\n            this._brx = this._blx;\n            this._bry = this._bly;\n            this._blx = tlx;\n            this._bly = tly\n        }\n        mirror() {\n            this._swap(0, 2);\n            this._swap(1, 3);\n            this._swap(6, 4);\n            this._swap(7, 5)\n        }\n        flip() {\n            this._swap(0, 6);\n            this._swap(1, 7);\n            this._swap(2, 4);\n            this._swap(3, 5)\n        }\n        diag() {\n            this._swap(2, 6);\n            this._swap(3, 7)\n        }\n        _swap(i, j) {\n            const tmp = this._getAtIndex(i);\n            this._setAtIndex(i, this._getAtIndex(j));\n            this._setAtIndex(j, tmp)\n        }\n        _getAtIndex(i) {\n            switch (i) {\n            case 0:\n                return this._tlx;\n            case 1:\n                return this._tly;\n            case 2:\n                return this._trx;\n            case 3:\n                return this._try;\n            case 4:\n                return this._brx;\n            case 5:\n                return this._bry;\n            case 6:\n                return this._blx;\n            case 7:\n                return this._bly;\n            default:\n                throw new RangeError("invalid quad point index");\n            }\n        }\n        _setAtIndex(i, v) {\n            v = +v;\n            switch (i) {\n            case 0:\n                this._tlx = v;\n                break;\n            case 1:\n                this._tly = v;\n                break;\n            case 2:\n                this._trx = v;\n                break;\n            case 3:\n                this._try = v;\n                break;\n            case 4:\n                this._brx = v;\n                break;\n            case 5:\n                this._bry = v;\n                break;\n            case 6:\n                this._blx = v;\n                break;\n            case 7:\n                this._bly = v;\n                break;\n            default:\n                throw new RangeError("invalid quad point index");\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ lib\/misc\/collisionPoly.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const assert = self.assert;\n    const DEFAULT_POLY_POINTS = [0, 0, 1, 0, 1, 1, 0, 1];\n    const tempQuad = C3.New(C3.Quad);\n    C3.CollisionPoly = class CollisionPoly extends C3.DefendedBase {\n        constructor(pointsArr, enabled=true) {\n            super();\n            if (!pointsArr)\n                pointsArr = DEFAULT_POLY_POINTS;\n            this._ptsArr = Float64Array.from(pointsArr);\n            this._bbox = new C3.Rect;\n            this._isBboxChanged = true;\n            this._enabled = enabled\n        }\n        Release() {}\n        pointsArr() {\n            return this._ptsArr\n        }\n        pointCount() {\n            return this._ptsArr.length \/ 2\n        }\n        setPoints(pointsArr) {\n            if (this._ptsArr.length === pointsArr.length)\n                this._ptsArr.set(pointsArr);\n            else\n                this._ptsArr = Float64Array.from(pointsArr);\n            this._isBboxChanged = true\n        }\n        setDefaultPoints() {\n            this.setPoints(DEFAULT_POLY_POINTS)\n        }\n        copy(poly) {\n            this.setPoints(poly._ptsArr)\n        }\n        setBboxChanged() {\n            this._isBboxChanged = true\n        }\n        _updateBbox() {\n            if (!this._isBboxChanged)\n                return;\n            const ptsArr = this._ptsArr;\n            let left = ptsArr[0];\n            let top = ptsArr[1];\n            let right = left;\n            let bottom = top;\n            for (let i = 0, len = ptsArr.length; i < len; i += 2) {\n                const x = ptsArr[i];\n                const y = ptsArr[i + 1];\n                if (x < left)\n                    left = x;\n                if (x > right)\n                    right = x;\n                if (y < top)\n                    top = y;\n                if (y > bottom)\n                    bottom = y\n            }\n            this._bbox.set(left, top, right, bottom);\n            this._isBboxChanged = false\n        }\n        setFromRect(rc, offX, offY) {\n            let ptsArr = this._ptsArr;\n            if (ptsArr.length !== 8) {\n                ptsArr = new Float64Array(8);\n                this._ptsArr = ptsArr\n            }\n            ptsArr[0] = rc.getLeft() - offX;\n            ptsArr[1] = rc.getTop() - offY;\n            ptsArr[2] = rc.getRight() - offX;\n            ptsArr[3] = rc.getTop() - offY;\n            ptsArr[4] = rc.getRight() - offX;\n            ptsArr[5] = rc.getBottom() - offY;\n            ptsArr[6] = rc.getLeft() - offX;\n            ptsArr[7] = rc.getBottom() - offY;\n            this._bbox.copy(rc);\n            if (offX !== 0 || offY !== 0)\n                this._bbox.offset(-offX, -offY);\n            this._isBboxChanged = false\n        }\n        setFromQuad(q, offX, offY) {\n            tempQuad.copy(q);\n            tempQuad.offset(offX, offY);\n            this.setPoints(tempQuad.toArray());\n            this._isBboxChanged = true\n        }\n        transform(w, h, a) {\n            let sina = 0;\n            let cosa = 1;\n            if (a !== 0) {\n                sina = Math.sin(a);\n                cosa = Math.cos(a)\n            }\n            this.transformPrecalc(w, h, sina, cosa)\n        }\n        transformPrecalc(w, h, sina, cosa) {\n            const ptsArr = this._ptsArr;\n            for (let i = 0, len = ptsArr.length; i < len; i += 2) {\n                const j = i + 1;\n                const x = ptsArr[i] * w;\n                const y = ptsArr[j] * h;\n                ptsArr[i] = x * cosa - y * sina;\n                ptsArr[j] = y * cosa + x * sina\n            }\n            this._isBboxChanged = true\n        }\n        offset(x, y) {\n            const ptsArr = this._ptsArr;\n            for (let i = 0, len = ptsArr.length; i < len; i += 2) {\n                ptsArr[i] += x;\n                ptsArr[i + 1] += y\n            }\n        }\n        containsPoint(a2x, a2y) {\n            const ptsArr = this._ptsArr;\n            if (a2x === ptsArr[0] && a2y === ptsArr[1])\n                return true;\n            this._updateBbox();\n            const bbox = this._bbox;\n            const a1x = bbox.getLeft() - 110;\n            const a1y = bbox.getTop() - 101;\n            const a3x = bbox.getRight() + 131;\n            const a3y = bbox.getBottom() + 120;\n            let minAx12 = 0;\n            let minAy12 = 0;\n            let maxAx12 = 0;\n            let maxAy12 = 0;\n            let minAx32 = 0;\n            let minAy32 = 0;\n            let maxAx32 = 0;\n            let maxAy32 = 0;\n            if (a1x < a2x) {\n                minAx12 = a1x;\n                maxAx12 = a2x\n            } else {\n                minAx12 = a2x;\n                maxAx12 = a1x\n            }\n            if (a1y < a2y) {\n                minAy12 = a1y;\n                maxAy12 = a2y\n            } else {\n                minAy12 = a2y;\n                maxAy12 = a1y\n            }\n            if (a3x < a2x) {\n                minAx32 = a3x;\n                maxAx32 = a2x\n            } else {\n                minAx32 = a2x;\n                maxAx32 = a3x\n            }\n            if (a3y < a2y) {\n                minAy32 = a3y;\n                maxAy32 = a2y\n            } else {\n                minAy32 = a2y;\n                maxAy32 = a3y\n            }\n            let count1 = 0;\n            let count2 = 0;\n            for (let i = 0, len = ptsArr.length; i < len; i += 2) {\n                const j = (i + 2) % len;\n                const b1x = ptsArr[i];\n                const b1y = ptsArr[i + 1];\n                const b2x = ptsArr[j];\n                const b2y = ptsArr[j + 1];\n                if (C3.segmentsIntersectPreCalc(a1x, a1y, a2x, a2y, minAx12, maxAx12, minAy12, maxAy12, b1x, b1y, b2x, b2y))\n                    ++count1;\n                if (C3.segmentsIntersectPreCalc(a3x, a3y, a2x, a2y, minAx32, maxAx32, minAy32, maxAy32, b1x, b1y, b2x, b2y))\n                    ++count2\n            }\n            return count1 % 2 === 1 || count2 % 2 === 1\n        }\n        intersectsPoly(poly, offX, offY) {\n            const rPts = poly._ptsArr;\n            const lPts = this._ptsArr;\n            if (this.containsPoint(rPts[0] + offX, rPts[1] + offY))\n                return true;\n            if (poly.containsPoint(lPts[0] - offX, lPts[1] - offY))\n                return true;\n            for (let i = 0, leni = lPts.length; i < leni; i += 2) {\n                const j = (i + 2) % leni;\n                const a1x = lPts[i];\n                const a1y = lPts[i + 1];\n                const a2x = lPts[j];\n                const a2y = lPts[j + 1];\n                let minAx = 0;\n                let minAy = 0;\n                let maxAx = 0;\n                let maxAy = 0;\n                if (a1x < a2x) {\n                    minAx = a1x;\n                    maxAx = a2x\n                } else {\n                    minAx = a2x;\n                    maxAx = a1x\n                }\n                if (a1y < a2y) {\n                    minAy = a1y;\n                    maxAy = a2y\n                } else {\n                    minAy = a2y;\n                    maxAy = a1y\n                }\n                for (let k = 0, lenk = rPts.length; k < lenk; k += 2) {\n                    const l = (k + 2) % lenk;\n                    const b1x = rPts[k] + offX;\n                    const b1y = rPts[k + 1] + offY;\n                    const b2x = rPts[l] + offX;\n                    const b2y = rPts[l + 1] + offY;\n                    if (C3.segmentsIntersectPreCalc(a1x, a1y, a2x, a2y, minAx, maxAx, minAy, maxAy, b1x, b1y, b2x, b2y))\n                        return true\n                }\n            }\n            return false\n        }\n        intersectsSegment(offX, offY, a1x, a1y, a2x, a2y) {\n            if (this.containsPoint(a1x - offX, a1y - offY))\n                return true;\n            if (this.containsPoint(a2x - offX, a2y - offY))\n                return true;\n            let minAx = 0;\n            let minAy = 0;\n            let maxAx = 0;\n            let maxAy = 0;\n            if (a1x < a2x) {\n                minAx = a1x;\n                maxAx = a2x\n            } else {\n                minAx = a2x;\n                maxAx = a1x\n            }\n            if (a1y < a2y) {\n                minAy = a1y;\n                maxAy = a2y\n            } else {\n                minAy = a2y;\n                maxAy = a1y\n            }\n            const ptsArr = this._ptsArr;\n            for (let i = 0, len = ptsArr.length; i < len; i += 2) {\n                const j = (i + 2) % len;\n                const b1x = ptsArr[i] + offX;\n                const b1y = ptsArr[i + 1] + offY;\n                const b2x = ptsArr[j] + offX;\n                const b2y = ptsArr[j + 1] + offY;\n                if (C3.segmentsIntersectPreCalc(a1x, a1y, a2x, a2y, minAx, maxAx, minAy, maxAy, b1x, b1y, b2x, b2y))\n                    return true\n            }\n            return false\n        }\n        mirror(px) {\n            const ptsArr = this._ptsArr;\n            for (let i = 0, len = ptsArr.length; i < len; i += 2)\n                ptsArr[i] = px * 2 - ptsArr[i];\n            this._isBboxChanged = true\n        }\n        flip(py) {\n            const ptsArr = this._ptsArr;\n            for (let i = 0, len = ptsArr.length; i < len; i += 2) {\n                const j = i + 1;\n                ptsArr[j] = py * 2 - ptsArr[j]\n            }\n            this._isBboxChanged = true\n        }\n        diag() {\n            const ptsArr = this._ptsArr;\n            for (let i = 0, len = ptsArr.length; i < len; i += 2) {\n                const j = i + 1;\n                const temp = ptsArr[i];\n                ptsArr[i] = ptsArr[j];\n                ptsArr[j] = temp\n            }\n            this._isBboxChanged = true\n        }\n        GetMidX() {\n            const ptsArr = this._ptsArr;\n            let ret = 0;\n            for (let i = 0, len = ptsArr.length; i < len; i += 2)\n                ret += ptsArr[i];\n            return ret \/ this.pointCount()\n        }\n        GetMidY() {\n            const ptsArr = this._ptsArr;\n            let ret = 0;\n            for (let i = 0, len = ptsArr.length; i < len; i += 2)\n                ret += ptsArr[i + 1];\n            return ret \/ this.pointCount()\n        }\n        GetPointsArray() {\n            return this._ptsArr\n        }\n        GetPointCount() {\n            return this.pointCount()\n        }\n        IsEnabled() {\n            return this._enabled\n        }\n    }\n    ;\n\n}\n\n\/\/ lib\/misc\/pairMap.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.PairMap = class PairMap extends C3.DefendedBase {\n        constructor(iterable) {\n            super();\n            this._firstMap = new Map;\n            if (iterable)\n                for (const [x,y,value] of iterable)\n                    this.Set(x, y, value)\n        }\n        Release() {\n            this.Clear();\n            this._firstMap = null\n        }\n        Clear() {\n            const firstMap = this._firstMap;\n            for (const secondMap of firstMap.values())\n                secondMap.clear();\n            firstMap.clear()\n        }\n        Set(x, y, value) {\n            const firstMap = this._firstMap;\n            let secondMap = firstMap.get(x);\n            if (!secondMap) {\n                secondMap = new Map;\n                firstMap.set(x, secondMap)\n            }\n            secondMap.set(y, value)\n        }\n        Get(x, y) {\n            const secondMap = this._firstMap.get(x);\n            if (!secondMap)\n                return secondMap;\n            return secondMap.get(y)\n        }\n        Has(x, y) {\n            const secondMap = this._firstMap.get(x);\n            if (!secondMap)\n                return false;\n            return secondMap.has(y)\n        }\n        Delete(x, y) {\n            const firstMap = this._firstMap;\n            const secondMap = firstMap.get(x);\n            if (!secondMap)\n                return false;\n            const ret = secondMap.delete(y);\n            if (ret && secondMap.size === 0)\n                firstMap.delete(x);\n            return ret\n        }\n        DeleteEither(k) {\n            const firstMap = this._firstMap;\n            const secondMap = firstMap.get(k);\n            if (secondMap) {\n                secondMap.clear();\n                firstMap.delete(k)\n            }\n            for (const [x,secondMap] of firstMap.entries())\n                if (secondMap.delete(k) && secondMap.size === 0)\n                    firstMap.delete(x)\n        }\n        GetSize() {\n            let ret = 0;\n            for (const secondMap of this._firstMap.values())\n                ret += secondMap.size;\n            return ret\n        }\n        *values() {\n            for (const secondMap of this._firstMap.values())\n                yield*secondMap.values()\n        }\n        *keyPairs() {\n            for (const [x,secondMap] of this._firstMap.entries())\n                for (const y of secondMap.keys())\n                    yield[x, y]\n        }\n        *entries() {\n            for (const [x,secondMap] of this._firstMap.entries())\n                for (const [y,value] of secondMap.entries())\n                    yield[x, y, value]\n        }\n    }\n    ;\n\n}\n\n\/\/ lib\/misc\/arraySet.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.ArraySet = class ArraySet extends C3.DefendedBase {\n        constructor() {\n            super();\n            this._set = new Set;\n            this._arr = [];\n            this._needToRebuildArray = false\n        }\n        Release() {\n            this.Clear()\n        }\n        Clear() {\n            this._set.clear();\n            C3.clearArray(this._arr);\n            this._needToRebuildArray = false\n        }\n        Add(v) {\n            if (this._set.has(v))\n                return;\n            this._set.add(v);\n            if (!this._needToRebuildArray)\n                this._arr.push(v)\n        }\n        Has(v) {\n            return this._set.has(v)\n        }\n        Delete(v) {\n            if (this._set.delete(v))\n                this._needToRebuildArray = true\n        }\n        GetSize() {\n            return this._set.size\n        }\n        IsEmpty() {\n            return this._set.size === 0\n        }\n        GetArray() {\n            if (this._needToRebuildArray) {\n                this._RebuildArray();\n                this._needToRebuildArray = false\n            }\n            return this._arr\n        }\n        _RebuildArray() {\n            const arr = this._arr;\n            C3.clearArray(arr);\n            for (const v of this._set)\n                arr.push(v)\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/misc\/ease.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const EASE_MAP = new Map;\n    const PREDEFINED_EASE_MAP = new Map;\n    const CUSTOM_EASE_EDITOR_MAP = new Map;\n    const CUSTOM_EASE_RUNTIME_MAP = new Map;\n    const PRIVATE_EASE_MAP = new Map;\n    const ALIAS_MAP = new Map;\n    ALIAS_MAP.set("linear", "noease");\n    ALIAS_MAP.set("default", "noease");\n    self.Ease = class Ease {\n        constructor() {}\n        static InheritEase() {\n            return "default"\n        }\n        static DefaultEase() {\n            return "noease"\n        }\n        static GetEditorEaseNames(project, ...filter) {\n            this._CreateEaseMap();\n            if (!CUSTOM_EASE_EDITOR_MAP.has(project))\n                CUSTOM_EASE_EDITOR_MAP.set(project, new Map);\n            const customEaseMap = CUSTOM_EASE_EDITOR_MAP.get(project);\n            const sortedCustomEases = [...customEaseMap.keys()];\n            sortedCustomEases.sort();\n            return [...PREDEFINED_EASE_MAP.keys()].concat(sortedCustomEases).filter(ease => !filter.includes(ease))\n        }\n        static GetRuntimeEaseNames() {\n            this._CreateEaseMap();\n            const sortedCustomEases = [...CUSTOM_EASE_RUNTIME_MAP.keys()];\n            sortedCustomEases.sort();\n            return [...PREDEFINED_EASE_MAP.keys()].concat(sortedCustomEases)\n        }\n        static IsNamePredefined(easeName) {\n            this._CreateEaseMap();\n            return [...PREDEFINED_EASE_MAP.keys()].includes(easeName)\n        }\n        static _GetEase(easeName) {\n            const realEaseName = ALIAS_MAP.get(easeName);\n            if (realEaseName)\n                return EASE_MAP.get(realEaseName);\n            if (Ease.IsNamePredefined(easeName))\n                return EASE_MAP.get(easeName);\n            if (PRIVATE_EASE_MAP.has(easeName))\n                return PRIVATE_EASE_MAP.get(easeName)\n        }\n        static GetEditorEase(easeName, project) {\n            this._CreateEaseMap();\n            const ease = Ease._GetEase(easeName);\n            if (ease)\n                return ease;\n            return CUSTOM_EASE_EDITOR_MAP.get(project).get(easeName)\n        }\n        static GetRuntimeEase(easeName) {\n            this._CreateEaseMap();\n            const ease = Ease._GetEase(easeName);\n            if (ease)\n                return ease;\n            return CUSTOM_EASE_RUNTIME_MAP.get(easeName)\n        }\n        static GetEaseFromIndex(index) {\n            this._CreateEaseMap();\n            const names = this.GetRuntimeEaseNames();\n            return names[index]\n        }\n        static GetIndexForEase(name, project) {\n            this._CreateEaseMap();\n            const names = this.GetEditorEaseNames(project);\n            return names.indexOf(name)\n        }\n        static _CreateEaseMap() {\n            if (EASE_MAP.size !== 0)\n                return;\n            this._AddPredifinedEase("default", () => {}\n            );\n            this._AddPredifinedEase("noease", this.NoEase);\n            this._AddPredifinedEase("easeinsine", this.EaseInSine);\n            this._AddPredifinedEase("easeoutsine", this.EaseOutSine);\n            this._AddPredifinedEase("easeinoutsine", this.EaseInOutSine);\n            this._AddPredifinedEase("easeinelastic", this.EaseInElastic);\n            this._AddPredifinedEase("easeoutelastic", this.EaseOutElastic);\n            this._AddPredifinedEase("easeinoutelastic", this.EaseInOutElastic);\n            this._AddPredifinedEase("easeinback", this.EaseInBack);\n            this._AddPredifinedEase("easeoutback", this.EaseOutBack);\n            this._AddPredifinedEase("easeinoutback", this.EaseInOutBack);\n            this._AddPredifinedEase("easeinbounce", this.EaseInBounce);\n            this._AddPredifinedEase("easeoutbounce", this.EaseOutBounce);\n            this._AddPredifinedEase("easeinoutbounce", this.EaseInOutBounce);\n            this._AddPredifinedEase("easeincubic", this.EaseInCubic);\n            this._AddPredifinedEase("easeoutcubic", this.EaseOutCubic);\n            this._AddPredifinedEase("easeinoutcubic", this.EaseInOutCubic);\n            this._AddPredifinedEase("easeinquad", this.EaseInQuad);\n            this._AddPredifinedEase("easeoutquad", this.EaseOutQuad);\n            this._AddPredifinedEase("easeinoutquad", this.EaseInOutQuad);\n            this._AddPredifinedEase("easeinquart", this.EaseInQuart);\n            this._AddPredifinedEase("easeoutquart", this.EaseOutQuart);\n            this._AddPredifinedEase("easeinoutquart", this.EaseInOutQuart);\n            this._AddPredifinedEase("easeinquint", this.EaseInQuint);\n            this._AddPredifinedEase("easeoutquint", this.EaseOutQuint);\n            this._AddPredifinedEase("easeinoutquint", this.EaseInOutQuint);\n            this._AddPredifinedEase("easeincirc", this.EaseInCirc);\n            this._AddPredifinedEase("easeoutcirc", this.EaseOutCirc);\n            this._AddPredifinedEase("easeinoutcirc", this.EaseInOutCirc);\n            this._AddPredifinedEase("easeinexpo", this.EaseInExpo);\n            this._AddPredifinedEase("easeoutexpo", this.EaseOutExpo);\n            this._AddPredifinedEase("easeinoutexpo", this.EaseInOutExpo);\n            this._AddPrivateCustomEase("cubicbezier", this.EaseCubicBezier);\n            this._AddPrivateCustomEase("spline", this.EaseSpline)\n        }\n        static _AddPredifinedEase(name, func) {\n            Ease._AddEase(name, func, "predefined")\n        }\n        static _AddPrivateCustomEase(name, func) {\n            Ease._AddEase(name, func, "private")\n        }\n        static AddCustomEase(name, func, project) {\n            this._CreateEaseMap();\n            Ease._AddEase(name, func, "custom", project)\n        }\n        static RemoveCustomEase(name, project) {\n            if (this.IsNamePredefined(name))\n                return;\n            if ([...PRIVATE_EASE_MAP.keys()].includes(name))\n                return;\n            const customEaseMap = CUSTOM_EASE_EDITOR_MAP.get(project);\n            if (customEaseMap)\n                customEaseMap.delete(name)\n        }\n        static _AddEase(name, func, mode, project) {\n            switch (mode) {\n            case "predefined":\n                EASE_MAP.set(name, func);\n                PREDEFINED_EASE_MAP.set(name, func);\n                break;\n            case "custom":\n                if (project) {\n                    if (!CUSTOM_EASE_EDITOR_MAP.has(project))\n                        CUSTOM_EASE_EDITOR_MAP.set(project, new Map);\n                    const customEaseMap = CUSTOM_EASE_EDITOR_MAP.get(project);\n                    customEaseMap.set(name, func)\n                } else\n                    CUSTOM_EASE_RUNTIME_MAP.set(name, func);\n                break;\n            case "private":\n                EASE_MAP.set(name, func);\n                PRIVATE_EASE_MAP.set(name, func);\n                break;\n            default:\n                throw new Error("unexpected ease mode");\n            }\n        }\n        static NoEase(t, b, c, d) {\n            return c * t \/ d + b\n        }\n        static EaseInQuad(t, b, c, d) {\n            return c * (t \/= d) * t + b\n        }\n        static EaseOutQuad(t, b, c, d) {\n            return -c * (t \/= d) * (t - 2) + b\n        }\n        static EaseInOutQuad(t, b, c, d) {\n            if ((t \/= d \/ 2) < 1)\n                return c \/ 2 * t * t + b;\n            return -c \/ 2 * (--t * (t - 2) - 1) + b\n        }\n        static EaseInCubic(t, b, c, d) {\n            return c * (t \/= d) * t * t + b\n        }\n        static EaseOutCubic(t, b, c, d) {\n            return c * ((t = t \/ d - 1) * t * t + 1) + b\n        }\n        static EaseInOutCubic(t, b, c, d) {\n            if ((t \/= d \/ 2) < 1)\n                return c \/ 2 * t * t * t + b;\n            return c \/ 2 * ((t -= 2) * t * t + 2) + b\n        }\n        static EaseInQuart(t, b, c, d) {\n            return c * (t \/= d) * t * t * t + b\n        }\n        static EaseOutQuart(t, b, c, d) {\n            return -c * ((t = t \/ d - 1) * t * t * t - 1) + b\n        }\n        static EaseInOutQuart(t, b, c, d) {\n            if ((t \/= d \/ 2) < 1)\n                return c \/ 2 * t * t * t * t + b;\n            return -c \/ 2 * ((t -= 2) * t * t * t - 2) + b\n        }\n        static EaseInQuint(t, b, c, d) {\n            return c * (t \/= d) * t * t * t * t + b\n        }\n        static EaseOutQuint(t, b, c, d) {\n            return c * ((t = t \/ d - 1) * t * t * t * t + 1) + b\n        }\n        static EaseInOutQuint(t, b, c, d) {\n            if ((t \/= d \/ 2) < 1)\n                return c \/ 2 * t * t * t * t * t + b;\n            return c \/ 2 * ((t -= 2) * t * t * t * t + 2) + b\n        }\n        static EaseInSine(t, b, c, d) {\n            return -c * Math.cos(t \/ d * (Math.PI \/ 2)) + c + b\n        }\n        static EaseOutSine(t, b, c, d) {\n            return c * Math.sin(t \/ d * (Math.PI \/ 2)) + b\n        }\n        static EaseInOutSine(t, b, c, d) {\n            return -c \/ 2 * (Math.cos(Math.PI * t \/ d) - 1) + b\n        }\n        static EaseInExpo(t, b, c, d) {\n            return t === 0 ? b : c * Math.pow(2, 10 * (t \/ d - 1)) + b\n        }\n        static EaseOutExpo(t, b, c, d) {\n            return t === d ? b + c : c * (-Math.pow(2, -10 * t \/ d) + 1) + b\n        }\n        static EaseInOutExpo(t, b, c, d) {\n            if (t === 0)\n                return b;\n            if (t === d)\n                return b + c;\n            if ((t \/= d \/ 2) < 1)\n                return c \/ 2 * Math.pow(2, 10 * (t - 1)) + b;\n            return c \/ 2 * (-Math.pow(2, -10 * --t) + 2) + b\n        }\n        static EaseInCirc(t, b, c, d) {\n            return -c * (Math.sqrt(1 - (t \/= d) * t) - 1) + b\n        }\n        static EaseOutCirc(t, b, c, d) {\n            return c * Math.sqrt(1 - (t = t \/ d - 1) * t) + b\n        }\n        static EaseInOutCirc(t, b, c, d) {\n            if ((t \/= d \/ 2) < 1)\n                return -c \/ 2 * (Math.sqrt(1 - t * t) - 1) + b;\n            return c \/ 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b\n        }\n        static EaseInElastic(t, b, c, d) {\n            let s = 1.70158;\n            let p = 0;\n            let a = c;\n            if (t === 0)\n                return b;\n            if ((t \/= d) === 1)\n                return b + c;\n            if (!p)\n                p = d * .3;\n            if (a < Math.abs(c)) {\n                a = c;\n                s = p \/ 4\n            } else\n                s = p \/ (2 * Math.PI) * Math.asin(c \/ a);\n            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) \/ p)) + b\n        }\n        static EaseOutElastic(t, b, c, d) {\n            let s = 1.70158;\n            let p = 0;\n            let a = c;\n            if (t === 0)\n                return b;\n            if ((t \/= d) === 1)\n                return b + c;\n            if (!p)\n                p = d * .3;\n            if (a < Math.abs(c)) {\n                a = c;\n                s = p \/ 4\n            } else\n                s = p \/ (2 * Math.PI) * Math.asin(c \/ a);\n            return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) \/ p) + c + b\n        }\n        static EaseInOutElastic(t, b, c, d) {\n            let s = 1.70158;\n            let p = 0;\n            let a = c;\n            if (t === 0)\n                return b;\n            if ((t \/= d \/ 2) === 2)\n                return b + c;\n            if (!p)\n                p = d * (.3 * 1.5);\n            if (a < Math.abs(c)) {\n                a = c;\n                s = p \/ 4\n            } else\n                s = p \/ (2 * Math.PI) * Math.asin(c \/ a);\n            if (t < 1)\n                return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) \/ p)) + b;\n            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) \/ p) * .5 + c + b\n        }\n        static EaseInBack(t, b, c, d, s) {\n            if (s === undefined)\n                s = 1.70158;\n            return c * (t \/= d) * t * ((s + 1) * t - s) + b\n        }\n        static EaseOutBack(t, b, c, d, s) {\n            if (s === undefined)\n                s = 1.70158;\n            return c * ((t = t \/ d - 1) * t * ((s + 1) * t + s) + 1) + b\n        }\n        static EaseInOutBack(t, b, c, d, s) {\n            if (s === undefined)\n                s = 1.70158;\n            if ((t \/= d \/ 2) < 1)\n                return c \/ 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;\n            return c \/ 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b\n        }\n        static EaseInBounce(t, b, c, d) {\n            return c - Ease.EaseOutBounce(d - t, 0, c, d) + b\n        }\n        static EaseOutBounce(t, b, c, d) {\n            if ((t \/= d) < 1 \/ 2.75)\n                return c * (7.5625 * t * t) + b;\n            else if (t < 2 \/ 2.75)\n                return c * (7.5625 * (t -= 1.5 \/ 2.75) * t + .75) + b;\n            else if (t < 2.5 \/ 2.75)\n                return c * (7.5625 * (t -= 2.25 \/ 2.75) * t + .9375) + b;\n            else\n                return c * (7.5625 * (t -= 2.625 \/ 2.75) * t + .984375) + b\n        }\n        static EaseInOutBounce(t, b, c, d) {\n            if (t < d \/ 2)\n                return Ease.EaseInBounce(t * 2, 0, c, d) * .5 + b;\n            return Ease.EaseOutBounce(t * 2 - d, 0, c, d) * .5 + c * .5 + b\n        }\n        static EaseCubicBezier(t, p0, p1, p2, p3) {\n            const _0 = p0;\n            const _1 = 3 * t * (p1 - p0);\n            const _2 = 3 * t ** 2 * (p0 + p2 - 2 * p1);\n            const _3 = t ** 3 * (p3 - p0 + 3 * p1 - 3 * p2);\n            return _0 + _1 + _2 + _3\n        }\n        static EaseSpline(t, sx, sy, x1, y1, x2, y2, ex, ey, samples) {\n            if (x1 === y1 && x2 === y2)\n                return t;\n            const tx = get_t_for_x(t, sx, x1, x2, ex, samples);\n            const va = a(sy, y1, y2, ey);\n            const vb = b(sy, y1, y2, ey);\n            const vc = c(sy, y1, y2, ey);\n            return calc_bezier(tx, va, vb, vc)\n        }\n        static GetBezierSamples(startx, a1x, a2x, endx) {\n            const ret = [];\n            const va = a(startx, a1x, a2x, endx);\n            const vb = b(startx, a1x, a2x, endx);\n            const vc = c(startx, a1x, a2x, endx);\n            for (let i = 0; i < SAMPLE_COUNT; ++i) {\n                const sample = calc_bezier(i * SAMPLE_STEP, va, vb, vc);\n                ret.push(sample)\n            }\n            return ret\n        }\n    }\n    ;\n    const SAMPLE_COUNT = 11;\n    const SAMPLE_STEP = 1 \/ (SAMPLE_COUNT - 1);\n    const NEWTON_RAPHSON_ITERATIONS = 4;\n    const NEWTON_RAPHSON_MIN_SLOPE = .02;\n    const SUBDIVISION_PRECISION = 1E-7;\n    const SUBDIVISION_MAX_ITERATIONS = 10;\n    const a = (p0, p1, p2, p3) => {\n        return p3 - 3 * p2 + 3 * p1 - p0\n    }\n    ;\n    const b = (p0, p1, p2, p3) => {\n        return 3 * p2 - 6 * p1 + 3 * p0\n    }\n    ;\n    const c = (p0, p1, p2, p3) => {\n        return 3 * (p1 - p0)\n    }\n    ;\n    const calc_bezier = (aT, a, b, c) => {\n        return ((a * aT + b) * aT + c) * aT\n    }\n    ;\n    const get_slope = (aT, a, b, c) => {\n        return 3 * a * aT * aT + 2 * b * aT + c\n    }\n    ;\n    const get_t_for_x = (aX, p0, p1, p2, p3, samples) => {\n        if (aX == 1)\n            return 1;\n        let intervalStart = 0;\n        let currentSampleIndex = 1;\n        let currentSampleValue = samples[currentSampleIndex];\n        let lastSampleIndex = SAMPLE_COUNT - 1;\n        let lastSampleValue = samples[SAMPLE_COUNT - 1];\n        while (currentSampleIndex != lastSampleIndex && currentSampleValue <= aX) {\n            currentSampleIndex++;\n            currentSampleValue = samples[currentSampleIndex];\n            intervalStart += SAMPLE_STEP\n        }\n        currentSampleIndex--;\n        currentSampleValue = samples[currentSampleIndex];\n        const dist = (aX - currentSampleValue) \/ (samples[currentSampleIndex + 1] - currentSampleValue);\n        let guess = intervalStart + dist * SAMPLE_STEP;\n        const va = a(p0, p1, p2, p3);\n        const vb = b(p0, p1, p2, p3);\n        const vc = c(p0, p1, p2, p3);\n        const initSlope = get_slope(guess, va, vb, vc);\n        if (initSlope === 0)\n            return guess;\n        else if (initSlope >= NEWTON_RAPHSON_MIN_SLOPE) {\n            for (let i = 0; i < NEWTON_RAPHSON_ITERATIONS; ++i) {\n                const x = calc_bezier(guess, va, vb, vc) - aX;\n                const slope = get_slope(guess, va, vb, vc);\n                guess -= x \/ slope\n            }\n            return guess\n        } else {\n            let aA = intervalStart;\n            let aB = intervalStart + SAMPLE_STEP;\n            let i = 0;\n            let precissionLimit;\n            let maxIterations;\n            do {\n                guess = aA + (aB - aA) \/ 2;\n                let x = calc_bezier(guess, va, vb, vc) - aX;\n                if (x > 0)\n                    aB = guess;\n                else\n                    aA = guess;\n                precissionLimit = Math.abs(x) > SUBDIVISION_PRECISION;\n                maxIterations = ++i < SUBDIVISION_MAX_ITERATIONS\n            } while (precissionLimit && maxIterations);\n            return guess\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/misc\/probability.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    function RequireStringOrNumber(value) {\n        if (!C3.IsString(value))\n            ;\n    }\n    C3.ProbabilityTable = class ProbabilityTable {\n        constructor() {\n            this._items = [];\n            this._totalWeight = 0\n        }\n        Release() {\n            this.Clear();\n            this._items = null\n        }\n        Clear() {\n            C3.clear2DArray(this._items);\n            this._totalWeight = 0\n        }\n        GetTotalWeight() {\n            return this._totalWeight\n        }\n        Sample(t=Math.random() * this.GetTotalWeight()) {\n            let sumWeight = 0;\n            for (const [weight,value] of this._items) {\n                sumWeight += weight;\n                if (t < sumWeight)\n                    return value\n            }\n            return 0\n        }\n        AddItem(weight, value) {\n            RequireStringOrNumber(value);\n            this._totalWeight += weight;\n            this._items.push([weight, value])\n        }\n        RemoveItem(weight, value) {\n            RequireStringOrNumber(value);\n            const ignoreWeight = weight === 0;\n            for (let i = 0; i < this._items.length; i++) {\n                const item = this._items[i];\n                const doesWeightMatch = ignoreWeight || item[0] === weight;\n                const doesValueMatch = item[1] === value;\n                if (doesWeightMatch && doesValueMatch) {\n                    this._items.splice(i, 1);\n                    this._totalWeight -= item[0];\n                    break\n                }\n            }\n        }\n        asJSON() {\n            return JSON.stringify(this._items)\n        }\n        static fromJSON(str) {\n            const table = new C3.ProbabilityTable;\n            const items = JSON.parse(str);\n            for (const item of items) {\n                const weight = item[0];\n                const value = item[1];\n                table.AddItem(weight, value)\n            }\n            return table\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/events\/event.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Event = class Event {\n        constructor(type, cancelable) {\n            this.type = type;\n            this.cancelable = !!cancelable;\n            this.defaultPrevented = false;\n            this.propagationStopped = false;\n            this.isAsync = false\n        }\n        preventDefault() {\n            if (!this.cancelable)\n                throw new Error(`event \'${this.type}\' is not cancelable`);\n            this.defaultPrevented = true\n        }\n        stopPropagation() {\n            if (!this.cancelable)\n                throw new Error(`event \'${this.type}\' cannot be stopped`);\n            if (this.isAsync)\n                throw new Error(`cannot stop async event \'${this.type}\' propagation`);\n            this.propagationStopped = true\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/events\/handler.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const assert = self.assert;\n    C3.Event.Handler = class EventHandler extends C3.DefendedBase {\n        constructor(type) {\n            super();\n            this._type = type;\n            this._captureListeners = [];\n            this._captureListenersSet = new Set;\n            this._listeners = [];\n            this._listenersSet = new Set;\n            this._fireDepth = 0;\n            this._queueModifyListeners = []\n        }\n        Release() {\n            if (this._fireDepth > 0)\n                return;\n            C3.clearArray(this._captureListeners);\n            this._captureListenersSet.clear();\n            C3.clearArray(this._listeners);\n            this._listenersSet.clear();\n            C3.clearArray(this._queueModifyListeners);\n            C3.Release(this)\n        }\n        _AddListener(func, capture) {\n            if (this._IsFiring()) {\n                this._queueModifyListeners.push({\n                    op: "add",\n                    func,\n                    capture\n                });\n                return\n            }\n            if (capture) {\n                if (this._captureListenersSet.has(func))\n                    return;\n                this._captureListeners.push(func);\n                this._captureListenersSet.add(func)\n            } else {\n                if (this._listenersSet.has(func))\n                    return;\n                this._listeners.push(func);\n                this._listenersSet.add(func)\n            }\n        }\n        _RemoveListener(func, capture) {\n            if (this._IsFiring()) {\n                this._queueModifyListeners.push({\n                    op: "remove",\n                    func,\n                    capture\n                });\n                return\n            }\n            if (capture) {\n                if (this._captureListenersSet.has(func)) {\n                    this._captureListenersSet.delete(func);\n                    C3.arrayFindRemove(this._captureListeners, func)\n                }\n            } else if (this._listenersSet.has(func)) {\n                this._listenersSet.delete(func);\n                C3.arrayFindRemove(this._listeners, func)\n            }\n        }\n        _IsEmpty() {\n            return !this._captureListeners.length && !this._listeners.length\n        }\n        _IsFiring() {\n            return this._fireDepth > 0\n        }\n        _ProcessQueuedListeners() {\n            const removeListenersSet = new Set;\n            const removeCaptureListenersSet = new Set;\n            for (const q of this._queueModifyListeners)\n                if (q.op === "add") {\n                    this._AddListener(q.func, q.capture);\n                    if (q.capture)\n                        removeCaptureListenersSet.delete(q.func);\n                    else\n                        removeListenersSet.delete(q.func)\n                } else if (q.op === "remove")\n                    if (q.capture) {\n                        this._captureListenersSet.delete(q.func);\n                        removeCaptureListenersSet.add(q.func)\n                    } else {\n                        this._listenersSet.delete(q.func);\n                        removeListenersSet.add(q.func)\n                    }\n                else\n                    throw new Error("invalid op");\n            C3.arrayRemoveAllInSet(this._listeners, removeListenersSet);\n            C3.arrayRemoveAllInSet(this._captureListeners, removeCaptureListenersSet);\n            C3.clearArray(this._queueModifyListeners)\n        }\n        _FireCancellable(event) {\n            this._IncreaseFireDepth();\n            let isStopped = false;\n            for (let i = 0, len = this._captureListeners.length; i < len; ++i) {\n                this._captureListeners[i](event);\n                if (event.propagationStopped) {\n                    isStopped = true;\n                    break\n                }\n            }\n            if (!isStopped)\n                for (let i = 0, len = this._listeners.length; i < len; ++i) {\n                    this._listeners[i](event);\n                    if (event.propagationStopped)\n                        break\n                }\n            this._DecreaseFireDepth();\n            return !event.defaultPrevented\n        }\n        _FireNonCancellable(event) {\n            this._IncreaseFireDepth();\n            for (let i = 0, len = this._captureListeners.length; i < len; ++i)\n                this._captureListeners[i](event);\n            for (let i = 0, len = this._listeners.length; i < len; ++i)\n                this._listeners[i](event);\n            this._DecreaseFireDepth();\n            return true\n        }\n        _IncreaseFireDepth() {\n            this._fireDepth++\n        }\n        _DecreaseFireDepth() {\n            this._fireDepth--;\n            if (this._fireDepth === 0 && this._queueModifyListeners.length > 0)\n                this._ProcessQueuedListeners()\n        }\n        SetDelayRemoveEventsEnabled(e) {\n            if (e)\n                this._IncreaseFireDepth();\n            else\n                this._DecreaseFireDepth()\n        }\n        _FireAsync(event) {\n            let callbackPromises = [];\n            for (let i = 0, len = this._captureListeners.length; i < len; ++i) {\n                let func = this._captureListeners[i];\n                callbackPromises.push(C3.Asyncify( () => func(event)))\n            }\n            for (let i = 0, len = this._listeners.length; i < len; ++i) {\n                let func = this._listeners[i];\n                callbackPromises.push(C3.Asyncify( () => func(event)))\n            }\n            return Promise.all(callbackPromises).then( () => !event.defaultPrevented)\n        }\n        _FireAndWait_AsyncOptional(event) {\n            const results = [];\n            this._IncreaseFireDepth();\n            for (let i = 0, len = this._captureListeners.length; i < len; ++i) {\n                const ret = this._captureListeners[i](event);\n                if (ret instanceof Promise)\n                    results.push(ret)\n            }\n            for (let i = 0, len = this._listeners.length; i < len; ++i) {\n                const ret = this._listeners[i](event);\n                if (ret instanceof Promise)\n                    results.push(ret)\n            }\n            this._DecreaseFireDepth();\n            if (results.length)\n                return Promise.all(results).then( () => !event.defaultPrevented);\n            else\n                return !event.defaultPrevented\n        }\n        async _FireAndWaitAsync(event) {\n            return await this._FireAndWait_AsyncOptional(event)\n        }\n        async _FireAndWaitAsyncSequential(event) {\n            this._IncreaseFireDepth();\n            for (let i = 0, len = this._captureListeners.length; i < len; ++i) {\n                const ret = this._captureListeners[i](event);\n                if (ret instanceof Promise)\n                    await ret\n            }\n            for (let i = 0, len = this._listeners.length; i < len; ++i) {\n                const ret = this._listeners[i](event);\n                if (ret instanceof Promise)\n                    await ret\n            }\n            this._DecreaseFireDepth();\n            return !event.defaultPrevented\n        }\n        *_FireAsGenerator(event) {\n            this._IncreaseFireDepth();\n            for (let i = 0, len = this._captureListeners.length; i < len; ++i) {\n                const ret = this._captureListeners[i](event);\n                if (C3.IsIterator(ret))\n                    yield*ret\n            }\n            for (let i = 0, len = this._listeners.length; i < len; ++i) {\n                const ret = this._listeners[i](event);\n                if (C3.IsIterator(ret))\n                    yield*ret\n            }\n            this._DecreaseFireDepth()\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/events\/dispatcher.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Event.Dispatcher = class EventDispatcher extends C3.DefendedBase {\n        constructor() {\n            super();\n            this._eventHandlers = new Map;\n            this._dispatcherWasReleased = false\n        }\n        Release() {\n            if (this._dispatcherWasReleased)\n                throw new Error("already released");\n            this.ClearEvents();\n            this._dispatcherWasReleased = true;\n            C3.Release(this)\n        }\n        WasReleased() {\n            return this._dispatcherWasReleased\n        }\n        ClearEvents() {\n            for (let handler of this._eventHandlers.values())\n                handler.Release();\n            this._eventHandlers.clear()\n        }\n        _GetHandlerByType(type, create_if_missing) {\n            let handler = this._eventHandlers.get(type);\n            if (handler)\n                return handler;\n            if (create_if_missing) {\n                handler = C3.New(C3.Event.Handler, type);\n                this._eventHandlers.set(type, handler);\n                return handler\n            }\n            return null\n        }\n        HasAnyHandlerFor(type) {\n            return this._eventHandlers.has(type)\n        }\n        addEventListener(type, func, capture) {\n            let handler = this._GetHandlerByType(type, true);\n            handler._AddListener(func, !!capture)\n        }\n        removeEventListener(type, func, capture) {\n            let handler = this._GetHandlerByType(type, false);\n            if (!handler)\n                return;\n            handler._RemoveListener(func, !!capture);\n            if (handler._IsEmpty())\n                this._eventHandlers.delete(type)\n        }\n        dispatchEvent(event) {\n            const handler = this._GetHandlerByType(event.type, false);\n            if (!handler)\n                return true;\n            if (event.cancelable)\n                return handler._FireCancellable(event);\n            else\n                return handler._FireNonCancellable(event)\n        }\n        dispatchEventAsync(event) {\n            const handler = this._GetHandlerByType(event.type, false);\n            if (!handler)\n                return Promise.resolve(true);\n            event.isAsync = true;\n            return handler._FireAsync(event)\n        }\n        async dispatchEventAndClearAsync(event) {\n            const handler = this._GetHandlerByType(event.type, false);\n            if (!handler)\n                return true;\n            this._eventHandlers.delete(event.type);\n            event.isAsync = true;\n            const ret = await handler._FireAsync(event);\n            handler.Release();\n            return ret\n        }\n        async dispatchEventAndWaitAsync(event) {\n            const handler = this._GetHandlerByType(event.type, false);\n            if (!handler)\n                return true;\n            return await handler._FireAndWaitAsync(event)\n        }\n        dispatchEventAndWait_AsyncOptional(event) {\n            const handler = this._GetHandlerByType(event.type, false);\n            if (!handler)\n                return true;\n            return handler._FireAndWait_AsyncOptional(event)\n        }\n        async dispatchEventAndWaitAsyncSequential(event) {\n            const handler = this._GetHandlerByType(event.type, false);\n            if (!handler)\n                return true;\n            return await handler._FireAndWaitAsyncSequential(event)\n        }\n        dispatchGeneratorEvent(event) {\n            const handler = this._GetHandlerByType(event.type, false);\n            if (!handler)\n                return null;\n            if (event.cancelable)\n                throw new Error("not supported");\n            else\n                return handler._FireAsGenerator(event)\n        }\n        SetDelayRemoveEventsEnabled(e) {\n            for (const handler of this._eventHandlers.values())\n                handler.SetDelayRemoveEventsEnabled(e)\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/util\/asyncify.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const SETTIMEOUT_WORK_DURATION = 12;\n    const SETTIMEOUT_INTERVAL = 16;\n    const IDLECALLBACK_TIMEOUT = 35;\n    const SUPPORTS_RIC = typeof requestIdleCallback !== "undefined";\n    let workQueue = [];\n    let callbackId = -1;\n    let highThroughputMode = 0;\n    function SetNewCallback(timerTimeout) {\n        if (SUPPORTS_RIC && highThroughputMode === 0)\n            callbackId = requestIdleCallback(DoAsyncifiedWork, {\n                timeout: IDLECALLBACK_TIMEOUT\n            });\n        else\n            callbackId = setTimeout(DoAsyncifiedWork, highThroughputMode > 0 ? 1 : timerTimeout)\n    }\n    function DoAsyncifiedWork(deadline) {\n        callbackId = -1;\n        if (!workQueue.length)\n            return;\n        let startTime = performance.now();\n        let curTime = startTime;\n        let jobCount = 0;\n        let estimatedNextJobDuration = 0;\n        do {\n            DoNextAsyncifiedJob(workQueue.shift());\n            curTime = performance.now();\n            ++jobCount;\n            estimatedNextJobDuration = (curTime - startTime) \/ jobCount * 1.1\n        } while (workQueue.length && (SUPPORTS_RIC && highThroughputMode === 0 && typeof deadline !== "undefined" ? estimatedNextJobDuration < deadline["timeRemaining"]() : curTime - startTime + estimatedNextJobDuration < SETTIMEOUT_WORK_DURATION));\n        if (callbackId === -1 && workQueue.length) {\n            let workDuration = curTime - startTime;\n            let timeout = Math.max(SETTIMEOUT_INTERVAL - workDuration, 4);\n            SetNewCallback(timeout)\n        }\n    }\n    function DoNextAsyncifiedJob(w) {\n        let ret;\n        try {\n            ret = w.func()\n        } catch (e) {\n            w.reject(e);\n            return\n        }\n        w.resolve(ret)\n    }\n    let asyncifyDisabled = C3.QueryString.Has("disable-asyncify");\n    if (asyncifyDisabled)\n        console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously.");\n    C3.Asyncify = function Asyncify(func) {\n        let stack = null;\n        if (C3.isDebug)\n            stack = C3.GetCallStack();\n        return new Promise( (resolve, reject) => {\n            workQueue.push({\n                func: func,\n                resolve: resolve,\n                reject: reject,\n                stack: stack\n            });\n            if (asyncifyDisabled) {\n                DoNextAsyncifiedJob(workQueue.pop());\n                return\n            }\n            if (callbackId === -1)\n                SetNewCallback(SETTIMEOUT_INTERVAL)\n        }\n        )\n    }\n    ;\n    C3.Asyncify.SetHighThroughputMode = function SetHighThroughputMode(m) {\n        if (m)\n            ++highThroughputMode;\n        else {\n            --highThroughputMode;\n            if (highThroughputMode < 0)\n                throw new Error("already turned off high throughput mode");\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/util\/idleTimeout.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const IDLE_CHECK_MIN_INTERVAL = 1E3;\n    const IDLE_CHECK_TIMER_OVERSHOOT = 100;\n    let cachedNowTime = -1;\n    function ClearTimeCache() {\n        cachedNowTime = -1\n    }\n    C3.FastGetDateNow = function FastGetDateNow() {\n        if (cachedNowTime === -1) {\n            cachedNowTime = Date.now();\n            self.setTimeout(ClearTimeCache, 16)\n        }\n        return cachedNowTime\n    }\n    ;\n    let timerId = -1;\n    let nextDeadline = -1;\n    let activeIdleTimeouts = new Set;\n    function CheckActiveIdleTimeouts() {\n        timerId = -1;\n        nextDeadline = -1;\n        let nowTime = Date.now();\n        for (let i of activeIdleTimeouts)\n            if (i._CheckTimeout(nowTime)) {\n                let deadline = i._GetDeadline();\n                if (nextDeadline === -1 || deadline < nextDeadline)\n                    nextDeadline = deadline\n            } else\n                activeIdleTimeouts.delete(i);\n        if (nextDeadline !== -1) {\n            let duration = Math.max(nextDeadline - nowTime + IDLE_CHECK_TIMER_OVERSHOOT, IDLE_CHECK_MIN_INTERVAL);\n            timerId = self.setTimeout(CheckActiveIdleTimeouts, duration)\n        }\n    }\n    C3.IdleTimeout = class IdleTimeout {\n        constructor(callback, timeoutInSeconds) {\n            this._callback = callback;\n            this._timeout = timeoutInSeconds * 1E3;\n            this._deadline = 0;\n            this._isActive = false\n        }\n        Reset() {\n            let nowTime = C3.FastGetDateNow();\n            this._deadline = nowTime + this._timeout;\n            if (!this._isActive) {\n                activeIdleTimeouts.add(this);\n                this._isActive = true\n            }\n            if (timerId === -1) {\n                nextDeadline = this._deadline;\n                timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + IDLE_CHECK_TIMER_OVERSHOOT)\n            } else if (this._deadline < nextDeadline && nextDeadline > nowTime + IDLE_CHECK_MIN_INTERVAL) {\n                self.clearTimeout(timerId);\n                nextDeadline = this._deadline;\n                timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + IDLE_CHECK_TIMER_OVERSHOOT)\n            }\n        }\n        _CheckTimeout(nowTime) {\n            if (nowTime >= this._deadline) {\n                if (this._callback()) {\n                    this._deadline = nowTime + this._timeout;\n                    return true\n                }\n                this._isActive = false;\n                return false\n            }\n            return true\n        }\n        _GetDeadline() {\n            return this._deadline\n        }\n        Cancel() {\n            if (this._isActive) {\n                activeIdleTimeouts.delete(this);\n                this._isActive = false;\n                if (activeIdleTimeouts.size === 0 && timerId !== -1) {\n                    self.clearTimeout(timerId);\n                    timerId = -1;\n                    nextDeadline = -1\n                }\n            }\n        }\n        Release() {\n            this.Cancel();\n            this._callback = null\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/util\/disposable.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Disposable = class Disposable {\n        constructor(disposeAction) {\n            this._disposed = false;\n            this._disposeAction = disposeAction\n        }\n        Dispose() {\n            if (this._disposed)\n                return;\n            this._disposed = true;\n            if (this._disposeAction) {\n                this._disposeAction();\n                this._disposeAction = null\n            }\n        }\n        IsDisposed() {\n            return this._disposed\n        }\n        Release() {\n            this.Dispose()\n        }\n        static Release(instance) {\n            return new Disposable( () => instance.Release())\n        }\n        static From(eventDispatcher, eventNames, eventHandler, opts, scope) {\n            if (typeof opts === "undefined" || opts === null)\n                opts = false;\n            else if (typeof opts !== "boolean" && typeof opts !== "object")\n                throw new TypeError("invalid event listener options");\n            if (scope)\n                eventHandler = eventHandler.bind(scope);\n            if (eventNames.includes(" ")) {\n                eventNames = eventNames.split(" ");\n                const disposable = new C3.CompositeDisposable;\n                for (let eventName of eventNames) {\n                    eventDispatcher.addEventListener(eventName, eventHandler, opts);\n                    disposable.Add(C3.New(C3.Disposable, () => eventDispatcher.removeEventListener(eventName, eventHandler, opts)))\n                }\n                return disposable\n            } else {\n                eventDispatcher.addEventListener(eventNames, eventHandler, opts);\n                return C3.New(C3.Disposable, () => eventDispatcher.removeEventListener(eventNames, eventHandler, opts))\n            }\n        }\n    }\n    ;\n    C3.StubDisposable = class StubDisposable extends C3.Disposable {\n        SetAction(disposeAction) {\n            this._disposeAction = disposeAction\n        }\n    }\n    ;\n    C3.CompositeDisposable = class CompositeDisposable extends C3.Disposable {\n        constructor(...disposables) {\n            super();\n            this._disposables = new Set;\n            for (let disposable of disposables)\n                this.Add(disposable)\n        }\n        Add(...disposables) {\n            if (this._disposed)\n                throw new Error("already disposed");\n            for (let disposable of disposables)\n                this._disposables.add(disposable)\n        }\n        Remove(disposable) {\n            if (this._disposed)\n                throw new Error("already disposed");\n            this._disposables.delete(disposable)\n        }\n        RemoveAll() {\n            if (this._disposed)\n                throw new Error("already disposed");\n            if (!this._disposables)\n                return;\n            for (let disposable of this._disposables)\n                disposable.Dispose();\n            this._disposables.clear()\n        }\n        IsDisposed() {\n            return this._disposed\n        }\n        Dispose() {\n            if (this._disposed)\n                throw new Error("already disposed");\n            this._disposed = true;\n            for (let disposable of this._disposables)\n                disposable.Dispose();\n            this._disposables.clear();\n            this._disposables = null\n        }\n        Release() {\n            this.Dispose()\n        }\n    }\n    ;\n\n}\n\n\/\/ lib\/util\/kahanSum.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.KahanSum = class KahanSum extends C3.DefendedBase {\n        constructor() {\n            super();\n            this._c = 0;\n            this._y = 0;\n            this._t = 0;\n            this._sum = 0\n        }\n        Add(v) {\n            v = +v;\n            this._y = v - this._c;\n            this._t = this._sum + this._y;\n            this._c = this._t - this._sum - this._y;\n            this._sum = this._t\n        }\n        Subtract(v) {\n            this._sum -= +v\n        }\n        Get() {\n            return this._sum\n        }\n        Reset() {\n            this._c = 0;\n            this._y = 0;\n            this._t = 0;\n            this._sum = 0\n        }\n        Set(s) {\n            this._c = 0;\n            this._y = 0;\n            this._t = 0;\n            this._sum = +s\n        }\n        Copy(ks) {\n            this._c = ks._c;\n            this._y = ks._y;\n            this._t = ks._t;\n            this._sum = ks._sum\n        }\n        Release() {}\n    }\n    ;\n\n}\n\n\/\/ lib\/util\/redblackset.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const js_cols = {};\n    const RED = true;\n    const BLACK = false;\n    js_cols.RBnode = function(tree) {\n        this.tree = tree;\n        this.right = this.tree.sentinel;\n        this.left = this.tree.sentinel;\n        this.parent = null;\n        this.color = false;\n        this.key = null\n    }\n    ;\n    js_cols.RedBlackSet = function(compare_func) {\n        this.size = 0;\n        this.sentinel = new js_cols.RBnode(this);\n        this.sentinel.color = BLACK;\n        this.root = this.sentinel;\n        this.root.parent = this.sentinel;\n        this.compare = compare_func || this.default_compare\n    }\n    ;\n    js_cols.RedBlackSet.prototype.default_compare = function(a, b) {\n        if (a < b)\n            return -1;\n        else if (b < a)\n            return 1;\n        else\n            return 0\n    }\n    ;\n    js_cols.RedBlackSet.prototype.clone = function() {\n        var rv = new js_cols.RedBlackSet(this.compare);\n        rv.insertAll(this);\n        return rv\n    }\n    ;\n    js_cols.RedBlackSet.prototype.clear = function() {\n        this.size = 0;\n        this.sentinel = new js_cols.RBnode(this);\n        this.sentinel.color = BLACK;\n        this.root = this.sentinel;\n        this.root.parent = this.sentinel\n    }\n    ;\n    js_cols.RedBlackSet.prototype.leftRotate = function(x) {\n        var y = x.right;\n        x.right = y.left;\n        if (y.left != this.sentinel)\n            y.left.parent = x;\n        y.parent = x.parent;\n        if (x.parent == this.sentinel)\n            this.root = y;\n        else if (x == x.parent.left)\n            x.parent.left = y;\n        else\n            x.parent.right = y;\n        y.left = x;\n        x.parent = y\n    }\n    ;\n    js_cols.RedBlackSet.prototype.rightRotate = function(x) {\n        var y = x.left;\n        x.left = y.right;\n        if (y.right != this.sentinel)\n            y.right.parent = x;\n        y.parent = x.parent;\n        if (x.parent == this.sentinel)\n            this.root = y;\n        else if (x == x.parent.right)\n            x.parent.right = y;\n        else\n            x.parent.left = y;\n        y.right = x;\n        x.parent = y\n    }\n    ;\n    js_cols.RedBlackSet.prototype.insert = function(key) {\n        if (!this.contains(key)) {\n            var z = new js_cols.RBnode(this);\n            z.key = key;\n            var y = this.sentinel;\n            var x = this.root;\n            while (x != this.sentinel) {\n                y = x;\n                if (this.compare(z.key, x.key) < 0)\n                    x = x.left;\n                else\n                    x = x.right\n            }\n            z.parent = y;\n            if (y == this.sentinel)\n                this.root = z;\n            else if (this.compare(z.key, y.key) < 0)\n                y.left = z;\n            else\n                y.right = z;\n            z.left = this.sentinel;\n            z.right = this.sentinel;\n            z.color = RED;\n            this.insertFixup(z);\n            this.size++\n        } else {\n            var node = this.get_(key);\n            node.key = key\n        }\n    }\n    ;\n    js_cols.RedBlackSet.prototype.insertFixup = function(z) {\n        while (z != this.sentinel && z != this.root && z.parent.color == RED)\n            if (z.parent == z.parent.parent.left) {\n                var y = z.parent.parent.right;\n                if (y.color == RED) {\n                    z.parent.color = BLACK;\n                    y.color = BLACK;\n                    z.parent.parent.color = RED;\n                    z = z.parent.parent\n                } else {\n                    if (z == z.parent.right) {\n                        z = z.parent;\n                        this.leftRotate(z)\n                    }\n                    z.parent.color = BLACK;\n                    z.parent.parent.color = RED;\n                    if (z.parent.parent != this.sentinel)\n                        this.rightRotate(z.parent.parent)\n                }\n            } else {\n                var y = z.parent.parent.left;\n                if (y.color == RED) {\n                    z.parent.color = BLACK;\n                    y.color = BLACK;\n                    z.parent.parent.color = RED;\n                    z = z.parent.parent\n                } else {\n                    if (z == z.parent.left) {\n                        z = z.parent;\n                        this.rightRotate(z)\n                    }\n                    z.parent.color = BLACK;\n                    z.parent.parent.color = RED;\n                    if (z.parent.parent != this.sentinel)\n                        this.leftRotate(z.parent.parent)\n                }\n            }\n        this.root.color = BLACK\n    }\n    ;\n    js_cols.RedBlackSet.prototype.delete_ = function(z) {\n        var y;\n        var x;\n        if (z.left == this.sentinel || z.right == this.sentinel)\n            y = z;\n        else\n            y = this.successor_(z);\n        if (y.left != this.sentinel)\n            x = y.left;\n        else\n            x = y.right;\n        x.parent = y.parent;\n        if (y.parent == this.sentinel)\n            this.root = x;\n        else if (y == y.parent.left)\n            y.parent.left = x;\n        else\n            y.parent.right = x;\n        if (y != z)\n            z.key = y.key;\n        if (y.color == BLACK)\n            this.deleteFixup(x);\n        this.size--\n    }\n    ;\n    js_cols.RedBlackSet.prototype.deleteFixup = function(x) {\n        while (x != this.root && x.color == BLACK)\n            if (x == x.parent.left) {\n                var w = x.parent.right;\n                if (w.color == RED) {\n                    w.color = BLACK;\n                    x.parent.color = RED;\n                    this.leftRotate(x.parent);\n                    w = x.parent.right\n                }\n                if (w.left.color == BLACK && w.right.color == BLACK) {\n                    w.color = RED;\n                    x = x.parent\n                } else {\n                    if (w.right.color == BLACK) {\n                        w.left.color = BLACK;\n                        w.color = RED;\n                        this.rightRotate(w);\n                        w = x.parent.right\n                    }\n                    w.color = x.parent.color;\n                    x.parent.color = BLACK;\n                    w.right.color = BLACK;\n                    this.leftRotate(x.parent);\n                    x = this.root\n                }\n            } else {\n                var w = x.parent.left;\n                if (w.color == RED) {\n                    w.color = BLACK;\n                    x.parent.color = RED;\n                    this.rightRotate(x.parent);\n                    w = x.parent.left\n                }\n                if (w.right.color == BLACK && w.left.color == BLACK) {\n                    w.color = RED;\n                    x = x.parent\n                } else {\n                    if (w.left.color == BLACK) {\n                        w.right.color = BLACK;\n                        w.color = RED;\n                        this.leftRotate(w);\n                        w = x.parent.left\n                    }\n                    w.color = x.parent.color;\n                    x.parent.color = BLACK;\n                    w.left.color = BLACK;\n                    this.rightRotate(x.parent);\n                    x = this.root\n                }\n            }\n        x.color = BLACK\n    }\n    ;\n    js_cols.RedBlackSet.prototype.remove = function(key) {\n        var x = this.get_(key);\n        if (x != this.sentinel) {\n            var retval = x.key;\n            this.delete_(x);\n            return retval\n        } else\n            return null\n    }\n    ;\n    js_cols.RedBlackSet.prototype.removeSwapped = function(value, key) {\n        this.remove(key)\n    }\n    ;\n    js_cols.RedBlackSet.prototype.min = function(x) {\n        while (x.left != this.sentinel)\n            x = x.left;\n        return x\n    }\n    ;\n    js_cols.RedBlackSet.prototype.max = function(x) {\n        while (x.right != this.sentinel)\n            x = x.right;\n        return x\n    }\n    ;\n    js_cols.RedBlackSet.prototype.successor_ = function(x) {\n        if (x.right != this.sentinel)\n            return this.min(x.right);\n        var y = x.parent;\n        while (y != this.sentinel && x == y.right) {\n            x = y;\n            y = y.parent\n        }\n        return y\n    }\n    ;\n    js_cols.RedBlackSet.prototype.predeccessor_ = function(x) {\n        if (x.left != this.sentinel)\n            return this.max(x.left);\n        var y = x.parent;\n        while (y != this.sentinel && x == y.left) {\n            x = y;\n            y = y.parent\n        }\n        return y\n    }\n    ;\n    js_cols.RedBlackSet.prototype.successor = function(key) {\n        if (this.size > 0) {\n            var x = this.get_(key);\n            if (x == this.sentinel)\n                return null;\n            if (x.right != this.sentinel)\n                return this.min(x.right).key;\n            var y = x.parent;\n            while (y != this.sentinel && x == y.right) {\n                x = y;\n                y = y.parent\n            }\n            if (y != this.sentinel)\n                return y.key;\n            else\n                return null\n        } else\n            return null\n    }\n    ;\n    js_cols.RedBlackSet.prototype.predecessor = function(key) {\n        if (this.size > 0) {\n            var x = this.get_(key);\n            if (x == this.sentinel)\n                return null;\n            if (x.left != this.sentinel)\n                return this.max(x.left).key;\n            var y = x.parent;\n            while (y != this.sentinel && x == y.left) {\n                x = y;\n                y = y.parent\n            }\n            if (y != this.sentinel)\n                return y.key;\n            else\n                return null\n        } else\n            return null\n    }\n    ;\n    js_cols.RedBlackSet.prototype.getMin = function() {\n        return this.min(this.root).key\n    }\n    ;\n    js_cols.RedBlackSet.prototype.getMax = function() {\n        return this.max(this.root).key\n    }\n    ;\n    js_cols.RedBlackSet.prototype.get_ = function(key) {\n        var x = this.root;\n        while (x != this.sentinel && this.compare(x.key, key) != 0)\n            if (this.compare(key, x.key) < 0)\n                x = x.left;\n            else\n                x = x.right;\n        return x\n    }\n    ;\n    js_cols.RedBlackSet.prototype.contains = function(key) {\n        return this.get_(key).key != null\n    }\n    ;\n    js_cols.RedBlackSet.prototype.getValues = function() {\n        var ret = [];\n        this.forEach(function(x) {\n            ret.push(x)\n        });\n        return ret\n    }\n    ;\n    js_cols.RedBlackSet.prototype.insertAll = function(col) {\n        if (js_cols.typeOf(col) == "array")\n            for (var i = 0; i < col.length; i++)\n                this.insert(col[i]);\n        else if (js_cols.typeOf(col.forEach) == "function")\n            col.forEach(this.insert, this);\n        else if (js_cols.typeOf(col.getValues) == "function") {\n            var arr = col.getValues();\n            for (var i = 0; i < arr.length; i++)\n                this.insert(arr[i])\n        } else if (js_cols.typeOf(col) == "object")\n            for (var key in col)\n                this.insert(col[key])\n    }\n    ;\n    js_cols.RedBlackSet.prototype.removeAll = function(col) {\n        if (js_cols.typeOf(col) == "array")\n            for (var i = 0; i < col.length; i++)\n                this.remove(col[i]);\n        else if (js_cols.typeOf(col.forEach) == "function")\n            col.forEach(this.removeSwapped, this);\n        else if (js_cols.typeOf(col.getValues) == "function") {\n            var arr = col.getValues();\n            for (var i = 0; i < arr.length; i++)\n                this.remove(arr[i])\n        } else if (js_cols.typeOf(col) == "object")\n            for (var key in col)\n                this.remove(col[key])\n    }\n    ;\n    js_cols.RedBlackSet.prototype.containsAll = function(col) {\n        if (js_cols.typeOf(col) == "array") {\n            for (var i = 0; i < col.length; i++)\n                if (!this.contains(col[i]))\n                    return false;\n            return true\n        } else if (js_cols.typeOf(col.forEach) == "function")\n            return col.every(this.contains, this);\n        else if (js_cols.typeOf(col.getValues) == "function") {\n            var arr = col.getValues();\n            for (var i = 0; i < arr.length; i++)\n                if (!this.contains(arr[i]))\n                    return false;\n            return true\n        } else if (js_cols.typeOf(col) == "object") {\n            for (var key in col)\n                if (!this.contains(col[key]))\n                    return false;\n            return true\n        }\n    }\n    ;\n    js_cols.RedBlackSet.prototype.range = function(from, to) {\n        var retArray = [];\n        this.traverseFromTo(function(x) {\n            retArray.push(x)\n        }, from, to);\n        return retArray\n    }\n    ;\n    js_cols.RedBlackSet.prototype.traverse = function(f, opt_obj) {\n        if (this.isEmpty())\n            return;\n        var node = this.min(this.root);\n        while (node != this.sentinel) {\n            if (f.call(opt_obj, node.key, this))\n                return;\n            node = this.successor_(node)\n        }\n    }\n    ;\n    js_cols.RedBlackSet.prototype.traverseFrom = function(f, fromKey, opt_obj) {\n        if (this.isEmpty())\n            return;\n        var node = this.get_(fromKey);\n        while (node != this.sentinel) {\n            if (f.call(opt_obj, node.key, this))\n                return;\n            node = this.successor_(node)\n        }\n    }\n    ;\n    js_cols.RedBlackSet.prototype.traverseTo = function(f, toKey, opt_obj) {\n        if (this.isEmpty())\n            return;\n        var node = this.min(this.root);\n        var toNode = this.get_(toKey);\n        while (node != toNode) {\n            if (f.call(opt_obj, node.key, this))\n                return;\n            node = this.successor_(node)\n        }\n    }\n    ;\n    js_cols.RedBlackSet.prototype.traverseFromTo = function(f, fromKey, toKey, opt_obj) {\n        if (this.isEmpty())\n            return;\n        var node = this.get_(fromKey);\n        var toNode = this.get_(toKey);\n        while (node != toNode) {\n            if (f.call(opt_obj, node.key, this))\n                return;\n            node = this.successor_(node)\n        }\n    }\n    ;\n    js_cols.RedBlackSet.prototype.traverseBackwards = function(f, opt_obj) {\n        if (this.isEmpty())\n            return;\n        var node = this.max(this.root);\n        while (node != this.sentinel) {\n            if (f.call(opt_obj, node.key, this))\n                return;\n            node = this.predeccessor_(node)\n        }\n    }\n    ;\n    js_cols.RedBlackSet.prototype.forEach = function(f, opt_obj) {\n        if (this.isEmpty())\n            return;\n        for (var n = this.min(this.root); n != this.sentinel; n = this.successor_(n))\n            f.call(opt_obj, n.key, n.key, this)\n    }\n    ;\n    js_cols.RedBlackSet.prototype.some = function(f, opt_obj) {\n        if (this.isEmpty())\n            return false;\n        for (var n = this.min(this.root); n != this.sentinel; n = this.successor_(n))\n            if (f.call(opt_obj, n.key, n.key, this))\n                return true;\n        return false\n    }\n    ;\n    js_cols.RedBlackSet.prototype.every = function(f, opt_obj) {\n        if (this.isEmpty())\n            return false;\n        for (var n = this.min(this.root); n != this.sentinel; n = this.successor_(n))\n            if (!f.call(opt_obj, n.key, n.key, this))\n                return false;\n        return true\n    }\n    ;\n    js_cols.RedBlackSet.prototype.map = function(f, opt_obj) {\n        var rv = [];\n        if (this.isEmpty())\n            return rv;\n        for (var n = this.min(this.root); n != this.sentinel; n = this.successor_(n))\n            rv.push(f.call(opt_obj, n.key, n.key, this));\n        return rv\n    }\n    ;\n    js_cols.RedBlackSet.prototype.filter = function(f, opt_obj) {\n        var rv = [];\n        if (this.isEmpty())\n            return rv;\n        for (var n = this.min(this.root); n != this.sentinel; n = this.successor_(n))\n            if (f.call(opt_obj, n.key, n.key, this))\n                rv.push(n.key);\n        return rv\n    }\n    ;\n    js_cols.RedBlackSet.prototype.getCount = function() {\n        return this.size\n    }\n    ;\n    js_cols.RedBlackSet.prototype.isEmpty = function() {\n        return this.size == 0\n    }\n    ;\n    js_cols.RedBlackSet.prototype.isSubsetOf = function(col) {\n        var colCount = js_cols.getCount(col);\n        if (this.getCount() > colCount)\n            return false;\n        var i = 0;\n        if (this.isEmpty())\n            return true;\n        for (var n = this.min(this.root); n != this.sentinel; n = this.successor_(n))\n            if (js_cols.contains.call(col, col, n.key))\n                i++;\n        return i == this.getCount()\n    }\n    ;\n    js_cols.RedBlackSet.prototype.intersection = function(col) {\n        var result = new js_cols.RedBlackSet(this.compare);\n        if (this.isEmpty())\n            return result;\n        for (var n = this.min(this.root); n != this.sentinel; n = this.successor_(n))\n            if (col.contains.call(col, n.key, n.key, this))\n                result.insert(n.key);\n        return result\n    }\n    ;\n    C3.RedBlackSet = class RedBlackSet extends C3.DefendedBase {\n        constructor(sortFunc) {\n            super();\n            this._rbSet = new js_cols.RedBlackSet(sortFunc);\n            this._enableQueue = false;\n            this._queueInsert = new Set;\n            this._queueRemove = new Set\n        }\n        Add(item) {\n            if (this._enableQueue)\n                if (this._rbSet.contains(item))\n                    this._queueRemove.delete(item);\n                else\n                    this._queueInsert.add(item);\n            else\n                this._rbSet.insert(item)\n        }\n        Remove(item) {\n            if (this._enableQueue)\n                if (this._rbSet.contains(item))\n                    this._queueRemove.add(item);\n                else\n                    this._queueInsert.delete(item);\n            else\n                this._rbSet.remove(item)\n        }\n        Has(item) {\n            if (this._enableQueue) {\n                if (this._queueInsert.has(item))\n                    return true;\n                return !this._queueRemove.has(item) && this._rbSet.contains(item)\n            } else\n                return this._rbSet.contains(item)\n        }\n        Clear() {\n            this._rbSet.clear();\n            this._queueInsert.clear();\n            this._queueRemove.clear()\n        }\n        toArray() {\n            if (this._enableQueue)\n                throw new Error("cannot be used in queueing mode");\n            return this._rbSet.getValues()\n        }\n        GetSize() {\n            return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size\n        }\n        IsEmpty() {\n            return this.GetSize() === 0\n        }\n        Front() {\n            if (this.IsEmpty())\n                throw new Error("empty set");\n            if (this._enableQueue)\n                throw new Error("cannot be used in queueing mode");\n            const rbSet = this._rbSet;\n            const n = rbSet.min(rbSet.root);\n            return n.key\n        }\n        Shift() {\n            if (this.IsEmpty())\n                throw new Error("empty set");\n            if (this._enableQueue)\n                throw new Error("cannot be used in queueing mode");\n            const item = this.Front();\n            this.Remove(item);\n            return item\n        }\n        SetQueueingEnabled(q) {\n            q = !!q;\n            if (this._enableQueue === q)\n                return;\n            this._enableQueue = q;\n            if (!q) {\n                for (const item of this._queueRemove)\n                    this._rbSet.remove(item);\n                this._queueRemove.clear();\n                for (const item of this._queueInsert)\n                    this._rbSet.insert(item);\n                this._queueInsert.clear()\n            }\n        }\n        ForEach(func) {\n            this._rbSet.forEach(func)\n        }\n        *values() {\n            if (this.IsEmpty())\n                return;\n            const rbSet = this._rbSet;\n            for (let n = rbSet.min(rbSet.root); n != rbSet.sentinel; n = rbSet.successor_(n))\n                yield n.key\n        }\n        [Symbol.iterator]() {\n            return this.values()\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/util\/promiseThrottle.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.PromiseThrottle = class PromiseThrottle {\n        constructor(maxParallel=C3.hardwareConcurrency) {\n            this._maxParallel = maxParallel;\n            this._queue = [];\n            this._activeCount = 0\n        }\n        Add(func) {\n            return new Promise( (resolve, reject) => {\n                this._queue.push({\n                    func,\n                    resolve,\n                    reject\n                });\n                this._MaybeStartNext()\n            }\n            )\n        }\n        _FindInQueue(func) {\n            for (let i = 0, len = this._queue.length; i < len; ++i)\n                if (this._queue[i].func === func)\n                    return i;\n            return -1\n        }\n        RemoveAndResolve(func, value) {\n            const i = this._FindInQueue(func);\n            if (i === -1)\n                throw new Error("cannot find promise to resolve");\n            this._queue[i].resolve(value);\n            this._queue.splice(i, 1)\n        }\n        RemoveAndReject(func, value) {\n            const i = this._FindInQueue(func);\n            if (i === -1)\n                throw new Error("cannot find promise to reject");\n            this._queue[i].reject(value);\n            this._queue.splice(i, 1)\n        }\n        async _MaybeStartNext() {\n            if (!this._queue.length)\n                return;\n            if (this._activeCount >= this._maxParallel)\n                return;\n            this._activeCount++;\n            const job = this._queue.shift();\n            try {\n                const result = await job.func();\n                job.resolve(result)\n            } catch (err) {\n                job.reject(err)\n            }\n            this._activeCount--;\n            this._MaybeStartNext()\n        }\n        static async Batch(concurrency, methods) {\n            const results = [];\n            let failed = false;\n            const execute = async _ => {\n                let fn;\n                while (fn = methods.pop()) {\n                    if (failed)\n                        return;\n                    try {\n                        results.push(await fn())\n                    } catch (e) {\n                        failed = true;\n                        throw e;\n                    }\n                }\n            }\n            ;\n            const promises = [];\n            while (concurrency--)\n                promises.push(execute());\n            await Promise.all(promises);\n            return results\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/util\/rateLimiter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.RateLimiter = class RateLimiter {\n        constructor(callback, interval, intervalOnBattery) {\n            this._callback = callback;\n            this._interval = interval;\n            this._intervalOnBattery = intervalOnBattery || interval * 2;\n            this._timerId = -1;\n            this._lastCallTime = -Infinity;\n            this._timerCallFunc = () => this._OnTimer();\n            this._ignoreReset = false;\n            this._canRunImmediate = false;\n            this._callbackArguments = null\n        }\n        SetCanRunImmediate(c) {\n            this._canRunImmediate = !!c\n        }\n        _GetInterval() {\n            if (typeof C3.Battery !== "undefined" && C3.Battery.IsOnBatteryPower())\n                return this._intervalOnBattery;\n            else\n                return this._interval\n        }\n        Call(...args) {\n            if (this._timerId !== -1)\n                return;\n            this._callbackArguments = args;\n            let nowTime = C3.FastGetDateNow();\n            let timeSinceLastCall = nowTime - this._lastCallTime;\n            let interval = this._GetInterval();\n            if (timeSinceLastCall >= interval && this._canRunImmediate) {\n                this._lastCallTime = nowTime;\n                this._RunCallback()\n            } else\n                this._timerId = self.setTimeout(this._timerCallFunc, Math.max(interval - timeSinceLastCall, 4))\n        }\n        _RunCallback() {\n            this._ignoreReset = true;\n            const args = this._callbackArguments;\n            this._callbackArguments = null;\n            if (args)\n                this._callback(...args);\n            else\n                this._callback();\n            this._ignoreReset = false\n        }\n        Reset() {\n            if (this._ignoreReset)\n                return;\n            this._CancelTimer();\n            this._callbackArguments = null;\n            this._lastCallTime = C3.FastGetDateNow()\n        }\n        _OnTimer() {\n            this._timerId = -1;\n            this._lastCallTime = C3.FastGetDateNow();\n            this._RunCallback()\n        }\n        _CancelTimer() {\n            if (this._timerId !== -1) {\n                self.clearTimeout(this._timerId);\n                this._timerId = -1\n            }\n        }\n        Release() {\n            this._CancelTimer();\n            this._callback = null;\n            this._callbackArguments = null;\n            this._timerCallFunc = null\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/util\/svgRaster\/svgRasterManager.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.SVGRasterManager = class SVGRasterManager {\n        constructor() {\n            this._images = new Map;\n            this._allowNpotSurfaces = false;\n            this._getBaseSizeCallback = null;\n            this._rasterAtSizeCallback = null;\n            this._releaseResultCallback = null;\n            this._redrawCallback = null\n        }\n        SetNpotSurfaceAllowed(a) {\n            this._allowNpotSurfaces = !!a\n        }\n        IsNpotSurfaceAllowed() {\n            return this._allowNpotSurfaces\n        }\n        SetGetBaseSizeCallback(f) {\n            this._getBaseSizeCallback = f\n        }\n        GetBaseSize(dataSource) {\n            if (!this._getBaseSizeCallback)\n                throw new Error("no get base size callback set");\n            return this._getBaseSizeCallback(dataSource)\n        }\n        SetRasterAtSizeCallback(f) {\n            this._rasterAtSizeCallback = f\n        }\n        RasterAtSize(dataSource, context, surfaceWidth, surfaceHeight, imageWidth, imageHeight) {\n            if (!this._rasterAtSizeCallback)\n                throw new Error("no raster at size callback set");\n            return this._rasterAtSizeCallback(dataSource, context, surfaceWidth, surfaceHeight, imageWidth, imageHeight)\n        }\n        SetReleaseResultCallback(f) {\n            this._releaseResultCallback = f\n        }\n        ReleaseResult(rasterizedResult) {\n            if (!this._releaseResultCallback)\n                throw new Error("no release result callback set");\n            this._releaseResultCallback(rasterizedResult)\n        }\n        SetRedrawCallback(f) {\n            this._redrawCallback = f\n        }\n        Redraw() {\n            if (!this._redrawCallback)\n                throw new Error("no redraw callback set");\n            this._redrawCallback()\n        }\n        AddImage(dataSource) {\n            let ret = this._images.get(dataSource);\n            if (!ret) {\n                ret = C3.New(C3.SVGRasterImage, this, dataSource);\n                this._images.set(dataSource, ret)\n            }\n            ret.IncReference();\n            return ret\n        }\n        _RemoveImage(ri) {\n            this._images.delete(ri.GetDataSource())\n        }\n        OnTexturesChanged() {\n            for (const ri of this._images.values()) {\n                ri.ReleaseRasterizedResult();\n                ri.ForceRasterAgain()\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/util\/svgRaster\/svgRasterImage.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const MAX_SURFACE_SIZE = 4096;\n    C3.SVGRasterImage = class SVGRasterImage {\n        constructor(manager, dataSource) {\n            this._manager = manager;\n            this._dataSource = dataSource;\n            this._refCount = 0;\n            this._baseWidth = 0;\n            this._baseHeight = 0;\n            this._getBaseSizePromise = this._manager.GetBaseSize(dataSource).then(baseSize => {\n                this._baseWidth = baseSize[0];\n                this._baseHeight = baseSize[1];\n                this._manager.Redraw()\n            }\n            ).catch(err => {\n                console.error("[SVG] Error loading SVG: ", err);\n                this._hadError = true;\n                this._manager.Redraw()\n            }\n            );\n            this._rasterSurfaceWidth = 0;\n            this._rasterSurfaceHeight = 0;\n            this._rasterImageWidth = 0;\n            this._rasterImageHeight = 0;\n            this._isRasterizing = false;\n            this._rasterizedResult = null;\n            this._forceRaster = false;\n            this._hadError = false\n        }\n        Release() {\n            if (this._refCount <= 0)\n                throw new Error("already released");\n            this._refCount--;\n            if (this._refCount === 0)\n                this._Release()\n        }\n        ReleaseRasterizedResult() {\n            if (this._rasterizedResult) {\n                this._manager.ReleaseResult(this._rasterizedResult);\n                this._rasterizedResult = null\n            }\n        }\n        _Release() {\n            this.ReleaseRasterizedResult();\n            this._manager._RemoveImage(this);\n            this._manager = null\n        }\n        GetDataSource() {\n            return this._dataSource\n        }\n        IncReference() {\n            this._refCount++\n        }\n        HasReferences() {\n            return this._refCount > 0\n        }\n        GetRasterizedResult() {\n            return this._rasterizedResult\n        }\n        ForceRasterAgain() {\n            this._forceRaster = true\n        }\n        async StartRasterForSize(context, width, height) {\n            if (width === 0 || height === 0 || this._hadError)\n                return;\n            if (this._isRasterizing)\n                return;\n            let rasterSurfaceWidth = C3.nextHighestPowerOfTwo(Math.ceil(width));\n            let rasterSurfaceHeight = C3.nextHighestPowerOfTwo(Math.ceil(height));\n            const maxDim = Math.max(rasterSurfaceWidth, rasterSurfaceHeight);\n            if (maxDim > MAX_SURFACE_SIZE) {\n                const scale = MAX_SURFACE_SIZE \/ maxDim;\n                width *= scale;\n                height *= scale;\n                rasterSurfaceWidth = Math.min(Math.ceil(rasterSurfaceWidth * scale), MAX_SURFACE_SIZE);\n                rasterSurfaceHeight = Math.min(Math.ceil(rasterSurfaceHeight * scale), MAX_SURFACE_SIZE)\n            }\n            if (width < rasterSurfaceWidth && height < rasterSurfaceHeight) {\n                const imageAspectRatio = width \/ height;\n                const surfaceAspectRatio = rasterSurfaceWidth \/ rasterSurfaceHeight;\n                if (surfaceAspectRatio > imageAspectRatio) {\n                    width = rasterSurfaceHeight * imageAspectRatio;\n                    height = rasterSurfaceHeight\n                } else {\n                    width = rasterSurfaceWidth;\n                    height = rasterSurfaceWidth \/ imageAspectRatio\n                }\n            }\n            if (this._manager.IsNpotSurfaceAllowed()) {\n                rasterSurfaceWidth = Math.ceil(width);\n                rasterSurfaceHeight = Math.ceil(height)\n            }\n            if (rasterSurfaceWidth <= this._rasterSurfaceWidth && rasterSurfaceHeight <= this._rasterSurfaceHeight && !this._forceRaster)\n                return;\n            this._isRasterizing = true;\n            this._rasterSurfaceWidth = rasterSurfaceWidth;\n            this._rasterSurfaceHeight = rasterSurfaceHeight;\n            const newRasterizedResult = await this._manager.RasterAtSize(this._dataSource, context, this._rasterSurfaceWidth, this._rasterSurfaceHeight, width, height);\n            if (!this._manager)\n                return;\n            this.ReleaseRasterizedResult();\n            this._rasterizedResult = newRasterizedResult;\n            this._rasterImageWidth = width;\n            this._rasterImageHeight = height;\n            this._isRasterizing = false;\n            this._forceRaster = false;\n            this._manager.Redraw()\n        }\n        WhenBaseSizeReady() {\n            return this._getBaseSizePromise\n        }\n        GetBaseWidth() {\n            return this._baseWidth\n        }\n        GetBaseHeight() {\n            return this._baseHeight\n        }\n        GetRasterWidth() {\n            return this._rasterImageWidth\n        }\n        GetRasterHeight() {\n            return this._rasterImageHeight\n        }\n        HadError() {\n            return this._hadError\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/str\/str.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.UTF8_BOM = "\\ufeff";\n    const NUMERIC_CHARS = new Set([..."0123456789"]);\n    C3.IsNumericChar = function IsNumericChar(c) {\n        return NUMERIC_CHARS.has(c)\n    }\n    ;\n    const WHITESPACE_CHARS = new Set([..." \\t\\n\\r\\u00a0\\u0085\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u2028\\u2029\\u202f\\u205f\\u3000"]);\n    C3.IsWhitespaceChar = function IsWhitespaceChar(c) {\n        return WHITESPACE_CHARS.has(c)\n    }\n    ;\n    C3.FilterWhitespace = function FilterWhitespace(str) {\n        return [...str].filter(ch => !C3.IsWhitespaceChar(ch)).join("")\n    }\n    ;\n    C3.IsStringAllWhitespace = function IsStringAllWhitespace(str) {\n        for (const ch of str)\n            if (!C3.IsWhitespaceChar(ch))\n                return false;\n        return true\n    }\n    ;\n    C3.IsCharArrayAllWhitespace = function IsStringAllWhitespace(chArr) {\n        for (const ch of chArr)\n            if (!C3.IsWhitespaceChar(ch))\n                return false;\n        return true\n    }\n    ;\n    C3.IsUnprintableChar = function IsUnprintableChar(c) {\n        return c.length === 1 && c.charCodeAt(0) < 32\n    }\n    ;\n    C3.FilterUnprintableChars = function FilterUnprintableChars(str) {\n        return [...str].filter(ch => !C3.IsUnprintableChar(ch)).join("")\n    }\n    ;\n    const NUMERIC_STRING_CHARS = new Set([..."0123456789.+-e"]);\n    C3.IsStringNumber = function IsStringNumber(str) {\n        str = str.trim();\n        if (!str.length)\n            return false;\n        let firstChar = str.charAt(0);\n        if (firstChar !== "-" && !NUMERIC_CHARS.has(firstChar))\n            return false;\n        for (let ch of str)\n            if (!NUMERIC_STRING_CHARS.has(ch))\n                return false;\n        return true\n    }\n    ;\n    C3.RemoveTrailingDigits = function RemoveTrailingDigits(str) {\n        let i = str.length;\n        while (i > 0) {\n            let prev_ch = str.charAt(i - 1);\n            if (!C3.IsNumericChar(prev_ch))\n                break;\n            --i\n        }\n        return str.substr(0, i)\n    }\n    ;\n    C3.IncrementNumberAtEndOf = function IncrementNumberAtEndOf(str) {\n        let baseStr = C3.RemoveTrailingDigits(str);\n        let numberStr = str.substr(baseStr.length);\n        if (numberStr)\n            numberStr = (parseInt(numberStr, 10) + 1).toString();\n        else\n            numberStr = "2";\n        return baseStr + numberStr\n    }\n    ;\n    const HTML_ENTITY_MAP = new Map([["&", "&amp;"], ["<", "&lt;"], [">", "&gt;"], [\'"\', "&quot;"], ["\'", "&#39;"]]);\n    function lookupHtmlEntity(s) {\n        return HTML_ENTITY_MAP.get(s)\n    }\n    const HTML_ENTITY_REGEX = \/[&<>"\']\/g;\n    C3.EscapeHTML = function EscapeHTML(str) {\n        return str.replace(HTML_ENTITY_REGEX, lookupHtmlEntity)\n    }\n    ;\n    C3.EscapeJS = function EscapeJS(str) {\n        let ret = C3.ReplaceAll(str, "\\\\", "\\\\\\\\");\n        ret = C3.ReplaceAll(ret, \'"\', \'\\\\"\');\n        ret = C3.ReplaceAll(ret, "\\t", "\\\\t");\n        ret = C3.ReplaceAll(ret, "\\r", "");\n        return C3.ReplaceAll(ret, "\\n", "\\\\n")\n    }\n    ;\n    C3.EscapeXML = function EscapeXML(str) {\n        let ret = C3.ReplaceAll(str, "&", "&amp;");\n        ret = C3.ReplaceAll(ret, "<", "&lt;");\n        ret = C3.ReplaceAll(ret, ">", "&gt;");\n        return C3.ReplaceAll(ret, \'"\', "&quot;")\n    }\n    ;\n    const ESCAPE_REGEX = \/[-[\\]{}()*+?.,\\\\^$|#\\s]\/g;\n    C3.EscapeRegex = function EscapeRegex(str) {\n        return str.replace(ESCAPE_REGEX, "\\\\$&")\n    }\n    ;\n    C3.FindAll = function FindAll(str, find, matchCase=false) {\n        if (!find)\n            return [];\n        if (!matchCase) {\n            str = str.toLowerCase();\n            find = find.toLowerCase()\n        }\n        const findLen = find.length;\n        let startIndex = 0;\n        let index = 0;\n        let ret = [];\n        while ((index = str.indexOf(find, startIndex)) > -1) {\n            ret.push(index);\n            startIndex = index + findLen\n        }\n        return ret\n    }\n    ;\n    C3.ReplaceAll = function ReplaceAll(str, find, replace) {\n        return str.replaceAll(find, () => replace)\n    }\n    ;\n    C3.ReplaceAllCaseInsensitive = function ReplaceAll(str, find, replace) {\n        return str.replace(new RegExp(C3.EscapeRegex(find),"gi"), () => replace)\n    }\n    ;\n    C3.SetElementContent = function SetElementContent(elem, stringlike) {\n        if (typeof stringlike === "string")\n            elem.textContent = stringlike;\n        else if (stringlike.isPlainText())\n            elem.textContent = stringlike.toString();\n        else {\n            elem.innerHTML = stringlike.toHTML();\n            if (stringlike instanceof C3.BBString)\n                stringlike.attachLinkHandlers(elem)\n        }\n    }\n    ;\n    C3.StringLikeEquals = function StringLikeEquals(a, b) {\n        if (a instanceof C3.HtmlString || a instanceof C3.BBString)\n            return a.equals(b);\n        else if (b instanceof C3.HtmlString || b instanceof C3.BBString)\n            return b.equals(a);\n        else\n            return a === b\n    }\n    ;\n    C3.StringSubstitute = function StringSubstitute(str, ...arr) {\n        let ret = str;\n        for (let i = 0, len = arr.length; i < len; ++i) {\n            const sub = `{${i}}`;\n            if (!str.includes(sub))\n                throw new Error(`missing placeholder \'${sub}\' in string substitution`);\n            ret = ret.replace(sub, arr[i].toString())\n        }\n        return ret\n    }\n    ;\n    C3.StringSubstituteAllowMissing = function StringSubstituteAllowMissing(str, ...arr) {\n        let ret = str;\n        let lowestMissingIndex = -1;\n        let highestUsedIndex = -1;\n        for (let i = 0, len = arr.length; i < len; ++i) {\n            const sub = `{${i}}`;\n            if (str.includes(sub)) {\n                highestUsedIndex = i;\n                ret = ret.replace(sub, arr[i].toString())\n            } else if (lowestMissingIndex === -1)\n                lowestMissingIndex = i\n        }\n        if (lowestMissingIndex >= 0 && highestUsedIndex >= 0 && lowestMissingIndex < highestUsedIndex)\n            throw new Error(`missing placeholder \'${lowestMissingIndex}\' in string substitution`);\n        return ret\n    }\n    ;\n    C3.StringSubstituteMap = function StringSubstituteMap(str, o) {\n        let ret = str;\n        for (let[placeholder,substitution] of Object.entries(o))\n            ret = ret.replaceAll(placeholder, substitution.toString());\n        return ret\n    }\n    ;\n    C3.SortAZ = function SortAZ(a, b) {\n        if (a > b)\n            return 1;\n        else if (a < b)\n            return -1;\n        else\n            return 0\n    }\n    ;\n    C3.SortAZCaseInsensitive = function SortAZCaseInsensitive(a, b) {\n        let lowerA = a.toLowerCase();\n        let lowerB = b.toLowerCase();\n        if (lowerA > lowerB)\n            return 1;\n        else if (lowerA < lowerB)\n            return -1;\n        else\n            return 0\n    }\n    ;\n    let intlSegmenter = null;\n    let graphemeSplitter = null;\n    if (self["Intl"] && self["Intl"]["Segmenter"])\n        intlSegmenter = new self["Intl"]["Segmenter"];\n    else\n        graphemeSplitter = new self.GraphemeSplitter;\n    C3.SplitGraphemes = function SplitGraphemes(str) {\n        if (intlSegmenter) {\n            const ret = [];\n            for (const s of intlSegmenter["segment"](str))\n                ret.push(s["segment"]);\n            return ret\n        } else\n            return graphemeSplitter.splitGraphemes(str)\n    }\n    ;\n    C3.IterateGraphemes = function *IterateGraphemes(str) {\n        if (intlSegmenter)\n            for (const s of intlSegmenter["segment"](str))\n                yield s["segment"];\n        else\n            yield*graphemeSplitter.iterateGraphemes(str)\n    }\n    ;\n    C3.CountGraphemes = function CountGraphemes(str) {\n        if (intlSegmenter) {\n            let ret = 0;\n            for (const s of intlSegmenter["segment"](str))\n                ++ret;\n            return ret\n        } else\n            return graphemeSplitter.countGraphemes(str)\n    }\n    ;\n    const KILOBYTE = 1024;\n    const MEGABYTE = KILOBYTE * 1024;\n    const GIGABYTE = MEGABYTE * 1024;\n    const TERABYTE = GIGABYTE * 1024;\n    C3.FormatDataSize = function FormatDataSize(sizeInBytes, asRate) {\n        let rootKey = "common." + (asRate ? "dataRates" : "dataSizes") + ".";\n        const langSub = self.langSub;\n        if (sizeInBytes < KILOBYTE)\n            return langSub(rootKey + "bytes", sizeInBytes);\n        else if (sizeInBytes < MEGABYTE) {\n            let kb = sizeInBytes \/ KILOBYTE;\n            if (kb < 10)\n                kb = Math.round(kb * 10) \/ 10;\n            else\n                kb = Math.round(kb);\n            return langSub(rootKey + "kilobytes", kb)\n        } else if (sizeInBytes < GIGABYTE) {\n            let mb = sizeInBytes \/ MEGABYTE;\n            if (mb < 10)\n                mb = Math.round(mb * 10) \/ 10;\n            else\n                mb = Math.round(mb);\n            return langSub(rootKey + "megabytes", mb)\n        } else if (sizeInBytes < TERABYTE) {\n            let gb = sizeInBytes \/ GIGABYTE;\n            if (gb < 10)\n                gb = Math.round(gb * 10) \/ 10;\n            else\n                gb = Math.round(gb);\n            return langSub(rootKey + "gigabytes", gb)\n        } else {\n            let tb = sizeInBytes \/ TERABYTE;\n            if (tb < 10)\n                tb = Math.round(tb * 10) \/ 10;\n            else\n                tb = Math.round(tb);\n            return langSub(rootKey + "terabytes", tb)\n        }\n    }\n    ;\n    const DEFAULT_FORMATTIME_OPTS = {\n        approximate: false,\n        days: true,\n        hours: true,\n        minutes: true,\n        seconds: true\n    };\n    C3.FormatTime = function FormatTime(secondsTotal, opts) {\n        opts = Object.assign({}, DEFAULT_FORMATTIME_OPTS, opts);\n        C3.Lang.PushContext("common.time");\n        const parts = [];\n        const lang = self.lang;\n        const langPluralSub = self.langPluralSub;\n        if (opts.days) {\n            const days = Math.floor(secondsTotal \/ (24 * 3600));\n            if (days > 0) {\n                secondsTotal -= days * 24 * 3600;\n                parts.push(langPluralSub(".days", null, days))\n            }\n        }\n        if (opts.hours) {\n            const hours = Math.floor(secondsTotal \/ 3600);\n            if (hours > 0 || parts.length) {\n                secondsTotal -= hours * 3600;\n                parts.push(langPluralSub(".hours", null, hours))\n            }\n        }\n        if (opts.minutes) {\n            const minutes = Math.floor(secondsTotal \/ 60);\n            if (minutes > 0 || parts.length || !opts.seconds) {\n                secondsTotal -= minutes * 60;\n                parts.push(langPluralSub(".minutes", null, minutes))\n            }\n        }\n        if (opts.seconds) {\n            const seconds = Math.floor(secondsTotal % 60);\n            parts.push(langPluralSub(".seconds", null, seconds))\n        }\n        const ret = (opts.approximate ? lang(".approx-prefix") : "") + parts.join(lang(".separator"));\n        C3.Lang.PopContext();\n        return ret\n    }\n    ;\n    C3.ZeroPad = function(n, d) {\n        let s = n < 0 ? "-" : "";\n        n = Math.abs(n);\n        let nStr = n.toString();\n        let zeroes = d - nStr.length;\n        for (let i = 0; i < zeroes; ++i)\n            s += "0";\n        return s + nStr\n    }\n    ;\n    C3.StringToTitleCase = function StringToTitleCase(str) {\n        return str.toLowerCase().replace(\/\\b\\w\/g, t => t.toUpperCase())\n    }\n    ;\n    C3.CompareVersionStrings = function CompareVersionStrings(v1, v2) {\n        let a1 = v1.split(".").map(s => s.trim());\n        let a2 = v2.split(".").map(s => s.trim());\n        C3.resizeArray(a1, 4, "0");\n        C3.resizeArray(a2, 4, "0");\n        a1 = a1.map(s => parseInt(s, 10));\n        a2 = a2.map(s => parseInt(s, 10));\n        for (let i = 0; i < 4; ++i) {\n            const diff = a1[i] - a2[i];\n            if (diff !== 0)\n                return diff < 0 ? -1 : 1\n        }\n        return 0\n    }\n    ;\n    C3.CreateGUID = function CreateGUID() {\n        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(\/[xy]\/g, c => {\n            const r = Math.floor(Math.random() * 16);\n            const v = c === "x" ? r : r & 3 | 8;\n            return v.toString(16)\n        }\n        )\n    }\n    ;\n    C3.StringHammingDistance = function StringHammingDistance(a, b) {\n        if (a.length !== b.length)\n            throw new Error("strings must be same length");\n        let ret = 0;\n        for (let i = 0, len = a.length; i < len; ++i)\n            if (a.charAt(i) !== b.charAt(i))\n                ++ret;\n        return ret\n    }\n    ;\n    C3.StringLevenshteinDistance = function StringLevenshteinDistance(a, b) {\n        if (a.length === 0)\n            return b.length;\n        if (b.length === 0)\n            return a.length;\n        let tmp, i, j, prev, val, row;\n        if (a.length > b.length) {\n            tmp = a;\n            a = b;\n            b = tmp\n        }\n        row = Array(a.length + 1);\n        for (i = 0; i <= a.length; i++)\n            row[i] = i;\n        for (i = 1; i <= b.length; i++) {\n            prev = i;\n            for (j = 1; j <= a.length; j++) {\n                if (b[i - 1] === a[j - 1])\n                    val = row[j - 1];\n                else\n                    val = Math.min(row[j - 1] + 1, Math.min(prev + 1, row[j] + 1));\n                row[j - 1] = prev;\n                prev = val\n            }\n            row[a.length] = prev\n        }\n        return row[a.length]\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/str\/bbstring.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const assert = self.assert;\n    const BB_CODE_MAP = new Map([["b", "strong"], ["i", "em"], ["s", "s"], ["u", "u"], ["sub", "sub"], ["sup", "sup"], ["small", "small"], ["mark", "mark"], ["code", "code"], ["a1", "a"], ["a2", "a"], ["a3", "a"], ["a4", "a"], ["a5", "a"], ["a6", "a"], ["a7", "a"], ["a8", "a"], ["a9", "a"], ["tip1", "abbr"], ["tip2", "abbr"], ["tip3", "abbr"], ["tip4", "abbr"], ["tip5", "abbr"], ["tip6", "abbr"], ["tip7", "abbr"], ["tip8", "abbr"], ["tip9", "abbr"], ["bad", ["span", "bbCodeBad"]], ["good", ["span", "bbCodeGood"]], ["info", ["span", "bbCodeInfo"]], ["h1", ["span", "bbCodeH1"]], ["h2", ["span", "bbCodeH2"]], ["h3", ["span", "bbCodeH3"]], ["h4", ["span", "bbCodeH4"]], ["item", ["span", "bbCodeItem"]]]);\n    const BBREGEX = \/\\[(\\\/?)([a-zA-Z0-9]+)\\]\/g;\n    const CUSTOM_BBREGEX = \/\\[(\\\/?)([^\\[\\n]*?)\\]\/g;\n    let linkActions = null;\n    let tipList = null;\n    let classIndex = 0;\n    function bbToHtmlReplacerFunc(match, closeSlash, tagName) {\n        const entry = BB_CODE_MAP.get(tagName);\n        if (entry)\n            if (typeof entry === "string") {\n                if (entry === "a" && linkActions.length === 0 || entry === "abbr" && tipList.length === 0)\n                    return match;\n                if (entry === "a" && !closeSlash) {\n                    const index = parseInt(tagName.substring(1), 10) - 1;\n                    if (index < 0 || index >= linkActions.length)\n                        throw new Error("invalid bbcode link substitution");\n                    const linkAction = linkActions[index];\n                    if (typeof linkAction === "string")\n                        return `<a href="${linkActions[index]}">`;\n                    else if (typeof linkAction === "function")\n                        return `<a class="bblink${index}">`;\n                    else\n                        throw new TypeError("invalid bbcode link action");\n                } else if (entry === "abbr" && !closeSlash) {\n                    const index = parseInt(tagName.substring(3), 10) - 1;\n                    if (index < 0 || index >= tipList.length)\n                        throw new Error("invalid bbcode tip substitution");\n                    const tip = tipList[index];\n                    let tipStr = "";\n                    if (typeof tip === "string")\n                        tipStr = tip;\n                    else if (typeof tip === "function")\n                        tipStr = tip();\n                    if (typeof tipStr !== "string")\n                        throw new TypeError("invalid bbcode tip");\n                    return `<abbr title="${C3.ReplaceAll(tipStr, \'"\', "&quot;")}">`\n                } else\n                    return "<" + closeSlash + entry + ">"\n            } else if (Array.isArray(entry)) {\n                let tag = entry[0];\n                let className = entry[1];\n                if (closeSlash)\n                    return "<\/" + tag + ">";\n                else\n                    return `<${tag} class="${className}">`\n            } else\n                ;\n        else if (tagName === "class")\n            if (closeSlash)\n                return "<\/span>";\n            else\n                return `<span class="bbclass${classIndex++}">`;\n        else\n            return match\n    }\n    const LINEBREAK_REGEX = \/\\n\/g;\n    C3.BBString = class BBString {\n        constructor(str, opts) {\n            this._bbstr = opts && opts.noEscape ? str : C3.EscapeHTML(str);\n            this._htmlstr = "";\n            this._convertLineBreaks = false;\n            this._linkActions = [];\n            this._tipList = [];\n            if (opts) {\n                this._convertLineBreaks = !!opts.convertLineBreaks;\n                if (opts.links) {\n                    if (opts.links.length > 9)\n                        throw new Error("too many links");\n                    this._linkActions = opts.links\n                }\n                if (opts.tips) {\n                    if (opts.tips.length > 9)\n                        throw new Error("too many tips");\n                    this._tipList = opts.tips\n                }\n            }\n            this._hasAnyBBtags = this._bbstr.includes("[");\n            this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes("\\n");\n            this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion && !this._bbstr.includes("&");\n            this._hasParsedFragments = false;\n            this._fragments = []\n        }\n        toString() {\n            return this._bbstr\n        }\n        valueOf() {\n            return this._bbstr\n        }\n        isPlainText() {\n            return this._isPlain\n        }\n        toPlainText() {\n            if (this._hasAnyBBtags)\n                return this._bbstr.replace(BBREGEX, "");\n            else\n                return this._bbstr\n        }\n        toHTML() {\n            if (this._isPlain)\n                return this._bbstr;\n            if (!this._htmlstr && this._bbstr) {\n                let str = this._bbstr;\n                if (this._hasAnyBBtags) {\n                    classIndex = 0;\n                    linkActions = this._linkActions;\n                    tipList = this._tipList;\n                    str = str.replace(BBREGEX, bbToHtmlReplacerFunc);\n                    linkActions = null;\n                    tipList = null\n                }\n                if (this._needsLineBreakConversion)\n                    str = str.replace(LINEBREAK_REGEX, "<br>");\n                this._htmlstr = str\n            }\n            return this._htmlstr\n        }\n        attachLinkHandlers(parentElem) {\n            if (!this._linkActions.length)\n                return;\n            for (let i = 0, len = this._linkActions.length; i < len; ++i) {\n                const linkAction = this._linkActions[i];\n                if (typeof linkAction !== "function")\n                    continue;\n                const linkElem = parentElem.querySelector(".bblink" + i);\n                if (!linkElem)\n                    throw new Error("unable to attach BBString link handler");\n                linkElem.onclick = linkAction\n            }\n        }\n        equals(s) {\n            if (s instanceof C3.HtmlString)\n                return this.toHTML() === s.toHTML();\n            else if (s instanceof C3.BBString)\n                return this._bbstr === s._bbstr;\n            else\n                return this._bbstr === s\n        }\n        toFragmentList() {\n            if (this._hasParsedFragments)\n                return this._fragments;\n            const bbStr = this._bbstr;\n            const styleStack = [];\n            CUSTOM_BBREGEX.lastIndex = 0;\n            let prevIndex = 0;\n            let result = null;\n            while ((result = CUSTOM_BBREGEX.exec(bbStr)) !== null) {\n                const index = result.index;\n                if (index > 0 && bbStr.charAt(index - 1) === "\\\\")\n                    continue;\n                const matchStr = result[0];\n                const closeSlash = result[1];\n                const tagName = result[2];\n                const strFrag = bbStr.substring(prevIndex, index);\n                prevIndex = index + matchStr.length;\n                if (strFrag)\n                    this._fragments.push({\n                        text: strFrag,\n                        styles: styleStack.slice(0)\n                    });\n                if (!tagName)\n                    continue;\n                if (closeSlash) {\n                    const lowerTagName = tagName.toLowerCase();\n                    for (let i = styleStack.length - 1; i >= 0; --i)\n                        if (styleStack[i].tag === lowerTagName) {\n                            styleStack.splice(i, 1);\n                            break\n                        }\n                } else {\n                    let tag = tagName;\n                    let param = null;\n                    const eq = tagName.indexOf("=");\n                    if (eq !== -1) {\n                        tag = tagName.substring(0, eq).toLowerCase();\n                        param = tagName.substring(eq + 1)\n                    } else\n                        tag = tag.toLowerCase();\n                    styleStack.push({\n                        tag,\n                        param\n                    })\n                }\n            }\n            if (prevIndex < bbStr.length)\n                this._fragments.push({\n                    text: bbStr.substring(prevIndex),\n                    styles: styleStack.slice(0)\n                });\n            for (const frag of this._fragments)\n                frag.text = this._ProcessBBCodeEscapeSequences(frag.text);\n            this._hasParsedFragments = true;\n            return this._fragments\n        }\n        _ProcessBBCodeEscapeSequences(text) {\n            text = C3.ReplaceAll(text, "\\\\[", "[");\n            return C3.ReplaceAll(text, "\\\\\\\\", "\\\\")\n        }\n        static StripTags(str) {\n            return C3.New(C3.BBString, str, {\n                noEscape: true\n            }).toPlainText()\n        }\n        static StripAnyTags(str) {\n            return str.replace(CUSTOM_BBREGEX, "")\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/str\/wordWrap.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    function IsWordBreakWhiteSpace(ch) {\n        if (ch === "\\u00a0" || ch === "\\u202f")\n            return false;\n        else\n            return C3.IsWhitespaceChar(ch)\n    }\n    function WordBreakTrimEnd(chArr) {\n        while (chArr.length > 0 && IsWordBreakWhiteSpace(chArr.at(-1)))\n            chArr.pop()\n    }\n    function IsNewline(ch) {\n        return ch === "\\n" || ch === "\\r\\n"\n    }\n    C3.WordWrap = class WordWrap {\n        constructor() {\n            this._lines = []\n        }\n        GetLines() {\n            return this._lines\n        }\n        GetLineCount() {\n            return this._lines.length\n        }\n        _MeasureLine(line, measureFunc) {\n            let width = 0;\n            let height = 0;\n            let fbbAscent = 0;\n            let fbbDescent = 0;\n            let topToAlphabeticDistance = 0;\n            for (const frag of line) {\n                if (frag.width === -1) {\n                    const m = measureFunc(frag.chArr, frag.styles);\n                    frag.width = m.width;\n                    frag.height = m.height;\n                    frag.fontBoundingBoxAscent = m.fontBoundingBoxAscent || 0;\n                    frag.fontBoundingBoxDescent = m.fontBoundingBoxDescent || 0;\n                    frag.topToAlphabeticDistance = m.topToAlphabeticDistance || 0\n                }\n                width += frag.width;\n                height = Math.max(height, frag.height);\n                fbbAscent = Math.max(fbbAscent, frag.fontBoundingBoxAscent);\n                fbbDescent = Math.max(fbbDescent, frag.fontBoundingBoxDescent);\n                topToAlphabeticDistance = Math.max(topToAlphabeticDistance, frag.topToAlphabeticDistance)\n            }\n            return {\n                width,\n                height,\n                fontBoundingBoxAscent: fbbAscent,\n                fontBoundingBoxDescent: fbbDescent,\n                topToAlphabeticDistance\n            }\n        }\n        _AddLine(fragments, width, height, fbbAscent, fbbDescent, topToAlphabeticDistance) {\n            this._lines.push({\n                fragments,\n                width,\n                height,\n                fontBoundingBoxAscent: fbbAscent,\n                fontBoundingBoxDescent: fbbDescent,\n                topToAlphabeticDistance\n            })\n        }\n        WordWrap(fragmentArr, measureFunc, wrapWidth, wrapMode, endOfLineMargin) {\n            if (typeof fragmentArr === "string")\n                fragmentArr = [{\n                    text: fragmentArr,\n                    styles: []\n                }];\n            C3.clearArray(this._lines);\n            if (!fragmentArr.length || fragmentArr.length === 1 && !fragmentArr[0].text.length || wrapWidth < 2)\n                return;\n            fragmentArr = fragmentArr.map(frag => ({\n                chArr: C3.SplitGraphemes(frag.text),\n                styles: frag.styles\n            }));\n            if (fragmentArr.length === 1) {\n                const frag = fragmentArr[0];\n                const chArr = frag.chArr;\n                const styles = frag.styles;\n                if (chArr.length <= 100 && !chArr.includes("\\n")) {\n                    let {width, height, fontBoundingBoxAscent, fontBoundingBoxDescent, topToAlphabeticDistance} = measureFunc(chArr, styles);\n                    width += endOfLineMargin;\n                    fontBoundingBoxAscent = fontBoundingBoxAscent || 0;\n                    fontBoundingBoxDescent = fontBoundingBoxDescent || 0;\n                    topToAlphabeticDistance = topToAlphabeticDistance || 0;\n                    if (width <= wrapWidth) {\n                        this._AddLine([{\n                            chArr,\n                            styles,\n                            width,\n                            height,\n                            fontBoundingBoxAscent,\n                            fontBoundingBoxDescent,\n                            topToAlphabeticDistance\n                        }], width, height, fontBoundingBoxAscent, fontBoundingBoxDescent, topToAlphabeticDistance);\n                        return\n                    }\n                }\n            }\n            let tokenisedFragments;\n            if (wrapMode === "word")\n                tokenisedFragments = this._TokeniseWords(fragmentArr);\n            else {\n                tokenisedFragments = [];\n                for (const frag of fragmentArr)\n                    C3.appendArray(tokenisedFragments, frag.chArr.map(ch => [{\n                        chArr: [ch],\n                        styles: frag.styles\n                    }]))\n            }\n            this._WrapText(tokenisedFragments, measureFunc, wrapWidth, endOfLineMargin)\n        }\n        _TokeniseWords(fragmentArr) {\n            const ret = [];\n            let curWord = [];\n            let isCurWhitespace = false;\n            for (const frag of fragmentArr) {\n                const chArr = frag.chArr;\n                const styles = frag.styles;\n                for (const ch of chArr)\n                    if (IsNewline(ch)) {\n                        if (curWord.length > 0)\n                            ret.push(curWord);\n                        ret.push([{\n                            chArr: ["\\n"],\n                            styles\n                        }]);\n                        curWord = []\n                    } else if (curWord.length === 0) {\n                        curWord.push({\n                            chArr: [ch],\n                            styles\n                        });\n                        isCurWhitespace = IsWordBreakWhiteSpace(ch)\n                    } else {\n                        const isWhitespace = IsWordBreakWhiteSpace(ch);\n                        if (isWhitespace === isCurWhitespace) {\n                            const curFrag = curWord.at(-1);\n                            if (curFrag.styles === styles)\n                                curFrag.chArr.push(ch);\n                            else\n                                curWord.push({\n                                    chArr: [ch],\n                                    styles\n                                })\n                        } else {\n                            ret.push(curWord);\n                            curWord = [];\n                            curWord.push({\n                                chArr: [ch],\n                                styles\n                            });\n                            isCurWhitespace = isWhitespace\n                        }\n                    }\n            }\n            if (curWord.length > 0)\n                ret.push(curWord);\n            return ret\n        }\n        _CopyLine(line) {\n            return line.map(f => ({\n                chArr: f.chArr.slice(0),\n                styles: f.styles,\n                width: f.width,\n                height: f.height,\n                fontBoundingBoxAscent: f.fontBoundingBoxAscent,\n                fontBoundingBoxDescent: f.fontBoundingBoxDescent,\n                topToAlphabeticDistance: f.topToAlphabeticDistance\n            }))\n        }\n        _AddWordToLine(currentLine, curWord) {\n            const lastFrag = currentLine.length ? currentLine.at(-1) : null;\n            let i = 0;\n            if (lastFrag && curWord[0].styles === lastFrag.styles) {\n                C3.appendArray(lastFrag.chArr, curWord[0].chArr);\n                lastFrag.width = -1;\n                lastFrag.height = -1;\n                lastFrag.fontBoundingBoxAscent = -1;\n                lastFrag.fontBoundingBoxDescent = -1;\n                lastFrag.topToAlphabeticDistance = -1;\n                i = 1\n            }\n            for (let len = curWord.length; i < len; ++i) {\n                const f = curWord[i];\n                currentLine.push({\n                    chArr: f.chArr.slice(0),\n                    styles: f.styles,\n                    width: -1,\n                    height: -1,\n                    fontBoundingBoxAscent: -1,\n                    fontBoundingBoxDescent: -1,\n                    topToAlphabeticDistance: -1\n                })\n            }\n        }\n        _WrapText(tokenisedFragments, measureFunc, wrapWidth, endOfLineMargin) {\n            let currentLine = [];\n            let currentLineWidth = 0;\n            let currentLineHeight = 0;\n            let currentLineFbbAscent = 0;\n            let currentLineFbbDescent = 0;\n            let currentLineTopToAlphabetic = 0;\n            for (const curWord of tokenisedFragments) {\n                if (curWord.length === 1 && curWord[0].chArr.length === 1 && IsNewline(curWord[0].chArr[0])) {\n                    if (currentLineHeight === 0) {\n                        const m = measureFunc([" "], curWord[0].styles);\n                        currentLineHeight = m.height;\n                        currentLineFbbAscent = m.fontBoundingBoxAscent || 0;\n                        currentLineFbbDescent = m.fontBoundingBoxDescent || 0;\n                        currentLineTopToAlphabetic = m.topToAlphabeticDistance || 0\n                    }\n                    this._AddLine(currentLine, currentLineWidth, currentLineHeight, currentLineFbbAscent, currentLineFbbDescent, currentLineTopToAlphabetic);\n                    currentLine = [];\n                    currentLineWidth = 0;\n                    currentLineHeight = 0;\n                    currentLineFbbAscent = 0;\n                    currentLineFbbDescent = 0;\n                    currentLineTopToAlphabetic = 0;\n                    continue\n                }\n                const tryLine = this._CopyLine(currentLine);\n                this._AddWordToLine(tryLine, curWord);\n                const tryMetrics = this._MeasureLine(tryLine, measureFunc);\n                const tryLineWidth = tryMetrics.width;\n                if (tryLineWidth >= wrapWidth) {\n                    if (currentLine.length > 0)\n                        this._AddLine(currentLine, currentLineWidth, currentLineHeight, currentLineFbbAscent, currentLineFbbDescent, currentLineTopToAlphabetic);\n                    currentLine = [];\n                    if (C3.IsCharArrayAllWhitespace(curWord[0].chArr)) {\n                        currentLineWidth = 0;\n                        currentLineHeight = 0;\n                        currentLineFbbAscent = 0;\n                        currentLineFbbDescent = 0;\n                        currentLineTopToAlphabetic = 0\n                    } else {\n                        this._AddWordToLine(currentLine, curWord);\n                        const metrics = this._MeasureLine(currentLine, measureFunc);\n                        currentLineWidth = metrics.width;\n                        currentLineHeight = metrics.height;\n                        currentLineFbbAscent = metrics.fontBoundingBoxAscent;\n                        currentLineFbbDescent = metrics.fontBoundingBoxDescent;\n                        currentLineTopToAlphabetic = metrics.topToAlphabeticDistance\n                    }\n                } else {\n                    currentLine = tryLine;\n                    currentLineWidth = tryLineWidth;\n                    currentLineHeight = tryMetrics.height;\n                    currentLineFbbAscent = tryMetrics.fontBoundingBoxAscent;\n                    currentLineFbbDescent = tryMetrics.fontBoundingBoxDescent;\n                    currentLineTopToAlphabetic = tryMetrics.topToAlphabeticDistance\n                }\n            }\n            if (currentLine.length > 0)\n                this._AddLine(currentLine, currentLineWidth, currentLineHeight, currentLineFbbAscent, currentLineFbbDescent, currentLineTopToAlphabetic);\n            this._TrimLinesTrailingWhitespace(measureFunc, endOfLineMargin)\n        }\n        _TrimLinesTrailingWhitespace(measureFunc, endOfLineMargin) {\n            for (const line of this._lines) {\n                const fragments = line.fragments;\n                if (!fragments.length)\n                    continue;\n                let lastFrag = fragments.at(-1);\n                const chArr = lastFrag.chArr;\n                const trimmedArr = chArr.slice(0);\n                WordBreakTrimEnd(trimmedArr);\n                if (trimmedArr.length === 0) {\n                    line.width -= lastFrag.width;\n                    fragments.pop()\n                } else if (trimmedArr.length < chArr.length) {\n                    const trimmedWidth = measureFunc(trimmedArr, lastFrag.styles).width;\n                    const diff = lastFrag.width - trimmedWidth;\n                    lastFrag.width = trimmedWidth;\n                    lastFrag.chArr = trimmedArr;\n                    line.width -= diff\n                }\n                if (endOfLineMargin !== 0 && fragments.length > 0) {\n                    lastFrag = fragments.at(-1);\n                    lastFrag.width += endOfLineMargin;\n                    line.width += endOfLineMargin\n                }\n            }\n        }\n        Clear() {\n            C3.clearArray(this._lines)\n        }\n        GetMaxLineWidth() {\n            return this._lines.reduce( (a, v) => Math.max(a, v.width), 0)\n        }\n        GetTotalLineHeight() {\n            return this._lines.reduce( (a, v) => a + v.height, 0)\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/gfx.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const glMatrix = self.glMatrix;\n    const vec3 = glMatrix.vec3;\n    const vec4 = glMatrix.vec4;\n    const mat4 = glMatrix.mat4;\n    const tempVec3a = vec3.create();\n    const tempVec3b = vec3.create();\n    const tempVec3c = vec3.create();\n    const tempVec4 = vec4.create();\n    const tempMat4 = mat4.create();\n    const neartl = vec3.create();\n    const neartr = vec3.create();\n    const nearbl = vec3.create();\n    const nearbr = vec3.create();\n    const fartl = vec3.create();\n    const fartr = vec3.create();\n    const farbl = vec3.create();\n    const farbr = vec3.create();\n    const unitViewport = vec4.fromValues(0, 0, 1, 1);\n    C3.Gfx = {\n        Project(objx, objy, objz, mv, proj, viewport, windowCoordinate) {\n            const fTemp0 = mv[0] * objx + mv[4] * objy + mv[8] * objz + mv[12];\n            const fTemp1 = mv[1] * objx + mv[5] * objy + mv[9] * objz + mv[13];\n            const fTemp2 = mv[2] * objx + mv[6] * objy + mv[10] * objz + mv[14];\n            const fTemp3 = mv[3] * objx + mv[7] * objy + mv[11] * objz + mv[15];\n            let fTemp4 = proj[0] * fTemp0 + proj[4] * fTemp1 + proj[8] * fTemp2 + proj[12] * fTemp3;\n            let fTemp5 = proj[1] * fTemp0 + proj[5] * fTemp1 + proj[9] * fTemp2 + proj[13] * fTemp3;\n            let fTemp6 = proj[2] * fTemp0 + proj[6] * fTemp1 + proj[10] * fTemp2 + proj[14] * fTemp3;\n            let fTemp7 = proj[3] * fTemp0 + proj[7] * fTemp1 + proj[11] * fTemp2 + proj[15] * fTemp3;\n            if (fTemp7 === 0)\n                return false;\n            fTemp7 = 1 \/ fTemp7;\n            fTemp4 *= fTemp7;\n            fTemp5 *= fTemp7;\n            fTemp6 *= fTemp7;\n            windowCoordinate[0] = (fTemp4 * .5 + .5) * viewport[2] + viewport[0];\n            windowCoordinate[1] = (fTemp5 * .5 + .5) * viewport[3] + viewport[1];\n            windowCoordinate[2] = (1 + fTemp6) * .5;\n            return true\n        },\n        Unproject(winx, winy, winz, mv, proj, viewport, objectCoordinate) {\n            const A = tempMat4;\n            const vec = tempVec4;\n            mat4.multiply(A, proj, mv);\n            if (mat4.invert(A, A) === null)\n                return false;\n            vec[0] = (winx - viewport[0]) \/ viewport[2] * 2 - 1;\n            vec[1] = (winy - viewport[1]) \/ viewport[3] * 2 - 1;\n            vec[2] = 2 * winz - 1;\n            vec[3] = 1;\n            vec4.transformMat4(vec, vec, A);\n            if (vec[3] === 0)\n                return false;\n            vec[3] = 1 \/ vec[3];\n            objectCoordinate[0] = vec[0] * vec[3];\n            objectCoordinate[1] = vec[1] * vec[3];\n            objectCoordinate[2] = vec[2] * vec[3];\n            return true\n        },\n        UnprojectScreenToWorldZ(winx, winy, worldZ, mv, proj, viewport, objectCoordinate) {\n            const nearPt = tempVec3a;\n            const farPt = tempVec3b;\n            if (!C3.Gfx.Unproject(winx, winy, 0, mv, proj, viewport, nearPt))\n                return false;\n            if (!C3.Gfx.Unproject(winx, winy, 1, mv, proj, viewport, farPt))\n                return false;\n            const dirVec = tempVec3b;\n            vec3.subtract(dirVec, farPt, nearPt);\n            const planeNormal = tempVec3c;\n            vec3.set(planeNormal, 0, 0, 1);\n            const planeConstant = -worldZ;\n            const denominator = vec3.dot(planeNormal, dirVec);\n            let distance = 0;\n            if (denominator === 0) {\n                const planeDistToPt = vec3.dot(planeNormal, nearPt) + planeConstant;\n                if (planeDistToPt !== 0)\n                    return false\n            } else {\n                distance = -(vec3.dot(nearPt, planeNormal) + planeConstant) \/ denominator;\n                if (distance < 0)\n                    return false\n            }\n            vec3.scaleAndAdd(objectCoordinate, nearPt, dirVec, distance);\n            return true\n        }\n    };\n    function PlaneFromPoints(ptA, ptB, ptC, plane) {\n        const normal = tempVec3c;\n        vec3.subtract(tempVec3a, ptC, ptB);\n        vec3.subtract(tempVec3b, ptA, ptB);\n        vec3.cross(normal, tempVec3a, tempVec3b);\n        vec3.normalize(normal, normal);\n        plane.set(normal[0], normal[1], normal[2], vec3.dot(ptA, normal))\n    }\n    function IsInFrontOfPlane(minX, minY, minZ, maxX, maxY, maxZ, plane) {\n        const nx = plane.x;\n        const ny = plane.y;\n        const nz = plane.z;\n        const d = plane.w;\n        const nxT = plane.xF;\n        const nyT = plane.yF;\n        const nzT = plane.zF;\n        const nxF = 1 - nxT;\n        const nyF = 1 - nyT;\n        const nzF = 1 - nzT;\n        const minD = nx * minX * nxT + nx * maxX * nxF + ny * minY * nyT + ny * maxY * nyF + nz * minZ * nzT + nz * maxZ * nzF;\n        if (minD >= d)\n            return true;\n        const maxD = nx * maxX * nxT + nx * minX * nxF + ny * maxY * nyT + ny * minY * nyF + nz * maxZ * nzT + nz * minZ * nzF;\n        return maxD > d\n    }\n    function IsPointInFrontOfPlane(x, y, z, plane) {\n        const nx = plane.x;\n        const ny = plane.y;\n        const nz = plane.z;\n        const d = plane.w;\n        const minD = nx * x + ny * y + nz * z;\n        return minD >= d\n    }\n    class Plane {\n        constructor() {\n            this.x = NaN;\n            this.y = NaN;\n            this.z = NaN;\n            this.w = NaN;\n            this.xF = NaN;\n            this.yF = NaN;\n            this.zF = NaN\n        }\n        set(x, y, z, w) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.w = w;\n            this.xF = x > 0 ? 1 : 0;\n            this.yF = y > 0 ? 1 : 0;\n            this.zF = z > 0 ? 1 : 0\n        }\n    }\n    C3.Gfx.ViewFrustum = class ViewFrustum {\n        constructor() {\n            this._leftP = new Plane;\n            this._topP = new Plane;\n            this._rightP = new Plane;\n            this._bottomP = new Plane;\n            this._nearP = new Plane;\n            this._farP = new Plane\n        }\n        CalculatePlanes(mv, proj) {\n            const vp = unitViewport;\n            C3.Gfx.Unproject(0, 1, 0, mv, proj, vp, neartl);\n            C3.Gfx.Unproject(1, 1, 0, mv, proj, vp, neartr);\n            C3.Gfx.Unproject(0, 0, 0, mv, proj, vp, nearbl);\n            C3.Gfx.Unproject(1, 0, 0, mv, proj, vp, nearbr);\n            C3.Gfx.Unproject(0, 1, 1, mv, proj, vp, fartl);\n            C3.Gfx.Unproject(1, 1, 1, mv, proj, vp, fartr);\n            C3.Gfx.Unproject(0, 0, 1, mv, proj, vp, farbl);\n            C3.Gfx.Unproject(1, 0, 1, mv, proj, vp, farbr);\n            PlaneFromPoints(nearbl, neartl, fartl, this._leftP);\n            PlaneFromPoints(neartl, neartr, fartr, this._topP);\n            PlaneFromPoints(neartr, nearbr, farbr, this._rightP);\n            PlaneFromPoints(nearbr, nearbl, farbl, this._bottomP);\n            PlaneFromPoints(farbl, fartl, fartr, this._farP);\n            PlaneFromPoints(nearbr, neartr, neartl, this._nearP)\n        }\n        ContainsAABB(minX, minY, minZ, maxX, maxY, maxZ) {\n            return IsInFrontOfPlane(minX, minY, minZ, maxX, maxY, maxZ, this._leftP) && IsInFrontOfPlane(minX, minY, minZ, maxX, maxY, maxZ, this._topP) && IsInFrontOfPlane(minX, minY, minZ, maxX, maxY, maxZ, this._rightP) && IsInFrontOfPlane(minX, minY, minZ, maxX, maxY, maxZ, this._bottomP) && IsInFrontOfPlane(minX, minY, minZ, maxX, maxY, maxZ, this._nearP) && IsInFrontOfPlane(minX, minY, minZ, maxX, maxY, maxZ, this._farP)\n        }\n        IsBehindNearPlane(x, y, z) {\n            return !IsPointInFrontOfPlane(x, y, z, this._nearP)\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/rendererBase.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const glMatrix = self.glMatrix;\n    const vec3 = glMatrix.vec3;\n    const vec4 = glMatrix.vec4;\n    const mat4 = glMatrix.mat4;\n    const tempMat4 = mat4.create();\n    const tmpVec3a = vec3.fromValues(0, 0, 0);\n    const tmpVec3b = vec3.fromValues(0, 0, 0);\n    const tmpVec3c = vec3.fromValues(0, 0, 0);\n    const defaultUpVector = vec3.fromValues(0, 1, 0);\n    const tmpVec4 = vec4.fromValues(0, 0, 0, 0);\n    const tmpQuad = new C3.Quad;\n    const tmpRect = new C3.Rect;\n    const defaultTexCoordsQuad = new C3.Quad(0,0,1,0,1,1,0,1);\n    C3.Gfx.RendererBase = class RendererBase {\n        constructor() {\n            this._width = 0;\n            this._height = 0;\n            this._fovY = C3.toRadians(45);\n            this._tan_fovY_2 = Math.tan(this._fovY \/ 2);\n            this._matP = mat4.create();\n            this._matMV = mat4.create();\n            this._zAxisScale = false;\n            this._allShaderPrograms = [];\n            this._shaderProgramsByName = new Map;\n            this._spTextureFill = null;\n            this._spPoints = null;\n            this._spTilemapFill = null;\n            this._spColorFill = null;\n            this._spLinearGradientFill = null;\n            this._spHardEllipseFill = null;\n            this._spHardEllipseOutline = null;\n            this._spSmoothEllipseFill = null;\n            this._spSmoothEllipseOutline = null;\n            this._spSmoothLineFill = null;\n            this._stateGroups = new Map;\n            this._currentStateGroup = null;\n            this._blendModeTable = [];\n            this._namedBlendModeMap = new Map;\n            this._baseZ = 0;\n            this._currentZ = 0;\n            this._lineWidth = 1;\n            this._lineWidthStack = [this._lineWidth];\n            this._lineCap = 1;\n            this._lineCapStack = [this._lineCap];\n            this._lineOffset = .5;\n            this._lineOffsetStack = [this._lineOffset];\n            this._frameNumber = 0;\n            this._enableMipmaps = true;\n            this._hasMajorPerformanceCaveat = false\n        }\n        FillIndexBufferData(indexData) {\n            let i = 0\n              , len = indexData.length\n              , fv = 0;\n            while (i < len) {\n                indexData[i++] = fv;\n                indexData[i++] = fv + 1;\n                indexData[i++] = fv + 2;\n                indexData[i++] = fv;\n                indexData[i++] = fv + 2;\n                indexData[i++] = fv + 3;\n                fv += 4\n            }\n        }\n        _ClearState() {\n            this._baseZ = 0;\n            this._currentZ = 0;\n            this._spTextureFill = null;\n            this._spPoints = null;\n            this._spTilemapFill = null;\n            this._spColorFill = null;\n            this._spLinearGradientFill = null;\n            this._spHardEllipseFill = null;\n            this._spHardEllipseOutline = null;\n            this._spSmoothEllipseFill = null;\n            this._spSmoothEllipseOutline = null;\n            this._spSmoothLineFill = null;\n            this._ClearAllShaderPrograms()\n        }\n        InitState() {\n            this._ClearState();\n            this._currentStateGroup = null\n        }\n        OnDeviceOrContextLost() {\n            for (const s of this._allShaderPrograms)\n                s.Release();\n            this._ClearState()\n        }\n        GetWidth() {\n            return this._width\n        }\n        GetHeight() {\n            return this._height\n        }\n        GetDefaultCameraZ(viewH) {\n            if (this.IsZAxisScaleNormalized())\n                return 100;\n            else\n                return viewH \/ (2 * this._GetTanFovYDiv2())\n        }\n        GetZAxisScaleFactor(viewH) {\n            if (this.IsZAxisScaleNormalized()) {\n                const realZunits = viewH \/ (2 * this._GetTanFovYDiv2());\n                return realZunits \/ this.GetDefaultCameraZ(viewH)\n            } else\n                return 1\n        }\n        GetNearZ() {\n            return 1\n        }\n        GetFarZ() {\n            return 1E4\n        }\n        SetFovY(f) {\n            this._fovY = f;\n            this._tan_fovY_2 = Math.tan(this._fovY \/ 2)\n        }\n        GetFovY() {\n            return this._fovY\n        }\n        _GetTanFovYDiv2() {\n            return this._tan_fovY_2\n        }\n        SetZAxisScaleNormalized() {\n            this._zAxisScale = false\n        }\n        SetZAxisScaleRegular() {\n            this._zAxisScale = true\n        }\n        IsZAxisScaleNormalized() {\n            return !this._zAxisScale\n        }\n        IsZAxisScaleRegular() {\n            return this._zAxisScale\n        }\n        CalculatePerspectiveMatrix(outMat, aspect, vpX=.5, vpY=.5) {\n            const zNear = this.GetNearZ();\n            const zFar = this.GetFarZ();\n            const fovY = this.GetFovY();\n            if (vpX === .5 && vpY === .5)\n                if (this.IsWebGPU())\n                    mat4.perspectiveZO(outMat, fovY, aspect, zNear, zFar);\n                else\n                    mat4.perspective(outMat, fovY, aspect, zNear, zFar);\n            else {\n                vpX = 1 - vpX;\n                const fLeft = vpX * 2 - 2;\n                const fRight = vpX * 2;\n                const fBottom = vpY * 2 - 2;\n                const fTop = vpY * 2;\n                const fH = this._GetTanFovYDiv2() * zNear;\n                const fW = fH * aspect;\n                mat4.frustum(outMat, fLeft * fW, fRight * fW, fBottom * fH, fTop * fH, zNear, zFar)\n            }\n        }\n        CalculateOrthographicMatrix(outMat, width, height, scale=1) {\n            const dpr = self.devicePixelRatio;\n            const worldScale = this.GetDefaultCameraZ(height) * 2 * dpr * this._GetTanFovYDiv2() \/ height;\n            const hScaleX = width * worldScale \/ (2 * dpr * scale);\n            const hScaleY = height * worldScale \/ (2 * dpr * scale);\n            const left = -hScaleX;\n            const right = hScaleX;\n            const bottom = -hScaleY;\n            const top = hScaleY;\n            if (this.IsWebGPU())\n                mat4.orthoZO(outMat, left, right, bottom, top, this.GetNearZ(), this.GetFarZ());\n            else\n                mat4.ortho(outMat, left, right, bottom, top, this.GetNearZ(), this.GetFarZ())\n        }\n        CalculateLookAtModelView(outMat, cam, look, up, viewH, zScale=1) {\n            let worldScale = 1;\n            if (this.IsZAxisScaleNormalized())\n                worldScale = 200 * this._GetTanFovYDiv2() \/ viewH;\n            const worldScaleVec3 = tmpVec3c;\n            vec3.set(worldScaleVec3, worldScale, -worldScale, 1);\n            const tmpCam = tmpVec3a;\n            const tmpLook = tmpVec3b;\n            vec3.multiply(tmpCam, cam, worldScaleVec3);\n            vec3.multiply(tmpLook, look, worldScaleVec3);\n            mat4.lookAt(outMat, tmpCam, tmpLook, up || defaultUpVector);\n            worldScaleVec3[2] = zScale;\n            mat4.scale(outMat, outMat, worldScaleVec3)\n        }\n        CalculateLookAtModelView2(camX, camY, camZ, lookX, lookY, lookZ, viewH, zScale) {\n            vec3.set(tmpVec3a, camX, camY, camZ);\n            vec3.set(tmpVec3b, lookX, lookY, lookZ);\n            this.CalculateLookAtModelView(tempMat4, tmpVec3a, tmpVec3b, defaultUpVector, viewH, zScale);\n            return tempMat4\n        }\n        _AddShaderProgram(sp) {\n            this._allShaderPrograms.push(sp);\n            this._shaderProgramsByName.set(sp.GetName(), sp)\n        }\n        _RemoveShaderProgram(sp) {\n            const i = this._allShaderPrograms.indexOf(sp);\n            if (i !== -1)\n                this._allShaderPrograms.splice(i, 1);\n            this._shaderProgramsByName.delete(sp.GetName())\n        }\n        _ClearAllShaderPrograms() {\n            C3.clearArray(this._allShaderPrograms);\n            this._shaderProgramsByName.clear()\n        }\n        GetShaderProgramByName(name) {\n            return this._shaderProgramsByName.get(name) || null\n        }\n        GetTextureFillShaderProgram() {\n            return this._spTextureFill\n        }\n        SetTextureFillMode() {\n            this.SetProgram(this._spTextureFill)\n        }\n        GetPointsRenderingProgram() {\n            return this._spPoints\n        }\n        SetPointsRenderingProgram() {\n            this.SetProgram(this._spPoints)\n        }\n        SetTilemapFillMode() {\n            this.SetProgram(this._spTilemapFill)\n        }\n        SetColorFillMode() {\n            this.SetProgram(this._spColorFill)\n        }\n        SetLinearGradientFillMode() {\n            this.SetProgram(this._spLinearGradientFill)\n        }\n        SetHardEllipseFillMode() {\n            this.SetProgram(this._spHardEllipseFill)\n        }\n        SetHardEllipseOutlineMode() {\n            this.SetProgram(this._spHardEllipseOutline)\n        }\n        SetSmoothEllipseFillMode() {\n            this.SetProgram(this._spSmoothEllipseFill)\n        }\n        SetSmoothEllipseOutlineMode() {\n            this.SetProgram(this._spSmoothEllipseOutline)\n        }\n        SetSmoothLineFillMode() {\n            this.SetProgram(this._spSmoothLineFill)\n        }\n        _SetCurrentStateGroup(sg) {\n            this._currentStateGroup = sg\n        }\n        GetCurrentStateGroup() {\n            return this._currentStateGroup\n        }\n        AcquireStateGroup(shaderProgram_or_name, blendMode, color, zElevation) {\n            const key = C3.Gfx.StateGroup.MakeKey(shaderProgram_or_name, blendMode, color, zElevation);\n            let stateGroup = this._stateGroups.get(key);\n            if (!stateGroup) {\n                stateGroup = C3.New(C3.Gfx.StateGroup, this, shaderProgram_or_name, blendMode, color, zElevation);\n                this._stateGroups.set(key, stateGroup)\n            }\n            stateGroup.AddRef();\n            return stateGroup\n        }\n        ReleaseStateGroup(stateGroup) {\n            stateGroup.DecRef();\n            if (stateGroup._GetRefCount() === 0) {\n                if (this._currentStateGroup === stateGroup)\n                    this._currentStateGroup = null;\n                this._stateGroups.delete(stateGroup.GetKey());\n                stateGroup.Release()\n            }\n        }\n        _InitBlendModeData(blendModeData) {\n            C3.clearArray(this._blendModeTable);\n            this._namedBlendModeMap.clear();\n            let number = 0;\n            for (const bmd of blendModeData) {\n                const name = bmd[0];\n                const srcBlend = bmd[1];\n                const destBlend = bmd[2];\n                this._blendModeTable.push([srcBlend, destBlend]);\n                this._namedBlendModeMap.set(name, {\n                    number,\n                    srcBlend,\n                    destBlend\n                });\n                number++\n            }\n        }\n        _GetBlendByIndex(blendIndex) {\n            return this._blendModeTable[blendIndex]\n        }\n        GetSrcBlendByIndex(blendIndex) {\n            return this._GetBlendByIndex(blendIndex)[0]\n        }\n        GetDestBlendByIndex(blendIndex) {\n            return this._GetBlendByIndex(blendIndex)[1]\n        }\n        GetNamedBlend(blendName) {\n            const ret = this._namedBlendModeMap.get(blendName);\n            if (typeof ret === "undefined")\n                throw new Error("invalid blend name");\n            return ret\n        }\n        NamedBlendToNumber(blendName) {\n            const ret = this._namedBlendModeMap.get(blendName);\n            if (typeof ret === "undefined")\n                throw new Error("invalid blend name");\n            return ret.number\n        }\n        SetBaseZ(z) {\n            this._baseZ = z\n        }\n        GetBaseZ() {\n            return this._baseZ\n        }\n        SetCurrentZ(z) {\n            this._currentZ = z;\n            this._currentStateGroup = null\n        }\n        GetCurrentZ() {\n            return this._currentZ\n        }\n        Line(x1, y1, x2, y2) {\n            const a = C3.angleTo(x1, y1, x2, y2);\n            const sin_a = Math.sin(a);\n            const cos_a = Math.cos(a);\n            const halfLineWidth = this._lineWidth * .5;\n            const sin_a_hlw = sin_a * halfLineWidth;\n            const cos_a_hlw = cos_a * halfLineWidth;\n            const lineCap = this._lineCap;\n            if (lineCap === 2)\n                this.LinePreCalc_LineCap2(x1, y1, 0, x2, y2, 0, sin_a_hlw, cos_a_hlw);\n            else if (lineCap === 1)\n                this.LinePreCalc_LineCap1(x1, y1, 0, x2, y2, 0, sin_a_hlw, cos_a_hlw);\n            else\n                this.LinePreCalc_LineCap0(x1, y1, 0, x2, y2, 0, sin_a_hlw, cos_a_hlw)\n        }\n        Line3D(x1, y1, z1, x2, y2, z2) {\n            const a = C3.angleTo(x1, y1, x2, y2);\n            const sin_a = Math.sin(a);\n            const cos_a = Math.cos(a);\n            const halfLineWidth = this._lineWidth * .5;\n            const sin_a_hlw = sin_a * halfLineWidth;\n            const cos_a_hlw = cos_a * halfLineWidth;\n            const lineCap = this._lineCap;\n            if (lineCap === 2)\n                this.LinePreCalc_LineCap2(x1, y1, z1, x2, y2, z2, sin_a_hlw, cos_a_hlw);\n            else if (lineCap === 1)\n                this.LinePreCalc_LineCap1(x1, y1, z1, x2, y2, z2, sin_a_hlw, cos_a_hlw);\n            else\n                this.LinePreCalc_LineCap0(x1, y1, z1, x2, y2, z2, sin_a_hlw, cos_a_hlw)\n        }\n        LinePreCalc_LineCap2(x1, y1, z1, x2, y2, z2, sin_a_hlw, cos_a_hlw) {\n            const lineOffset = this._lineOffset;\n            const startX = x1 + lineOffset - cos_a_hlw;\n            const startY = y1 + lineOffset - sin_a_hlw;\n            const endX = x2 + lineOffset + cos_a_hlw;\n            const endY = y2 + lineOffset + sin_a_hlw;\n            const cos_a_lw = cos_a_hlw * 2;\n            const sin_a_lw = sin_a_hlw * 2;\n            const tlx = startX + sin_a_hlw;\n            const tly = startY - cos_a_hlw;\n            const blx = startX - sin_a_hlw + cos_a_lw;\n            const bly = startY + cos_a_hlw + sin_a_lw;\n            const trx = endX + sin_a_hlw;\n            const try_ = endY - cos_a_hlw;\n            const brx = endX - sin_a_hlw - cos_a_lw;\n            const bry = endY + cos_a_hlw - sin_a_lw;\n            this.Quad3D2(tlx, tly, z1, trx, try_, z2, brx, bry, z2, blx, bly, z1, defaultTexCoordsQuad)\n        }\n        LinePreCalc_LineCap1(x1, y1, z1, x2, y2, z2, sin_a_hlw, cos_a_hlw) {\n            const lineOffset = this._lineOffset;\n            const startX = x1 + lineOffset - cos_a_hlw;\n            const startY = y1 + lineOffset - sin_a_hlw;\n            const endX = x2 + lineOffset + cos_a_hlw;\n            const endY = y2 + lineOffset + sin_a_hlw;\n            const tlx = startX + sin_a_hlw;\n            const tly = startY - cos_a_hlw;\n            const blx = startX - sin_a_hlw;\n            const bly = startY + cos_a_hlw;\n            const trx = endX + sin_a_hlw;\n            const try_ = endY - cos_a_hlw;\n            const brx = endX - sin_a_hlw;\n            const bry = endY + cos_a_hlw;\n            this.Quad3D2(tlx, tly, z1, trx, try_, z2, brx, bry, z2, blx, bly, z1, defaultTexCoordsQuad)\n        }\n        LinePreCalc_LineCap0(x1, y1, z1, x2, y2, z2, sin_a_hlw, cos_a_hlw) {\n            const lineOffset = this._lineOffset;\n            const startX = x1 + lineOffset;\n            const startY = y1 + lineOffset;\n            const endX = x2 + lineOffset;\n            const endY = y2 + lineOffset;\n            const tlx = startX + sin_a_hlw;\n            const tly = startY - cos_a_hlw;\n            const blx = startX - sin_a_hlw;\n            const bly = startY + cos_a_hlw;\n            const trx = endX + sin_a_hlw;\n            const try_ = endY - cos_a_hlw;\n            const brx = endX - sin_a_hlw;\n            const bry = endY + cos_a_hlw;\n            this.Quad3D2(tlx, tly, z1, trx, try_, z2, brx, bry, z2, blx, bly, z1, defaultTexCoordsQuad)\n        }\n        TexturedLine(x1, y1, x2, y2, u, v) {\n            const a = C3.angleTo(x1, y1, x2, y2);\n            const sin_a = Math.sin(a);\n            const cos_a = Math.cos(a);\n            const halfLineWidth = this._lineWidth * .5;\n            const sin_a_hlw = sin_a * halfLineWidth;\n            const cos_a_hlw = cos_a * halfLineWidth;\n            const lineCap = this._lineCap;\n            if (lineCap === 2)\n                this.TexturedLinePreCalc_LineCap2(x1, y1, x2, y2, sin_a_hlw, cos_a_hlw, u, v);\n            else if (lineCap === 1)\n                this.TexturedLinePreCalc_LineCap1(x1, y1, x2, y2, sin_a_hlw, cos_a_hlw, u, v);\n            else\n                this.TexturedLinePreCalc_LineCap0(x1, y1, x2, y2, sin_a_hlw, cos_a_hlw, u, v)\n        }\n        TexturedLinePreCalc_LineCap2(x1, y1, x2, y2, sin_a_hlw, cos_a_hlw, u, v) {\n            const lineOffset = this._lineOffset;\n            const startX = x1 + lineOffset - cos_a_hlw;\n            const startY = y1 + lineOffset - sin_a_hlw;\n            const endX = x2 + lineOffset + cos_a_hlw;\n            const endY = y2 + lineOffset + sin_a_hlw;\n            const cos_a_lw = cos_a_hlw * 2;\n            const sin_a_lw = sin_a_hlw * 2;\n            const tlx = startX + sin_a_hlw;\n            const tly = startY - cos_a_hlw;\n            const blx = startX - sin_a_hlw + cos_a_lw;\n            const bly = startY + cos_a_hlw + sin_a_lw;\n            const trx = endX + sin_a_hlw;\n            const try_ = endY - cos_a_hlw;\n            const brx = endX - sin_a_hlw - cos_a_lw;\n            const bry = endY + cos_a_hlw - sin_a_lw;\n            tmpQuad.set(tlx, tly, trx, try_, brx, bry, blx, bly);\n            tmpRect.set(u, 0, v, 0);\n            this.Quad3(tmpQuad, tmpRect)\n        }\n        TexturedLinePreCalc_LineCap1(x1, y1, x2, y2, sin_a_hlw, cos_a_hlw, u, v) {\n            const lineOffset = this._lineOffset;\n            const startX = x1 + lineOffset - cos_a_hlw;\n            const startY = y1 + lineOffset - sin_a_hlw;\n            const endX = x2 + lineOffset + cos_a_hlw;\n            const endY = y2 + lineOffset + sin_a_hlw;\n            const tlx = startX + sin_a_hlw;\n            const tly = startY - cos_a_hlw;\n            const blx = startX - sin_a_hlw;\n            const bly = startY + cos_a_hlw;\n            const trx = endX + sin_a_hlw;\n            const try_ = endY - cos_a_hlw;\n            const brx = endX - sin_a_hlw;\n            const bry = endY + cos_a_hlw;\n            tmpQuad.set(tlx, tly, trx, try_, brx, bry, blx, bly);\n            tmpRect.set(u, 0, v, 0);\n            this.Quad3(tmpQuad, tmpRect)\n        }\n        TexturedLinePreCalc_LineCap0(x1, y1, x2, y2, sin_a_hlw, cos_a_hlw, u, v) {\n            const lineOffset = this._lineOffset;\n            const startX = x1 + lineOffset;\n            const startY = y1 + lineOffset;\n            const endX = x2 + lineOffset;\n            const endY = y2 + lineOffset;\n            const tlx = startX + sin_a_hlw;\n            const tly = startY - cos_a_hlw;\n            const blx = startX - sin_a_hlw;\n            const bly = startY + cos_a_hlw;\n            const trx = endX + sin_a_hlw;\n            const try_ = endY - cos_a_hlw;\n            const brx = endX - sin_a_hlw;\n            const bry = endY + cos_a_hlw;\n            tmpQuad.set(tlx, tly, trx, try_, brx, bry, blx, bly);\n            tmpRect.set(u, 0, v, 0);\n            this.Quad3(tmpQuad, tmpRect)\n        }\n        LineRect(left, top, right, bottom) {\n            const halfLineWidth = this._lineWidth * .5;\n            const lineCap = this._lineCap;\n            if (lineCap === 2)\n                this._LineRectPreCalc_LineCap2(left, top, right, bottom, halfLineWidth);\n            else if (lineCap === 1)\n                this._LineRectPreCalc_LineCap1(left, top, right, bottom, halfLineWidth);\n            else\n                this._LineRectPreCalc_LineCap0(left, top, right, bottom, halfLineWidth)\n        }\n        _LineRectPreCalc_LineCap2(left, top, right, bottom, halfLineWidth) {\n            this.LinePreCalc_LineCap2(left, top, 0, right, top, 0, 0, halfLineWidth);\n            this.LinePreCalc_LineCap2(right, top, 0, right, bottom, 0, halfLineWidth, 0);\n            this.LinePreCalc_LineCap2(right, bottom, 0, left, bottom, 0, 0, -halfLineWidth);\n            this.LinePreCalc_LineCap2(left, bottom, 0, left, top, 0, -halfLineWidth, 0)\n        }\n        _LineRectPreCalc_LineCap1(left, top, right, bottom, halfLineWidth) {\n            this.LinePreCalc_LineCap1(left, top, 0, right, top, 0, 0, halfLineWidth);\n            this.LinePreCalc_LineCap1(right, top, 0, right, bottom, 0, halfLineWidth, 0);\n            this.LinePreCalc_LineCap1(right, bottom, 0, left, bottom, 0, 0, -halfLineWidth);\n            this.LinePreCalc_LineCap1(left, bottom, 0, left, top, 0, -halfLineWidth, 0)\n        }\n        _LineRectPreCalc_LineCap0(left, top, right, bottom, halfLineWidth) {\n            this.LinePreCalc_LineCap0(left, top, 0, right, top, 0, 0, halfLineWidth);\n            this.LinePreCalc_LineCap0(right, top, 0, right, bottom, 0, halfLineWidth, 0);\n            this.LinePreCalc_LineCap0(right, bottom, 0, left, bottom, 0, 0, -halfLineWidth);\n            this.LinePreCalc_LineCap0(left, bottom, 0, left, top, 0, -halfLineWidth, 0)\n        }\n        LineRect2(r) {\n            this.LineRect(r.getLeft(), r.getTop(), r.getRight(), r.getBottom())\n        }\n        LineQuad(q) {\n            const a = C3.angleTo(q.getTlx(), q.getTly(), q.getTrx(), q.getTry());\n            const sin_a = Math.sin(a);\n            const cos_a = Math.cos(a);\n            const halfLineWidth = this._lineWidth * .5;\n            const sin_a_hlw = sin_a * halfLineWidth;\n            const cos_a_hlw = cos_a * halfLineWidth;\n            const lineCap = this._lineCap;\n            if (lineCap === 2)\n                this._LineQuadPreCalc_LineCap2(q, sin_a_hlw, cos_a_hlw);\n            else if (lineCap === 1)\n                this._LineQuadPreCalc_LineCap1(q, sin_a_hlw, cos_a_hlw);\n            else\n                this._LineQuadPreCalc_LineCap0(q, sin_a_hlw, cos_a_hlw)\n        }\n        _LineQuadPreCalc_LineCap2(q, sin_a_hlw, cos_a_hlw) {\n            this.LinePreCalc_LineCap2(q.getTlx(), q.getTly(), 0, q.getTrx(), q.getTry(), 0, sin_a_hlw, cos_a_hlw);\n            this.LinePreCalc_LineCap2(q.getTrx(), q.getTry(), 0, q.getBrx(), q.getBry(), 0, cos_a_hlw, -sin_a_hlw);\n            this.LinePreCalc_LineCap2(q.getBrx(), q.getBry(), 0, q.getBlx(), q.getBly(), 0, -sin_a_hlw, -cos_a_hlw);\n            this.LinePreCalc_LineCap2(q.getBlx(), q.getBly(), 0, q.getTlx(), q.getTly(), 0, -cos_a_hlw, sin_a_hlw)\n        }\n        _LineQuadPreCalc_LineCap1(q, sin_a_hlw, cos_a_hlw) {\n            this.LinePreCalc_LineCap1(q.getTlx(), q.getTly(), 0, q.getTrx(), q.getTry(), 0, sin_a_hlw, cos_a_hlw);\n            this.LinePreCalc_LineCap1(q.getTrx(), q.getTry(), 0, q.getBrx(), q.getBry(), 0, cos_a_hlw, -sin_a_hlw);\n            this.LinePreCalc_LineCap1(q.getBrx(), q.getBry(), 0, q.getBlx(), q.getBly(), 0, -sin_a_hlw, -cos_a_hlw);\n            this.LinePreCalc_LineCap1(q.getBlx(), q.getBly(), 0, q.getTlx(), q.getTly(), 0, -cos_a_hlw, sin_a_hlw)\n        }\n        _LineQuadPreCalc_LineCap0(q, sin_a_hlw, cos_a_hlw) {\n            this.LinePreCalc_LineCap0(q.getTlx(), q.getTly(), 0, q.getTrx(), q.getTry(), 0, sin_a_hlw, cos_a_hlw);\n            this.LinePreCalc_LineCap0(q.getTrx(), q.getTry(), 0, q.getBrx(), q.getBry(), 0, cos_a_hlw, -sin_a_hlw);\n            this.LinePreCalc_LineCap0(q.getBrx(), q.getBry(), 0, q.getBlx(), q.getBly(), 0, -sin_a_hlw, -cos_a_hlw);\n            this.LinePreCalc_LineCap0(q.getBlx(), q.getBly(), 0, q.getTlx(), q.getTly(), 0, -cos_a_hlw, sin_a_hlw)\n        }\n        SetLineWidth(n) {\n            this._lineWidth = n;\n            this._lineWidthStack[this._lineWidthStack.length - 1] = n\n        }\n        GetLineWidth() {\n            return this._lineWidth\n        }\n        PushLineWidth(n) {\n            if (this._lineWidthStack.length >= 100)\n                throw new Error("pushed too many line widths - check push\/pop pairs");\n            this._lineWidthStack.push(n);\n            this._lineWidth = n\n        }\n        PopLineWidth() {\n            if (this._lineWidthStack.length <= 1)\n                throw new Error("cannot pop last line width - check push\/pop pairs");\n            this._lineWidthStack.pop();\n            this._lineWidth = this._lineWidthStack.at(-1)\n        }\n        SetLineCapButt() {\n            this._lineCap = 0;\n            this._lineCapStack[this._lineCapStack.length - 1] = 0\n        }\n        SetLineCapSquare() {\n            this._lineCap = 1;\n            this._lineCapStack[this._lineCapStack.length - 1] = 0\n        }\n        SetLineCapZag() {\n            this._lineCap = 2;\n            this._lineCapStack[this._lineCapStack.length - 1] = 0\n        }\n        PushLineCap(type) {\n            if (type === "butt")\n                this.PushLineCapButt();\n            else if (type === "square")\n                this.PushLineCapSquare();\n            else if (type === "zag")\n                this.PushLineCapZag();\n            else\n                throw new Error("invalid line cap");\n        }\n        PushLineCapButt() {\n            if (this._lineCapStack.length >= 100)\n                throw new Error("pushed too many line caps - check push\/pop pairs");\n            this._lineCapStack.push(0);\n            this._lineCap = 0\n        }\n        PushLineCapSquare() {\n            if (this._lineCapStack.length >= 100)\n                throw new Error("pushed too many line caps - check push\/pop pairs");\n            this._lineCapStack.push(1);\n            this._lineCap = 1\n        }\n        PushLineCapZag() {\n            if (this._lineCapStack.length >= 100)\n                throw new Error("pushed too many line caps - check push\/pop pairs");\n            this._lineCapStack.push(2);\n            this._lineCap = 2\n        }\n        PopLineCap() {\n            if (this._lineCapStack.length <= 1)\n                throw new Error("cannot pop last line cap - check push\/pop pairs");\n            this._lineCapStack.pop();\n            this._lineCap = this._lineCapStack.at(-1)\n        }\n        SetLineOffset(n) {\n            this._lineOffset = n;\n            this._lineOffsetStack[this._lineOffsetStack.length - 1] = n\n        }\n        GetLineOffset() {\n            return this._lineOffset\n        }\n        PushLineOffset(n) {\n            if (this._lineOffsetStack.length >= 100)\n                throw new Error("pushed too many line offsets - check push\/pop pairs");\n            this._lineOffsetStack.push(n);\n            this._lineOffset = n\n        }\n        PopLineOffset() {\n            if (this._lineOffsetStack.length <= 1)\n                throw new Error("cannot pop last line offset - check push\/pop pairs");\n            this._lineOffsetStack.pop();\n            this._lineOffset = this._lineOffsetStack.at(-1)\n        }\n        ConvexPoly(pts) {\n            const pts_count = pts.length \/ 2;\n            if (pts_count < 3)\n                throw new Error("need at least 3 points");\n            const tris = pts_count - 2;\n            const last_tri = tris - 1;\n            const p0x = pts[0];\n            const p0y = pts[1];\n            for (let i = 0; i < tris; i += 2) {\n                const i2 = i * 2;\n                const p1x = pts[i2 + 2];\n                const p1y = pts[i2 + 3];\n                const p2x = pts[i2 + 4];\n                const p2y = pts[i2 + 5];\n                if (i === last_tri)\n                    this.Quad2(p0x, p0y, p1x, p1y, p2x, p2y, p2x, p2y);\n                else {\n                    const p3x = pts[i2 + 6];\n                    const p3y = pts[i2 + 7];\n                    this.Quad2(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y)\n                }\n            }\n        }\n        GetNumVertexComponents() {\n            return 3\n        }\n        Finish() {\n            this.EndBatch(true);\n            this._frameNumber++\n        }\n        GetFrameNumber() {\n            return this._frameNumber\n        }\n        IncrementFrameNumber() {\n            this._frameNumber++\n        }\n        SetMipmapsEnabled(e) {\n            this._enableMipmaps = !!e\n        }\n        AreMipmapsEnabled() {\n            return this._enableMipmaps\n        }\n        SetHasMajorPerformanceCaveat(c) {\n            this._hasMajorPerformanceCaveat = !!c\n        }\n        HasMajorPerformanceCaveat() {\n            return this._hasMajorPerformanceCaveat\n        }\n        IsWebGL() {\n            return false\n        }\n        IsWebGPU() {\n            return false\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/shaderProgramBase.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Gfx.ShaderProgramBase = class ShaderProgramBase {\n        constructor(renderer, name, shaderInfo) {\n            this._name = name;\n            this._renderer = renderer;\n            this._extendBoxHorizontal = shaderInfo.extendBoxHorizontal || 0;\n            this._extendBoxVertical = shaderInfo.extendBoxVertical || 0;\n            this._crossSampling = !!shaderInfo.crossSampling;\n            this._mustPreDraw = !!shaderInfo.mustPreDraw;\n            this._preservesOpaqueness = !!shaderInfo.preservesOpaqueness;\n            this._animated = !!shaderInfo.animated;\n            this._blendsBackground = !!shaderInfo.blendsBackground;\n            this._usesDepth = !!shaderInfo.usesDepth;\n            this._usesAnySrcRectOrPixelSize = false;\n            this._needsPostDrawOrExtendBox = this._crossSampling || this._blendsBackground || this._extendBoxHorizontal !== 0 || this._extendBoxVertical !== 0\n        }\n        Release() {\n            this._renderer = null\n        }\n        GetRenderer() {\n            return this._renderer\n        }\n        GetName() {\n            return this._name\n        }\n        ExtendsBox() {\n            return this._extendBoxHorizontal !== 0 || this._extendBoxVertical !== 0\n        }\n        GetBoxExtendHorizontal() {\n            return this._extendBoxHorizontal\n        }\n        GetBoxExtendVertical() {\n            return this._extendBoxVertical\n        }\n        UsesCrossSampling() {\n            return this._crossSampling\n        }\n        MustPreDraw() {\n            return this._mustPreDraw\n        }\n        PreservesOpaqueness() {\n            return this._preservesOpaqueness\n        }\n        IsAnimated() {\n            return this._animated\n        }\n        BlendsBackground() {\n            return this._blendsBackground\n        }\n        UsesDepth() {\n            return this._usesDepth\n        }\n        UsesAnySrcRectOrPixelSize() {\n            return this._usesAnySrcRectOrPixelSize\n        }\n        NeedsPostDrawOrExtendsBox() {\n            return this._needsPostDrawOrExtendBox\n        }\n        UsesIsSrcTexRotated() {\n            return false\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/stateGroup.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Gfx.StateGroup = class StateGroup {\n        constructor(renderer, shaderProgram_or_name, blendMode, color, zElevation) {\n            this._renderer = renderer;\n            this._refCount = 0;\n            this._shaderProgram = null;\n            this._shaderProgramName = "";\n            this._blendMode = blendMode;\n            this._color = C3.New(C3.Color);\n            this._color.set(color);\n            this._zElevation = zElevation;\n            if (typeof shaderProgram_or_name === "string")\n                this._shaderProgramName = shaderProgram_or_name;\n            else {\n                this._shaderProgram = shaderProgram_or_name;\n                this._shaderProgramName = this._shaderProgram.GetName()\n            }\n        }\n        Release() {\n            if (this._refCount > 0)\n                throw new Error("releasing state group still in use");\n            this._renderer = null;\n            this._shaderProgram = null;\n            this._shaderProgramName = ""\n        }\n        Apply() {\n            const renderer = this._renderer;\n            renderer.SetProgram(this._shaderProgram);\n            renderer.SetBlendMode(this._blendMode);\n            renderer.SetColor(this._color);\n            renderer.SetCurrentZ(this._zElevation);\n            renderer._SetCurrentStateGroup(this)\n        }\n        GetKey() {\n            return C3.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation)\n        }\n        AddRef() {\n            ++this._refCount\n        }\n        DecRef() {\n            --this._refCount\n        }\n        _GetRefCount() {\n            return this._refCount\n        }\n        OnContextLost() {\n            this._shaderProgram = null\n        }\n        OnContextRestored(renderer) {\n            this._shaderProgram = renderer.GetShaderProgramByName(this._shaderProgramName);\n            if (!this._shaderProgram)\n                throw new Error("failed to restore shader program");\n        }\n        static MakeKey(shaderProgram_or_name, blendMode, c, zElevation) {\n            const shaderProgramName = typeof shaderProgram_or_name === "string" ? shaderProgram_or_name : shaderProgram_or_name.GetName();\n            return shaderProgramName + "," + blendMode + "," + c.getR() + "," + c.getG() + "," + c.getB() + "," + c.getA() + "," + zElevation\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/mesh.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const tempQuadTex = C3.New(C3.Quad);\n    function interpolateQuad(srcX, srcY, quad) {\n        const qtlx = quad.getTlx();\n        const qtly = quad.getTly();\n        const qtrx = quad.getTrx() - qtlx;\n        const qtry = quad.getTry() - qtly;\n        const qblx = quad.getBlx() - qtlx;\n        const qbly = quad.getBly() - qtly;\n        const xix = qtrx * srcX;\n        const xiy = qtry * srcX;\n        const yix = qblx * srcY;\n        const yiy = qbly * srcY;\n        return [qtlx + xix + yix, qtly + xiy + yiy]\n    }\n    C3.Gfx.MeshPoint = class MeshPoint {\n        constructor(mesh, col, row) {\n            this._mesh = mesh;\n            this._col = col;\n            this._row = row;\n            this._x = NaN;\n            this._y = NaN;\n            this._zElevation = NaN;\n            this._u = NaN;\n            this._v = NaN;\n            this._x = 0;\n            this._y = 0;\n            this._zElevation = 0;\n            this._u = 0;\n            this._v = 0\n        }\n        _Init(x, y, u, v) {\n            this._x = x;\n            this._y = y;\n            this._u = u;\n            this._v = v\n        }\n        GetX() {\n            return this._x\n        }\n        SetX(x) {\n            if (this._x === x)\n                return;\n            this._x = x;\n            this._mesh._SetPointsChanged()\n        }\n        GetY() {\n            return this._y\n        }\n        SetY(y) {\n            if (this._y === y)\n                return;\n            this._y = y;\n            this._mesh._SetPointsChanged()\n        }\n        GetZElevation() {\n            return this._zElevation\n        }\n        SetZElevation(z) {\n            if (this._zElevation === z)\n                return;\n            this._zElevation = Math.max(z, 0);\n            this._mesh._SetPointsChanged()\n        }\n        GetU() {\n            return this._u\n        }\n        SetU(u) {\n            this._u = u\n        }\n        GetV() {\n            return this._v\n        }\n        SetV(v) {\n            this._v = v\n        }\n        _Interpolate_TexRect(srcPoint, quadPos, rcTex) {\n            [this._x,this._y] = interpolateQuad(srcPoint._x, srcPoint._y, quadPos);\n            this._zElevation = srcPoint._zElevation;\n            this._u = C3.lerp(rcTex.getLeft(), rcTex.getRight(), srcPoint._u);\n            this._v = C3.lerp(rcTex.getTop(), rcTex.getBottom(), srcPoint._v)\n        }\n        _Interpolate_TexQuad(srcPoint, quadPos, quadTex) {\n            [this._x,this._y] = interpolateQuad(srcPoint._x, srcPoint._y, quadPos);\n            this._zElevation = srcPoint._zElevation;\n            [this._u,this._v] = interpolateQuad(srcPoint._u, srcPoint._v, quadTex)\n        }\n        SaveToJson() {\n            return {\n                "x": this.GetX(),\n                "y": this.GetY(),\n                "z": this.GetZElevation(),\n                "u": this.GetU(),\n                "v": this.GetV()\n            }\n        }\n        LoadFromJson(o) {\n            this.SetX(o["x"]);\n            this.SetY(o["y"]);\n            if (o.hasOwnProperty("z"))\n                this.SetZElevation(o["z"]);\n            this.SetU(o["u"]);\n            this.SetV(o["v"])\n        }\n        GetMesh() {\n            return this._mesh\n        }\n        GetColumn() {\n            return this._col\n        }\n        GetRow() {\n            return this._row\n        }\n    }\n    ;\n    C3.Gfx.Mesh = class Mesh {\n        constructor(hsize, vsize, owner) {\n            if (hsize < 2 || vsize < 2)\n                throw new Error("invalid mesh size");\n            this._hsize = hsize;\n            this._vsize = vsize;\n            this._owner = owner || null;\n            this._pts = [];\n            this._minX = 0;\n            this._minY = 0;\n            this._maxX = 1;\n            this._maxY = 1;\n            this._maxZ = 0;\n            this._pointsChanged = false;\n            const lastX = hsize - 1;\n            const lastY = vsize - 1;\n            for (let y = 0; y < vsize; ++y) {\n                const row = [];\n                for (let x = 0; x < hsize; ++x) {\n                    const meshPoint = C3.New(C3.Gfx.MeshPoint, this, x, y);\n                    const xf = x \/ lastX;\n                    const yf = y \/ lastY;\n                    meshPoint._Init(xf, yf, xf, yf);\n                    row.push(meshPoint)\n                }\n                this._pts.push(row)\n            }\n        }\n        Release() {\n            C3.clearArray(this._pts)\n        }\n        GetHSize() {\n            return this._hsize\n        }\n        GetVSize() {\n            return this._vsize\n        }\n        GetOwner() {\n            return this._owner\n        }\n        _GetPoints() {\n            return this._pts\n        }\n        _SetPointsChanged() {\n            this._pointsChanged = true\n        }\n        _MaybeComputeBounds() {\n            if (!this._pointsChanged)\n                return;\n            let minX = Infinity;\n            let minY = Infinity;\n            let maxX = -Infinity;\n            let maxY = -Infinity;\n            let maxZ = 0;\n            for (const row of this._pts)\n                for (const meshPoint of row) {\n                    const x = meshPoint.GetX();\n                    const y = meshPoint.GetY();\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                    maxZ = Math.max(maxZ, meshPoint.GetZElevation())\n                }\n            this._minX = minX;\n            this._minY = minY;\n            this._maxX = maxX;\n            this._maxY = maxY;\n            this._maxZ = maxZ;\n            this._pointsChanged = false\n        }\n        GetMinX() {\n            this._MaybeComputeBounds();\n            return this._minX\n        }\n        GetMinY() {\n            this._MaybeComputeBounds();\n            return this._minY\n        }\n        GetMaxX() {\n            this._MaybeComputeBounds();\n            return this._maxX\n        }\n        GetMaxY() {\n            this._MaybeComputeBounds();\n            return this._maxY\n        }\n        GetMaxZ() {\n            this._MaybeComputeBounds();\n            return this._maxZ\n        }\n        HasAnyZElevation() {\n            return this.GetMaxZ() > 0\n        }\n        GetMeshPointAt(x, y) {\n            x = Math.floor(x);\n            y = Math.floor(y);\n            if (x < 0 || x >= this._hsize || y < 0 || y >= this._vsize)\n                return null;\n            return this._pts[y][x]\n        }\n        CalculateTransformedMesh(srcMesh, quadPos, rcTex_or_quad) {\n            const isTexRect = rcTex_or_quad instanceof C3.Rect;\n            if (srcMesh.GetHSize() !== this.GetHSize() || srcMesh.GetVSize() !== this.GetVSize())\n                throw new Error("source mesh wrong size");\n            const srcPts = srcMesh._pts;\n            const destPts = this._pts;\n            for (let y = 0, lenY = destPts.length; y < lenY; ++y) {\n                const srcRow = srcPts[y];\n                const destRow = destPts[y];\n                for (let x = 0, lenX = destRow.length; x < lenX; ++x) {\n                    const srcPoint = srcRow[x];\n                    const destPoint = destRow[x];\n                    if (isTexRect)\n                        destPoint._Interpolate_TexRect(srcPoint, quadPos, rcTex_or_quad);\n                    else\n                        destPoint._Interpolate_TexQuad(srcPoint, quadPos, rcTex_or_quad)\n                }\n            }\n        }\n        Draw(renderer) {\n            const pts = this._pts;\n            let prevRow = pts[0];\n            for (let y = 1, lenY = pts.length; y < lenY; ++y) {\n                const row = pts[y];\n                let tl = prevRow[0];\n                let bl = row[0];\n                for (let x = 1, lenX = row.length; x < lenX; ++x) {\n                    const tr = prevRow[x];\n                    const br = row[x];\n                    tempQuadTex.set(tl.GetU(), tl.GetV(), tr.GetU(), tr.GetV(), br.GetU(), br.GetV(), bl.GetU(), bl.GetV());\n                    renderer.Quad3D2(tl.GetX(), tl.GetY(), tl.GetZElevation(), tr.GetX(), tr.GetY(), tr.GetZElevation(), br.GetX(), br.GetY(), br.GetZElevation(), bl.GetX(), bl.GetY(), bl.GetZElevation(), tempQuadTex);\n                    tl = tr;\n                    bl = br\n                }\n                prevRow = row\n            }\n        }\n        Outline(renderer, transformFunc) {\n            if (!transformFunc)\n                transformFunc = (x, y, z) => [x, y, z];\n            const pts = this._pts;\n            let prevRow = pts[0];\n            for (let y = 1, lenY = pts.length; y < lenY; ++y) {\n                const row = pts[y];\n                let tl = prevRow[0];\n                let bl = row[0];\n                for (let x = 1, lenX = row.length; x < lenX; ++x) {\n                    const tr = prevRow[x];\n                    const br = row[x];\n                    const [tlx,tly,tlz] = transformFunc(tl.GetX(), tl.GetY(), tl.GetZElevation());\n                    const [trx,try_,trz] = transformFunc(tr.GetX(), tr.GetY(), tr.GetZElevation());\n                    const [brx,bry,brz] = transformFunc(br.GetX(), br.GetY(), br.GetZElevation());\n                    const [blx,bly,blz] = transformFunc(bl.GetX(), bl.GetY(), bl.GetZElevation());\n                    renderer.Line3D(tlx, tly, tlz, trx, try_, trz);\n                    renderer.Line3D(tlx, tly, tlz, brx, bry, brz);\n                    renderer.Line3D(tlx, tly, tlz, blx, bly, blz);\n                    if (x === lenX - 1)\n                        renderer.Line3D(trx, try_, trz, brx, bry, brz);\n                    if (y === lenY - 1)\n                        renderer.Line3D(blx, bly, blz, brx, bry, brz);\n                    tl = tr;\n                    bl = br\n                }\n                prevRow = row\n            }\n        }\n        InsertPolyMeshVertices(srcPoly) {\n            const RAY_EXT_DIST = .001;\n            const MIN_RAY_DIST = 0;\n            const MAX_RAY_DIST = .99999999;\n            const inPts = srcPoly.pointsArr();\n            const outPts = [];\n            const colCount = this.GetHSize() - 1;\n            const rowCount = this.GetVSize() - 1;\n            const colWidthNorm = 1 \/ colCount;\n            const rowHeightNorm = 1 \/ rowCount;\n            const lastCol = colCount - 1;\n            const lastRow = rowCount - 1;\n            let curX = inPts[0];\n            let curY = inPts[1];\n            let curCol = C3.clamp(Math.floor(curX * colCount), 0, lastCol);\n            let curRow = C3.clamp(Math.floor(curY * rowCount), 0, lastRow);\n            let isUpper = true;\n            let nextX = 0;\n            let nextY = 0;\n            let rayHit = 0;\n            const NOTHING_DISABLED = -1;\n            const DISABLE_DIAGONAL = 0;\n            const DISABLE_LEFT_EDGE = 1;\n            const DISABLE_TOP_EDGE = 2;\n            const DISABLE_RIGHT_EDGE = 3;\n            const DISABLE_BOTTOM_EDGE = 4;\n            let disableCheck = NOTHING_DISABLED;\n            const addVertexAtRayHit = () => {\n                curX = C3.clamp(C3.lerp(curX, nextX, rayHit), 0, 1);\n                curY = C3.clamp(C3.lerp(curY, nextY, rayHit), 0, 1);\n                outPts.push(curX, curY)\n            }\n            ;\n            for (let i = 0, len = inPts.length; i < len; i += 2) {\n                curX = inPts[i];\n                curY = inPts[i + 1];\n                outPts.push(curX, curY);\n                curCol = C3.clamp(Math.floor(curX * colCount), 0, lastCol);\n                curRow = C3.clamp(Math.floor(curY * rowCount), 0, lastRow);\n                const j = (i + 2) % len;\n                nextX = inPts[j];\n                nextY = inPts[j + 1];\n                disableCheck = NOTHING_DISABLED;\n                while (true) {\n                    if (outPts.length > 1E6)\n                        throw new Error("Too many mesh poly points");\n                    const srcTlx = curCol * colWidthNorm;\n                    const srcTly = curRow * rowHeightNorm;\n                    const srcBrx = (curCol + 1) * colWidthNorm;\n                    const srcBry = (curRow + 1) * rowHeightNorm;\n                    isUpper = C3.isPointInTriangleInclusive(curX, curY, srcTlx, srcTly, srcBrx, srcTly, srcBrx, srcBry);\n                    if (disableCheck !== DISABLE_DIAGONAL) {\n                        rayHit = C3.rayIntersectExtended(curX, curY, nextX, nextY, srcTlx, srcTly, srcBrx, srcBry, -RAY_EXT_DIST);\n                        if (rayHit >= MIN_RAY_DIST && rayHit <= MAX_RAY_DIST) {\n                            addVertexAtRayHit();\n                            isUpper = !isUpper;\n                            disableCheck = DISABLE_DIAGONAL;\n                            continue\n                        }\n                    }\n                    if (curRow > 0 && disableCheck !== DISABLE_TOP_EDGE) {\n                        rayHit = C3.rayIntersectExtended(curX, curY, nextX, nextY, srcTlx, srcTly, srcBrx, srcTly, RAY_EXT_DIST);\n                        if (rayHit >= MIN_RAY_DIST && rayHit <= MAX_RAY_DIST) {\n                            addVertexAtRayHit();\n                            curRow--;\n                            isUpper = false;\n                            disableCheck = DISABLE_BOTTOM_EDGE;\n                            continue\n                        }\n                    }\n                    if (curCol < lastCol && disableCheck !== DISABLE_RIGHT_EDGE) {\n                        rayHit = C3.rayIntersectExtended(curX, curY, nextX, nextY, srcBrx, srcTly, srcBrx, srcBry, RAY_EXT_DIST);\n                        if (rayHit >= MIN_RAY_DIST && rayHit <= MAX_RAY_DIST) {\n                            addVertexAtRayHit();\n                            curCol++;\n                            isUpper = false;\n                            disableCheck = DISABLE_LEFT_EDGE;\n                            continue\n                        }\n                    }\n                    if (curCol > 0 && disableCheck !== DISABLE_LEFT_EDGE) {\n                        rayHit = C3.rayIntersectExtended(curX, curY, nextX, nextY, srcTlx, srcTly, srcTlx, srcBry, RAY_EXT_DIST);\n                        if (rayHit >= MIN_RAY_DIST && rayHit <= MAX_RAY_DIST) {\n                            addVertexAtRayHit();\n                            curCol--;\n                            isUpper = true;\n                            disableCheck = DISABLE_RIGHT_EDGE;\n                            continue\n                        }\n                    }\n                    if (curRow < lastRow && disableCheck !== DISABLE_BOTTOM_EDGE) {\n                        rayHit = C3.rayIntersectExtended(curX, curY, nextX, nextY, srcTlx, srcBry, srcBrx, srcBry, RAY_EXT_DIST);\n                        if (rayHit >= MIN_RAY_DIST && rayHit <= MAX_RAY_DIST) {\n                            addVertexAtRayHit();\n                            curRow++;\n                            isUpper = true;\n                            disableCheck = DISABLE_TOP_EDGE;\n                            continue\n                        }\n                    }\n                    break\n                }\n            }\n            return C3.New(C3.CollisionPoly, outPts)\n        }\n        TransformCollisionPoly(srcPoly, destPoly) {\n            const ptsArr = this._TransformPolyPoints(srcPoly);\n            this._SimplifyPoly(ptsArr);\n            destPoly.setPoints(ptsArr)\n        }\n        _TransformPolyPoints(srcPoly) {\n            const outPts = [];\n            const ptsArr = srcPoly.pointsArr();\n            for (let i = 0, len = ptsArr.length; i < len; i += 2) {\n                const srcX = ptsArr[i];\n                const srcY = ptsArr[i + 1];\n                const [destX,destY] = this.TransformPoint(srcX, srcY);\n                outPts.push(destX, destY)\n            }\n            return outPts\n        }\n        TransformPoint(srcX, srcY) {\n            const lastCol = this.GetHSize() - 1;\n            const lastRow = this.GetVSize() - 1;\n            const colWidthNorm = 1 \/ lastCol;\n            const rowHeightNorm = 1 \/ lastRow;\n            const srcCol = C3.clamp(Math.floor(srcX * lastCol), 0, lastCol - 1);\n            const srcRow = C3.clamp(Math.floor(srcY * lastRow), 0, lastRow - 1);\n            const srcTlx = srcCol * colWidthNorm;\n            const srcTly = srcRow * rowHeightNorm;\n            const srcBrx = (srcCol + 1) * colWidthNorm;\n            const srcBry = (srcRow + 1) * rowHeightNorm;\n            const destTl = this.GetMeshPointAt(srcCol, srcRow);\n            const destBr = this.GetMeshPointAt(srcCol + 1, srcRow + 1);\n            const isUpper = C3.isPointInTriangleInclusive(srcX, srcY, srcTlx, srcTly, srcBrx, srcTly, srcBrx, srcBry);\n            const srcAltX = isUpper ? srcTlx + colWidthNorm : srcTlx;\n            const srcAltY = isUpper ? srcTly : srcTly + rowHeightNorm;\n            const destAlt = this.GetMeshPointAt(srcCol + (isUpper ? 1 : 0), srcRow + (isUpper ? 0 : 1));\n            const [u,v,w] = C3.triangleCartesianToBarycentric(srcX, srcY, srcTlx, srcTly, srcAltX, srcAltY, srcBrx, srcBry);\n            return C3.triangleBarycentricToCartesian(u, v, w, destTl.GetX(), destTl.GetY(), destAlt.GetX(), destAlt.GetY(), destBr.GetX(), destBr.GetY())\n        }\n        _SimplifyPoly(ptsArr) {\n            const outPts = [];\n            const EPSILON = 1E-7;\n            let curX = ptsArr[0];\n            let curY = ptsArr[1];\n            let lastDx = curX - ptsArr.at(-2);\n            let lastDy = curY - ptsArr.at(-1);\n            for (let i = 0, len = ptsArr.length; i < len; i += 2) {\n                const j = (i + 2) % len;\n                const nextX = ptsArr[j];\n                const nextY = ptsArr[j + 1];\n                const dx = nextX - curX;\n                const dy = nextY - curY;\n                const bothXNearZero = Math.abs(dx) < EPSILON && Math.abs(lastDx) < EPSILON && Math.sign(dy) === Math.sign(lastDy);\n                const bothYNearZero = Math.abs(dy) < EPSILON && Math.abs(lastDy) < EPSILON && Math.sign(dx) === Math.sign(lastDx);\n                if (!bothXNearZero && !bothYNearZero && Math.abs(dx \/ lastDx - dy \/ lastDy) > EPSILON || dx == 0 && dy === 0)\n                    outPts.push(curX, curY);\n                curX = nextX;\n                curY = nextY;\n                lastDx = dx;\n                lastDy = dy\n            }\n            if (outPts.length >= 6 && outPts.length < ptsArr.length)\n                C3.shallowAssignArray(ptsArr, outPts)\n        }\n        SaveToJson() {\n            return {\n                "cols": this.GetHSize(),\n                "rows": this.GetVSize(),\n                "points": this._pts.map(row => row.map(pt => pt.SaveToJson()))\n            }\n        }\n        LoadFromJson(o) {\n            const cols = this.GetHSize();\n            const rows = this.GetVSize();\n            if (o["cols"] !== cols || o["rows"] !== rows)\n                throw new Error("mesh data wrong size");\n            const meshRows = o["points"];\n            for (let y = 0; y < rows; ++y) {\n                const rowData = meshRows[y];\n                for (let x = 0; x < cols; ++x) {\n                    const pt = this.GetMeshPointAt(x, y);\n                    pt.LoadFromJson(rowData[x])\n                }\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/webgl\/texture.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const VALID_PIXEL_FORMATS = new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"]);\n    const VALID_SAMPLINGS = new Set(["nearest", "bilinear", "trilinear"]);\n    const VALID_MIPMAP_QUALITIES = new Set(["default", "low", "high"]);\n    const VALID_WRAP_MODES = new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);\n    function GetFormatSpecifiers(pixelFormat, gl) {\n        let sizedinternalformat;\n        let internalformat;\n        let format;\n        let type;\n        switch (pixelFormat) {\n        case "rgba8":\n            sizedinternalformat = gl.RGBA8;\n            internalformat = gl.RGBA;\n            format = gl.RGBA;\n            type = gl.UNSIGNED_BYTE;\n            break;\n        case "rgb8":\n            sizedinternalformat = gl.RGB8;\n            internalformat = gl.RGB;\n            format = gl.RGB;\n            type = gl.UNSIGNED_BYTE;\n            break;\n        case "rgba4":\n            sizedinternalformat = gl.RGBA4;\n            internalformat = gl.RGBA;\n            format = gl.RGBA;\n            type = gl.UNSIGNED_SHORT_4_4_4_4;\n            break;\n        case "rgb5_a1":\n            sizedinternalformat = gl.RGB5_A1;\n            internalformat = gl.RGBA;\n            format = gl.RGBA;\n            type = gl.UNSIGNED_SHORT_5_5_5_1;\n            break;\n        case "rgb565":\n            sizedinternalformat = gl.RGB565;\n            internalformat = gl.RGB;\n            format = gl.RGB;\n            type = gl.UNSIGNED_SHORT_5_6_5;\n            break;\n        default:\n            throw new Error("invalid pixel format");\n        }\n        return {\n            sizedinternalformat,\n            internalformat,\n            format,\n            type\n        }\n    }\n    const CREATEFROM_DEFAULT_OPTIONS = {\n        wrapX: "clamp-to-edge",\n        wrapY: "clamp-to-edge",\n        sampling: "trilinear",\n        anisotropy: 0,\n        pixelFormat: "rgba8",\n        mipMap: true,\n        mipMapQuality: "default",\n        premultiplyAlpha: true,\n        isSvg: false,\n        width: -1,\n        height: -1\n    };\n    const UPDATE_DEFAULT_OPTIONS = {\n        premultiplyAlpha: true,\n        flipY: false\n    };\n    const allTextures = new Set;\n    C3.Gfx.WebGLRendererTexture = class WebGLRendererTexture {\n        constructor(renderer) {\n            this._renderer = renderer;\n            this._texture = null;\n            this._width = 0;\n            this._height = 0;\n            this._isStatic = true;\n            this._wrapX = "clamp-to-edge";\n            this._wrapY = "clamp-to-edge";\n            this._sampling = "trilinear";\n            this._anisotropy = 0;\n            this._pixelFormat = "rgba8";\n            this._isMipMapped = false;\n            this._mipMapQuality = "default";\n            this._refCount = 0\n        }\n        _CreateStatic(data, opts) {\n            if ((typeof HTMLImageElement === "undefined" || !(data instanceof HTMLImageElement)) && (typeof HTMLCanvasElement === "undefined" || !(data instanceof HTMLCanvasElement)) && (typeof ImageBitmap === "undefined" || !(data instanceof ImageBitmap)) && (typeof OffscreenCanvas === "undefined" || !(data instanceof OffscreenCanvas)) && !(data instanceof ImageData) && !(data instanceof ArrayBuffer) && data !== null)\n                throw new Error("invalid texture source");\n            opts = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, opts);\n            if (this._texture)\n                throw new Error("already created texture");\n            this._wrapX = opts.wrapX;\n            this._wrapY = opts.wrapY;\n            this._sampling = opts.sampling;\n            this._anisotropy = opts.anisotropy;\n            this._pixelFormat = opts.pixelFormat;\n            this._isMipMapped = !!opts.mipMap && this._renderer.AreMipmapsEnabled();\n            this._mipMapQuality = opts.mipMapQuality;\n            if (!VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY))\n                throw new Error("invalid wrap mode");\n            if (!VALID_SAMPLINGS.has(this._sampling))\n                throw new Error("invalid sampling");\n            if (!VALID_PIXEL_FORMATS.has(this._pixelFormat))\n                throw new Error("invalid pixel format");\n            if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality))\n                throw new Error("invalid mipmap quality");\n            this._isStatic = true;\n            if (data instanceof ArrayBuffer || data === null || opts.isSvg) {\n                this._width = opts.width;\n                this._height = opts.height;\n                if (data instanceof ArrayBuffer && data.byteLength !== this._width * this._height * 4)\n                    throw new Error("ArrayBuffer wrong size");\n            } else {\n                this._width = data.width;\n                this._height = data.height\n            }\n            if (this._width <= 0 || this._height <= 0)\n                throw new Error("invalid texture data size");\n            if (opts.isSvg) {\n                const canvas = C3.CreateCanvas(this._width, this._height);\n                const ctx = canvas.getContext("2d");\n                ctx.drawImage(data, 0, 0, this._width, this._height);\n                data = canvas\n            }\n            const isPOT = C3.isPOT(this._width) && C3.isPOT(this._height);\n            const maxTextureSize = this._renderer.GetMaxTextureSize();\n            if (this._width > maxTextureSize || this._height > maxTextureSize)\n                throw new Error("texture data exceeds maximum texture size");\n            const gl = this._renderer.GetContext();\n            const webglVersion = this._renderer.GetWebGLVersionNumber();\n            this._texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, this._texture);\n            gl.pixelStorei(gl["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], opts.premultiplyAlpha);\n            gl.pixelStorei(gl["UNPACK_FLIP_Y_WEBGL"], false);\n            const formatspec = GetFormatSpecifiers(this._pixelFormat, gl);\n            if (!this._renderer.SupportsNPOTTextures() && !isPOT && this._IsTiled()) {\n                if (data === null)\n                    throw new Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");\n                if (data instanceof ArrayBuffer)\n                    data = new ImageData(new Uint8ClampedArray(data),this._width,this._height);\n                if (data instanceof ImageData) {\n                    const tmpCanvas = C3.CreateCanvas(this._width, this._height);\n                    const tmpCtx = tmpCanvas.getContext("2d");\n                    tmpCtx.putImageData(data, 0, 0);\n                    data = tmpCanvas\n                }\n                const canvas = C3.CreateCanvas(C3.nextHighestPowerOfTwo(this._width), C3.nextHighestPowerOfTwo(this._height));\n                const ctx = canvas.getContext("2d");\n                ctx.imageSmoothingEnabled = this._sampling !== "nearest";\n                ctx.drawImage(data, 0, 0, this._width, this._height, 0, 0, canvas.width, canvas.height);\n                gl.texImage2D(gl.TEXTURE_2D, 0, formatspec.internalformat, formatspec.format, formatspec.type, canvas)\n            } else if (webglVersion >= 2) {\n                let levels;\n                if (this._isMipMapped)\n                    levels = Math.floor(Math.log2(Math.max(this._width, this._height)) + 1);\n                else\n                    levels = 1;\n                gl.texStorage2D(gl.TEXTURE_2D, levels, formatspec.sizedinternalformat, this._width, this._height);\n                if (data instanceof ArrayBuffer)\n                    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this._width, this._height, formatspec.format, formatspec.type, new Uint8Array(data));\n                else if (data !== null)\n                    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, formatspec.format, formatspec.type, data)\n            } else if (data instanceof ArrayBuffer)\n                gl.texImage2D(gl.TEXTURE_2D, 0, formatspec.internalformat, this._width, this._height, 0, formatspec.format, formatspec.type, new Uint8Array(data));\n            else if (data === null)\n                gl.texImage2D(gl.TEXTURE_2D, 0, formatspec.internalformat, this._width, this._height, 0, formatspec.format, formatspec.type, null);\n            else\n                gl.texImage2D(gl.TEXTURE_2D, 0, formatspec.internalformat, formatspec.format, formatspec.type, data);\n            if (data !== null)\n                this._SetTextureParameters(gl);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            this._renderer._ResetLastTexture();\n            this._refCount = 1;\n            allTextures.add(this)\n        }\n        _CreateDynamic(width, height, opts) {\n            opts = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, opts);\n            if (this._texture)\n                throw new Error("already created texture");\n            this._wrapX = opts.wrapX;\n            this._wrapY = opts.wrapY;\n            this._sampling = opts.sampling;\n            this._pixelFormat = opts.pixelFormat;\n            this._isMipMapped = !!opts.mipMap && this._renderer.AreMipmapsEnabled();\n            this._mipMapQuality = opts.mipMapQuality;\n            if (!VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY))\n                throw new Error("invalid wrap mode");\n            if (!VALID_SAMPLINGS.has(this._sampling))\n                throw new Error("invalid sampling");\n            if (!VALID_PIXEL_FORMATS.has(this._pixelFormat))\n                throw new Error("invalid pixel format");\n            if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality))\n                throw new Error("invalid mipmap quality");\n            this._isStatic = false;\n            this._width = Math.floor(width);\n            this._height = Math.floor(height);\n            const isPOT = C3.isPOT(this._width) && C3.isPOT(this._height);\n            const maxTextureSize = this._renderer.GetMaxTextureSize();\n            if (this._width <= 0 || this._height <= 0)\n                throw new Error("invalid texture size");\n            if (this._width > maxTextureSize || this._height > maxTextureSize)\n                throw new Error("texture exceeds maximum texture size");\n            if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !isPOT)\n                throw new Error("non-power-of-two tiled textures not supported");\n            const gl = this._renderer.GetContext();\n            const webglVersion = this._renderer.GetWebGLVersionNumber();\n            this._texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, this._texture);\n            gl.pixelStorei(gl["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], opts.premultiplyAlpha);\n            gl.pixelStorei(gl["UNPACK_FLIP_Y_WEBGL"], false);\n            const formatspec = GetFormatSpecifiers(this._pixelFormat, gl);\n            const internalformat = webglVersion >= 2 ? formatspec.sizedinternalformat : formatspec.internalformat;\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalformat, this._width, this._height, 0, formatspec.format, formatspec.type, null);\n            this._SetTextureParameters(gl);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            this._renderer._ResetLastTexture();\n            this._refCount = 1;\n            allTextures.add(this)\n        }\n        _GetMipMapHint(gl) {\n            if (this._mipMapQuality === "default")\n                return this._isStatic ? gl.NICEST : gl.FASTEST;\n            else if (this._mipMapQuality === "low")\n                return gl.FASTEST;\n            else if (this._mipMapQuality === "high")\n                return gl.NICEST;\n            else\n                throw new Error("invalid mipmap quality");\n        }\n        _IsTiled() {\n            return this._wrapX !== "clamp-to-edge" || this._wrapY !== "clamp-to-edge"\n        }\n        _GetTextureWrapMode(gl, wrapMode) {\n            if (wrapMode === "clamp-to-edge")\n                return gl.CLAMP_TO_EDGE;\n            else if (wrapMode === "repeat")\n                return gl.REPEAT;\n            else if (wrapMode === "mirror-repeat")\n                return gl.MIRRORED_REPEAT;\n            else\n                throw new Error("invalid wrap mode");\n        }\n        _SetTextureParameters(gl) {\n            const isPOT = C3.isPOT(this._width) && C3.isPOT(this._height);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._GetTextureWrapMode(gl, this._wrapX));\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._GetTextureWrapMode(gl, this._wrapY));\n            if (this._sampling === "nearest") {\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n                this._isMipMapped = false\n            } else {\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                if ((isPOT || this._renderer.SupportsNPOTTextures()) && this._isMipMapped) {\n                    gl.hint(gl.GENERATE_MIPMAP_HINT, this._GetMipMapHint(gl));\n                    gl.generateMipmap(gl.TEXTURE_2D);\n                    const useTrilinear = this._sampling === "trilinear" && !this._renderer.HasMajorPerformanceCaveat();\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, useTrilinear ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR_MIPMAP_NEAREST)\n                } else {\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                    this._isMipMapped = false\n                }\n            }\n            const anisotropicExt = this._renderer._GetAnisotropicExtension();\n            if (anisotropicExt && this._anisotropy > 0 && this._sampling !== "nearest")\n                gl.texParameterf(gl.TEXTURE_2D, anisotropicExt["TEXTURE_MAX_ANISOTROPY_EXT"], Math.min(this._anisotropy, this._renderer._GetMaxAnisotropy()))\n        }\n        _Update(data, opts) {\n            if ((typeof HTMLImageElement === "undefined" || !(data instanceof HTMLImageElement)) && (typeof HTMLVideoElement === "undefined" || !(data instanceof HTMLVideoElement)) && (typeof HTMLCanvasElement === "undefined" || !(data instanceof HTMLCanvasElement)) && (typeof ImageBitmap === "undefined" || !(data instanceof ImageBitmap)) && (typeof OffscreenCanvas === "undefined" || !(data instanceof OffscreenCanvas)) && !(data instanceof ImageData))\n                throw new Error("invalid texture source");\n            if (!this._texture || this._refCount <= 0)\n                throw new Error("texture not created");\n            if (this._isStatic)\n                throw new Error("cannot update static texture");\n            opts = Object.assign({}, UPDATE_DEFAULT_OPTIONS, opts);\n            const dataWidth = data.width || data.videoWidth;\n            const dataHeight = data.height || data.videoHeight;\n            const webglVersion = this._renderer.GetWebGLVersionNumber();\n            const gl = this._renderer.GetContext();\n            gl.bindTexture(gl.TEXTURE_2D, this._texture);\n            gl.pixelStorei(gl["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], opts.premultiplyAlpha);\n            gl.pixelStorei(gl["UNPACK_FLIP_Y_WEBGL"], !!opts.flipY);\n            const formatspec = GetFormatSpecifiers(this._pixelFormat, gl);\n            const internalformat = webglVersion >= 2 ? formatspec.sizedinternalformat : formatspec.internalformat;\n            try {\n                if (this._width === dataWidth && this._height === dataHeight) {\n                    const isPOT = C3.isPOT(this._width) && C3.isPOT(this._height);\n                    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, formatspec.format, formatspec.type, data);\n                    if ((isPOT || this._renderer.SupportsNPOTTextures()) && this._isMipMapped) {\n                        gl.hint(gl.GENERATE_MIPMAP_HINT, this._GetMipMapHint(gl));\n                        gl.generateMipmap(gl.TEXTURE_2D)\n                    }\n                } else {\n                    this._width = dataWidth;\n                    this._height = dataHeight;\n                    const isPOT = C3.isPOT(this._width) && C3.isPOT(this._height);\n                    if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !isPOT)\n                        throw new Error("non-power-of-two tiled textures not supported");\n                    gl.texImage2D(gl.TEXTURE_2D, 0, internalformat, formatspec.format, formatspec.type, data);\n                    if ((isPOT || this._renderer.SupportsNPOTTextures()) && this._isMipMapped) {\n                        gl.hint(gl.GENERATE_MIPMAP_HINT, this._GetMipMapHint(gl));\n                        gl.generateMipmap(gl.TEXTURE_2D)\n                    }\n                }\n            } catch (e) {\n                console.error("Error updating WebGL texture: ", e)\n            }\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            this._renderer._ResetLastTexture()\n        }\n        _Delete() {\n            if (this._refCount > 0)\n                throw new Error("texture still has references");\n            if (!this._texture)\n                throw new Error("already deleted texture");\n            allTextures.delete(this);\n            const gl = this._renderer.GetContext();\n            gl.deleteTexture(this._texture);\n            this._texture = null\n        }\n        IsValid() {\n            return !!this._texture\n        }\n        _GetTexture() {\n            return this._texture\n        }\n        GetRenderer() {\n            return this._renderer\n        }\n        AddReference() {\n            this._refCount++\n        }\n        SubtractReference() {\n            if (this._refCount <= 0)\n                throw new Error("no more references");\n            this._refCount--\n        }\n        GetReferenceCount() {\n            return this._refCount\n        }\n        GetWidth() {\n            return this._width\n        }\n        GetHeight() {\n            return this._height\n        }\n        IsStatic() {\n            return this._isStatic\n        }\n        GetEstimatedMemoryUsage() {\n            let size = this._width * this._height;\n            switch (this._pixelFormat) {\n            case "rgba8":\n                size *= 4;\n                break;\n            case "rgb8":\n                size *= 3;\n                break;\n            case "rgba4":\n            case "rgb5_a1":\n            case "rgb565":\n                size *= 2;\n                break\n            }\n            if (this._isMipMapped)\n                size += Math.floor(size \/ 3);\n            return size\n        }\n        static OnContextLost() {\n            allTextures.clear()\n        }\n        static allTextures() {\n            return allTextures.values()\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/webgl\/renderTarget.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const assert = self.assert;\n    const glMatrix = self.glMatrix;\n    const vec3 = glMatrix.vec3;\n    const mat4 = glMatrix.mat4;\n    const VALID_SAMPLINGS = new Set(["nearest", "bilinear", "trilinear"]);\n    const DEFAULT_RENDERTARGET_OPTIONS = {\n        sampling: "trilinear",\n        alpha: true,\n        depth: false,\n        isSampled: true,\n        isDefaultSize: true,\n        multisampling: 0\n    };\n    const allRenderTargets = new Set;\n    C3.Gfx.WebGLRenderTarget = class WebGLRenderTarget {\n        constructor(renderer) {\n            this._renderer = renderer;\n            this._frameBuffer = null;\n            this._frameBufferNoDepth = null;\n            this._texture = null;\n            this._renderBuffer = null;\n            this._width = 0;\n            this._height = 0;\n            this._isDefaultSize = true;\n            this._sampling = "trilinear";\n            this._alpha = true;\n            this._depth = false;\n            this._isSampled = true;\n            this._multisampling = 0;\n            this._projectionMatrix = mat4.create();\n            this._lastFov = 0\n        }\n        _Create(width, height, opts) {\n            opts = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, opts);\n            const webGLVersion = this._renderer.GetWebGLVersionNumber();\n            if (this._texture || this._renderBuffer)\n                throw new Error("already created render target");\n            this._sampling = opts.sampling;\n            this._alpha = !!opts.alpha;\n            this._depth = !!opts.depth;\n            this._isSampled = !!opts.isSampled;\n            this._isDefaultSize = !!opts.isDefaultSize;\n            this._multisampling = opts.multisampling;\n            if (!VALID_SAMPLINGS.has(this._sampling))\n                throw new Error("invalid sampling");\n            if (this._multisampling > 0 && (webGLVersion < 2 || this._isSampled))\n                throw new Error("invalid use of multisampling");\n            if (webGLVersion < 2)\n                this._isSampled = true;\n            this._width = width;\n            this._height = height;\n            if (this._width <= 0 || this._height <= 0)\n                throw new Error("invalid render target size");\n            this._CalculateProjection();\n            const gl = this._renderer.GetContext();\n            this._frameBuffer = gl.createFramebuffer();\n            if (this._depth)\n                this._frameBufferNoDepth = gl.createFramebuffer();\n            if (this._isSampled) {\n                this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, {\n                    sampling: this._sampling,\n                    pixelFormat: this._alpha ? "rgba8" : "rgb8",\n                    mipMap: false\n                });\n                const tex = this._texture._GetTexture();\n                gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);\n                if (this._depth) {\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBufferNoDepth);\n                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0)\n                }\n            } else {\n                this._renderBuffer = gl.createRenderbuffer();\n                gl.bindRenderbuffer(gl.RENDERBUFFER, this._renderBuffer);\n                const internalFormat = this._alpha ? gl.RGBA8 : gl.RGB8;\n                if (this._multisampling > 0) {\n                    const formatSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, internalFormat, gl.SAMPLES);\n                    if (formatSamples && formatSamples[0]) {\n                        const maxSamples = formatSamples[0];\n                        if (this._multisampling > maxSamples)\n                            this._multisampling = maxSamples\n                    } else\n                        this._multisampling = 0\n                }\n                if (this._multisampling === 0)\n                    gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, this._width, this._height);\n                else\n                    gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._multisampling, internalFormat, this._width, this._height);\n                gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\n                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this._renderBuffer);\n                if (this._depth) {\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBufferNoDepth);\n                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this._renderBuffer)\n                }\n                gl.bindRenderbuffer(gl.RENDERBUFFER, null)\n            }\n            const rendererDepthBuffer = this._renderer._GetDepthBuffer();\n            if (this._depth && rendererDepthBuffer) {\n                gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\n                if (this._renderer._CanSampleDepth())\n                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, rendererDepthBuffer, 0);\n                else\n                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, rendererDepthBuffer)\n            }\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            allRenderTargets.add(this)\n        }\n        _Resize(width, height) {\n            if (this._width === width && this._height === height)\n                return;\n            this._width = width;\n            this._height = height;\n            this._CalculateProjection();\n            const gl = this._renderer.GetContext();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\n            if (this._texture)\n                this._texture._Update(new ImageData(this._width,this._height));\n            else {\n                gl.bindRenderbuffer(gl.RENDERBUFFER, this._renderBuffer);\n                gl.renderbufferStorage(gl.RENDERBUFFER, this._alpha ? gl.RGBA8 : gl.RGB8, this._width, this._height);\n                gl.bindRenderbuffer(gl.RENDERBUFFER, null)\n            }\n            const rendererDepthBuffer = this._renderer._GetDepthBuffer();\n            if (this._depth && rendererDepthBuffer)\n                if (this._renderer._CanSampleDepth())\n                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, rendererDepthBuffer, 0);\n                else\n                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, rendererDepthBuffer);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null)\n        }\n        _Delete() {\n            if (!this._texture && !this._renderBuffer)\n                throw new Error("already deleted render target");\n            allRenderTargets.delete(this);\n            const gl = this._renderer.GetContext();\n            if (this._texture) {\n                gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);\n                if (this._depth) {\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBufferNoDepth);\n                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0)\n                }\n                this._renderer.DeleteTexture(this._texture);\n                this._texture = null\n            } else if (this._renderBuffer) {\n                gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\n                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, null);\n                if (this._depth) {\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBufferNoDepth);\n                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, null)\n                }\n                gl.deleteRenderbuffer(this._renderBuffer);\n                this._renderBuffer = null\n            }\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            if (this._renderer.GetWebGLVersionNumber() >= 2) {\n                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null)\n            }\n            gl.deleteFramebuffer(this._frameBuffer);\n            if (this._depth)\n                gl.deleteFramebuffer(this._frameBufferNoDepth);\n            const batchState = this._renderer.GetBatchState();\n            batchState.currentFramebuffer = null;\n            batchState.currentFramebufferNoDepth = null;\n            this._frameBuffer = null\n        }\n        _CalculateProjection() {\n            this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this._width \/ this._height);\n            this._lastFov = this._renderer.GetFovY()\n        }\n        _GetFramebuffer() {\n            return this._frameBuffer\n        }\n        _GetFramebufferNoDepth() {\n            return this._frameBufferNoDepth\n        }\n        GetRenderer() {\n            return this._renderer\n        }\n        GetTexture() {\n            return this._texture\n        }\n        GetProjectionMatrix() {\n            if (this._renderer.GetFovY() !== this._lastFov)\n                this._CalculateProjection();\n            return this._projectionMatrix\n        }\n        IsLinearSampling() {\n            return this._sampling !== "nearest"\n        }\n        HasAlpha() {\n            return this._alpha\n        }\n        IsSampled() {\n            return this._isSampled\n        }\n        HasDepthBuffer() {\n            return this._depth\n        }\n        GetWidth() {\n            return this._width\n        }\n        GetHeight() {\n            return this._height\n        }\n        IsDefaultSize() {\n            return this._isDefaultSize\n        }\n        GetMultisampling() {\n            return this._multisampling\n        }\n        GetOptions() {\n            const ret = {\n                sampling: this._sampling,\n                alpha: this._alpha,\n                isSampled: this._isSampled\n            };\n            if (!this._isDefaultSize) {\n                ret.width = this._width;\n                ret.height = this._height\n            }\n            return ret\n        }\n        IsCompatibleWithOptions(opts) {\n            opts = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, opts);\n            if (opts.sampling !== "nearest" !== this.IsLinearSampling())\n                return false;\n            if (!!opts.alpha !== this.HasAlpha())\n                return false;\n            if (!!opts.depth !== this.HasDepthBuffer())\n                return false;\n            if (this._renderer.GetWebGLVersionNumber() >= 2)\n                if (!!opts.isSampled !== this.IsSampled())\n                    return false;\n            if (typeof opts.width === "number" || typeof opts.height === "number")\n                return !this.IsDefaultSize() && this.GetWidth() === opts.width && this.GetHeight() === opts.height;\n            else\n                return this.IsDefaultSize()\n        }\n        _GetWebGLTexture() {\n            if (!this._texture)\n                return null;\n            return this._texture._GetTexture()\n        }\n        GetEstimatedMemoryUsage() {\n            if (this._texture)\n                return this._texture.GetEstimatedMemoryUsage();\n            return this._width * this._height * (this._alpha ? 4 : 3)\n        }\n        static async DebugReadPixelsToBlob(renderer, renderTarget) {\n            const imageData = await renderer.ReadBackRenderTargetToImageData(renderTarget, true);\n            return await C3.ImageDataToBlob(imageData)\n        }\n        static OnContextLost() {\n            allRenderTargets.clear()\n        }\n        static allRenderTargets() {\n            return allRenderTargets.values()\n        }\n        static ResizeAll(width, height) {\n            for (const rt of allRenderTargets)\n                if (rt.IsDefaultSize())\n                    rt._Resize(width, height)\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/webgl\/shaderProgram.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const glMatrix = self.glMatrix;\n    const vec3 = glMatrix.vec3;\n    const mat4 = glMatrix.mat4;\n    const RESERVED_UNIFORM_NAMES = new Set(["aPos", "aTex", "aPoints", "matP", "matMV", "samplerFront", "samplerBack", "samplerDepth", "destStart", "destEnd", "srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "pixelSize", "seconds", "devicePixelRatio", "layerScale", "layerAngle", "layoutStart", "layoutEnd", "color", "color2_", "pointTexStart", "pointTexEnd", "zElevation", "tileSize", "tileSpacing", "outlineThickness"]);\n    C3.Gfx.WebGLShaderProgram = class WebGLShaderProgram extends C3.Gfx.ShaderProgramBase {\n        static async Compile(renderer, fragSrc, vsSource, name) {\n            const gl = renderer.GetContext();\n            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n            gl.shaderSource(fragmentShader, fragSrc);\n            gl.compileShader(fragmentShader);\n            const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n            gl.shaderSource(vertexShader, vsSource);\n            gl.compileShader(vertexShader);\n            const shaderProgram = gl.createProgram();\n            gl.attachShader(shaderProgram, fragmentShader);\n            gl.attachShader(shaderProgram, vertexShader);\n            gl.bindAttribLocation(shaderProgram, 0, "aPos");\n            gl.bindAttribLocation(shaderProgram, 1, "aTex");\n            gl.bindAttribLocation(shaderProgram, 2, "aPoints");\n            gl.linkProgram(shaderProgram);\n            const parallelShaderCompileExt = renderer._GetParallelShaderCompileExtension();\n            if (parallelShaderCompileExt)\n                await renderer._WaitForObjectReady( () => gl.getProgramParameter(shaderProgram, parallelShaderCompileExt["COMPLETION_STATUS_KHR"]));\n            else\n                await C3.Wait(5);\n            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n                const log = gl.getShaderInfoLog(fragmentShader);\n                gl.deleteShader(fragmentShader);\n                gl.deleteShader(vertexShader);\n                gl.deleteProgram(shaderProgram);\n                throw new Error("Error compiling fragment shader: " + log);\n            }\n            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n                const log = gl.getShaderInfoLog(vertexShader);\n                gl.deleteShader(fragmentShader);\n                gl.deleteShader(vertexShader);\n                gl.deleteProgram(shaderProgram);\n                throw new Error("Error compiling vertex shader: " + log);\n            }\n            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n                const log = gl.getProgramInfoLog(shaderProgram);\n                gl.deleteShader(fragmentShader);\n                gl.deleteShader(vertexShader);\n                gl.deleteProgram(shaderProgram);\n                throw new Error("Error linking shader program: " + log);\n            }\n            const infoLog = C3.FilterUnprintableChars(gl.getProgramInfoLog(shaderProgram) || "").trim();\n            if (infoLog && !C3.IsStringAllWhitespace(infoLog))\n                console.info(`[WebGL] Shader program \'${name}\' compilation log: `, infoLog);\n            gl.deleteShader(fragmentShader);\n            gl.deleteShader(vertexShader);\n            return shaderProgram\n        }\n        static async Create(renderer, shaderInfo, vsSource, name) {\n            const shaderProgram = await C3.Gfx.WebGLShaderProgram.Compile(renderer, shaderInfo.src, vsSource, name);\n            return new C3.Gfx.WebGLShaderProgram(renderer,shaderProgram,shaderInfo,name)\n        }\n        constructor(renderer, shaderProgram, shaderInfo, name) {\n            super(renderer, name, shaderInfo);\n            const gl = renderer.GetContext();\n            const batchState = renderer.GetBatchState();\n            renderer.EndBatch();\n            gl.useProgram(shaderProgram);\n            this._gl = gl;\n            this._shaderProgram = shaderProgram;\n            this._isDeviceTransform = name === "<default-device-transform>";\n            const locAPos = gl.getAttribLocation(shaderProgram, "aPos");\n            const locATex = gl.getAttribLocation(shaderProgram, "aTex");\n            this._locAPoints = gl.getAttribLocation(shaderProgram, "aPoints");\n            if (locAPos !== -1) {\n                gl.bindBuffer(gl.ARRAY_BUFFER, renderer._vertexBuffer);\n                gl.vertexAttribPointer(locAPos, renderer.GetNumVertexComponents(), gl.FLOAT, false, 0, 0);\n                gl.enableVertexAttribArray(locAPos)\n            }\n            if (locATex !== -1) {\n                gl.bindBuffer(gl.ARRAY_BUFFER, renderer._texcoordBuffer);\n                gl.vertexAttribPointer(locATex, 2, gl.FLOAT, false, 0, 0);\n                gl.enableVertexAttribArray(locATex)\n            }\n            if (this._locAPoints !== -1) {\n                gl.bindBuffer(gl.ARRAY_BUFFER, renderer._pointBuffer);\n                gl.vertexAttribPointer(this._locAPoints, 4, gl.FLOAT, false, 0, 0);\n                gl.enableVertexAttribArray(this._locAPoints)\n            }\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n            this._uMatP = new C3.Gfx.WebGLShaderUniform(this,"matP","mat4");\n            this._uMatMV = new C3.Gfx.WebGLShaderUniform(this,"matMV","mat4");\n            this._uColor = new C3.Gfx.WebGLShaderUniform(this,"color","vec4");\n            this._uSamplerFront = new C3.Gfx.WebGLShaderUniform(this,"samplerFront","sampler");\n            this._uPointTexStart = new C3.Gfx.WebGLShaderUniform(this,"pointTexStart","vec2");\n            this._uPointTexEnd = new C3.Gfx.WebGLShaderUniform(this,"pointTexEnd","vec2");\n            this._uZElevation = new C3.Gfx.WebGLShaderUniform(this,"zElevation","float");\n            this._uTileSize = new C3.Gfx.WebGLShaderUniform(this,"tileSize","vec2");\n            this._uTileSpacing = new C3.Gfx.WebGLShaderUniform(this,"tileSpacing","vec2");\n            this._uColor2 = new C3.Gfx.WebGLShaderUniform(this,"color2_","vec4");\n            this._uOutlineThickness = new C3.Gfx.WebGLShaderUniform(this,"outlineThickness","float");\n            this._uSamplerBack = new C3.Gfx.WebGLShaderUniform(this,"samplerBack","sampler");\n            this._uSamplerDepth = new C3.Gfx.WebGLShaderUniform(this,"samplerDepth","sampler");\n            this._uDestStart = new C3.Gfx.WebGLShaderUniform(this,"destStart","vec2");\n            this._uDestEnd = new C3.Gfx.WebGLShaderUniform(this,"destEnd","vec2");\n            this._uSrcStart = new C3.Gfx.WebGLShaderUniform(this,"srcStart","vec2");\n            this._uSrcEnd = new C3.Gfx.WebGLShaderUniform(this,"srcEnd","vec2");\n            this._uSrcOriginStart = new C3.Gfx.WebGLShaderUniform(this,"srcOriginStart","vec2");\n            this._uSrcOriginEnd = new C3.Gfx.WebGLShaderUniform(this,"srcOriginEnd","vec2");\n            this._uPixelSize = new C3.Gfx.WebGLShaderUniform(this,"pixelSize","vec2");\n            this._uSeconds = new C3.Gfx.WebGLShaderUniform(this,"seconds","float");\n            this._uDevicePixelRatio = new C3.Gfx.WebGLShaderUniform(this,"devicePixelRatio","float");\n            this._uLayerScale = new C3.Gfx.WebGLShaderUniform(this,"layerScale","float");\n            this._uLayerAngle = new C3.Gfx.WebGLShaderUniform(this,"layerAngle","float");\n            this._uLayoutStart = new C3.Gfx.WebGLShaderUniform(this,"layoutStart","vec2");\n            this._uLayoutEnd = new C3.Gfx.WebGLShaderUniform(this,"layoutEnd","vec2");\n            this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() || this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uDevicePixelRatio.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() || this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed());\n            const customParameterDefs = shaderInfo.parameters || [];\n            this._uCustomParameters = [];\n            this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed();\n            this._hasCurrentMatP = false;\n            this._hasCurrentMatMV = false;\n            this._uColor.Init4f(1, 1, 1, 1);\n            this._uColor2.Init4f(1, 1, 1, 1);\n            this._uSamplerFront.Init1i(0);\n            this._uSamplerBack.Init1i(1);\n            this._uSamplerDepth.Init1i(2);\n            this._uPointTexStart.Init2f(0, 0);\n            this._uPointTexEnd.Init2f(1, 1);\n            this._uZElevation.Init1f(0);\n            this._uTileSize.Init2f(0, 0);\n            this._uTileSpacing.Init2f(0, 0);\n            this._uDestStart.Init2f(0, 0);\n            this._uDestEnd.Init2f(1, 1);\n            this._uSrcStart.Init2f(0, 0);\n            this._uSrcEnd.Init2f(0, 0);\n            this._uSrcOriginStart.Init2f(0, 0);\n            this._uSrcOriginEnd.Init2f(0, 0);\n            this._uPixelSize.Init2f(0, 0);\n            this._uDevicePixelRatio.Init1f(1);\n            this._uLayerScale.Init1f(1);\n            this._uLayerAngle.Init1f(0);\n            this._uSeconds.Init1f(0);\n            this._uLayoutStart.Init2f(0, 0);\n            this._uLayoutEnd.Init2f(0, 0);\n            this._uOutlineThickness.Init1f(1);\n            for (const p of customParameterDefs) {\n                const uniformName = p[0];\n                const paramType = p[2];\n                const shaderUniform = new C3.Gfx.WebGLShaderUniform(this,uniformName,paramType);\n                if (paramType === "color")\n                    shaderUniform.Init3f(0, 0, 0);\n                else\n                    shaderUniform.Init1f(0);\n                this._uCustomParameters.push(shaderUniform)\n            }\n            if (this._isDeviceTransform)\n                this._UpdateDeviceTransformUniforms(batchState.currentMatP);\n            else {\n                this.UpdateMatP(batchState.currentMatP, true);\n                this.UpdateMatMV(batchState.currentMV, true)\n            }\n            const currentShader = batchState.currentShader;\n            gl.useProgram(currentShader ? currentShader._shaderProgram : null)\n        }\n        Release() {\n            this._gl.deleteProgram(this._shaderProgram);\n            this._shaderProgram = null;\n            this._renderer._RemoveShaderProgram(this);\n            this._gl = null;\n            super.Release()\n        }\n        GetWebGLContext() {\n            return this._gl\n        }\n        GetShaderProgram() {\n            return this._shaderProgram\n        }\n        GetParameterCount() {\n            return this._uCustomParameters.length\n        }\n        GetParameterType(paramIndex) {\n            if (paramIndex < 0 || paramIndex >= this._uCustomParameters.length)\n                return null;\n            return this._uCustomParameters[paramIndex].GetType()\n        }\n        AreCustomParametersAlreadySetInBatch(params) {\n            for (let i = 0, len = params.length; i < len; ++i)\n                if (!this._uCustomParameters[i].IsSetToCustomInBatch(params[i]))\n                    return false;\n            return true\n        }\n        SetCustomParametersInBatch(params) {\n            for (let i = 0, len = params.length; i < len; ++i)\n                this._uCustomParameters[i].SetBatchValueCustom(params[i])\n        }\n        AreOptionalUniformsAlreadySetInBatch(destRect, srcRect, srcOriginRect, layoutRect, pixelWidth, pixelHeight, dpr, layerScale, layerAngle, time) {\n            if (this._uSamplerBack.IsUsed())\n                return false;\n            if (this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(pixelWidth, pixelHeight))\n                return false;\n            if (this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(destRect.getLeft(), destRect.getTop()))\n                return false;\n            if (this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(destRect.getRight(), destRect.getBottom()))\n                return false;\n            if (this._uDevicePixelRatio.IsUsed() && !this._uDevicePixelRatio.IsSetTo1InBatch(dpr))\n                return false;\n            if (this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(layerScale))\n                return false;\n            if (this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(layerAngle))\n                return false;\n            if (this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(srcRect.getLeft(), srcRect.getTop()))\n                return false;\n            if (this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(srcRect.getRight(), srcRect.getBottom()))\n                return false;\n            if (this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(srcOriginRect.getLeft(), srcOriginRect.getTop()))\n                return false;\n            if (this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(srcOriginRect.getRight(), srcOriginRect.getBottom()))\n                return false;\n            if (this._uLayoutStart.IsUsed() && !this._uLayoutStart.IsSetTo2InBatch(layoutRect.getLeft(), layoutRect.getTop()))\n                return false;\n            if (this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(layoutRect.getTop(), layoutRect.getBottom()))\n                return false;\n            if (this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(time))\n                return false;\n            return true\n        }\n        SetOptionalUniformsInBatch(destRect, srcRect, srcOriginRect, layoutRect, pixelWidth, pixelHeight, dpr, layerScale, layerAngle, time) {\n            if (this._uSamplerBack.IsUsed())\n                return;\n            if (this._uPixelSize.IsUsed())\n                this._uPixelSize.SetBatch2(pixelWidth, pixelHeight);\n            if (this._uDestStart.IsUsed())\n                this._uDestStart.SetBatch2(destRect.getLeft(), destRect.getTop());\n            if (this._uDestEnd.IsUsed())\n                this._uDestEnd.SetBatch2(destRect.getRight(), destRect.getBottom());\n            if (this._uDevicePixelRatio.IsUsed())\n                this._uDevicePixelRatio.SetBatch1(dpr);\n            if (this._uLayerScale.IsUsed())\n                this._uLayerScale.SetBatch1(layerScale);\n            if (this._uLayerAngle.IsUsed())\n                this._uLayerAngle.SetBatch1(layerAngle);\n            if (this._uSrcStart.IsUsed())\n                this._uSrcStart.SetBatch2(srcRect.getLeft(), srcRect.getTop());\n            if (this._uSrcEnd.IsUsed())\n                this._uSrcEnd.SetBatch2(srcRect.getRight(), srcRect.getBottom());\n            if (this._uSrcOriginStart.IsUsed())\n                this._uSrcOriginStart.SetBatch2(srcOriginRect.getLeft(), srcOriginRect.getTop());\n            if (this._uSrcOriginEnd.IsUsed())\n                this._uSrcOriginEnd.SetBatch2(srcOriginRect.getRight(), srcOriginRect.getBottom());\n            if (this._uLayoutStart.IsUsed())\n                this._uLayoutStart.SetBatch2(layoutRect.getLeft(), layoutRect.getTop());\n            if (this._uLayoutEnd.IsUsed())\n                this._uLayoutEnd.SetBatch2(layoutRect.getTop(), layoutRect.getBottom());\n            if (this._uSeconds.IsUsed())\n                this._uSeconds.SetBatch1(time)\n        }\n        UpdateMatP(matP, force) {\n            if (this._hasCurrentMatP && !force)\n                return;\n            if (this._isDeviceTransform)\n                return;\n            if (this._uMatP.IsUsed())\n                this._uMatP.UpdateMatrix4fv(matP);\n            this._hasCurrentMatP = true\n        }\n        SetMatPStale() {\n            this._hasCurrentMatP = false\n        }\n        UpdateMatMV(matMV, force) {\n            if (this._hasCurrentMatMV && !force)\n                return;\n            if (this._isDeviceTransform)\n                return;\n            if (this._uMatMV.IsUsed())\n                this._uMatMV.UpdateMatrix4fv(matMV);\n            this._hasCurrentMatMV = true\n        }\n        SetMatMVStale() {\n            this._hasCurrentMatMV = false\n        }\n        _UpdateDeviceTransformUniforms(matP) {\n            if (!this._isDeviceTransform)\n                throw new Error("not device transform shader");\n            this._uMatP.UpdateMatrix4fv(matP);\n            const renderer = this._renderer;\n            const scrollX = renderer.GetWidth() \/ 2;\n            const scrollY = renderer.GetHeight() \/ 2;\n            const tempMat4 = renderer.CalculateLookAtModelView2(scrollX, scrollY, renderer.GetDefaultCameraZ(renderer.GetHeight()), scrollX, scrollY, 0, renderer.GetHeight());\n            this._uMatMV.UpdateMatrix4fv(tempMat4)\n        }\n        UpdateColor(c) {\n            if (this._uColor.IsUsed())\n                this._uColor.Update4f(c[0], c[1], c[2], c[3])\n        }\n        static GetReservedUniformNames() {\n            return RESERVED_UNIFORM_NAMES\n        }\n        static GetDefaultVertexShaderSource(useHighP) {\n            const texPrecision = useHighP ? "highmedp" : "mediump";\n            return [`#ifdef GL_FRAGMENT_PRECISION_HIGH`, `#define highmedp highp`, `#else`, `#define highmedp mediump`, `#endif`, `attribute highp vec3 aPos;`, `attribute ${texPrecision} vec2 aTex;`, `varying ${texPrecision} vec2 vTex;`, `uniform highp mat4 matP;`, `uniform highp mat4 matMV;`, `void main(void) {`, `	gl_Position = matP * matMV * vec4(aPos, 1.0);`, `	vTex = aTex;`, `}`].join("\\n")\n        }\n        static GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth() {\n            return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\\tgl_FragColor = texture2D(samplerFront, vTex) * color;", "}"].join("\\n")\n        }\n        static GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT() {\n            return ["#extension GL_EXT_frag_depth : enable", "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\\tgl_FragColor = texture2D(samplerFront, vTex) * color;", "\\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\\n")\n        }\n        static GetDefaultVertexShaderSource_WebGL2() {\n            return [`#version 300 es`, `in highp vec3 aPos;`, `in mediump vec2 aTex;`, `out mediump vec2 vTex;`, `uniform highp mat4 matP;`, `uniform highp mat4 matMV;`, `void main(void) {`, `	gl_Position = matP * matMV * vec4(aPos, 1.0);`, `	vTex = aTex;`, `}`].join("\\n")\n        }\n        static GetTextureFillFragmentShaderSource_WebGL2() {\n            return ["#version 300 es", "in mediump vec2 vTex;", "out lowp vec4 outColor;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\\toutColor = texture(samplerFront, vTex) * color;", "\\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\\n")\n        }\n        static GetTilemapFragmentShaderSource() {\n            return ["#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "varying highmedp vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "uniform highmedp vec2 srcStart;", "uniform highmedp vec2 pixelSize;", "uniform highmedp vec2 tileSize;", "uniform highmedp vec2 tileSpacing;", "void main(void) {", "\\thighmedp vec2 tile = floor(vTex);", "\\thighmedp vec2 tex = fract(vTex);", "\\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\\thighmedp vec2 lowerBound = tileOrigin + pixelSize \/ 2.0;", "\\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize \/ 2.0;", "\\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;", "}"].join("\\n")\n        }\n        static GetPointVertexShaderSource(webglVersion) {\n            return C3.Gfx.WebGLShaderProgram.GetPointVertexShaderSource_WebGL1()\n        }\n        static GetPointFragmentShaderSource(webglVersion) {\n            return C3.Gfx.WebGLShaderProgram.GetPointFragmentShaderSource_WebGL1()\n        }\n        static GetPointVertexShaderSource_WebGL1() {\n            return ["attribute vec4 aPoints;", "varying float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "\\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "\\tgl_PointSize = aPoints.z;", "\\tpointOpacity = aPoints.w;", "}"].join("\\n")\n        }\n        static GetPointFragmentShaderSource_WebGL1() {\n            return ["uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "\\tgl_FragColor = texture2D(samplerFront, mix(pointTexStart, pointTexEnd, gl_PointCoord)) * color * pointOpacity;", "}"].join("\\n")\n        }\n        static GetColorFillFragmentShaderSource() {\n            return ["uniform lowp vec4 color;", "void main(void) {", "\\tgl_FragColor = color;", "}"].join("\\n")\n        }\n        static GetLinearGradientFillFragmentShaderSource() {\n            return ["precision lowp float;", "varying mediump vec2 vTex;", "uniform vec4 color;", "uniform vec4 color2_;", "vec3 fromLinear(vec3 linearRGB)", "{", "\\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));", "\\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0\/2.4)) - vec3(0.055);", "\\tvec3 lower = linearRGB * vec3(12.92);", "\\treturn mix(higher, lower, vec3(cutoff));", "}", "vec3 toLinear(vec3 sRGB)", "{", "\\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));", "\\tvec3 higher = pow(abs((sRGB + vec3(0.055))\/vec3(1.055)), vec3(2.4));", "\\tvec3 lower = sRGB\/vec3(12.92);", "\\treturn mix(higher, lower, vec3(cutoff));", "}", "void main(void) {", "\\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);", "\\tfloat a = mix(color.a, color2_.a, vTex.x);", "\\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);", "}"].join("\\n")\n        }\n        static GetSmoothLineFillFragmentShaderSource() {\n            return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "void main(void) {", "\\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;", "\\tgl_FragColor = color * f;", "}"].join("\\n")\n        }\n        static GetHardEllipseFillFragmentShaderSource() {\n            return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "void main(void) {", "\\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\\tmediump vec2 diffSq = diff * diff;", "\\tmediump float f = step(diffSq.x + diffSq.y, 0.25);", "\\tgl_FragColor = color * f;", "}"].join("\\n")\n        }\n        static GetHardEllipseOutlineFragmentShaderSource() {\n            return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "uniform mediump float outlineThickness;", "void main(void) {", "\\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\\tmediump vec2 diffSq = diff * diff;", "\\tmediump float distSq = diffSq.x + diffSq.y;", "\\tmediump vec2 norm = normalize(diff);", "\\tmediump vec2 halfNorm = norm * 0.5;", "\\tmediump float innerF = step(distSq, 0.25);", "\\tmediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;", "\\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;", "\\tmediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);", "\\tgl_FragColor = color * innerF * outerF;", "}"].join("\\n")\n        }\n        static GetSmoothEllipseFillFragmentShaderSource() {\n            return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "void main(void) {", "\\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\\tmediump vec2 diffSq = diff * diff;", "\\tmediump vec2 norm = normalize(diff);", "\\tmediump vec2 halfNorm = norm * 0.5;", "\\tmediump vec2 halfNormSq = halfNorm * halfNorm;", "\\tmediump vec2 innerEdge = halfNorm - pixelSize * norm;", "\\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;", "\\tmediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);", "\\tgl_FragColor = color * f;", "}"].join("\\n")\n        }\n        static GetSmoothEllipseOutlineFragmentShaderSource() {\n            return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "uniform mediump float outlineThickness;", "void main(void) {", "\\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\\tmediump vec2 diffSq = diff * diff;", "\\tmediump float distSq = diffSq.x + diffSq.y;", "\\tmediump vec2 norm = normalize(diff);", "\\tmediump vec2 halfNorm = norm * 0.5;", "\\tmediump vec2 halfNormSq = halfNorm * halfNorm;", "\\tmediump vec2 pxNorm = pixelSize * norm;", "\\tmediump vec2 innerEdge1 = halfNorm - pxNorm;", "\\tmediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;", "\\tmediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);", "\\tmediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;", "\\tmediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;", "\\tmediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);", "\\tmediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;", "\\tmediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);", "\\tgl_FragColor = color * innerF * outerF;", "}"].join("\\n")\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/webgl\/shaderUniform.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const glMatrix = self.glMatrix;\n    const mat4 = glMatrix.mat4;\n    const TYPE_SIZES = new Map([["float", 1], ["percent", 1], ["sampler", 1], ["vec2", 2], ["vec3", 3], ["color", 3], ["vec4", 4], ["mat4", 16]]);\n    C3.Gfx.WebGLShaderUniform = class WebGLShaderUniform {\n        constructor(owner, name, type) {\n            if (!TYPE_SIZES.has(type))\n                throw new Error("invalid uniform type");\n            this._owner = owner;\n            this._gl = this._owner.GetWebGLContext();\n            this._name = name;\n            this._type = type;\n            this._isColorType = this._type === "color";\n            this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), name);\n            this._isUsed = !!this._location;\n            const typeSize = TYPE_SIZES.get(type);\n            this._lastValue = new Float32Array(typeSize);\n            this._lastBatchValue = new Float32Array(typeSize)\n        }\n        Release() {\n            this._owner = null;\n            this._gl = null;\n            this._location = null\n        }\n        IsUsed() {\n            return this._isUsed\n        }\n        GetType() {\n            return this._type\n        }\n        IsColorType() {\n            return this._isColorType\n        }\n        Init1f(v0) {\n            if (!this.IsUsed())\n                return;\n            this._lastValue[0] = v0;\n            this._lastBatchValue.set(this._lastValue);\n            this._gl.uniform1f(this._location, v0)\n        }\n        Init1i(v0) {\n            if (!this.IsUsed())\n                return;\n            this._lastValue[0] = v0;\n            this._lastBatchValue.set(this._lastValue);\n            this._gl.uniform1i(this._location, v0)\n        }\n        Init2f(v0, v1) {\n            if (!this.IsUsed())\n                return;\n            this._lastValue[0] = v0;\n            this._lastValue[1] = v1;\n            this._lastBatchValue.set(this._lastValue);\n            this._gl.uniform2f(this._location, v0, v1)\n        }\n        Init3f(v0, v1, v2) {\n            if (!this.IsUsed())\n                return;\n            this._lastValue[0] = v0;\n            this._lastValue[1] = v1;\n            this._lastValue[2] = v2;\n            this._lastBatchValue.set(this._lastValue);\n            this._gl.uniform3f(this._location, v0, v1, v2)\n        }\n        Init4f(v0, v1, v2, v3) {\n            if (!this.IsUsed())\n                return;\n            this._lastValue[0] = v0;\n            this._lastValue[1] = v1;\n            this._lastValue[2] = v2;\n            this._lastValue[3] = v3;\n            this._lastBatchValue.set(this._lastValue);\n            this._gl.uniform4f(this._location, v0, v1, v2, v3)\n        }\n        Update1f(v0) {\n            v0 = Math.fround(v0);\n            const lastValue = this._lastValue;\n            if (lastValue[0] === v0)\n                return;\n            lastValue[0] = v0;\n            this._gl.uniform1f(this._location, v0)\n        }\n        Update1i(v0) {\n            const lastValue = this._lastValue;\n            if (lastValue[0] === v0)\n                return;\n            lastValue[0] = v0;\n            this._gl.uniform1i(this._location, v0)\n        }\n        Update2f(v0, v1) {\n            v0 = Math.fround(v0);\n            v1 = Math.fround(v1);\n            const lastValue = this._lastValue;\n            if (lastValue[0] === v0 && lastValue[1] === v1)\n                return;\n            lastValue[0] = v0;\n            lastValue[1] = v1;\n            this._gl.uniform2f(this._location, v0, v1)\n        }\n        Update3f(v0, v1, v2) {\n            v0 = Math.fround(v0);\n            v1 = Math.fround(v1);\n            v2 = Math.fround(v2);\n            const lastValue = this._lastValue;\n            if (lastValue[0] === v0 && lastValue[1] === v1 && lastValue[2] === v2)\n                return;\n            lastValue[0] = v0;\n            lastValue[1] = v1;\n            lastValue[2] = v2;\n            this._gl.uniform3f(this._location, v0, v1, v2)\n        }\n        Update4f(v0, v1, v2, v3) {\n            v0 = Math.fround(v0);\n            v1 = Math.fround(v1);\n            v2 = Math.fround(v2);\n            v3 = Math.fround(v3);\n            const lastValue = this._lastValue;\n            if (lastValue[0] === v0 && lastValue[1] === v1 && lastValue[2] === v2 && lastValue[3] === v3)\n                return;\n            lastValue[0] = v0;\n            lastValue[1] = v1;\n            lastValue[2] = v2;\n            lastValue[3] = v3;\n            this._gl.uniform4f(this._location, v0, v1, v2, v3)\n        }\n        UpdateMatrix4fv(m) {\n            const lastValue = this._lastValue;\n            if (mat4.exactEquals(lastValue, m))\n                return;\n            C3.typedArraySet16(lastValue, m, 0);\n            this._gl.uniformMatrix4fv(this._location, false, m)\n        }\n        IsSetToCustomInBatch(p) {\n            const batchValue = this._lastBatchValue;\n            if (this.IsColorType())\n                return batchValue[0] === Math.fround(p.getR()) && batchValue[1] === Math.fround(p.getG()) && batchValue[2] === Math.fround(p.getB());\n            else\n                return batchValue[0] === Math.fround(p)\n        }\n        SetBatchValueCustom(p) {\n            const batchValue = this._lastBatchValue;\n            if (this.IsColorType()) {\n                batchValue[0] = p.getR();\n                batchValue[1] = p.getG();\n                batchValue[2] = p.getB()\n            } else\n                batchValue[0] = p\n        }\n        IsSetTo1InBatch(x) {\n            return this._lastBatchValue[0] === Math.fround(x)\n        }\n        IsSetTo2InBatch(x, y) {\n            const batchValue = this._lastBatchValue;\n            return batchValue[0] === Math.fround(x) && batchValue[1] === Math.fround(y)\n        }\n        SetBatch1(x) {\n            this._lastBatchValue[0] = x\n        }\n        SetBatch2(x, y) {\n            const batchValue = this._lastBatchValue;\n            batchValue[0] = x;\n            batchValue[1] = y\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/webgl\/batchJob.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const glMatrix = self.glMatrix;\n    const vec4 = glMatrix.vec4;\n    const mat4 = glMatrix.mat4;\n    const BATCH_NULL = 0;\n    const BATCH_QUAD = 1;\n    const BATCH_SETTEXTURE = 2;\n    const BATCH_SETCOLOR = 3;\n    const BATCH_SETBLEND = 4;\n    const BATCH_SETVIEWPORT = 5;\n    const BATCH_SETPROJECTION = 6;\n    const BATCH_SETMODELVIEW = 7;\n    const BATCH_SETRENDERTARGET = 8;\n    const BATCH_CLEARSURFACE = 9;\n    const BATCH_POINTS = 10;\n    const BATCH_SETPROGRAM = 11;\n    const BATCH_SETPROGRAMPARAMETERS = 12;\n    const BATCH_SETPROGRAMCUSTOMPARAMETERS = 13;\n    const BATCH_INVALIDATEFRAMEBUFFER = 14;\n    const BATCH_SETPOINTTEXCOORDS = 15;\n    const BATCH_SETTILEMAPINFO = 16;\n    const BATCH_BLITFRAMEBUFFER = 17;\n    const BATCH_STARTQUERY = 18;\n    const BATCH_ENDQUERY = 19;\n    const BATCH_SETELLIPSEPARAMS = 20;\n    const BATCH_SETGRADIENTCOLOR = 21;\n    const BATCH_CLEARDEPTH = 22;\n    const BATCH_SETDEPTHENABLED = 23;\n    const BATCH_SETDEPTHSAMPLINGENABLED = 24;\n    const BATCH_COPLANAR_STARTSTENCILPASS = 25;\n    const BATCH_COPLANAR_STARTCOLORPASS = 26;\n    const BATCH_COPLANAR_RESTORE = 27;\n    const BATCH_SET_SCISSOR = 28;\n    C3.Gfx.BatchState = class BatchState {\n        constructor(renderer) {\n            this.renderer = renderer;\n            this.currentMV = mat4.create();\n            this.currentMatP = mat4.create();\n            this.currentFramebuffer = null;\n            this.currentFramebufferNoDepth = null;\n            this.isDepthSamplingEnabled = false;\n            this.currentColor = vec4.fromValues(1, 1, 1, 1);\n            this.currentShader = null;\n            this.pointTexCoords = new C3.Rect;\n            this.clearColor = C3.New(C3.Color, 0, 0, 0, 0)\n        }\n    }\n    ;\n    C3.Gfx.WebGLBatchJob = class WebGLBatchJob {\n        constructor(batchState) {\n            const arrayBuffer = new ArrayBuffer(96);\n            this._type = 0;\n            this._batchState = batchState;\n            this._gl = batchState.renderer.GetContext();\n            this._startIndex = 0;\n            this._indexCount = 0;\n            this._texParam = null;\n            this._mat4param = new Float32Array(arrayBuffer,0,16);\n            this._colorParam = new Float32Array(arrayBuffer,64,4);\n            this._srcOriginRect = new Float32Array(arrayBuffer,80,4);\n            this._shaderParams = []\n        }\n        InitQuad(startIndex, indexCount) {\n            this._type = BATCH_QUAD;\n            this._startIndex = startIndex;\n            this._indexCount = indexCount\n        }\n        DoQuad() {\n            const gl = this._gl;\n            gl.drawElements(gl.TRIANGLES, this._indexCount, gl.UNSIGNED_SHORT, this._startIndex)\n        }\n        InitSetTexture(rendererTex) {\n            this._type = BATCH_SETTEXTURE;\n            this._texParam = rendererTex\n        }\n        DoSetTexture() {\n            const gl = this._gl;\n            const texParam = this._texParam;\n            gl.bindTexture(gl.TEXTURE_2D, texParam ? texParam._GetTexture() : null)\n        }\n        InitSetColor(c) {\n            this._type = BATCH_SETCOLOR;\n            c.writeToTypedArray(this._colorParam, 0)\n        }\n        DoSetColor() {\n            const c = this._colorParam;\n            const batchState = this._batchState;\n            vec4.copy(batchState.currentColor, c);\n            batchState.currentShader.UpdateColor(c)\n        }\n        InitSetGradientColor(c) {\n            this._type = BATCH_SETGRADIENTCOLOR;\n            c.writeToTypedArray(this._colorParam, 0)\n        }\n        DoSetGradientColor() {\n            const c = this._colorParam;\n            const s = this._batchState.currentShader;\n            if (s._uColor2.IsUsed())\n                s._uColor2.Update4f(c[0], c[1], c[2], c[3])\n        }\n        InitSetBlend(s, d) {\n            this._type = BATCH_SETBLEND;\n            this._startIndex = s;\n            this._indexCount = d\n        }\n        DoSetBlend() {\n            this._gl.blendFunc(this._startIndex, this._indexCount)\n        }\n        InitSetViewport(x, y, w, h) {\n            this._type = BATCH_SETVIEWPORT;\n            const colorParam = this._colorParam;\n            colorParam[0] = x;\n            colorParam[1] = y;\n            colorParam[2] = w;\n            colorParam[3] = h\n        }\n        DoSetViewport() {\n            const colorParam = this._colorParam;\n            this._gl.viewport(colorParam[0], colorParam[1], colorParam[2], colorParam[3])\n        }\n        InitSetProjection(m) {\n            this._type = BATCH_SETPROJECTION;\n            mat4.copy(this._mat4param, m)\n        }\n        DoSetProjection() {\n            const batchState = this._batchState;\n            const allShaderPrograms = batchState.renderer._allShaderPrograms;\n            const currentShader = batchState.currentShader;\n            const mat4param = this._mat4param;\n            for (let i = 0, len = allShaderPrograms.length; i < len; ++i) {\n                const s = allShaderPrograms[i];\n                if (s === currentShader)\n                    s.UpdateMatP(mat4param, true);\n                else\n                    s.SetMatPStale()\n            }\n            mat4.copy(batchState.currentMatP, mat4param)\n        }\n        InitSetModelView(m) {\n            this._type = BATCH_SETMODELVIEW;\n            mat4.copy(this._mat4param, m)\n        }\n        DoSetModelView() {\n            const batchState = this._batchState;\n            const allShaderPrograms = batchState.renderer._allShaderPrograms;\n            const currentShader = batchState.currentShader;\n            const mat4param = this._mat4param;\n            for (let i = 0, len = allShaderPrograms.length; i < len; ++i) {\n                const s = allShaderPrograms[i];\n                if (s === currentShader)\n                    s.UpdateMatMV(mat4param, true);\n                else\n                    s.SetMatMVStale()\n            }\n            mat4.copy(batchState.currentMV, mat4param)\n        }\n        InitSetRenderTarget(renderTarget) {\n            this._type = BATCH_SETRENDERTARGET;\n            this._texParam = renderTarget\n        }\n        DoSetRenderTarget() {\n            const gl = this._gl;\n            const renderTarget = this._texParam;\n            const batchState = this._batchState;\n            if (renderTarget) {\n                batchState.currentFramebuffer = renderTarget._GetFramebuffer();\n                batchState.currentFramebufferNoDepth = renderTarget._GetFramebufferNoDepth();\n                if (batchState.isDepthSamplingEnabled && batchState.currentFramebufferNoDepth)\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, batchState.currentFramebufferNoDepth);\n                else\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, batchState.currentFramebuffer)\n            } else {\n                batchState.currentFramebuffer = null;\n                batchState.currentFramebufferNoDepth = null;\n                gl.bindFramebuffer(gl.FRAMEBUFFER, null)\n            }\n        }\n        InitClearSurface(c) {\n            this._type = BATCH_CLEARSURFACE;\n            c.writeToTypedArray(this._mat4param, 0)\n        }\n        InitClearSurface2(r, g, b, a) {\n            this._type = BATCH_CLEARSURFACE;\n            const c = this._mat4param;\n            c[0] = r;\n            c[1] = g;\n            c[2] = b;\n            c[3] = a\n        }\n        DoClearSurface() {\n            const gl = this._gl;\n            const mat4param = this._mat4param;\n            const batchState = this._batchState;\n            const lastClearColor = batchState.clearColor;\n            const r = mat4param[0];\n            const g = mat4param[1];\n            const b = mat4param[2];\n            const a = mat4param[3];\n            if (!lastClearColor.equalsRgba(r, g, b, a)) {\n                gl.clearColor(r, g, b, a);\n                lastClearColor.setRgba(r, g, b, a)\n            }\n            gl.clear(gl.COLOR_BUFFER_BIT)\n        }\n        InitSetPointTexCoords(rect) {\n            this._type = BATCH_SETPOINTTEXCOORDS;\n            rect.writeToTypedArray(this._mat4param, 0)\n        }\n        DoSetPointTextureCoords() {\n            const mat4param = this._mat4param;\n            this._batchState.pointTexCoords.set(mat4param[0], mat4param[1], mat4param[2], mat4param[3])\n        }\n        InitPoints(startIndex, z) {\n            this._type = BATCH_POINTS;\n            this._startIndex = startIndex;\n            this._indexCount = 1;\n            this._mat4param[0] = z\n        }\n        DoPoints() {\n            const gl = this._gl;\n            const batchState = this._batchState;\n            const renderer = batchState.renderer;\n            const s = renderer._spPoints;\n            gl.useProgram(s._shaderProgram);\n            s.UpdateMatP(batchState.currentMatP, false);\n            s.UpdateMatMV(batchState.currentMV, false);\n            const ptc = batchState.pointTexCoords;\n            if (s._uPointTexStart.IsUsed())\n                s._uPointTexStart.Update2f(ptc.getLeft(), ptc.getTop());\n            if (s._uPointTexEnd.IsUsed())\n                s._uPointTexEnd.Update2f(ptc.getRight(), ptc.getBottom());\n            const z = this._mat4param[0];\n            if (s._uZElevation.IsUsed())\n                s._uZElevation.Update1f(z);\n            if (s._uColor.IsUsed()) {\n                const c = batchState.currentColor;\n                s._uColor.Update4f(c[0], c[1], c[2], c[3])\n            }\n            gl.drawArrays(gl.POINTS, this._startIndex \/ 4, this._indexCount);\n            gl.useProgram(batchState.currentShader._shaderProgram)\n        }\n        InitSetProgram(program) {\n            this._type = BATCH_SETPROGRAM;\n            this._texParam = program\n        }\n        DoSetProgram() {\n            const gl = this._gl;\n            const batchState = this._batchState;\n            const s = this._texParam;\n            batchState.currentShader = s;\n            gl.useProgram(s._shaderProgram);\n            s.UpdateMatP(batchState.currentMatP, false);\n            s.UpdateMatMV(batchState.currentMV, false);\n            if (s._uColor.IsUsed()) {\n                const c = batchState.currentColor;\n                s._uColor.Update4f(c[0], c[1], c[2], c[3])\n            }\n        }\n        InitSetProgramParameters() {\n            this._type = BATCH_SETPROGRAMPARAMETERS\n        }\n        DoSetProgramParameters() {\n            const s = this._batchState.currentShader;\n            const gl = this._gl;\n            const mat4param = this._mat4param;\n            const colorParam = this._colorParam;\n            const srcOriginRect = this._srcOriginRect;\n            if (s._uSamplerBack.IsUsed()) {\n                const renderer = this._batchState.renderer;\n                const texParam = this._texParam;\n                if (renderer._lastTexture1 !== texParam) {\n                    gl.activeTexture(gl.TEXTURE1);\n                    gl.bindTexture(gl.TEXTURE_2D, texParam ? texParam._GetTexture() : null);\n                    renderer._lastTexture1 = texParam;\n                    gl.activeTexture(gl.TEXTURE0)\n                }\n            }\n            if (s._uPixelSize.IsUsed())\n                s._uPixelSize.Update2f(mat4param[0], mat4param[1]);\n            if (s._uDestStart.IsUsed())\n                s._uDestStart.Update2f(mat4param[2], mat4param[3]);\n            if (s._uDestEnd.IsUsed())\n                s._uDestEnd.Update2f(mat4param[4], mat4param[5]);\n            if (s._uDevicePixelRatio.IsUsed())\n                s._uDevicePixelRatio.Update1f(this._indexCount);\n            if (s._uLayerScale.IsUsed())\n                s._uLayerScale.Update1f(mat4param[6]);\n            if (s._uLayerAngle.IsUsed())\n                s._uLayerAngle.Update1f(mat4param[7]);\n            if (s._uSrcStart.IsUsed())\n                s._uSrcStart.Update2f(mat4param[12], mat4param[13]);\n            if (s._uSrcEnd.IsUsed())\n                s._uSrcEnd.Update2f(mat4param[14], mat4param[15]);\n            if (s._uSrcOriginStart.IsUsed())\n                s._uSrcOriginStart.Update2f(srcOriginRect[0], srcOriginRect[1]);\n            if (s._uSrcOriginEnd.IsUsed())\n                s._uSrcOriginEnd.Update2f(srcOriginRect[2], srcOriginRect[3]);\n            if (s._uLayoutStart.IsUsed())\n                s._uLayoutStart.Update2f(colorParam[0], colorParam[1]);\n            if (s._uLayoutEnd.IsUsed())\n                s._uLayoutEnd.Update2f(colorParam[2], colorParam[3]);\n            if (s._uSeconds.IsUsed())\n                s._uSeconds.Update1f(this._startIndex)\n        }\n        InitSetProgramCustomParameters() {\n            this._type = BATCH_SETPROGRAMCUSTOMPARAMETERS\n        }\n        DoSetProgramCustomParameters() {\n            const s = this._batchState.currentShader;\n            const uCustomParameters = s._uCustomParameters;\n            const shaderParams = this._shaderParams;\n            for (let i = 0, len = uCustomParameters.length; i < len; ++i) {\n                const shaderUniform = uCustomParameters[i];\n                const paramValue = shaderParams[i];\n                if (shaderUniform.IsColorType())\n                    shaderUniform.Update3f(paramValue.getR(), paramValue.getG(), paramValue.getB());\n                else\n                    shaderUniform.Update1f(paramValue)\n            }\n        }\n        InitInvalidateFramebuffer(fbo) {\n            this._type = BATCH_INVALIDATEFRAMEBUFFER;\n            this._texParam = fbo\n        }\n        DoInvalidateFramebuffer() {\n            const gl = this._gl;\n            const fbo = this._texParam;\n            const lastBoundFbo = this._batchState.currentFramebuffer;\n            if (fbo !== lastBoundFbo)\n                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n            gl.invalidateFramebuffer(gl.FRAMEBUFFER, [gl.COLOR_ATTACHMENT0]);\n            if (fbo !== lastBoundFbo)\n                gl.bindFramebuffer(gl.FRAMEBUFFER, lastBoundFbo)\n        }\n        InitBlitFramebuffer(sourceRenderTarget, destRenderTarget, mode) {\n            this._type = BATCH_BLITFRAMEBUFFER;\n            const mat4param = this._mat4param;\n            const renderer = this._batchState.renderer;\n            mat4param[0] = sourceRenderTarget.GetWidth();\n            mat4param[1] = sourceRenderTarget.GetHeight();\n            mat4param[2] = destRenderTarget ? destRenderTarget.GetWidth() : renderer.GetWidth();\n            mat4param[3] = destRenderTarget ? destRenderTarget.GetHeight() : renderer.GetHeight();\n            mat4param[4] = sourceRenderTarget.IsLinearSampling() ? 1 : 0;\n            mat4param[5] = mode === "stretch";\n            const shaderParams = this._shaderParams;\n            C3.clearArray(shaderParams);\n            shaderParams.push(sourceRenderTarget._GetFramebuffer());\n            shaderParams.push(destRenderTarget ? destRenderTarget._GetFramebuffer() : null)\n        }\n        DoBlitFramebuffer() {\n            const mat4param = this._mat4param;\n            const shaderParams = this._shaderParams;\n            const gl = this._gl;\n            const srcWidth = mat4param[0];\n            const srcHeight = mat4param[1];\n            const destWidth = mat4param[2];\n            const destHeight = mat4param[3];\n            const isLinearSampling = mat4param[4] !== 0;\n            const isStretch = mat4param[5] !== 0;\n            const srcFbo = shaderParams[0];\n            const destFbo = shaderParams[1];\n            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFbo);\n            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, destFbo);\n            if (isStretch)\n                gl.blitFramebuffer(0, 0, srcWidth, srcHeight, 0, 0, destWidth, destHeight, gl.COLOR_BUFFER_BIT, isLinearSampling ? gl.LINEAR : gl.NEAREST);\n            else {\n                const w = Math.min(srcWidth, destWidth);\n                const h = Math.min(srcHeight, destHeight);\n                const srcOffY = Math.max(srcHeight - destHeight, 0);\n                const destOffY = Math.max(destHeight - srcHeight, 0);\n                gl.blitFramebuffer(0, srcOffY, w, h + srcOffY, 0, destOffY, w, h + destOffY, gl.COLOR_BUFFER_BIT, gl.NEAREST)\n            }\n        }\n        InitStartQuery(query) {\n            this._type = BATCH_STARTQUERY;\n            this._texParam = query\n        }\n        DoStartQuery() {\n            this._texParam.BeginTimeElapsed();\n            this._texParam = null\n        }\n        InitEndQuery(query) {\n            this._type = BATCH_ENDQUERY;\n            this._texParam = query\n        }\n        DoEndQuery() {\n            this._texParam.EndTimeElapsed();\n            this._texParam = null\n        }\n        InitSetEllipseParams(pixelW, pixelH, outlineThickness) {\n            this._type = BATCH_SETELLIPSEPARAMS;\n            const mat4param = this._mat4param;\n            mat4param[0] = pixelW;\n            mat4param[1] = pixelH;\n            mat4param[2] = outlineThickness\n        }\n        DoSetEllipseParams() {\n            const s = this._batchState.currentShader;\n            const mat4param = this._mat4param;\n            if (s._uPixelSize.IsUsed())\n                s._uPixelSize.Update2f(mat4param[0], mat4param[1]);\n            if (s._uOutlineThickness.IsUsed())\n                s._uOutlineThickness.Update1f(mat4param[2])\n        }\n        InitSetTilemapInfo(srcRect, textureWidth, textureHeight, tileWidth, tileHeight, tileSpacingX, tileSpacingY) {\n            this._type = BATCH_SETTILEMAPINFO;\n            const mat4param = this._mat4param;\n            srcRect.writeToTypedArray(mat4param, 0);\n            mat4param[4] = 1 \/ textureWidth;\n            mat4param[5] = 1 \/ textureHeight;\n            mat4param[6] = tileWidth \/ textureWidth;\n            mat4param[7] = tileHeight \/ textureHeight;\n            mat4param[8] = tileSpacingX \/ textureWidth;\n            mat4param[9] = tileSpacingY \/ textureHeight\n        }\n        DoSetTilemapInfo() {\n            const s = this._batchState.currentShader;\n            const mat4param = this._mat4param;\n            if (s._uSrcStart.IsUsed())\n                s._uSrcStart.Update2f(mat4param[0], mat4param[1]);\n            if (s._uPixelSize.IsUsed())\n                s._uPixelSize.Update2f(mat4param[4], mat4param[5]);\n            if (s._uTileSize.IsUsed())\n                s._uTileSize.Update2f(mat4param[6], mat4param[7]);\n            if (s._uTileSpacing.IsUsed())\n                s._uTileSpacing.Update2f(mat4param[8], mat4param[9])\n        }\n        InitClearDepth(isDepthEnabled) {\n            this._type = BATCH_CLEARDEPTH;\n            this._startIndex = isDepthEnabled ? 1 : 0\n        }\n        DoClearDepth() {\n            const gl = this._gl;\n            const isDepthEnabled = this._startIndex !== 0;\n            if (!isDepthEnabled)\n                gl.depthMask(true);\n            gl.clear(gl.DEPTH_BUFFER_BIT);\n            if (!isDepthEnabled)\n                gl.depthMask(false)\n        }\n        InitSetDepthEnabled(e) {\n            this._type = BATCH_SETDEPTHENABLED;\n            this._startIndex = e ? 1 : 0\n        }\n        DoSetDepthEnabled() {\n            const gl = this._gl;\n            if (this._startIndex === 0) {\n                gl.disable(gl.DEPTH_TEST);\n                gl.depthMask(false)\n            } else {\n                gl.enable(gl.DEPTH_TEST);\n                gl.depthMask(true)\n            }\n        }\n        InitSetDepthSamplingEnabled(e) {\n            this._type = BATCH_SETDEPTHSAMPLINGENABLED;\n            this._startIndex = e ? 1 : 0\n        }\n        DoSetDepthSamplingEnabled() {\n            const gl = this._gl;\n            const batchState = this._batchState;\n            const renderer = batchState.renderer;\n            const isDepthSamplingEnabled = this._startIndex !== 0;\n            batchState.isDepthSamplingEnabled = isDepthSamplingEnabled;\n            gl.activeTexture(gl.TEXTURE2);\n            if (isDepthSamplingEnabled) {\n                if (batchState.currentFramebufferNoDepth)\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, batchState.currentFramebufferNoDepth);\n                gl.bindTexture(gl.TEXTURE_2D, renderer._GetDepthBuffer())\n            } else {\n                gl.bindTexture(gl.TEXTURE_2D, null);\n                if (batchState.currentFramebufferNoDepth)\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, batchState.currentFramebuffer)\n            }\n            gl.activeTexture(gl.TEXTURE0)\n        }\n        InitCoplanarStartStencilPass() {\n            this._type = BATCH_COPLANAR_STARTSTENCILPASS\n        }\n        DoCoplanarStartStencilPass() {\n            const gl = this._gl;\n            gl.clear(gl.STENCIL_BUFFER_BIT);\n            gl.enable(gl.STENCIL_TEST);\n            gl.stencilFunc(gl.ALWAYS, 1, 1);\n            gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n            gl.colorMask(false, false, false, false)\n        }\n        InitCoplanarStartColorPass() {\n            this._type = BATCH_COPLANAR_STARTCOLORPASS\n        }\n        DoCoplanarStartColorPass() {\n            const gl = this._gl;\n            gl.colorMask(true, true, true, true);\n            gl.stencilFunc(gl.EQUAL, 1, 1);\n            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP)\n        }\n        InitCoplanarRestore() {\n            this._type = BATCH_COPLANAR_RESTORE\n        }\n        DoCoplanarRestore() {\n            const gl = this._gl;\n            gl.disable(gl.STENCIL_TEST)\n        }\n        InitSetScissor(enable, x, y, w, h) {\n            this._type = BATCH_SET_SCISSOR;\n            this._startIndex = enable ? 1 : 0;\n            const mat4param = this._mat4param;\n            mat4param[0] = x;\n            mat4param[1] = y;\n            mat4param[2] = w;\n            mat4param[3] = h\n        }\n        DoSetScissor() {\n            const gl = this._gl;\n            const mat4param = this._mat4param;\n            if (this._startIndex === 1) {\n                gl.enable(gl.SCISSOR_TEST);\n                gl.scissor(mat4param[0], mat4param[1], mat4param[2], mat4param[3])\n            } else\n                gl.disable(gl.SCISSOR_TEST)\n        }\n        Run() {\n            switch (this._type) {\n            case 1:\n                this.DoQuad();\n                return;\n            case 2:\n                this.DoSetTexture();\n                return;\n            case 3:\n                this.DoSetColor();\n                return;\n            case 4:\n                this.DoSetBlend();\n                return;\n            case 5:\n                this.DoSetViewport();\n                return;\n            case 6:\n                this.DoSetProjection();\n                return;\n            case 7:\n                this.DoSetModelView();\n                return;\n            case 8:\n                this.DoSetRenderTarget();\n                return;\n            case 9:\n                this.DoClearSurface();\n                return;\n            case 10:\n                this.DoPoints();\n                return;\n            case 11:\n                this.DoSetProgram();\n                return;\n            case 12:\n                this.DoSetProgramParameters();\n                return;\n            case 13:\n                this.DoSetProgramCustomParameters();\n                return;\n            case 14:\n                this.DoInvalidateFramebuffer();\n                return;\n            case 15:\n                this.DoSetPointTextureCoords();\n                return;\n            case 16:\n                this.DoSetTilemapInfo();\n                return;\n            case 17:\n                this.DoBlitFramebuffer();\n                return;\n            case 18:\n                this.DoStartQuery();\n                return;\n            case 19:\n                this.DoEndQuery();\n                return;\n            case 20:\n                this.DoSetEllipseParams();\n                return;\n            case 21:\n                this.DoSetGradientColor();\n                return;\n            case 22:\n                this.DoClearDepth();\n                return;\n            case 23:\n                this.DoSetDepthEnabled();\n                return;\n            case 24:\n                this.DoSetDepthSamplingEnabled();\n                return;\n            case 25:\n                this.DoCoplanarStartStencilPass();\n                return;\n            case 26:\n                this.DoCoplanarStartColorPass();\n                return;\n            case 27:\n                this.DoCoplanarRestore();\n                return;\n            case 28:\n                this.DoSetScissor();\n                return\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/text.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const MAX_TEXTURE_SIZE = 4096;\n    const EXTRA_LINE_HEIGHT = 4;\n    const GENERIC_FONT_FAMILIES = new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]);\n    const DEFAULT_OPTS = {\n        timeout: 60\n    };\n    const tempColor = new C3.Color(0,0,0,1);\n    const VALID_HORIZ_ALIGNMENTS = new Set(["left", "center", "right"]);\n    const VALID_VERT_ALIGNMENTS = new Set(["top", "center", "bottom"]);\n    const VALID_WORD_WRAP_MODES = new Set(["word", "character"]);\n    const allRendererTexts = new Set;\n    if (C3.FontManager)\n        C3.FontManager.addEventListener("fontload", e => {\n            const fontName = e.font.GetName();\n            for (const f of allRendererTexts)\n                if (f.IsBBCodeEnabled() || C3.equalsNoCase(f.GetFontName(), fontName))\n                    f._SetTextChanged()\n        }\n        );\n    function fillOrStrokeText(ctx, isStroke, text, x, y, maxWidth) {\n        if (isStroke)\n            if (C3.Platform.BrowserEngine === "Gecko")\n                ctx.strokeText(text, x, y, maxWidth);\n            else\n                ctx.strokeText(text, x, y);\n        else if (C3.Platform.BrowserEngine === "Gecko")\n            ctx.fillText(text, x, y, maxWidth);\n        else\n            ctx.fillText(text, x, y)\n    }\n    function fillOrStrokeRect(ctx, isStroke, x, y, w, h) {\n        if (isStroke)\n            ctx.strokeRect(x, y, w, h);\n        else\n            ctx.fillRect(x, y, w, h)\n    }\n    function ptToPx(pt) {\n        return pt * (4 \/ 3)\n    }\n    let didCheckFoundBoundingBoxSupport = false;\n    let supportsFontBoundingBoxMeasurements = false;\n    C3.Gfx.RendererText = class RendererText {\n        constructor(renderer, opts) {\n            opts = Object.assign({}, DEFAULT_OPTS, opts);\n            this._renderer = renderer;\n            this._fontName = "Arial";\n            this._fontSize = 16;\n            this._fontSizeScale = 1;\n            this._lineHeight = 0;\n            this._isBold = false;\n            this._isItalic = false;\n            this._colorStr = "black";\n            this._isBBcodeEnabled = false;\n            this.onloadfont = null;\n            this._alreadyLoadedFonts = new Set;\n            this._horizontalAlign = "left";\n            this._verticalAlign = "top";\n            this._text = "";\n            this._bbString = null;\n            this._wrappedText = C3.New(C3.WordWrap);\n            this._wrapMode = "word";\n            this._textChanged = false;\n            this._isUpdating = false;\n            this._isAsync = true;\n            this._drawMaxCharCount = -1;\n            this._drawCharCount = 0;\n            this._cssWidth = 0;\n            this._cssHeight = 0;\n            this._width = 0;\n            this._height = 0;\n            this._zoom = 1;\n            this._changed = false;\n            this._textCanvas = null;\n            this._textContext = null;\n            this._measureContext = null;\n            this._measureContextTop = null;\n            this._lastCanvasWidth = -1;\n            this._lastCanvasHeight = -1;\n            this._lastTextCanvasFont = "";\n            this._lastMeasureCanvasFont = "";\n            this._lastTextCanvasFillStyle = "";\n            this._lastTextCanvasOpacity = 1;\n            this._lastTextCanvasLineWidth = 1;\n            this._measureTextCallback = (chArr, styles) => this._MeasureText(chArr, styles);\n            this._texture = null;\n            this._textureWidth = 0;\n            this._textureHeight = 0;\n            this._rcTex = new C3.Rect;\n            this._scaleFactor = 1;\n            this._needToRecreateTexture = false;\n            this._textureTimeout = new C3.IdleTimeout( () => {\n                this.ReleaseTexture();\n                this._SetTextCanvasSize(8, 8)\n            }\n            ,opts.timeout);\n            this.ontextureupdate = null;\n            this._wasReleased = false;\n            allRendererTexts.add(this)\n        }\n        Release() {\n            this.onloadfont = null;\n            this._alreadyLoadedFonts.clear();\n            this._bbString = null;\n            this._textCanvas = null;\n            this._textContext = null;\n            this._measureContext = null;\n            this._measureContextTop = null;\n            this._measureTextCallback = null;\n            this._textureTimeout.Release();\n            this.ontextureupdate = null;\n            this.ReleaseTexture();\n            this._wrappedText.Clear();\n            this._wrappedText = null;\n            this._renderer = null;\n            this._wasReleased = true;\n            allRendererTexts.delete(this)\n        }\n        _SetChanged() {\n            this._changed = true\n        }\n        _SetTextChanged() {\n            this._SetChanged();\n            this._wrappedText.Clear();\n            this._textChanged = true\n        }\n        SetIsAsync(a) {\n            this._isAsync = !!a\n        }\n        IsAsync() {\n            return this._isAsync\n        }\n        SetBBCodeEnabled(e) {\n            e = !!e;\n            if (this._isBBcodeEnabled === e)\n                return;\n            this._isBBcodeEnabled = e;\n            const textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top";\n            if (this._textContext)\n                this._textContext.textBaseline = textBaseline;\n            if (this._measureContext)\n                this._measureContext.textBaseline = textBaseline;\n            this._SetTextChanged()\n        }\n        IsBBCodeEnabled() {\n            return this._isBBcodeEnabled\n        }\n        SetFontName(fontName) {\n            if (!fontName)\n                fontName = "serif";\n            if (this._fontName === fontName)\n                return;\n            this._fontName = fontName;\n            this._SetTextChanged()\n        }\n        GetFontName() {\n            return this._fontName\n        }\n        SetFontSize(fontSize) {\n            if (fontSize < .1)\n                fontSize = .1;\n            if (this._fontSize === fontSize)\n                return;\n            this._fontSize = fontSize;\n            this._SetTextChanged()\n        }\n        SetFontSizeScale(s) {\n            if (this._fontSizeScale === s)\n                return;\n            this._fontSizeScale = s;\n            this._SetTextChanged()\n        }\n        SetLineHeight(h) {\n            if (this._lineHeight === h)\n                return;\n            this._lineHeight = h;\n            this._SetChanged()\n        }\n        SetBold(bold) {\n            bold = !!bold;\n            if (this._isBold === bold)\n                return;\n            this._isBold = bold;\n            this._SetTextChanged()\n        }\n        SetItalic(italic) {\n            italic = !!italic;\n            if (this._isItalic === italic)\n                return;\n            this._isItalic = italic;\n            this._SetTextChanged()\n        }\n        SetDrawMaxCharacterCount(n) {\n            n = Math.floor(n);\n            if (this._drawMaxCharCount === n)\n                return;\n            this._drawMaxCharCount = n;\n            this._SetChanged()\n        }\n        GetDrawMaxCharacterCount() {\n            return this._drawMaxCharCount\n        }\n        _GetStyleTag(styles, tag) {\n            for (let i = styles.length - 1; i >= 0; --i) {\n                const s = styles[i];\n                if (s.tag === tag)\n                    return s\n            }\n            return null\n        }\n        _HasStyleTag(styles, tag) {\n            return !!this._GetStyleTag(styles, tag)\n        }\n        _GetFontString(useCssUnits, styles) {\n            let ret = [];\n            if (this._isBold || this._HasStyleTag(styles, "b"))\n                ret.push("bold");\n            if (this._isItalic || this._HasStyleTag(styles, "i"))\n                ret.push("italic");\n            const sizeStyle = this._GetStyleTag(styles, "size");\n            const fontSize = (sizeStyle ? parseFloat(sizeStyle.param) : this._fontSize) * this._fontSizeScale;\n            if (useCssUnits)\n                ret.push(fontSize + "pt");\n            else\n                ret.push(fontSize * this._scaleFactor * this._zoom * self.devicePixelRatio + "pt");\n            let fontName = this._fontName;\n            const fontStyle = this._GetStyleTag(styles, "font");\n            if (fontStyle && fontStyle.param) {\n                fontName = fontStyle.param;\n                if (this.onloadfont && !this._alreadyLoadedFonts.has(fontName)) {\n                    this.onloadfont(fontName);\n                    this._alreadyLoadedFonts.add(fontName)\n                }\n            }\n            if (fontName)\n                if (GENERIC_FONT_FAMILIES.has(fontName))\n                    ret.push(fontName);\n                else\n                    ret.push(\'"\' + fontName + \'"\');\n            return ret.join(" ")\n        }\n        SetColor(c) {\n            if (c instanceof C3.Color)\n                c = c.getCssRgb();\n            if (this._colorStr === c)\n                return;\n            this._colorStr = c;\n            this._SetChanged()\n        }\n        SetColorRgb(r, g, b) {\n            tempColor.setRgb(r, g, b);\n            this.SetColor(tempColor)\n        }\n        SetHorizontalAlignment(h) {\n            if (!VALID_HORIZ_ALIGNMENTS.has(h))\n                throw new Error("invalid horizontal alignment");\n            if (this._horizontalAlign === h)\n                return;\n            this._horizontalAlign = h;\n            this._SetChanged()\n        }\n        SetVerticalAlignment(v) {\n            if (!VALID_VERT_ALIGNMENTS.has(v))\n                throw new Error("invalid vertical alignment");\n            if (this._verticalAlign === v)\n                return;\n            this._verticalAlign = v;\n            this._SetChanged()\n        }\n        SetWordWrapMode(m) {\n            if (!VALID_WORD_WRAP_MODES.has(m))\n                throw new Error("invalid word wrap mode");\n            if (this._wrapMode === m)\n                return;\n            this._wrapMode = m;\n            this._SetTextChanged()\n        }\n        SetText(text) {\n            if (this._text === text)\n                return;\n            this._text = text;\n            this._SetTextChanged()\n        }\n        SetSize(cssWidth, cssHeight, zoom) {\n            if (typeof zoom === "undefined")\n                zoom = 1;\n            if (cssWidth <= 0 || cssWidth <= 0)\n                return;\n            if (this._cssWidth === cssWidth && this._cssHeight === cssHeight && this._zoom === zoom)\n                return;\n            if (this._zoom === 1 !== (zoom === 1))\n                this._needToRecreateTexture = true;\n            const oldCssWidth = this._cssWidth;\n            const oldZoom = this._zoom;\n            this._cssWidth = cssWidth;\n            this._cssHeight = cssHeight;\n            this._zoom = zoom;\n            const dpr = self.devicePixelRatio;\n            this._width = this._cssWidth * this._zoom * dpr;\n            this._height = this._cssHeight * this._zoom * dpr;\n            const maxDim = Math.max(this._width, this._height);\n            const maxTextureSize = Math.min(this._renderer.GetMaxTextureSize(), MAX_TEXTURE_SIZE);\n            let scale = 1;\n            if (maxDim > maxTextureSize) {\n                scale = maxTextureSize \/ maxDim;\n                this._width = Math.min(this._width * scale, maxTextureSize);\n                this._height = Math.min(this._height * scale, maxTextureSize)\n            }\n            this._scaleFactor = scale;\n            if (this._textureWidth > 0 && this._textureHeight > 0 && this._zoom === oldZoom)\n                this._rcTex.set(0, 0, this._width \/ this._textureWidth, this._height \/ this._textureHeight);\n            if (this._cssWidth !== oldCssWidth)\n                this._SetTextChanged();\n            else\n                this._SetChanged()\n        }\n        GetWidth() {\n            return this._width\n        }\n        GetHeight() {\n            return this._height\n        }\n        GetTextWidth() {\n            this._MaybeWrapText();\n            return this._wrappedText.GetMaxLineWidth()\n        }\n        GetTextHeight() {\n            this._MaybeWrapText();\n            return this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() * (this._lineHeight + EXTRA_LINE_HEIGHT) - this._lineHeight\n        }\n        GetTexture() {\n            this._textureTimeout.Reset();\n            this._MaybeUpdate();\n            return this._texture\n        }\n        _MaybeUpdate() {\n            if (this._texture && !this._changed && !this._textChanged)\n                return;\n            if (this._isUpdating)\n                return;\n            if (this._width <= 0 || this._height <= 0)\n                return;\n            this._changed = false;\n            this._isUpdating = true;\n            if (this._isAsync)\n                C3.Asyncify( () => this._DoUpdate());\n            else\n                this._DoUpdate()\n        }\n        _DoUpdate() {\n            if (this._wasReleased)\n                return;\n            this._SetTextCanvasSize(Math.ceil(this._width), Math.ceil(this._height));\n            this._MaybeWrapText();\n            this._DrawTextToCanvas();\n            this._UpdateTexture();\n            this._textureTimeout.Reset();\n            this._isUpdating = false\n        }\n        _SetTextCanvasSize(w, h) {\n            if (!this._textCanvas)\n                this._textCanvas = C3.CreateCanvas(16, 16);\n            let wasReset = false;\n            if (this._lastCanvasWidth !== w || this._lastCanvasHeight !== h) {\n                this._lastCanvasWidth = w;\n                this._lastCanvasHeight = h;\n                this._textCanvas.width = w;\n                this._textCanvas.height = h;\n                wasReset = true\n            }\n            if (!this._textContext) {\n                this._textContext = this._textCanvas.getContext("2d");\n                wasReset = true\n            }\n            if (wasReset) {\n                this._textContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top";\n                this._textContext.font = this._lastTextCanvasFont;\n                this._textContext.fillStyle = this._lastTextCanvasFillStyle;\n                this._textContext.strokeStyle = this._lastTextCanvasFillStyle;\n                this._textContext.globalAlpha = this._lastTextCanvasOpacity;\n                this._textContext.lineWidth = this._lastTextCanvasLineWidth\n            } else\n                this._textContext.clearRect(0, 0, w, h)\n        }\n        _MaybeCreateMeasureContext() {\n            if (this._measureContext)\n                return;\n            this._measureContext = C3.CreateCanvas(16, 16).getContext("2d");\n            this._measureContextTop = C3.CreateCanvas(16, 16).getContext("2d");\n            this._measureContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top";\n            this._measureContextTop.textBaseline = "top"\n        }\n        _SetMeasureFontString(fontString) {\n            if (this._lastMeasureCanvasFont === fontString)\n                return;\n            this._lastMeasureCanvasFont = fontString;\n            this._measureContext.font = fontString;\n            this._measureContextTop.font = fontString\n        }\n        _SupportsFontBoundingBoxMeasurements() {\n            if (!didCheckFoundBoundingBoxSupport) {\n                didCheckFoundBoundingBoxSupport = true;\n                this._MaybeCreateMeasureContext();\n                const textMetrics = this._measureContext.measureText("test");\n                supportsFontBoundingBoxMeasurements = typeof textMetrics["fontBoundingBoxAscent"] === "number" && typeof textMetrics["fontBoundingBoxDescent"] === "number"\n            }\n            return supportsFontBoundingBoxMeasurements\n        }\n        _MaybeWrapText() {\n            if (!this._textChanged)\n                return;\n            this._MaybeCreateMeasureContext();\n            if (this._isBBcodeEnabled && (!this._bbString || this._bbString.toString() !== this._text))\n                this._bbString = new C3.BBString(this._text,{\n                    noEscape: true\n                });\n            this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0);\n            this._textChanged = false\n        }\n        _MeasureText(chArr, styles) {\n            const text = chArr.join("");\n            this._SetMeasureFontString(this._GetFontString(true, styles));\n            const sizeStyle = this._GetStyleTag(styles, "size");\n            const fontSize = (sizeStyle ? parseFloat(sizeStyle.param) : this._fontSize) * this._fontSizeScale;\n            const textMetrics = this._measureContext.measureText(text);\n            let topToAlphabeticDistance = 0;\n            if (this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements()) {\n                const textMetricsTop = this._measureContextTop.measureText(text);\n                topToAlphabeticDistance = textMetrics["fontBoundingBoxAscent"] - textMetricsTop["fontBoundingBoxAscent"]\n            }\n            return {\n                width: textMetrics.width,\n                height: ptToPx(fontSize),\n                fontBoundingBoxAscent: textMetrics["fontBoundingBoxAscent"] || 0,\n                fontBoundingBoxDescent: textMetrics["fontBoundingBoxDescent"] || 0,\n                topToAlphabeticDistance\n            }\n        }\n        _SetDrawFontString(fontString) {\n            if (this._lastTextCanvasFont === fontString)\n                return;\n            this._lastTextCanvasFont = fontString;\n            this._textContext.font = fontString\n        }\n        _SetDrawCanvasColor(styleStr) {\n            if (this._lastTextCanvasFillStyle === styleStr)\n                return;\n            this._lastTextCanvasFillStyle = styleStr;\n            this._textContext.fillStyle = styleStr;\n            this._textContext.strokeStyle = styleStr\n        }\n        _SetDrawCanvasOpacity(o) {\n            if (this._lastTextCanvasOpacity === o)\n                return;\n            this._lastTextCanvasOpacity = o;\n            this._textContext.globalAlpha = o\n        }\n        _SetDrawCanvasLineWith(w) {\n            if (this._lastTextCanvasLineWidth === w)\n                return;\n            this._lastTextCanvasLineWidth = w;\n            this._textContext.lineWidth = w\n        }\n        _DrawTextToCanvas() {\n            this._drawCharCount = 0;\n            const scale = this._scaleFactor * this._zoom * self.devicePixelRatio;\n            const lineSpaceHeight = (EXTRA_LINE_HEIGHT + this._lineHeight) * scale;\n            let penY = 0;\n            const lines = this._wrappedText.GetLines();\n            if (lines.length === 0)\n                return;\n            const useFontBoundingBoxMeasurements = this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements();\n            let firstLineTextHeight = lines[0].height * scale;\n            if (this._verticalAlign === "center") {\n                const linesTotalHeight = lines.reduce( (a, v) => a + v.height * scale + lineSpaceHeight, 0) - lineSpaceHeight;\n                penY = Math.max(this._height \/ 2 - linesTotalHeight \/ 2, 0);\n                if (useFontBoundingBoxMeasurements)\n                    firstLineTextHeight = lines[0].topToAlphabeticDistance * scale\n            } else if (this._verticalAlign === "bottom") {\n                const linesTotalHeight = lines.reduce( (a, v) => a + v.height * scale + lineSpaceHeight, 0) - this._lineHeight * scale;\n                const lastLineDescentHeight = useFontBoundingBoxMeasurements ? lines.at(-1).fontBoundingBoxDescent * scale : 0;\n                penY = this._height - linesTotalHeight - lastLineDescentHeight - 2\n            }\n            for (let i = 0, len = lines.length; i < len; ++i) {\n                const line = lines[i];\n                const curLineTextHeight = line.height * scale;\n                const startPenY = penY;\n                if (this._isBBcodeEnabled) {\n                    penY += i === 0 ? firstLineTextHeight : curLineTextHeight;\n                    if (i > 0 && penY > this._height - EXTRA_LINE_HEIGHT * scale)\n                        break\n                } else if (i > 0 && penY >= this._height - curLineTextHeight)\n                    break;\n                if (startPenY >= 0)\n                    this._DrawTextLine(line, penY, scale);\n                if (!this._isBBcodeEnabled)\n                    penY += curLineTextHeight;\n                penY += lineSpaceHeight\n            }\n        }\n        _DrawTextLine(line, penY, scale) {\n            let penX = 0;\n            if (this._horizontalAlign === "center")\n                penX = (this._width - line.width * scale) \/ 2;\n            else if (this._horizontalAlign === "right")\n                penX = this._width - line.width * scale;\n            for (const frag of line.fragments) {\n                this._DrawTextFragment(frag, penX, penY, scale, line.height);\n                penX += frag.width * scale\n            }\n        }\n        _DrawTextFragment(frag, penX, penY, scale, lineHeight) {\n            const textContext = this._textContext;\n            const lineFontScale = lineHeight \/ 16;\n            let fragWidth = frag.width * scale;\n            const fragHeight = frag.height * scale;\n            const fragFontScale = frag.height \/ 16;\n            const lineSpaceHeight = (EXTRA_LINE_HEIGHT + this._lineHeight) * scale;\n            const styles = frag.styles;\n            let chArr = frag.chArr;\n            if (this._drawMaxCharCount !== -1) {\n                if (this._drawCharCount >= this._drawMaxCharCount)\n                    return;\n                if (this._drawCharCount + chArr.length > this._drawMaxCharCount) {\n                    chArr = chArr.slice(0, this._drawMaxCharCount - this._drawCharCount);\n                    fragWidth = this._MeasureText(chArr, styles).width * scale\n                }\n                this._drawCharCount += chArr.length\n            }\n            const backgroundStyle = this._GetStyleTag(styles, "background");\n            const hasUnderline = this._HasStyleTag(styles, "u");\n            const hasStrikethrough = this._HasStyleTag(styles, "s");\n            if (C3.IsCharArrayAllWhitespace(chArr) && !backgroundStyle && !hasUnderline && !hasStrikethrough || this._HasStyleTag(styles, "hide"))\n                return;\n            const text = chArr.join("");\n            const offsetXStyle = this._GetStyleTag(styles, "offsetx");\n            penX += offsetXStyle ? parseFloat(offsetXStyle.param) * scale : 0;\n            const offsetYStyle = this._GetStyleTag(styles, "offsety");\n            penY += offsetYStyle ? parseFloat(offsetYStyle.param) * scale : 0;\n            if (backgroundStyle) {\n                this._SetDrawCanvasColor(backgroundStyle.param);\n                textContext.fillRect(penX, penY - fragHeight, fragWidth, fragHeight + lineSpaceHeight)\n            }\n            const colorStyle = this._GetStyleTag(styles, "color");\n            this._SetDrawCanvasColor(colorStyle ? colorStyle.param : this._colorStr);\n            const opacityStyle = this._GetStyleTag(styles, "opacity");\n            this._SetDrawCanvasOpacity(opacityStyle ? parseFloat(opacityStyle.param) \/ 100 : 1);\n            const lineThicknessStyle = this._GetStyleTag(styles, "linethickness");\n            const lineThicknessScale = lineThicknessStyle ? parseFloat(lineThicknessStyle.param) : 1;\n            const isStroke = this._HasStyleTag(styles, "stroke");\n            if (isStroke)\n                this._SetDrawCanvasLineWith(fragFontScale * .5 * lineThicknessScale * this._scaleFactor * this._zoom * self.devicePixelRatio);\n            this._SetDrawFontString(this._GetFontString(false, styles));\n            fillOrStrokeText(textContext, isStroke, text, penX, penY, fragWidth);\n            if (!isStroke) {\n                this._SetDrawCanvasLineWith(fragFontScale * .5 * lineThicknessScale * this._scaleFactor * this._zoom * self.devicePixelRatio);\n                const outlineStyle = this._GetStyleTag(styles, "outline");\n                if (outlineStyle) {\n                    this._SetDrawCanvasColor(outlineStyle.param);\n                    fillOrStrokeText(textContext, true, text, penX, penY, fragWidth)\n                }\n            }\n            this._SetDrawCanvasColor(colorStyle ? colorStyle.param : this._colorStr);\n            if (hasUnderline)\n                fillOrStrokeRect(textContext, isStroke, penX, penY + scale * lineFontScale, fragWidth, scale * lineFontScale * lineThicknessScale);\n            if (hasStrikethrough) {\n                const defaultStrikeY = penY - fragHeight \/ 4;\n                const defaultStrikeHeight = scale * fragFontScale;\n                const strikeYMid = defaultStrikeY + defaultStrikeHeight \/ 2;\n                textContext.fillRect(penX, strikeYMid - defaultStrikeHeight * lineThicknessScale \/ 2, fragWidth, defaultStrikeHeight * lineThicknessScale)\n            }\n        }\n        _UpdateTexture() {\n            if (this._renderer.IsContextLost())\n                return;\n            this._textureWidth = Math.ceil(this._width);\n            this._textureHeight = Math.ceil(this._height);\n            this._rcTex.set(0, 0, this._width \/ this._textureWidth, this._height \/ this._textureHeight);\n            if (this._needToRecreateTexture) {\n                this.ReleaseTexture();\n                this._needToRecreateTexture = false\n            }\n            if (!this._texture)\n                this._texture = this._renderer.CreateDynamicTexture(this._textureWidth, this._textureHeight, {\n                    mipMap: this._zoom === 1,\n                    mipMapQuality: "high"\n                });\n            this._renderer.UpdateTexture(this._textCanvas, this._texture);\n            if (this.ontextureupdate)\n                this.ontextureupdate()\n        }\n        GetTexRect() {\n            return this._rcTex\n        }\n        ReleaseTexture() {\n            if (this._texture) {\n                if (!this._renderer.IsContextLost())\n                    this._renderer.DeleteTexture(this._texture);\n                this._texture = null\n            }\n        }\n        static OnContextLost() {\n            for (const rendererText of allRendererTexts)\n                rendererText.ReleaseTexture()\n        }\n        static GetAll() {\n            return allRendererTexts.values()\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/webgl\/query.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    class WebGLRealTimeElapsedQuery {\n        constructor(renderer) {\n            this._gl = renderer.GetContext();\n            this._version = renderer.GetWebGLVersionNumber();\n            this._timerExt = renderer._GetDisjointTimerQueryExtension();\n            this._query = null;\n            this._isActive = false;\n            this._hasResult = false;\n            this._result = 0;\n            if (this._version === 1)\n                this._query = this._timerExt["createQueryEXT"]();\n            else\n                this._query = this._gl["createQuery"]()\n        }\n        Release() {\n            this._DeleteQueryObject();\n            this._gl = null;\n            this._timerExt = null;\n            this._hasResult = false\n        }\n        _DeleteQueryObject() {\n            if (!this._query)\n                return;\n            if (this._version === 1)\n                this._timerExt["deleteQueryEXT"](this._query);\n            else\n                this._gl["deleteQuery"](this._query);\n            this._query = null\n        }\n        BeginTimeElapsed() {\n            if (this._isActive)\n                throw new Error("query already active");\n            if (this._version === 1)\n                this._timerExt["beginQueryEXT"](this._timerExt["TIME_ELAPSED_EXT"], this._query);\n            else\n                this._gl["beginQuery"](this._timerExt["TIME_ELAPSED_EXT"], this._query);\n            this._isActive = true\n        }\n        EndTimeElapsed() {\n            if (!this._isActive)\n                throw new Error("query not active");\n            if (this._version === 1)\n                this._timerExt["endQueryEXT"](this._timerExt["TIME_ELAPSED_EXT"]);\n            else\n                this._gl["endQuery"](this._timerExt["TIME_ELAPSED_EXT"]);\n            this._isActive = false\n        }\n        CheckForResult() {\n            if (!this._query || this._hasResult || this._isActive)\n                return;\n            let available = false;\n            if (this._version === 1)\n                available = this._timerExt["getQueryObjectEXT"](this._query, this._timerExt["QUERY_RESULT_AVAILABLE_EXT"]);\n            else\n                available = this._gl["getQueryParameter"](this._query, this._gl["QUERY_RESULT_AVAILABLE"]);\n            const disjoint = this._gl.getParameter(this._timerExt["GPU_DISJOINT_EXT"]);\n            if (available && !disjoint) {\n                if (this._version === 1)\n                    this._result = this._timerExt["getQueryObjectEXT"](this._query, this._timerExt["QUERY_RESULT_EXT"]);\n                else\n                    this._result = this._gl["getQueryParameter"](this._query, this._gl["QUERY_RESULT"]);\n                this._result \/= 1E9;\n                this._hasResult = true\n            }\n            if (available || disjoint)\n                this._DeleteQueryObject()\n        }\n        HasResult() {\n            return this._hasResult\n        }\n        GetResult() {\n            if (!this._hasResult)\n                throw new Error("no result available");\n            return this._result\n        }\n    }\n    C3.Gfx.WebGLTimeElapsedQuery = class WebGLTimeElapsedQuery {\n        constructor(renderer) {\n            this._renderer = renderer;\n            this._frameNumber = renderer.GetFrameNumber();\n            this._isActive = false;\n            this._parentQuery = null;\n            this._isNested = false;\n            this._realQuery = null;\n            this._queries = []\n        }\n        Release() {\n            for (const q of this._queries)\n                if (q instanceof WebGLRealTimeElapsedQuery)\n                    q.Release();\n            C3.clearArray(this._queries);\n            this._parentQuery = null;\n            this._realQuery = null;\n            this._renderer = null\n        }\n        BeginTimeElapsed() {\n            if (this._isActive)\n                throw new Error("query already active");\n            const stack = this._renderer._GetTimeQueryStack();\n            if (stack.length > 0) {\n                this._isNested = true;\n                this._parentQuery = stack.at(-1);\n                this._parentQuery._EndReal();\n                this._parentQuery._queries.push(this)\n            } else {\n                this._isNested = false;\n                this._parentQuery = null\n            }\n            this._isActive = true;\n            stack.push(this);\n            this._StartReal()\n        }\n        EndTimeElapsed() {\n            if (!this._isActive)\n                throw new Error("query not active");\n            const top = this._renderer._GetTimeQueryStack().pop();\n            if (top !== this)\n                throw new Error("can only end most nested query");\n            this._isActive = false;\n            this._EndReal();\n            if (this._parentQuery) {\n                this._parentQuery._StartReal();\n                this._parentQuery = null\n            }\n        }\n        _StartReal() {\n            this._realQuery = C3.New(WebGLRealTimeElapsedQuery, this._renderer);\n            this._queries.push(this._realQuery);\n            this._realQuery.BeginTimeElapsed()\n        }\n        _EndReal() {\n            this._realQuery.EndTimeElapsed();\n            this._realQuery = null\n        }\n        CheckForResult() {\n            for (const q of this._queries)\n                q.CheckForResult()\n        }\n        IsNested() {\n            return this._isNested\n        }\n        HasResult() {\n            return this._queries.every(q => q.HasResult())\n        }\n        GetResult() {\n            return this._queries.reduce( (a, v) => a + v.GetResult(), 0)\n        }\n        GetFrameNumber() {\n            return this._frameNumber\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/webgl\/queryResultBuffer.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Gfx.WebGLQueryResultBuffer = class WebGLQueryResultBuffer {\n        constructor(renderer, maxQueries=1E3) {\n            this._renderer = renderer;\n            this._maxQueries = maxQueries;\n            this._buffer = [];\n            this._renderer._AddQueryResultBuffer(this)\n        }\n        Release() {\n            this.Clear();\n            this._renderer._RemoveQueryResultBuffer(this);\n            this._renderer = null\n        }\n        Clear() {\n            for (const q of this._buffer)\n                q.Release();\n            C3.clearArray(this._buffer)\n        }\n        AddTimeElapsedQuery() {\n            const ret = new C3.Gfx.WebGLTimeElapsedQuery(this._renderer);\n            this._buffer.push(ret);\n            if (this._buffer.length > this._maxQueries) {\n                const oldest = this._buffer.shift();\n                oldest.Release()\n            }\n            return ret\n        }\n        CheckForResults(toFrameNumber) {\n            for (const q of this._buffer) {\n                if (q.GetFrameNumber() >= toFrameNumber)\n                    return;\n                if (q.IsNested())\n                    return;\n                q.CheckForResult()\n            }\n        }\n        GetFrameRangeResultSum(startFrame, endFrame) {\n            if (endFrame <= startFrame)\n                return NaN;\n            let sum = 0;\n            for (const q of this._buffer) {\n                if (q.GetFrameNumber() >= endFrame)\n                    break;\n                if (q.GetFrameNumber() < startFrame)\n                    continue;\n                if (q.HasResult())\n                    sum += q.GetResult();\n                else\n                    return NaN\n            }\n            return sum\n        }\n        DeleteAllBeforeFrameNumber(frameNumber) {\n            for (let i = 0, len = this._buffer.length; i < len; ++i) {\n                const q = this._buffer[i];\n                if (q.GetFrameNumber() < frameNumber)\n                    q.Release();\n                else {\n                    if (i > 0)\n                        this._buffer.splice(0, i);\n                    return\n                }\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/webgl\/webglRenderer.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const assert = self.assert;\n    const glMatrix = self.glMatrix;\n    const vec3 = glMatrix.vec3;\n    const vec4 = glMatrix.vec4;\n    const mat4 = glMatrix.mat4;\n    const DEFAULT_WEBGLRENDERER_OPTS = {\n        powerPreference: "default",\n        enableGpuProfiling: true,\n        alpha: false,\n        lowLatency: false,\n        depth: false,\n        canSampleDepth: false,\n        maxWebGLVersion: 2,\n        failIfMajorPerformanceCaveat: false\n    };\n    const VALID_POWER_PREFERENCES = new Set(["default", "low-power", "high-performance"]);\n    const MAX_VERTICES = 8E3;\n    const MAX_INDICES = MAX_VERTICES \/ 2 * 3;\n    const MAX_POINTS = 8E3;\n    const LAST_POINT = MAX_POINTS - 4;\n    const PARTIAL_TEXTURE_UPLOAD_CHUNK_SIZE = 256 * 1024;\n    const defaultTexCoordsQuad = new C3.Quad(0,0,1,0,1,1,0,1);\n    const tmpProjection = mat4.create();\n    const tmpModelView = mat4.create();\n    const tmpQuad = new C3.Quad;\n    const tmpRect = new C3.Rect;\n    let loseContextExtension = null;\n    if (C3.isDebug) {\n        self.debug_lose_context = function() {\n            if (!loseContextExtension) {\n                console.warn("WEBGL_lose_context not supported");\n                return\n            }\n            loseContextExtension.loseContext()\n        }\n        ;\n        self.debug_restore_context = function() {\n            if (!loseContextExtension) {\n                console.warn("WEBGL_lose_context not supported");\n                return\n            }\n            loseContextExtension.restoreContext()\n        }\n    }\n    const pendingPolls = new Set;\n    let pollRafId = -1;\n    function CheckPendingPolls() {\n        pollRafId = -1;\n        for (const info of pendingPolls)\n            if (info.checkFunc()) {\n                info.resolve();\n                pendingPolls.delete(info)\n            }\n        if (pendingPolls.size > 0)\n            pollRafId = self.requestAnimationFrame(CheckPendingPolls)\n    }\n    C3.Gfx.WebGLRenderer = class WebGLRenderer extends C3.Gfx.RendererBase {\n        constructor(canvas, opts) {\n            super();\n            opts = Object.assign({}, DEFAULT_WEBGLRENDERER_OPTS, opts);\n            if (!VALID_POWER_PREFERENCES.has(opts.powerPreference))\n                throw new Error("invalid power preference");\n            const attribs = {\n                "alpha": !!opts.alpha,\n                "depth": false,\n                "antialias": false,\n                "powerPreference": opts.powerPreference,\n                "failIfMajorPerformanceCaveat": !!opts.failIfMajorPerformanceCaveat\n            };\n            if (opts.lowLatency) {\n                attribs["desynchronized"] = true;\n                attribs["preserveDrawingBuffer"] = true\n            }\n            let gl = null;\n            let version = 0;\n            if (opts.maxWebGLVersion >= 2) {\n                gl = canvas.getContext("webgl2", attribs);\n                version = 2\n            }\n            if (!gl) {\n                gl = canvas.getContext("webgl", attribs);\n                version = 1\n            }\n            if (!gl)\n                throw new Error("failed to initialise WebGL context");\n            this._gl = gl;\n            this._attribs = gl.getContextAttributes();\n            if (opts.lowLatency && !this._attribs["desynchronized"])\n                console.info("[WebGLRenderer] Low-latency mode specified but is not supported here");\n            this._versionString = gl.getParameter(gl.VERSION);\n            this._version = version;\n            this._viewport = vec4.create();\n            this._didChangeTransform = false;\n            this._bbProjectionMatrix = mat4.create();\n            this._usesDepthBuffer = !!opts.depth;\n            this._canSampleDepth = !!(opts.depth && opts.canSampleDepth);\n            this._isDepthEnabled = this._usesDepthBuffer;\n            this._isDepthSamplingEnabled = false;\n            this._depthBuffer = null;\n            this._isAutoSizeDepthBuffer = true;\n            this._depthBufferWidth = 0;\n            this._depthBufferHeight = 0;\n            this._vertexBuffer = null;\n            this._texcoordBuffer = null;\n            this._indexBuffer = null;\n            this._pointBuffer = null;\n            this._vertexData = new Float32Array(MAX_VERTICES * this.GetNumVertexComponents());\n            this._indexData = new Uint16Array(MAX_INDICES);\n            this._texcoordData = new Float32Array(MAX_VERTICES * 2);\n            this._pointData = new Float32Array(MAX_POINTS * 4);\n            this._vertexPtr = 0;\n            this._texPtr = 0;\n            this._pointPtr = 0;\n            this._lastVertexPtr = 0;\n            this._lastProgram = null;\n            this._spDeviceTransformTextureFill = null;\n            this._batch = [];\n            this._batchPtr = 0;\n            this._topOfBatch = 0;\n            this._currentRenderTarget = null;\n            this._lastPointZ = 0;\n            this._batchState = C3.New(C3.Gfx.BatchState, this);\n            this._lastColor = C3.New(C3.Color, 1, 1, 1, 1);\n            this._lastTexture0 = null;\n            this._lastTexture1 = null;\n            this._lastSrcBlend = 0;\n            this._lastDestBlend = 0;\n            this._lastPointTexCoords = new C3.Rect;\n            this._lastScissorRect = C3.New(C3.Rect, 0, 0, -1, -1);\n            this._maxTextureSize = -1;\n            this._minPointSize = 0;\n            this._maxPointSize = 0;\n            this._highpPrecision = 0;\n            this._unmaskedVendor = "(unavailable)";\n            this._unmaskedRenderer = "(unavailable)";\n            this._extensions = [];\n            this._isInitialisingAfterContextRestored = false;\n            this._parallelShaderCompileExt = null;\n            this._anisotropicExt = null;\n            this._depthTextureExt = null;\n            this._fragDepthExt = null;\n            this._maxAnisotropy = 0;\n            this._isGpuProfilingEnabled = !!opts.enableGpuProfiling;\n            this._timerExt = null;\n            this._allQueryResultBuffers = new Set;\n            this._timeQueryStack = [];\n            this.FillIndexBufferData(this._indexData)\n        }\n        IsWebGL() {\n            return true\n        }\n        async InitState() {\n            super.InitState();\n            const gl = this._gl;\n            const numVertexComponents = this.GetNumVertexComponents();\n            this._lastColor.setRgba(1, 1, 1, 1);\n            this._lastTexture0 = null;\n            this._lastTexture1 = null;\n            this._vertexPtr = 0;\n            this._pointPtr = 0;\n            this._lastVertexPtr = MAX_VERTICES * numVertexComponents - 4 * numVertexComponents;\n            C3.clearArray(this._batch);\n            this._batchPtr = 0;\n            this._topOfBatch = 0;\n            this._lastProgram = null;\n            this._currentRenderTarget = null;\n            this._lastPointTexCoords.set(0, 0, 1, 1);\n            this._lastPointZ = 0;\n            const batchState = this._batchState;\n            batchState.currentShader = null;\n            batchState.currentFramebuffer = null;\n            batchState.currentFramebufferNoDepth = null;\n            vec4.set(batchState.currentColor, 1, 1, 1, 1);\n            batchState.clearColor.setRgba(0, 0, 0, 0);\n            batchState.pointTexCoords.set(0, 0, 1, 1);\n            gl.clearColor(0, 0, 0, 0);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            this._lastSrcBlend = gl.ONE;\n            this._lastDestBlend = gl.ONE_MINUS_SRC_ALPHA;\n            this._InitBlendModes(gl);\n            gl.disable(gl.CULL_FACE);\n            gl.disable(gl.STENCIL_TEST);\n            gl.disable(gl.DITHER);\n            if (this._usesDepthBuffer) {\n                gl.enable(gl.DEPTH_TEST);\n                gl.depthMask(true);\n                gl.depthFunc(gl.LEQUAL)\n            } else {\n                gl.disable(gl.DEPTH_TEST);\n                gl.depthMask(false)\n            }\n            this._isDepthEnabled = this._usesDepthBuffer;\n            this._isDepthSamplingEnabled = false;\n            this._pointBuffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, this._pointBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, this._pointData.byteLength, gl.DYNAMIC_DRAW);\n            this._vertexBuffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, this._vertexData.byteLength, gl.DYNAMIC_DRAW);\n            this._texcoordBuffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, this._texcoordBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, this._texcoordData.byteLength, gl.DYNAMIC_DRAW);\n            this._indexBuffer = gl.createBuffer();\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indexData, gl.STATIC_DRAW);\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n            const pointsizes = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);\n            this._minPointSize = pointsizes[0];\n            this._maxPointSize = pointsizes[1];\n            const highpVertex = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);\n            const highpFrag = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n            if (highpVertex && highpFrag)\n                this._highpPrecision = Math.min(highpVertex["precision"], highpFrag["precision"]);\n            else\n                this._highpPrecision = 0;\n            if (this._maxPointSize > 2048)\n                this._maxPointSize = 2048;\n            this._extensions = gl.getSupportedExtensions();\n            const debug_ext = gl.getExtension("WEBGL_debug_renderer_info");\n            if (debug_ext) {\n                this._unmaskedVendor = gl.getParameter(debug_ext["UNMASKED_VENDOR_WEBGL"]);\n                this._unmaskedRenderer = gl.getParameter(debug_ext["UNMASKED_RENDERER_WEBGL"])\n            }\n            this._parallelShaderCompileExt = gl.getExtension("KHR_parallel_shader_compile");\n            if (C3.isDebug)\n                loseContextExtension = gl.getExtension("WEBGL_lose_context");\n            if (this._isGpuProfilingEnabled)\n                if (this.GetWebGLVersionNumber() === 1) {\n                    if (C3.Platform.BrowserEngine !== "Chromium" || C3.Platform.BrowserVersionNumber >= 81 || typeof document !== "undefined")\n                        this._timerExt = gl.getExtension("EXT_disjoint_timer_query")\n                } else\n                    this._timerExt = gl.getExtension("EXT_disjoint_timer_query_webgl2") || gl.getExtension("EXT_disjoint_timer_query");\n            this._anisotropicExt = gl.getExtension("EXT_texture_filter_anisotropic");\n            if (this._anisotropicExt)\n                this._maxAnisotropy = gl.getParameter(this._anisotropicExt["MAX_TEXTURE_MAX_ANISOTROPY_EXT"]);\n            else\n                this._maxAnisotropy = 0;\n            if (this.GetWebGLVersionNumber() < 2 && this._usesDepthBuffer && this._canSampleDepth) {\n                this._depthTextureExt = gl.getExtension("WEBGL_depth_texture");\n                if (!this._depthTextureExt)\n                    throw new Error("no depth texture support");\n            }\n            if (this.GetWebGLVersionNumber() < 2)\n                this._fragDepthExt = gl.getExtension("EXT_frag_depth");\n            const WebGLShaderProgram = C3.Gfx.WebGLShaderProgram;\n            const vsSource = WebGLShaderProgram.GetDefaultVertexShaderSource(false);\n            let textureFillFragmentSrc = WebGLShaderProgram.GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth();\n            let textureFillVertexSrc = vsSource;\n            if (this._usesDepthBuffer && (C3.Platform.Browser !== "Safari" || C3.Platform.BrowserVersionNumber >= 15.5))\n                if (this.GetWebGLVersionNumber() < 2) {\n                    if (this._fragDepthExt)\n                        textureFillFragmentSrc = WebGLShaderProgram.GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT()\n                } else {\n                    textureFillVertexSrc = WebGLShaderProgram.GetDefaultVertexShaderSource_WebGL2();\n                    textureFillFragmentSrc = WebGLShaderProgram.GetTextureFillFragmentShaderSource_WebGL2()\n                }\n            const DEFAULT_SHADER_PROGRAMS = [[textureFillFragmentSrc, textureFillVertexSrc, "<default>"], [textureFillFragmentSrc, textureFillVertexSrc, "<default-device-transform>"], [WebGLShaderProgram.GetPointFragmentShaderSource(this._version), WebGLShaderProgram.GetPointVertexShaderSource(this._version), "<point>"], [WebGLShaderProgram.GetColorFillFragmentShaderSource(), vsSource, "<fill>"], [WebGLShaderProgram.GetLinearGradientFillFragmentShaderSource(), vsSource, "<lineargradient>"], [WebGLShaderProgram.GetHardEllipseFillFragmentShaderSource(), vsSource, "<hardellipse>"], [WebGLShaderProgram.GetHardEllipseOutlineFragmentShaderSource(), vsSource, "<hardellipseoutline>"], [WebGLShaderProgram.GetSmoothEllipseFillFragmentShaderSource(), vsSource, "<smoothellipse>"], [WebGLShaderProgram.GetSmoothEllipseOutlineFragmentShaderSource(), vsSource, "<smoothellipseoutline>"], [WebGLShaderProgram.GetSmoothLineFillFragmentShaderSource(), vsSource, "<smoothline>"], [WebGLShaderProgram.GetTilemapFragmentShaderSource(), WebGLShaderProgram.GetDefaultVertexShaderSource(true), "<tilemap>"]];\n            const defaultShaders = await Promise.all(DEFAULT_SHADER_PROGRAMS.map(i => this.CreateShaderProgram({\n                src: i[0]\n            }, i[1], i[2])));\n            this._spTextureFill = defaultShaders[0];\n            this._spDeviceTransformTextureFill = defaultShaders[1];\n            this._spPoints = defaultShaders[2];\n            this._spColorFill = defaultShaders[3];\n            this._spLinearGradientFill = defaultShaders[4];\n            this._spHardEllipseFill = defaultShaders[5];\n            this._spHardEllipseOutline = defaultShaders[6];\n            this._spSmoothEllipseFill = defaultShaders[7];\n            this._spSmoothEllipseOutline = defaultShaders[8];\n            this._spSmoothLineFill = defaultShaders[9];\n            this._spTilemapFill = defaultShaders[10];\n            this.SetTextureFillMode()\n        }\n        async CreateShaderProgram(shaderInfo, vsSource, name) {\n            const ret = await C3.Gfx.WebGLShaderProgram.Create(this, shaderInfo, vsSource, name);\n            this._AddShaderProgram(ret);\n            return ret\n        }\n        ResetLastProgram() {\n            this._lastProgram = null\n        }\n        SetSize(w, h, force) {\n            if (this._width === w && this._height === h && !force)\n                return;\n            this.EndBatch();\n            const gl = this._gl;\n            const batchState = this._batchState;\n            this._width = w;\n            this._height = h;\n            this._SetViewport(0, 0, w, h);\n            this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, w \/ h);\n            this.SetProjectionMatrix(this._bbProjectionMatrix);\n            if (this._spDeviceTransformTextureFill) {\n                gl.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram());\n                this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP);\n                this._lastProgram = this._spDeviceTransformTextureFill;\n                this._batchState.currentShader = this._spDeviceTransformTextureFill\n            }\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            gl.activeTexture(gl.TEXTURE1);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            gl.activeTexture(gl.TEXTURE0);\n            this._lastTexture0 = null;\n            this._lastTexture1 = null;\n            if (this._usesDepthBuffer && this._isAutoSizeDepthBuffer)\n                this._SetDepthBufferSize(this._width, this._height);\n            if (this._currentRenderTarget)\n                this._currentRenderTarget._Resize(this._width, this._height);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            this._currentRenderTarget = null;\n            batchState.currentFramebuffer = null;\n            batchState.currentFramebufferNoDepth = null\n        }\n        _SetDepthBufferSize(width, height) {\n            const gl = this._gl;\n            if (this._depthBuffer && this._depthBufferWidth === width && this._depthBufferHeight === height)\n                return;\n            if (this._canSampleDepth) {\n                if (this._depthBuffer)\n                    gl.deleteTexture(this._depthBuffer);\n                this._depthBuffer = gl.createTexture();\n                gl.bindTexture(gl.TEXTURE_2D, this._depthBuffer);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                if (this.GetWebGLVersionNumber() >= 2)\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH24_STENCIL8, width, height, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);\n                else if (this._depthTextureExt)\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_STENCIL, width, height, 0, gl.DEPTH_STENCIL, this._depthTextureExt["UNSIGNED_INT_24_8_WEBGL"], null);\n                else\n                    ;gl.bindTexture(gl.TEXTURE_2D, null)\n            } else {\n                if (this._depthBuffer)\n                    gl.deleteRenderbuffer(this._depthBuffer);\n                this._depthBuffer = gl.createRenderbuffer();\n                gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthBuffer);\n                gl.renderbufferStorage(gl.RENDERBUFFER, this._version >= 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL, width, height);\n                gl.bindRenderbuffer(gl.RENDERBUFFER, null)\n            }\n            this._depthBufferWidth = width;\n            this._depthBufferHeight = height\n        }\n        SetFixedSizeDepthBuffer(width, height) {\n            if (!this._usesDepthBuffer)\n                return;\n            this._isAutoSizeDepthBuffer = false;\n            this._SetDepthBufferSize(width, height)\n        }\n        SetAutoSizeDepthBuffer() {\n            if (!this._usesDepthBuffer)\n                return;\n            this._isAutoSizeDepthBuffer = true;\n            this._SetDepthBufferSize(this._width, this._height)\n        }\n        _SetViewport(x, y, w, h) {\n            const viewport = this._viewport;\n            if (viewport[0] === x && viewport[1] === y && viewport[2] === w && viewport[3] === h)\n                return;\n            const b = this.PushBatch();\n            b.InitSetViewport(x, y, w, h);\n            vec4.set(viewport, x, y, w, h);\n            this._topOfBatch = 0\n        }\n        SetFovY(f) {\n            super.SetFovY(f);\n            this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width \/ this._height)\n        }\n        SetProjectionMatrix(matP) {\n            if (mat4.exactEquals(this._matP, matP))\n                return;\n            const b = this.PushBatch();\n            b.InitSetProjection(matP);\n            mat4.copy(this._matP, matP);\n            this._topOfBatch = 0;\n            this._didChangeTransform = true\n        }\n        SetDefaultRenderTargetProjectionState() {\n            let projectionMatrix;\n            let viewportWidth, viewportHeight;\n            const currentRenderTarget = this._currentRenderTarget;\n            if (currentRenderTarget === null) {\n                projectionMatrix = this._bbProjectionMatrix;\n                viewportWidth = this.GetWidth();\n                viewportHeight = this.GetHeight()\n            } else {\n                projectionMatrix = currentRenderTarget.GetProjectionMatrix();\n                viewportWidth = currentRenderTarget.GetWidth();\n                viewportHeight = currentRenderTarget.GetHeight()\n            }\n            this.SetProjectionMatrix(projectionMatrix);\n            this._SetViewport(0, 0, viewportWidth, viewportHeight)\n        }\n        SetModelViewMatrix(matMV) {\n            if (mat4.exactEquals(this._matMV, matMV))\n                return;\n            const b = this.PushBatch();\n            b.InitSetModelView(matMV);\n            mat4.copy(this._matMV, matMV);\n            this._topOfBatch = 0;\n            this._didChangeTransform = true\n        }\n        ResetDidChangeTransformFlag() {\n            this._didChangeTransform = false\n        }\n        DidChangeTransform() {\n            return this._didChangeTransform\n        }\n        GetBatchState() {\n            return this._batchState\n        }\n        PushBatch() {\n            const batch = this._batch;\n            if (this._batchPtr === batch.length)\n                batch.push(new C3.Gfx.WebGLBatchJob(this._batchState));\n            return batch[this._batchPtr++]\n        }\n        EndBatch() {\n            if (this._batchPtr === 0)\n                return;\n            if (this.IsContextLost())\n                return;\n            this._WriteBuffers();\n            this._ExecuteBatch();\n            this._batchPtr = 0;\n            this._vertexPtr = 0;\n            this._texPtr = 0;\n            this._pointPtr = 0;\n            this._topOfBatch = 0\n        }\n        _WriteBuffers() {\n            const gl = this._gl;\n            if (this._pointPtr > 0) {\n                gl.bindBuffer(gl.ARRAY_BUFFER, this._pointBuffer);\n                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr))\n            }\n            if (this._vertexPtr > 0) {\n                gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);\n                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._vertexData.subarray(0, this._vertexPtr));\n                gl.bindBuffer(gl.ARRAY_BUFFER, this._texcoordBuffer);\n                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, this._texPtr))\n            }\n        }\n        _ExecuteBatch() {\n            const batch = this._batch;\n            for (let i = 0, len = this._batchPtr; i < len; ++i)\n                batch[i].Run()\n        }\n        GetOpacity() {\n            return this._lastColor.getA()\n        }\n        SetColorRgba(r, g, b, a) {\n            const lastColor = this._lastColor;\n            if (lastColor.equalsRgba(r, g, b, a))\n                return;\n            lastColor.setRgba(r, g, b, a);\n            const batch = this.PushBatch();\n            batch.InitSetColor(lastColor);\n            this._topOfBatch = 0;\n            this._currentStateGroup = null\n        }\n        SetOpacity(a) {\n            const lastColor = this._lastColor;\n            if (lastColor.getA() === a)\n                return;\n            lastColor.setA(a);\n            const batch = this.PushBatch();\n            batch.InitSetColor(lastColor);\n            this._topOfBatch = 0;\n            this._currentStateGroup = null\n        }\n        SetColor(c) {\n            const lastColor = this._lastColor;\n            if (lastColor.equals(c))\n                return;\n            lastColor.set(c);\n            const batch = this.PushBatch();\n            batch.InitSetColor(lastColor);\n            this._topOfBatch = 0;\n            this._currentStateGroup = null\n        }\n        ResetColor() {\n            this.SetColorRgba(1, 1, 1, 1)\n        }\n        GetColor() {\n            return this._lastColor\n        }\n        SetTexture(rendererTex) {\n            if (rendererTex === this._lastTexture0)\n                return;\n            const b = this.PushBatch();\n            b.InitSetTexture(rendererTex);\n            this._lastTexture0 = rendererTex;\n            this._topOfBatch = 0\n        }\n        _ResetLastTexture() {\n            this._lastTexture0 = null\n        }\n        SetBlendMode(bm) {\n            const arr = this._GetBlendByIndex(bm);\n            this._SetBlend(arr[0], arr[1])\n        }\n        SetNamedBlendMode(bm) {\n            const o = this.GetNamedBlend(bm);\n            this._SetBlend(o.srcBlend, o.destBlend)\n        }\n        _SetBlend(s, d) {\n            if (s === this._lastSrcBlend && d === this._lastDestBlend)\n                return;\n            const b = this.PushBatch();\n            b.InitSetBlend(s, d);\n            this._lastSrcBlend = s;\n            this._lastDestBlend = d;\n            this._topOfBatch = 0;\n            this._currentStateGroup = null\n        }\n        IsPremultipliedAlphaBlend() {\n            return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA\n        }\n        SetAlphaBlend() {\n            this._SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA)\n        }\n        SetNoPremultiplyAlphaBlend() {\n            this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA)\n        }\n        SetCopyBlend() {\n            this._SetBlend(this._gl.ONE, this._gl.ZERO)\n        }\n        Rect(r) {\n            this.Rect2(r.getLeft(), r.getTop(), r.getRight(), r.getBottom())\n        }\n        Rect2(left, top, right, bottom) {\n            this.Quad2(left, top, right, top, right, bottom, left, bottom)\n        }\n        _ExtendQuadBatch() {\n            let v = this._vertexPtr;\n            if (v >= this._lastVertexPtr) {\n                this.EndBatch();\n                v = 0\n            }\n            if (this._topOfBatch === 1)\n                this._batch[this._batchPtr - 1]._indexCount += 6;\n            else {\n                const b = this.PushBatch();\n                b.InitQuad(v, 6);\n                this._topOfBatch = 1\n            }\n        }\n        _WriteQuadToVertexBuffer(quad) {\n            quad.writeToTypedArray3D(this._vertexData, this._vertexPtr, this._baseZ + this._currentZ);\n            this._vertexPtr += 12\n        }\n        Quad(quad) {\n            this._ExtendQuadBatch();\n            this._WriteQuadToVertexBuffer(quad);\n            defaultTexCoordsQuad.writeToTypedArray(this._texcoordData, this._texPtr);\n            this._texPtr += 8\n        }\n        Quad2(tlx, tly, trx, try_, brx, bry, blx, bly) {\n            this._ExtendQuadBatch();\n            const vd = this._vertexData;\n            let v = this._vertexPtr;\n            const z = this._baseZ + this._currentZ;\n            vd[v++] = tlx;\n            vd[v++] = tly;\n            vd[v++] = z;\n            vd[v++] = trx;\n            vd[v++] = try_;\n            vd[v++] = z;\n            vd[v++] = brx;\n            vd[v++] = bry;\n            vd[v++] = z;\n            vd[v++] = blx;\n            vd[v++] = bly;\n            vd[v++] = z;\n            this._vertexPtr = v;\n            defaultTexCoordsQuad.writeToTypedArray(this._texcoordData, this._texPtr);\n            this._texPtr += 8\n        }\n        Quad3(quad, rcTex) {\n            this._ExtendQuadBatch();\n            this._WriteQuadToVertexBuffer(quad);\n            rcTex.writeAsQuadToTypedArray(this._texcoordData, this._texPtr);\n            this._texPtr += 8\n        }\n        Quad4(quad, uv) {\n            this._ExtendQuadBatch();\n            this._WriteQuadToVertexBuffer(quad);\n            uv.writeToTypedArray(this._texcoordData, this._texPtr);\n            this._texPtr += 8\n        }\n        Quad3D(tlx, tly, tlz, trx, try_, trz, brx, bry, brz, blx, bly, blz, rcTex) {\n            this._ExtendQuadBatch();\n            const vd = this._vertexData;\n            let v = this._vertexPtr;\n            const z = this._baseZ + this._currentZ;\n            vd[v++] = tlx;\n            vd[v++] = tly;\n            vd[v++] = z + tlz;\n            vd[v++] = trx;\n            vd[v++] = try_;\n            vd[v++] = z + trz;\n            vd[v++] = brx;\n            vd[v++] = bry;\n            vd[v++] = z + brz;\n            vd[v++] = blx;\n            vd[v++] = bly;\n            vd[v++] = z + blz;\n            this._vertexPtr = v;\n            rcTex.writeAsQuadToTypedArray(this._texcoordData, this._texPtr);\n            this._texPtr += 8\n        }\n        Quad3D2(tlx, tly, tlz, trx, try_, trz, brx, bry, brz, blx, bly, blz, uv) {\n            this._ExtendQuadBatch();\n            const vd = this._vertexData;\n            let v = this._vertexPtr;\n            const z = this._baseZ + this._currentZ;\n            vd[v++] = tlx;\n            vd[v++] = tly;\n            vd[v++] = z + tlz;\n            vd[v++] = trx;\n            vd[v++] = try_;\n            vd[v++] = z + trz;\n            vd[v++] = brx;\n            vd[v++] = bry;\n            vd[v++] = z + brz;\n            vd[v++] = blx;\n            vd[v++] = bly;\n            vd[v++] = z + blz;\n            this._vertexPtr = v;\n            uv.writeToTypedArray(this._texcoordData, this._texPtr);\n            this._texPtr += 8\n        }\n        FullscreenQuad(mode, curTex) {\n            mat4.copy(tmpProjection, this._matP);\n            mat4.copy(tmpModelView, this._matMV);\n            this.SetDefaultRenderTargetProjectionState();\n            const [width,height] = this.GetRenderTargetSize(this._currentRenderTarget);\n            const tempMat4b = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ(height), 0, 0, 0, height);\n            this.SetModelViewMatrix(tempMat4b);\n            if (mode === "crop" && this._currentRenderTarget && curTex) {\n                const left = this._width \/ 2;\n                const top = this._height \/ 2;\n                const srcW = curTex.GetWidth();\n                const srcH = curTex.GetHeight();\n                const destW = this._currentRenderTarget.GetWidth();\n                const destH = this._currentRenderTarget.GetHeight();\n                const copyW = Math.min(destW, srcW);\n                const copyH = Math.min(destH, srcH);\n                const srcOffY = Math.max(srcH - destH, 0);\n                const destOffY = Math.max(destH - srcH, 0);\n                tmpRect.set(-left, top - destOffY, -left + copyW, top - copyH - destOffY);\n                tmpQuad.setFromRect(tmpRect);\n                tmpRect.set(0, srcOffY, copyW, copyH + srcOffY);\n                tmpRect.divide(srcW, srcH);\n                this.Quad3(tmpQuad, tmpRect)\n            } else {\n                const halfW = width \/ 2;\n                const halfH = height \/ 2;\n                this.Rect2(-halfW, halfH, halfW, -halfH)\n            }\n            this.SetProjectionMatrix(tmpProjection);\n            this.SetModelViewMatrix(tmpModelView)\n        }\n        StartRenderingPoints(rect) {\n            if (this._lastPointTexCoords.equals(rect))\n                return;\n            this._lastPointTexCoords.copy(rect);\n            const b = this.PushBatch();\n            b.InitSetPointTexCoords(rect);\n            this._topOfBatch = 0\n        }\n        FinishRenderingPoints() {}\n        Point(x_, y_, size_, opacity_) {\n            if (this._pointPtr >= LAST_POINT)\n                this.EndBatch();\n            let p = this._pointPtr;\n            const z = this._baseZ + this._currentZ;\n            if (this._topOfBatch === 2 && this._lastPointZ === z)\n                this._batch[this._batchPtr - 1]._indexCount++;\n            else {\n                const b = this.PushBatch();\n                b.InitPoints(p, z);\n                this._topOfBatch = 2;\n                this._lastPointZ = z\n            }\n            const pd = this._pointData;\n            pd[p++] = x_;\n            pd[p++] = y_;\n            pd[p++] = size_;\n            pd[p++] = opacity_;\n            this._pointPtr = p\n        }\n        SetProgram(program) {\n            if (this._lastProgram === program)\n                return;\n            const b = this.PushBatch();\n            b.InitSetProgram(program);\n            this._lastProgram = program;\n            this._topOfBatch = 0;\n            this._currentStateGroup = null\n        }\n        SetDeviceTransformTextureFillMode() {\n            this.SetProgram(this._spDeviceTransformTextureFill)\n        }\n        SetGradientColor(c) {\n            const b = this.PushBatch();\n            b.InitSetGradientColor(c);\n            this._topOfBatch = 0\n        }\n        SetEllipseParams(pixelW, pixelH, outlineThickness=1) {\n            const b = this.PushBatch();\n            b.InitSetEllipseParams(pixelW, pixelH, outlineThickness);\n            this._topOfBatch = 0\n        }\n        SetTilemapInfo(srcRect, textureWidth, textureHeight, tileWidth, tileHeight, tileSpacingX, tileSpacingY) {\n            if (this._lastProgram !== this._spTilemapFill)\n                throw new Error("must set tilemap fill mode first");\n            const b = this.PushBatch();\n            b.InitSetTilemapInfo(srcRect, textureWidth, textureHeight, tileWidth, tileHeight, tileSpacingX, tileSpacingY);\n            this._topOfBatch = 0\n        }\n        SetProgramParameters(backTex, destRect, srcRect, srcOriginRect, layoutRect, pixelWidth, pixelHeight, dpr, layerScale, layerAngle, time) {\n            const s = this._lastProgram;\n            if (!s._hasAnyOptionalUniforms || s.AreOptionalUniformsAlreadySetInBatch(destRect, srcRect, srcOriginRect, layoutRect, pixelWidth, pixelHeight, dpr, layerScale, layerAngle, time))\n                return;\n            const b = this.PushBatch();\n            b.InitSetProgramParameters();\n            s.SetOptionalUniformsInBatch(destRect, srcRect, srcOriginRect, layoutRect, pixelWidth, pixelHeight, dpr, layerScale, layerAngle, time);\n            const mat4param = b._mat4param;\n            mat4param[0] = pixelWidth;\n            mat4param[1] = pixelHeight;\n            destRect.writeToTypedArray(mat4param, 2);\n            mat4param[6] = layerScale;\n            mat4param[7] = layerAngle;\n            srcRect.writeToTypedArray(mat4param, 12);\n            const colorParam = b._colorParam;\n            layoutRect.writeToTypedArray(colorParam, 0);\n            const tmp = colorParam[1];\n            colorParam[1] = colorParam[3];\n            colorParam[3] = tmp;\n            srcOriginRect.writeToTypedArray(b._srcOriginRect, 0);\n            b._startIndex = time;\n            b._indexCount = dpr;\n            if (s._uSamplerBack.IsUsed())\n                b._texParam = backTex ? backTex.GetTexture() : null;\n            else\n                b._texParam = null;\n            this._topOfBatch = 0\n        }\n        SetProgramCustomParameters(params) {\n            const s = this._lastProgram;\n            if (params.length === 0 || s.AreCustomParametersAlreadySetInBatch(params))\n                return;\n            const b = this.PushBatch();\n            b.InitSetProgramCustomParameters();\n            s.SetCustomParametersInBatch(params);\n            C3.shallowAssignArray(b._shaderParams, params);\n            this._topOfBatch = 0\n        }\n        ClearRgba(r, g, b_, a) {\n            const b = this.PushBatch();\n            b.InitClearSurface2(r, g, b_, a);\n            this._topOfBatch = 0\n        }\n        Clear(c) {\n            const b = this.PushBatch();\n            b.InitClearSurface(c);\n            this._topOfBatch = 0\n        }\n        Start() {}\n        Finish() {\n            super.Finish();\n            this._gl.flush()\n        }\n        ClearDepth() {\n            if (!this._usesDepthBuffer || !this._currentRenderTarget || !this._currentRenderTarget.HasDepthBuffer())\n                return;\n            const batch = this.PushBatch();\n            batch.InitClearDepth(this._isDepthEnabled);\n            this._topOfBatch = 0\n        }\n        SetDepthEnabled(e) {\n            e = !!e;\n            if (this._isDepthEnabled === e)\n                return;\n            if (!this._usesDepthBuffer)\n                return;\n            this._isDepthEnabled = e;\n            const batch = this.PushBatch();\n            batch.InitSetDepthEnabled(e);\n            this._topOfBatch = 0\n        }\n        IsDepthEnabled() {\n            return this._isDepthEnabled\n        }\n        _GetDepthBuffer() {\n            return this._depthBuffer\n        }\n        _CanSampleDepth() {\n            return this._canSampleDepth\n        }\n        SetDepthSamplingEnabled(e) {\n            e = !!e;\n            if (!this._canSampleDepth)\n                return;\n            if (this._isDepthSamplingEnabled === e)\n                return;\n            if (e && this.IsDepthEnabled())\n                throw new Error("depth still enabled");\n            this._isDepthSamplingEnabled = e;\n            const batch = this.PushBatch();\n            batch.InitSetDepthSamplingEnabled(e);\n            this._topOfBatch = 0\n        }\n        SetScissorRect(x, y, w, h, rtHeight_=0) {\n            x = Math.floor(x);\n            y = Math.floor(y);\n            w = Math.floor(w);\n            h = Math.floor(h);\n            if (this._lastScissorRect.equalsWH(x, y, w, h))\n                return;\n            this._lastScissorRect.setWH(x, y, w, h);\n            const rtHeight = rtHeight_ || this.GetRenderTargetSize(this.GetRenderTarget())[1];\n            y = rtHeight - y - h;\n            const batch = this.PushBatch();\n            batch.InitSetScissor(true, x, y, w, h);\n            this._topOfBatch = 0\n        }\n        RemoveScissorRect() {\n            if (this._lastScissorRect.getRight() === -1)\n                return;\n            this._lastScissorRect.set(0, 0, -1, -1);\n            const batch = this.PushBatch();\n            batch.InitSetScissor(false, 0, 0, 0, 0);\n            this._topOfBatch = 0\n        }\n        CheckForQueryResults() {\n            for (const qrb of this._allQueryResultBuffers)\n                qrb.CheckForResults(this._frameNumber)\n        }\n        IsContextLost() {\n            return !this._gl || this._gl.isContextLost() || this._isInitialisingAfterContextRestored\n        }\n        OnContextLost() {\n            super.OnDeviceOrContextLost();\n            C3.Gfx.WebGLRendererTexture.OnContextLost();\n            C3.Gfx.WebGLRenderTarget.OnContextLost();\n            C3.Gfx.RendererText.OnContextLost();\n            for (const qrb of this._allQueryResultBuffers)\n                qrb.Clear();\n            this._extensions = [];\n            this._timerExt = null;\n            this._parallelShaderCompileExt = null;\n            this._anisotropicExt = null;\n            this._depthTextureExt = null;\n            this._fragDepthExt = null;\n            this._maxAnisotropy = 0;\n            this._unmaskedVendor = "(unavailable)";\n            this._unmaskedRenderer = "(unavailable)";\n            this._lastProgram = null;\n            this._spDeviceTransformTextureFill = null;\n            this._depthBuffer = null;\n            for (const stateGroup of this._stateGroups.values())\n                stateGroup.OnContextLost()\n        }\n        async OnContextRestored() {\n            this._isInitialisingAfterContextRestored = true;\n            await this.InitState();\n            this._isInitialisingAfterContextRestored = false;\n            for (const stateGroup of this._stateGroups.values())\n                stateGroup.OnContextRestored(this);\n            this.SetSize(this._width, this._height, true)\n        }\n        CreateStaticTexture(data, opts) {\n            if (this.IsContextLost())\n                throw new Error("context lost");\n            this.EndBatch();\n            const rendererTex = C3.New(C3.Gfx.WebGLRendererTexture, this);\n            rendererTex._CreateStatic(data, opts);\n            return rendererTex\n        }\n        async CreateStaticTextureAsync(data, opts) {\n            if (this.IsContextLost())\n                throw new Error("context lost");\n            opts = Object.assign({}, opts);\n            if (C3.Supports.ImageBitmapOptions && (C3.Platform.Browser !== "Safari" || !(data instanceof ImageData) || typeof Image === "undefined")) {\n                let imageBitmap = await createImageBitmap(data, {\n                    "premultiplyAlpha": "premultiply"\n                });\n                const isTiled = opts.wrapX && opts.wrapX !== "clamp-to-edge" || opts.wrapY && opts.wrapY !== "clamp-to-edge";\n                const isPOT = C3.isPOT(imageBitmap.width) && C3.isPOT(imageBitmap.height);\n                if (!this.SupportsNPOTTextures() && !isPOT && isTiled)\n                    if (C3.Supports.ImageBitmapOptionsResize) {\n                        imageBitmap = await createImageBitmap(data, {\n                            "premultiplyAlpha": "premultiply",\n                            "resizeWidth": C3.nextHighestPowerOfTwo(imageBitmap.width),\n                            "resizeHeight": C3.nextHighestPowerOfTwo(imageBitmap.height)\n                        });\n                        opts.premultiplyAlpha = false\n                    } else\n                        imageBitmap = await createImageBitmap(data, {\n                            "premultiplyAlpha": "none"\n                        });\n                else\n                    opts.premultiplyAlpha = false;\n                return await C3.Asyncify( () => this.CreateStaticTexture(imageBitmap, opts))\n            } else {\n                if (data instanceof Blob) {\n                    if (typeof Image === "undefined")\n                        throw new Error("texture upload variant not supported in worker");\n                    const img = await C3.BlobToImage(data);\n                    data = img\n                }\n                return await C3.Asyncify( () => this.CreateStaticTexture(data, opts))\n            }\n        }\n        CreateDynamicTexture(width, height, opts) {\n            this.EndBatch();\n            const rendererTex = C3.New(C3.Gfx.WebGLRendererTexture, this);\n            rendererTex._CreateDynamic(width, height, opts);\n            return rendererTex\n        }\n        UpdateTexture(data, rendererTex, opts) {\n            this.EndBatch();\n            rendererTex._Update(data, opts)\n        }\n        DeleteTexture(rendererTex) {\n            if (!rendererTex)\n                return;\n            rendererTex.SubtractReference();\n            if (rendererTex.GetReferenceCount() > 0)\n                return;\n            this.EndBatch();\n            if (rendererTex === this._lastTexture0) {\n                this._gl.bindTexture(this._gl.TEXTURE_2D, null);\n                this._lastTexture0 = null\n            }\n            if (rendererTex === this._lastTexture1) {\n                this._gl.activeTexture(this._gl.TEXTURE1);\n                this._gl.bindTexture(this._gl.TEXTURE_2D, null);\n                this._gl.activeTexture(this._gl.TEXTURE0);\n                this._lastTexture1 = null\n            }\n            rendererTex._Delete()\n        }\n        CreateRenderTarget(opts) {\n            let width = this._width;\n            let height = this._height;\n            let isDefaultSize = true;\n            if (opts) {\n                if (typeof opts.width === "number") {\n                    width = opts.width;\n                    isDefaultSize = false\n                }\n                if (typeof opts.height === "number") {\n                    height = opts.height;\n                    isDefaultSize = false\n                }\n            }\n            if (width <= 0 || height <= 0)\n                throw new Error("invalid size");\n            this.EndBatch();\n            const renderTarget = C3.New(C3.Gfx.WebGLRenderTarget, this);\n            renderTarget._Create(width, height, Object.assign({\n                isDefaultSize\n            }, opts));\n            this._currentRenderTarget = null;\n            this._batchState.currentFramebuffer = null;\n            this._batchState.currentFramebufferNoDepth = null;\n            return renderTarget\n        }\n        SetRenderTarget(renderTarget, updateProjection=true) {\n            if (renderTarget === this._currentRenderTarget)\n                return;\n            if (renderTarget && renderTarget.IsDefaultSize())\n                renderTarget._Resize(this._width, this._height);\n            const b = this.PushBatch();\n            b.InitSetRenderTarget(renderTarget);\n            this._currentRenderTarget = renderTarget;\n            this._topOfBatch = 0;\n            if (updateProjection)\n                this.SetDefaultRenderTargetProjectionState()\n        }\n        GetRenderTarget() {\n            return this._currentRenderTarget\n        }\n        GetRenderTargetSize(renderTarget) {\n            if (renderTarget)\n                return [renderTarget.GetWidth(), renderTarget.GetHeight()];\n            else\n                return [this._width, this._height]\n        }\n        CopyRenderTarget(renderTarget, mode="stretch") {\n            if (this._version < 2 || this._currentRenderTarget && this._currentRenderTarget.GetMultisampling() > 0) {\n                this.SetCopyBlend();\n                this.ResetColor();\n                this.DrawRenderTarget(renderTarget, mode)\n            } else {\n                const b = this.PushBatch();\n                b.InitBlitFramebuffer(renderTarget, this._currentRenderTarget, mode);\n                this._topOfBatch = 0\n            }\n        }\n        DrawRenderTarget(renderTarget, mode="stretch") {\n            const tex = renderTarget.GetTexture();\n            if (!tex)\n                throw new Error("not a texture-backed render target");\n            this.SetTexture(tex);\n            this.FullscreenQuad(mode, tex)\n        }\n        InvalidateRenderTarget(renderTarget) {\n            if (this._version < 2)\n                return;\n            const b = this.PushBatch();\n            b.InitInvalidateFramebuffer(renderTarget._GetFramebuffer());\n            this._topOfBatch = 0\n        }\n        DeleteRenderTarget(renderTarget) {\n            this.SetRenderTarget(null);\n            this.EndBatch();\n            const renderTex = renderTarget.GetTexture();\n            if (renderTex === this._lastTexture0) {\n                this._gl.bindTexture(this._gl.TEXTURE_2D, null);\n                this._lastTexture0 = null\n            }\n            if (renderTex === this._lastTexture1) {\n                this._gl.activeTexture(this._gl.TEXTURE1);\n                this._gl.bindTexture(this._gl.TEXTURE_2D, null);\n                this._gl.activeTexture(this._gl.TEXTURE0);\n                this._lastTexture1 = null\n            }\n            renderTarget._Delete()\n        }\n        async ReadBackRenderTargetToImageData(renderTarget, forceSynchronous, areaRect) {\n            this.EndBatch();\n            const oldRenderTarget = this._currentRenderTarget;\n            let width, height, framebuffer;\n            if (renderTarget) {\n                width = renderTarget.GetWidth();\n                height = renderTarget.GetHeight();\n                framebuffer = renderTarget._GetFramebuffer()\n            } else {\n                width = this.GetWidth();\n                height = this.GetHeight();\n                framebuffer = null\n            }\n            let x = 0;\n            let y = 0;\n            let areaWidth = width;\n            let areaHeight = height;\n            if (areaRect) {\n                x = C3.clamp(Math.floor(areaRect.getLeft()), 0, width - 1);\n                y = C3.clamp(Math.floor(areaRect.getTop()), 0, height - 1);\n                let w = areaRect.width();\n                if (w === 0)\n                    w = width - x;\n                else\n                    w = C3.clamp(Math.floor(w), 0, width - x);\n                let h = areaRect.height();\n                if (h === 0)\n                    h = height - y;\n                else\n                    h = C3.clamp(Math.floor(h), 0, height - y);\n                areaWidth = w;\n                areaHeight = h;\n                y = height - (y + areaHeight)\n            }\n            const gl = this._gl;\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n            const restorePreviousRenderTarget = () => {\n                gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                this._currentRenderTarget = null;\n                this._batchState.currentFramebuffer = null;\n                this._batchState.currentFramebufferNoDepth = null;\n                this.SetRenderTarget(oldRenderTarget)\n            }\n            ;\n            let imageData;\n            if (!forceSynchronous && this.GetWebGLVersionNumber() >= 2) {\n                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer);\n                const pixelBuffer = gl.createBuffer();\n                const bufferSize = areaWidth * areaHeight * 4;\n                const PIXEL_PACK_BUFFER = gl["PIXEL_PACK_BUFFER"];\n                gl.bindBuffer(PIXEL_PACK_BUFFER, pixelBuffer);\n                gl.bufferData(PIXEL_PACK_BUFFER, bufferSize, gl["STREAM_READ"]);\n                gl.readPixels(x, y, areaWidth, areaHeight, gl.RGBA, gl.UNSIGNED_BYTE, 0);\n                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n                gl.bindBuffer(PIXEL_PACK_BUFFER, null);\n                restorePreviousRenderTarget();\n                const sync = gl["fenceSync"](gl["SYNC_GPU_COMMANDS_COMPLETE"], 0);\n                await this._WaitForObjectReady( () => gl["getSyncParameter"](sync, gl["SYNC_STATUS"]) === gl["SIGNALED"]);\n                gl["deleteSync"](sync);\n                imageData = new ImageData(areaWidth,areaHeight);\n                gl.bindBuffer(PIXEL_PACK_BUFFER, pixelBuffer);\n                gl["getBufferSubData"](PIXEL_PACK_BUFFER, 0, new Uint8Array(imageData.data.buffer), 0, bufferSize);\n                gl.bindBuffer(PIXEL_PACK_BUFFER, null);\n                gl.deleteBuffer(pixelBuffer)\n            } else {\n                imageData = new ImageData(areaWidth,areaHeight);\n                gl.readPixels(x, y, areaWidth, areaHeight, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(imageData.data.buffer));\n                restorePreviousRenderTarget()\n            }\n            return imageData\n        }\n        CoplanarStartStencilPass() {\n            this.SetDepthEnabled(true);\n            const batch = this.PushBatch();\n            batch.InitCoplanarStartStencilPass();\n            this._topOfBatch = 0\n        }\n        CoplanarStartColorPass() {\n            this.SetDepthEnabled(false);\n            const batch = this.PushBatch();\n            batch.InitCoplanarStartColorPass();\n            this._topOfBatch = 0\n        }\n        CoplanarRestoreStandardRendering() {\n            this.SetDepthEnabled(true);\n            const batch = this.PushBatch();\n            batch.InitCoplanarRestore();\n            this._topOfBatch = 0\n        }\n        StartQuery(query) {\n            if (!this.SupportsGPUProfiling())\n                return;\n            const b = this.PushBatch();\n            b.InitStartQuery(query);\n            this._topOfBatch = 0\n        }\n        EndQuery(query) {\n            if (!this.SupportsGPUProfiling())\n                return;\n            const b = this.PushBatch();\n            b.InitEndQuery(query);\n            this._topOfBatch = 0\n        }\n        _WaitForObjectReady(checkFunc) {\n            const ret = new Promise(resolve => pendingPolls.add({\n                resolve,\n                checkFunc\n            }));\n            if (pollRafId === -1)\n                pollRafId = self.requestAnimationFrame(CheckPendingPolls);\n            return ret\n        }\n        IsDesynchronized() {\n            return !!this._attribs["desynchronized"]\n        }\n        GetEstimatedBackBufferMemoryUsage() {\n            return this._width * this._height * (this._attribs["alpha"] ? 4 : 3)\n        }\n        GetEstimatedRenderBufferMemoryUsage() {\n            let ret = 0;\n            for (const t of C3.Gfx.WebGLRenderTarget.allRenderTargets()) {\n                if (t.GetTexture())\n                    continue;\n                ret += t.GetEstimatedMemoryUsage()\n            }\n            return ret\n        }\n        GetEstimatedTextureMemoryUsage() {\n            let ret = 0;\n            for (const t of C3.Gfx.WebGLRendererTexture.allTextures())\n                ret += t.GetEstimatedMemoryUsage();\n            return ret\n        }\n        GetEstimatedTotalMemoryUsage() {\n            return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage()\n        }\n        GetWebGLVersionString() {\n            return this._versionString\n        }\n        GetWebGLVersionNumber() {\n            return this._version\n        }\n        GetDisplayName() {\n            return "webgl" + this.GetWebGLVersionNumber()\n        }\n        SupportsNPOTTextures() {\n            return this.GetWebGLVersionNumber() >= 2\n        }\n        GetMaxTextureSize() {\n            return this._maxTextureSize\n        }\n        GetMinPointSize() {\n            return this._minPointSize\n        }\n        GetMaxPointSize() {\n            return this._maxPointSize\n        }\n        SupportsHighP() {\n            return this._highpPrecision !== 0\n        }\n        GetHighPPrecision() {\n            return this._highpPrecision\n        }\n        GetUnmaskedVendor() {\n            return this._unmaskedVendor\n        }\n        GetUnmaskedRenderer() {\n            return this._unmaskedRenderer\n        }\n        GetExtensions() {\n            return this._extensions\n        }\n        SupportsGPUProfiling() {\n            return !!this._timerExt\n        }\n        _GetDisjointTimerQueryExtension() {\n            return this._timerExt\n        }\n        _GetParallelShaderCompileExtension() {\n            return this._parallelShaderCompileExt\n        }\n        _GetAnisotropicExtension() {\n            return this._anisotropicExt\n        }\n        _GetMaxAnisotropy() {\n            return this._maxAnisotropy\n        }\n        _AddQueryResultBuffer(qrb) {\n            this._allQueryResultBuffers.add(qrb)\n        }\n        _RemoveQueryResultBuffer(qrb) {\n            this._allQueryResultBuffers.delete(qrb)\n        }\n        _GetTimeQueryStack() {\n            return this._timeQueryStack\n        }\n        GetContext() {\n            return this._gl\n        }\n        _InitBlendModes(gl) {\n            this._InitBlendModeData([["normal", gl.ONE, gl.ONE_MINUS_SRC_ALPHA], ["additive", gl.ONE, gl.ONE], ["xor", gl.ONE, gl.ONE_MINUS_SRC_ALPHA], ["copy", gl.ONE, gl.ZERO], ["destination-over", gl.ONE_MINUS_DST_ALPHA, gl.ONE], ["source-in", gl.DST_ALPHA, gl.ZERO], ["destination-in", gl.ZERO, gl.SRC_ALPHA], ["source-out", gl.ONE_MINUS_DST_ALPHA, gl.ZERO], ["destination-out", gl.ZERO, gl.ONE_MINUS_SRC_ALPHA], ["source-atop", gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA], ["destination-atop", gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA]])\n        }\n        CreateRendererText() {\n            return C3.New(C3.Gfx.RendererText, this)\n        }\n        CreateWebGLText() {\n            return this.CreateRendererText()\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/effectCompositor\/effectChainManager.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const DEFAULT_CTOR_OPTS = {\n        getDrawSize: null,\n        getRenderTarget: null,\n        releaseRenderTarget: null,\n        getTime: null,\n        redraw: null\n    };\n    C3.Gfx.EffectChainManager = class EffectChainManager {\n        constructor(opts) {\n            opts = Object.assign({}, DEFAULT_CTOR_OPTS, opts);\n            this._cbGetDrawSize = opts.getDrawSize;\n            this._cbGetRenderTarget = opts.getRenderTarget;\n            this._cbReleaseRenderTarget = opts.releaseRenderTarget;\n            this._cbGetTime = opts.getTime;\n            this._cbRedraw = opts.redraw;\n            this._webgpuBackTexture = null\n        }\n        GetDrawSize(renderer) {\n            if (this._cbGetDrawSize)\n                return this._cbGetDrawSize(renderer);\n            else\n                return [renderer.GetWidth(), renderer.GetHeight()]\n        }\n        GetRenderTarget(effectChain) {\n            return this._cbGetRenderTarget(effectChain)\n        }\n        ReleaseRenderTarget(rt, effectChain) {\n            this._cbReleaseRenderTarget(rt, effectChain)\n        }\n        GetTime() {\n            return this._cbGetTime()\n        }\n        Redraw(effectChain) {\n            this._cbRedraw(effectChain)\n        }\n        _GetWebGPUBackTexture(renderer, width, height) {\n            if (this._webgpuBackTexture && (this._webgpuBackTexture.GetWidth() !== width || this._webgpuBackTexture.GetHeight() !== height)) {\n                renderer.DeleteTexture(this._webgpuBackTexture);\n                this._webgpuBackTexture = null\n            }\n            if (this._webgpuBackTexture === null)\n                this._webgpuBackTexture = renderer.CreateStaticTexture(null, {\n                    width,\n                    height,\n                    sampling: "nearest",\n                    mipMap: false\n                });\n            return this._webgpuBackTexture\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/effectCompositor\/effectChain.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const assert = self.assert;\n    const glMatrix = self.glMatrix;\n    const mat4 = glMatrix.mat4;\n    const tempRect = C3.New(C3.Rect);\n    const tempRect2 = C3.New(C3.Rect);\n    const tempRect3 = C3.New(C3.Rect);\n    const tempRect4 = C3.New(C3.Rect);\n    const tempMat4a = mat4.create();\n    const tempMat4b = mat4.create();\n    const DEFAULT_CTOR_OPTS = {\n        drawContent: null,\n        getSourceTextureInfo: null,\n        getShaderParameters: null,\n        invalidateRenderTargets: false\n    };\n    const DEFAULT_BUILDSTEPS_OPTS = {\n        indexMap: null,\n        forcePreDraw: false,\n        forcePostDraw: false,\n        is3D: false,\n        isSourceTextureRotated: false,\n        isRotatedOrNegativeSizeInstance: false,\n        useFullSurface: false\n    };\n    C3.Gfx.EffectChain = class EffectChain {\n        constructor(manager, opts) {\n            opts = Object.assign({}, DEFAULT_CTOR_OPTS, opts);\n            this._manager = manager;\n            this._cbDrawContent = opts.drawContent;\n            this._cbGetSourceTextureInfo = opts.getSourceTextureInfo;\n            this._cbGetShaderParameters = opts.getShaderParameters;\n            this._cbDrawContentHook = null;\n            this._shaderProgramList = [];\n            this._shaderProgramIndices = [];\n            this._steps = [];\n            this._blendMode = 0;\n            this._isAnyShaderAnimated = false;\n            this._isAnyShaderDepthSampling = false;\n            this._isAnyShaderBackgroundBlending = false;\n            this._isAnyShaderCrossSampling = false;\n            this._isAnyIsSrcTexRotated = false;\n            this._useCopyTextureBackgroundSampling = false;\n            this._didChangeTransform = false;\n            this._depthEnabledAtStart = false;\n            this._canUseFastPath = false;\n            this._useFullSurface = false;\n            this._isSourceTextureRotated = false;\n            this._numTempSurfacesRequired = 0;\n            this._renderTargets = [null, null, null];\n            this._invalidateRenderTargets = !!opts.invalidateRenderTargets;\n            this._boxExtendHorizontal = 0;\n            this._boxExtendVertical = 0;\n            this._drawWidth = 0;\n            this._drawHeight = 0;\n            this._contentObject = null;\n            this._contextObject = null;\n            this._layoutRect = C3.New(C3.Rect);\n            this._drawSurfaceRect = C3.New(C3.Rect);\n            this._rcTexOriginal = C3.New(C3.Rect);\n            this._rcTexBounce = C3.New(C3.Rect);\n            this._rcTexDest = C3.New(C3.Rect);\n            this._devicePixelRatio = 1;\n            this._layerScale = 1;\n            this._layerAngle = 0;\n            this._time = 0;\n            this._destRenderTarget = null;\n            this._backTex = null;\n            this._compositOffX = 0;\n            this._compositOffY = 0;\n            this._updateOwnProjection = false;\n            this._projectionMatrix = mat4.create();\n            this._modelViewMatrix = mat4.create()\n        }\n        Release() {\n            C3.clearArray(this._steps);\n            C3.clearArray(this._shaderProgramList);\n            C3.clearArray(this._shaderProgramIndices);\n            this._contentObject = null;\n            this._contextObject = null;\n            this._cbDrawContent = null;\n            this._cbGetSourceTextureInfo = null;\n            this._cbGetShaderParameters = null\n        }\n        BuildSteps(shaderProgramList, opts) {\n            opts = Object.assign({}, DEFAULT_BUILDSTEPS_OPTS, opts);\n            C3.clearArray(this._steps);\n            this._boxExtendHorizontal = 0;\n            this._boxExtendVertical = 0;\n            this._isAnyShaderAnimated = false;\n            this._isAnyShaderDepthSampling = false;\n            this._isAnyShaderBackgroundBlending = false;\n            this._isAnyShaderCrossSampling = false;\n            this._isAnyIsSrcTexRotated = false;\n            this._useCopyTextureBackgroundSampling = false;\n            this._numTempSurfacesRequired = 0;\n            this._isSourceTextureRotated = !!opts.isSourceTextureRotated;\n            this._useFullSurface = !!opts.useFullSurface;\n            C3.shallowAssignArray(this._shaderProgramList, shaderProgramList);\n            if (shaderProgramList.length === 0)\n                return;\n            if (opts.indexMap) {\n                if (opts.indexMap.length !== shaderProgramList.length)\n                    throw new Error("incorrect indexMap length");\n                C3.shallowAssignArray(this._shaderProgramIndices, opts.indexMap)\n            } else {\n                C3.clearArray(this._shaderProgramIndices);\n                for (let i = 0, len = shaderProgramList.length; i < len; ++i)\n                    this._shaderProgramIndices.push(i)\n            }\n            for (const s of shaderProgramList) {\n                this._boxExtendHorizontal += s.GetBoxExtendHorizontal();\n                this._boxExtendVertical += s.GetBoxExtendVertical();\n                if (s.IsAnimated())\n                    this._isAnyShaderAnimated = true;\n                if (s.UsesDepth())\n                    this._isAnyShaderDepthSampling = true;\n                if (s.BlendsBackground())\n                    this._isAnyShaderBackgroundBlending = true;\n                if (s.UsesCrossSampling())\n                    this._isAnyShaderCrossSampling = true;\n                if (s.UsesIsSrcTexRotated())\n                    this._isAnyIsSrcTexRotated = true\n            }\n            this._useCopyTextureBackgroundSampling = this._ShouldUseCopyTextureBackgroundSampling(shaderProgramList[0].GetRenderer());\n            const doPreDraw = this._ShouldPreDraw(shaderProgramList[0], opts);\n            const doPostDraw = this._ShouldPostDraw(shaderProgramList.at(-1), opts);\n            if (shaderProgramList.length === 1 && !doPreDraw && !doPostDraw) {\n                this._canUseFastPath = true;\n                return\n            }\n            this._canUseFastPath = false;\n            let lastTargetId = 0;\n            if (doPreDraw) {\n                this._numTempSurfacesRequired = 1;\n                this._steps.push(C3.New(C3.Gfx.EffectChain.Step.PreDraw, this, -1, 1));\n                lastTargetId = 1\n            }\n            for (let i = 0, len = shaderProgramList.length; i < len; ++i)\n                if (i === 0 && !doPreDraw) {\n                    this._numTempSurfacesRequired = 1;\n                    this._steps.push(C3.New(C3.Gfx.EffectChain.Step.FirstBounce, this, -1, 1, i));\n                    lastTargetId = 1\n                } else {\n                    let nextTargetId = lastTargetId === 1 ? 2 : 1;\n                    if (i === len - 1 && !doPostDraw)\n                        nextTargetId = 0;\n                    this._numTempSurfacesRequired = Math.max(this._numTempSurfacesRequired, nextTargetId);\n                    this._steps.push(C3.New(C3.Gfx.EffectChain.Step.Bounce, this, lastTargetId, nextTargetId, i));\n                    lastTargetId = nextTargetId\n                }\n            if (doPostDraw)\n                this._steps.push(C3.New(C3.Gfx.EffectChain.Step.PostDraw, this, lastTargetId, 0))\n        }\n        _ShouldPreDraw(firstShaderProgram, opts) {\n            if (opts.forcePreDraw || firstShaderProgram.MustPreDraw() || opts.is3D || firstShaderProgram.UsesDepth() && !this._useFullSurface || (this._boxExtendHorizontal !== 0 || this._boxExtendVertical !== 0) && !this._useFullSurface)\n                return true;\n            if (firstShaderProgram.GetRenderer().IsWebGL())\n                return firstShaderProgram.BlendsBackground() && (opts.isRotatedOrNegativeSizeInstance || opts.isSourceTextureRotated) || firstShaderProgram.UsesAnySrcRectOrPixelSize() && opts.isSourceTextureRotated;\n            else\n                return false\n        }\n        _ShouldPostDraw(lastShaderProgram, opts) {\n            if (opts.forcePostDraw)\n                return true;\n            if (lastShaderProgram.GetRenderer().IsWebGL())\n                return lastShaderProgram.BlendsBackground() || lastShaderProgram.UsesCrossSampling();\n            else\n                return (lastShaderProgram.BlendsBackground() || lastShaderProgram.UsesCrossSampling()) && this._UseRenderTargetBackgroundSampling()\n        }\n        _ShouldUseCopyTextureBackgroundSampling(renderer) {\n            return renderer.IsWebGPU() && this._isAnyShaderBackgroundBlending && !this._isAnyShaderCrossSampling\n        }\n        Render(renderer, destRenderTarget, opts) {\n            if (renderer.IsWebGPU() && destRenderTarget === null)\n                destRenderTarget = renderer.GetBackbufferRenderTarget();\n            this._destRenderTarget = destRenderTarget;\n            this._contentObject = opts.contentObject || null;\n            this._contextObject = opts.contextObject || null;\n            this._blendMode = opts.blendMode || 0;\n            this._devicePixelRatio = opts.devicePixelRatio || 1;\n            this._layerScale = opts.layerScale || 1;\n            this._layerAngle = opts.layerAngle || 0;\n            this._time = typeof opts.time === "number" ? opts.time : this._manager.GetTime();\n            this._didChangeTransform = false;\n            renderer.ResetDidChangeTransformFlag();\n            if (this._isAnyShaderAnimated)\n                this._Redraw();\n            let didCalcDrawSizeAndRects = false;\n            if (this._UseCopyTextureBackgroundSampling()) {\n                this._CalculateDrawSizeAndRectangles(renderer, opts);\n                didCalcDrawSizeAndRects = true;\n                this._backTex = this._manager._GetWebGPUBackTexture(renderer, this._drawWidth, this._drawHeight);\n                tempRect.copy(this._drawSurfaceRect);\n                tempRect.roundOuter();\n                renderer.CopyTextureToTexture(this._destRenderTarget.GetTexture(), this._backTex, tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height())\n            }\n            if (this._canUseFastPath) {\n                this._Render_FastPath(renderer, opts);\n                return\n            }\n            if (!didCalcDrawSizeAndRects)\n                this._CalculateDrawSizeAndRectangles(renderer, opts);\n            renderer.ResetColor();\n            renderer.SetBaseZ(0);\n            renderer.SetCurrentZ(0);\n            this._cbDrawContentHook = opts.drawContentHook || null;\n            this._compositOffX = opts.compositOffX || 0;\n            this._compositOffY = opts.compositOffY || 0;\n            this._updateOwnProjection = !!opts.updateOwnProjection;\n            this._OnBeforeStartEffectChain(renderer);\n            this._renderTargets[0] = destRenderTarget;\n            this._renderTargets[1] = this._numTempSurfacesRequired >= 1 ? this._GetRenderTarget() : null;\n            this._renderTargets[2] = this._numTempSurfacesRequired === 2 ? this._GetRenderTarget() : null;\n            for (const step of this._steps) {\n                const srcTarget = this._GetRenderTargetForId(step.GetSrcTargetId());\n                const destTarget = this._GetRenderTargetForId(step.GetDestTargetId());\n                if (renderer.IsWebGPU())\n                    step.Run_WebGPU(renderer, srcTarget, destTarget);\n                else\n                    step.Run_WebGL(renderer, srcTarget, destTarget)\n            }\n            if (this._renderTargets[1])\n                this._ReleaseRenderTarget(this._renderTargets[1]);\n            if (this._renderTargets[2])\n                this._ReleaseRenderTarget(this._renderTargets[2]);\n            this._renderTargets.fill(null);\n            this._OnAfterEndEffectChain(renderer);\n            this._destRenderTarget = null;\n            this._backTex = null;\n            this._contentObject = null;\n            this._contextObject = null;\n            this._cbDrawContentHook = null\n        }\n        _CalculateDrawSizeAndRectangles(renderer, opts) {\n            const [drawWidth,drawHeight] = this._manager.GetDrawSize(renderer);\n            this._SetDrawSize(renderer, drawWidth, drawHeight);\n            this._CalculateRectangles(opts)\n        }\n        _SetDrawSize(renderer, drawWidth, drawHeight) {\n            if (drawWidth <= 0 || drawHeight <= 0)\n                throw new Error("invalid draw size");\n            if (this._drawWidth !== drawWidth || this._drawHeight !== drawHeight)\n                this._CalculateDeviceTransformMatrices(renderer, drawWidth, drawHeight, 0, 0, this._projectionMatrix, this._modelViewMatrix);\n            this._drawWidth = drawWidth;\n            this._drawHeight = drawHeight\n        }\n        _CalculateDeviceTransformMatrices(renderer, width, height, offX, offY, projMat, mvMat) {\n            const scrollX = width \/ 2 + offX;\n            const scrollY = height \/ 2 + offY;\n            renderer.CalculatePerspectiveMatrix(projMat, width \/ height);\n            const tempMat4 = renderer.CalculateLookAtModelView2(scrollX, scrollY, renderer.GetDefaultCameraZ(height), scrollX, scrollY, 0, height);\n            mat4.copy(mvMat, tempMat4)\n        }\n        _CalculateRectangles(opts) {\n            this._layoutRect.copy(opts.layoutRect);\n            if (opts.drawSurfaceRect)\n                this._drawSurfaceRect.copy(opts.drawSurfaceRect);\n            else\n                this._drawSurfaceRect.set(0, 0, this._drawWidth, this._drawHeight);\n            this._rcTexOriginal.copy(this._drawSurfaceRect);\n            this._rcTexOriginal.divide(this._drawWidth, this._drawHeight);\n            const boxScale = this._layerScale * this._devicePixelRatio;\n            this._drawSurfaceRect.inflate(this._boxExtendHorizontal * boxScale, this._boxExtendVertical * boxScale);\n            this._rcTexDest.copy(this._drawSurfaceRect);\n            this._rcTexDest.divide(this._drawWidth, this._drawHeight);\n            this._drawSurfaceRect.clamp(0, 0, this._drawWidth, this._drawHeight);\n            this._rcTexBounce.copy(this._drawSurfaceRect);\n            this._rcTexBounce.divide(this._drawWidth, this._drawHeight)\n        }\n        _OnBeforeStartEffectChain(renderer) {\n            this._depthEnabledAtStart = renderer.IsDepthEnabled();\n            if (this._useFullSurface) {\n                renderer.SetDepthEnabled(false);\n                if (this._isAnyShaderDepthSampling)\n                    renderer.SetDepthSamplingEnabled(true)\n            } else {\n                tempRect.copy(this._drawSurfaceRect);\n                if (renderer.IsWebGL()) {\n                    const boxScale = this._layerScale * this._devicePixelRatio;\n                    tempRect.inflate(Math.max(this._boxExtendHorizontal, 1) * boxScale, Math.max(this._boxExtendVertical, 1) * boxScale);\n                    tempRect.roundOuter();\n                    tempRect.clamp(0, 0, this._drawWidth, this._drawHeight)\n                } else\n                    tempRect.roundOuter();\n                renderer.SetScissorRect(tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height(), this._drawHeight)\n            }\n        }\n        _OnAfterEffectChainDrawContent(renderer) {\n            renderer.ResetColor();\n            if (!this._useFullSurface) {\n                renderer.SetDepthEnabled(false);\n                if (this._isAnyShaderDepthSampling)\n                    renderer.SetDepthSamplingEnabled(true)\n            }\n            if (renderer.IsWebGPU())\n                renderer.SetNormalizedCoordsProgramVariant(true)\n        }\n        _OnAfterEndEffectChain(renderer) {\n            renderer.SetDepthSamplingEnabled(false);\n            renderer.SetDepthEnabled(this._depthEnabledAtStart);\n            if (!this._useFullSurface)\n                renderer.RemoveScissorRect();\n            if (renderer.IsWebGPU())\n                renderer.SetNormalizedCoordsProgramVariant(false);\n            this._didChangeTransform = renderer.DidChangeTransform()\n        }\n        _ClampRcTexDest() {\n            this._rcTexDest.clamp(0, 0, 1, 1)\n        }\n        _GetRenderTargetForId(id) {\n            return id < 0 ? null : this._renderTargets[id]\n        }\n        _GetRenderTarget() {\n            return this._manager.GetRenderTarget(this)\n        }\n        _GetDestRenderTarget() {\n            return this._destRenderTarget\n        }\n        _ReleaseRenderTarget(rt) {\n            this._manager.ReleaseRenderTarget(rt, this)\n        }\n        _GetShaderProgramAt(i) {\n            return this._shaderProgramList[i]\n        }\n        _DrawContent(renderer) {\n            if (this._cbDrawContentHook)\n                this._cbDrawContentHook(this, renderer, () => this._cbDrawContent(renderer, this));\n            else\n                this._cbDrawContent(renderer, this);\n            if (!this._canUseFastPath)\n                this._OnAfterEffectChainDrawContent(renderer)\n        }\n        _IsRenderTargetSameSizeAndOffset(renderer) {\n            if (this._useFullSurface)\n                return true;\n            if (this._compositOffX !== 0 || this._compositOffY !== 0)\n                return false;\n            const [rtWidth,rtHeight] = renderer.GetRenderTargetSize(renderer.GetRenderTarget());\n            if (rtWidth !== this._drawWidth || rtHeight !== this._drawHeight)\n                return false;\n            return true\n        }\n        _SetDeviceTransform(renderer, isLast) {\n            let projMat = this._projectionMatrix;\n            let mvMat = this._modelViewMatrix;\n            if (isLast && !this._IsRenderTargetSameSizeAndOffset(renderer)) {\n                projMat = tempMat4a;\n                mvMat = tempMat4b;\n                const [rtWidth,rtHeight] = renderer.GetRenderTargetSize(renderer.GetRenderTarget());\n                this._CalculateDeviceTransformMatrices(renderer, rtWidth, rtHeight, this._compositOffX, this._compositOffY, projMat, mvMat);\n                if (!this._useFullSurface)\n                    renderer.RemoveScissorRect()\n            }\n            renderer.SetProjectionMatrix(projMat);\n            renderer.SetModelViewMatrix(mvMat)\n        }\n        _Redraw() {\n            this._manager.Redraw(this)\n        }\n        _GetShaderParameters(index) {\n            return this._cbGetShaderParameters(this._shaderProgramIndices[index])\n        }\n        _SetProgramParameters(renderer, index) {\n            let rcTexDest = this._rcTexDest;\n            let srcRect = this._rcTexBounce;\n            let srcOriginRect = this._rcTexOriginal;\n            if (renderer.IsWebGL()) {\n                tempRect2.copy(rcTexDest);\n                tempRect2.flipAround(1);\n                rcTexDest = tempRect2;\n                tempRect3.copy(srcRect);\n                tempRect3.flipAround(1);\n                srcRect = tempRect3;\n                tempRect4.copy(srcOriginRect);\n                tempRect4.flipAround(1);\n                srcOriginRect = tempRect4\n            }\n            this._DoSetProgramParameters(renderer, index, srcRect, srcOriginRect, rcTexDest, 1 \/ this._drawWidth, 1 \/ this._drawHeight)\n        }\n        _SetFirstBounceProgramParameters(renderer, index) {\n            let srcRect = this._rcTexBounce;\n            let srcOriginRect = this._rcTexOriginal;\n            let pixelWidth = 1 \/ this._drawWidth;\n            let pixelHeight = 1 \/ this._drawHeight;\n            if (this._cbGetSourceTextureInfo) {\n                let {srcTexRect, srcWidth, srcHeight} = this._cbGetSourceTextureInfo(this._contentObject);\n                if (!srcTexRect) {\n                    tempRect.set(0, 0, 0, 0);\n                    srcTexRect = tempRect\n                }\n                if (!srcWidth)\n                    srcWidth = this._drawWidth;\n                if (!srcHeight)\n                    srcHeight = this._drawHeight;\n                srcRect = srcTexRect;\n                srcOriginRect = srcTexRect;\n                pixelWidth = 1 \/ srcWidth;\n                pixelHeight = 1 \/ srcHeight\n            } else if (renderer.IsWebGL()) {\n                tempRect3.copy(srcRect);\n                tempRect3.flipAround(1);\n                srcRect = tempRect3;\n                tempRect4.copy(srcOriginRect);\n                tempRect4.flipAround(1);\n                srcOriginRect = tempRect4\n            }\n            let rcTexDest = this._rcTexDest;\n            if (renderer.IsWebGL()) {\n                rcTexDest = tempRect2;\n                rcTexDest.copy(this._rcTexDest);\n                rcTexDest.flipAround(1)\n            }\n            this._DoSetProgramParameters(renderer, index, srcRect, srcOriginRect, rcTexDest, pixelWidth, pixelHeight);\n            if (renderer.IsWebGPU() && this._isAnyIsSrcTexRotated)\n                renderer.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated)\n        }\n        _GetBackTex(renderer) {\n            if (this._isAnyShaderBackgroundBlending)\n                if (renderer.IsWebGPU())\n                    if (this._UseCopyTextureBackgroundSampling())\n                        return this._backTex;\n                    else\n                        return this._destRenderTarget.GetTexture();\n                else\n                    return this._destRenderTarget;\n            else\n                return null\n        }\n        _DoSetProgramParameters(renderer, index, srcRect, srcOriginRect, rcTexDest, pixelWidth, pixelHeight) {\n            renderer.SetProgramParameters(this._GetBackTex(renderer), rcTexDest, srcRect, srcOriginRect, this._layoutRect, pixelWidth, pixelHeight, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time);\n            renderer.SetProgramCustomParameters(this._GetShaderParameters(index))\n        }\n        _Render_FastPath(renderer, opts) {\n            const shaderProgram = this._shaderProgramList[0];\n            const wasDepthEnabled = renderer.IsDepthEnabled();\n            const usesDepth = shaderProgram.UsesDepth();\n            if (usesDepth) {\n                renderer.SetDepthEnabled(false);\n                renderer.SetDepthSamplingEnabled(true);\n                this._rcTexDest.set(0, 0, 1, 1);\n                this._rcTexOriginal.set(0, 0, 1, 1)\n            }\n            renderer.SetProgram(shaderProgram);\n            renderer.SetBlendMode(this._blendMode);\n            renderer.SetRenderTarget(this._destRenderTarget);\n            let pixelWidth = 0;\n            let pixelHeight = 1;\n            this._rcTexOriginal.set(0, 0, 1, 1);\n            if (shaderProgram.UsesAnySrcRectOrPixelSize() && this._cbGetSourceTextureInfo) {\n                const {srcTexRect, srcWidth, srcHeight} = this._cbGetSourceTextureInfo(this._contentObject);\n                if (srcTexRect)\n                    this._rcTexOriginal.copy(srcTexRect);\n                pixelWidth = Number.isFinite(srcWidth) ? 1 \/ srcWidth : 0;\n                pixelHeight = Number.isFinite(srcHeight) ? 1 \/ srcHeight : 0\n            } else {\n                const [drawWidth,drawHeight] = this._manager.GetDrawSize(renderer);\n                pixelWidth = 1 \/ drawWidth;\n                pixelHeight = 1 \/ drawHeight\n            }\n            if (opts.layoutRect)\n                this._layoutRect.copy(opts.layoutRect);\n            else\n                this._layoutRect.set(0, 0, 0, 0);\n            renderer.SetProgramParameters(this._GetBackTex(renderer), this._rcTexDest, this._rcTexOriginal, this._rcTexOriginal, this._layoutRect, pixelWidth, pixelHeight, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time);\n            renderer.SetProgramCustomParameters(this._GetShaderParameters(0));\n            if (renderer.IsWebGPU() && this._isAnyIsSrcTexRotated)\n                renderer.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated);\n            renderer.SetBaseZ(0);\n            this._DrawContent(renderer);\n            if (usesDepth) {\n                renderer.SetDepthSamplingEnabled(false);\n                renderer.SetDepthEnabled(wasDepthEnabled)\n            }\n        }\n        _UseCopyTextureBackgroundSampling() {\n            return this._useCopyTextureBackgroundSampling\n        }\n        _UseRenderTargetBackgroundSampling() {\n            return !this._useCopyTextureBackgroundSampling\n        }\n        IsAnyShaderBackgroundBlending() {\n            return this._isAnyShaderBackgroundBlending\n        }\n        CanSkipCalculatingDrawSurfaceRect() {\n            if (!this._canUseFastPath)\n                return false;\n            if (this._UseCopyTextureBackgroundSampling())\n                return false;\n            return true\n        }\n        UseFullSurface() {\n            return this._useFullSurface\n        }\n        GetContentObject() {\n            return this._contentObject\n        }\n        GetContextObject() {\n            return this._contextObject\n        }\n        _GetBlendMode() {\n            return this._blendMode\n        }\n        _UpdateOwnProjection() {\n            return this._updateOwnProjection\n        }\n        DidChangeTransform() {\n            return this._didChangeTransform\n        }\n        _GetDrawSurfaceRect() {\n            return this._drawSurfaceRect\n        }\n        _GetRcTexBounce() {\n            return this._rcTexBounce\n        }\n        _ShouldInvalidateRenderTargets() {\n            return this._invalidateRenderTargets\n        }\n        async DebugLogRenderTargetContents(msg, renderer, renderTarget) {}\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/effectCompositor\/step.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Gfx.EffectChain.Step = class EffectChainStep {\n        constructor(effectChain, srcTargetId, destTargetId, index=-1) {\n            this._effectChain = effectChain;\n            this._srcTargetId = srcTargetId;\n            this._destTargetId = destTargetId;\n            this._index = index\n        }\n        GetEffectChain() {\n            return this._effectChain\n        }\n        GetSrcTargetId() {\n            return this._srcTargetId\n        }\n        GetDestTargetId() {\n            return this._destTargetId\n        }\n        GetIndex() {\n            return this._index\n        }\n        GetShaderProgram() {\n            return this.GetEffectChain()._GetShaderProgramAt(this.GetIndex())\n        }\n        Run_WebGL(renderer, srcRenderTarget, destRenderTarget) {}\n        Run_WebGPU(renderer, srcRenderTarget, destRenderTarget) {}\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/effectCompositor\/preDrawStep.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Gfx.EffectChain.Step.PreDraw = class PreDrawStep extends C3.Gfx.EffectChain.Step {\n        constructor(effectChain, srcTargetId, destTargetId, index) {\n            super(effectChain, srcTargetId, destTargetId, index)\n        }\n        Run_WebGL(renderer, srcRenderTarget, destRenderTarget) {\n            const effectChain = this.GetEffectChain();\n            renderer.SetAlphaBlend();\n            renderer.SetTextureFillMode();\n            renderer.SetRenderTarget(destRenderTarget, effectChain._UpdateOwnProjection());\n            renderer.ClearRgba(0, 0, 0, 0);\n            effectChain._DrawContent(renderer);\n            effectChain._ClampRcTexDest()\n        }\n        Run_WebGPU(renderer, srcRenderTarget, destRenderTarget) {\n            const effectChain = this.GetEffectChain();\n            renderer.SetAlphaBlend();\n            renderer.SetTextureFillMode();\n            renderer.SetRenderTarget(destRenderTarget, false);\n            renderer.ClearRgba(0, 0, 0, 0);\n            effectChain._DrawContent(renderer);\n            effectChain._ClampRcTexDest()\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/effectCompositor\/postDrawStep.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const tempRect = C3.New(C3.Rect);\n    const tempQuad = C3.New(C3.Quad);\n    C3.Gfx.EffectChain.Step.PostDraw = class PostDrawStep extends C3.Gfx.EffectChain.Step {\n        constructor(effectChain, srcTargetId, destTargetId, index) {\n            super(effectChain, srcTargetId, destTargetId, index)\n        }\n        Run_WebGL(renderer, srcRenderTarget, destRenderTarget) {\n            const effectChain = this.GetEffectChain();\n            renderer.SetTextureFillMode();\n            renderer.SetRenderTarget(destRenderTarget);\n            effectChain._SetDeviceTransform(renderer, true);\n            renderer.SetBlendMode(effectChain._GetBlendMode());\n            renderer.SetTexture(srcRenderTarget.GetTexture());\n            tempQuad.setFromRect(effectChain._GetDrawSurfaceRect());\n            tempRect.copy(effectChain._GetRcTexBounce());\n            tempRect.flipAround(1);\n            renderer.Quad3(tempQuad, tempRect);\n            if (effectChain._ShouldInvalidateRenderTargets())\n                renderer.InvalidateRenderTarget(srcRenderTarget)\n        }\n        Run_WebGPU(renderer, srcRenderTarget, destRenderTarget) {\n            const effectChain = this.GetEffectChain();\n            renderer.SetTextureFillMode();\n            renderer.SetRenderTarget(destRenderTarget, false);\n            if (effectChain._IsRenderTargetSameSizeAndOffset(renderer))\n                tempQuad.setFromRect(effectChain._GetRcTexBounce());\n            else {\n                renderer.SetNormalizedCoordsProgramVariant(false);\n                effectChain._SetDeviceTransform(renderer, true);\n                tempQuad.setFromRect(effectChain._GetDrawSurfaceRect())\n            }\n            renderer.SetBackTexture(null);\n            renderer.SetBlendMode(effectChain._GetBlendMode());\n            renderer.SetTexture(srcRenderTarget.GetTexture());\n            if (effectChain.UseFullSurface())\n                renderer.FullscreenQuad();\n            else\n                renderer.Quad3(tempQuad, effectChain._GetRcTexBounce())\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/effectCompositor\/firstBounceStep.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Gfx.EffectChain.Step.FirstBounce = class FirstBounceStep extends C3.Gfx.EffectChain.Step {\n        constructor(effectChain, srcTargetId, destTargetId, index) {\n            super(effectChain, srcTargetId, destTargetId, index)\n        }\n        Run_WebGL(renderer, srcRenderTarget, destRenderTarget) {\n            const effectChain = this.GetEffectChain();\n            renderer.SetRenderTarget(destRenderTarget, effectChain._UpdateOwnProjection());\n            renderer.ClearRgba(0, 0, 0, 0);\n            renderer.SetCopyBlend();\n            renderer.SetProgram(this.GetShaderProgram());\n            effectChain._SetFirstBounceProgramParameters(renderer, this.GetIndex());\n            effectChain._DrawContent(renderer);\n            effectChain._ClampRcTexDest()\n        }\n        Run_WebGPU(renderer, srcRenderTarget, destRenderTarget) {\n            const effectChain = this.GetEffectChain();\n            renderer.SetRenderTarget(destRenderTarget, false);\n            renderer.ClearRgba(0, 0, 0, 0);\n            renderer.SetCopyBlend();\n            renderer.SetProgram(this.GetShaderProgram());\n            effectChain._SetFirstBounceProgramParameters(renderer, this.GetIndex());\n            effectChain._DrawContent(renderer);\n            effectChain._ClampRcTexDest()\n        }\n    }\n    ;\n\n}\n\n\/\/ ..\/lib\/gfx\/effectCompositor\/bounceStep.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const tempRect = C3.New(C3.Rect);\n    const tempQuad = C3.New(C3.Quad);\n    C3.Gfx.EffectChain.Step.Bounce = class BounceStep extends C3.Gfx.EffectChain.Step {\n        constructor(effectChain, srcTargetId, destTargetId, index) {\n            super(effectChain, srcTargetId, destTargetId, index)\n        }\n        Run_WebGL(renderer, srcRenderTarget, destRenderTarget) {\n            const effectChain = this.GetEffectChain();\n            renderer.SetRenderTarget(destRenderTarget);\n            const isLast = this.GetDestTargetId() === 0;\n            if (isLast)\n                renderer.SetBlendMode(effectChain._GetBlendMode());\n            else {\n                renderer.ClearRgba(0, 0, 0, 0);\n                renderer.SetCopyBlend()\n            }\n            renderer.SetProgram(this.GetShaderProgram());\n            effectChain._SetProgramParameters(renderer, this.GetIndex());\n            renderer.SetTexture(srcRenderTarget.GetTexture());\n            effectChain._SetDeviceTransform(renderer, isLast);\n            tempQuad.setFromRect(effectChain._GetDrawSurfaceRect());\n            tempRect.copy(effectChain._GetRcTexBounce());\n            tempRect.flipAround(1);\n            renderer.Quad3(tempQuad, tempRect);\n            if (effectChain._ShouldInvalidateRenderTargets())\n                renderer.InvalidateRenderTarget(srcRenderTarget)\n        }\n        Run_WebGPU(renderer, srcRenderTarget, destRenderTarget) {\n            const effectChain = this.GetEffectChain();\n            renderer.SetRenderTarget(destRenderTarget, false);\n            const isLast = this.GetDestTargetId() === 0;\n            if (isLast) {\n                renderer.SetBlendMode(effectChain._GetBlendMode());\n                renderer.SetBackTexture(null);\n                if (effectChain._IsRenderTargetSameSizeAndOffset(renderer))\n                    tempQuad.setFromRect(effectChain._GetRcTexBounce());\n                else {\n                    renderer.SetNormalizedCoordsProgramVariant(false);\n                    effectChain._SetDeviceTransform(renderer, true);\n                    tempQuad.setFromRect(effectChain._GetDrawSurfaceRect())\n                }\n            } else {\n                renderer.ClearRgba(0, 0, 0, 0);\n                renderer.SetCopyBlend();\n                tempQuad.setFromRect(effectChain._GetRcTexBounce())\n            }\n            renderer.SetProgram(this.GetShaderProgram());\n            effectChain._SetProgramParameters(renderer, this.GetIndex());\n            renderer.SetTexture(srcRenderTarget.GetTexture());\n            if (effectChain.UseFullSurface())\n                renderer.FullscreenQuad();\n            else\n                renderer.Quad3(tempQuad, effectChain._GetRcTexBounce())\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/IRuntime.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    let runtime = null;\n    const keysDownByKey = new Set;\n    function SortZOrderList(a, b) {\n        const layerA = a[0];\n        const layerB = b[0];\n        const diff = layerA - layerB;\n        if (diff !== 0)\n            return diff;\n        const indexA = a[1];\n        const indexB = b[1];\n        return indexA - indexB\n    }\n    const tempZOrderList = [];\n    const tempInstances = [];\n    let didWarnInAlertPolyfill = false;\n    self.IRuntime = class IRuntime {\n        constructor(runtime_, objects) {\n            runtime = runtime_;\n            Object.defineProperties(this, {\n                assets: {\n                    value: runtime.GetAssetManager().GetIAssetManager(),\n                    writable: false\n                },\n                objects: {\n                    value: objects,\n                    writable: false\n                },\n                globalVars: {\n                    value: {},\n                    writable: false\n                },\n                projectName: {\n                    value: runtime.GetProjectName(),\n                    writable: false\n                },\n                projectVersion: {\n                    value: runtime.GetProjectVersion(),\n                    writable: false\n                },\n                storage: {\n                    value: new self.IStorage(runtime),\n                    writable: false\n                },\n                isInWorker: {\n                    value: runtime.IsInWorker(),\n                    writable: false\n                }\n            });\n            runtime.UserScriptDispatcher().addEventListener("keydown", e => {\n                if (keysDownByKey.has(e["key"])) {\n                    e.stopPropagation();\n                    return\n                }\n                keysDownByKey.add(e["key"])\n            }\n            );\n            runtime.UserScriptDispatcher().addEventListener("keyup", e => keysDownByKey.delete(e["key"]));\n            runtime.Dispatcher().addEventListener("window-blur", () => keysDownByKey.clear());\n            if (runtime.IsInWorker())\n                self["alert"] = message => {\n                    if (!didWarnInAlertPolyfill) {\n                        didWarnInAlertPolyfill = true;\n                        console.warn("[Construct] alert() was called from a Web Worker, because the project \'Use worker\' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable \'Use worker\', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual.")\n                    }\n                    return this.alert(message)\n                }\n        }\n        _InitGlobalVars(globalVarDescriptors) {\n            Object.defineProperties(this.globalVars, globalVarDescriptors)\n        }\n        addEventListener(name, func) {\n            runtime.UserScriptDispatcher().addEventListener(name, func)\n        }\n        removeEventListener(name, func) {\n            runtime.UserScriptDispatcher().removeEventListener(name, func)\n        }\n        callFunction(name, ...params) {\n            C3X.RequireString(name);\n            const eventSheetManager = runtime.GetEventSheetManager();\n            const functionBlock = eventSheetManager.GetFunctionBlockByName(name);\n            if (!functionBlock)\n                throw new Error(`cannot find function name \'${name}\'`);\n            if (!functionBlock.IsEnabled())\n                return functionBlock.GetDefaultReturnValue();\n            if (params.length < functionBlock.GetFunctionParameterCount())\n                throw new Error(`not enough function parameters passed for \'${name}\' (${params.length} passed, ${functionBlock.GetFunctionParameterCount()} expected)`);\n            const callEventBlock = functionBlock.GetEventBlock();\n            let solModifiers = null;\n            const currentEvent = eventSheetManager.GetCurrentEvent();\n            if (currentEvent) {\n                const sm = currentEvent.GetSolModifiersIncludingParents();\n                if (sm.length > 0) {\n                    solModifiers = sm;\n                    eventSheetManager.PushCleanSol(sm)\n                }\n            }\n            const ret = callEventBlock.RunAsExpressionFunctionCall(callEventBlock.GetSolModifiersIncludingParents(), functionBlock.GetReturnType(), functionBlock.GetDefaultReturnValue(), ...params);\n            if (solModifiers)\n                eventSheetManager.PopSol(solModifiers);\n            return ret\n        }\n        setReturnValue(v) {\n            const frame = runtime.GetEventStack().GetCurrentExpFuncStackFrame();\n            if (!frame)\n                throw new Error("not in a function which returns a value");\n            switch (frame.GetFunctionReturnType()) {\n            case 1:\n                if (typeof v === "number")\n                    frame.SetFunctionReturnValue(v);\n                break;\n            case 2:\n                if (typeof v === "string")\n                    frame.SetFunctionReturnValue(v);\n                break;\n            case 3:\n                if (typeof v === "number" || typeof v === "string")\n                    frame.SetFunctionReturnValue(v);\n                break\n            }\n        }\n        get dt() {\n            return runtime.GetDt()\n        }\n        get gameTime() {\n            return runtime.GetGameTime()\n        }\n        get wallTime() {\n            return runtime.GetWallTime()\n        }\n        random() {\n            return runtime.Random()\n        }\n        get layout() {\n            return runtime.GetMainRunningLayout().GetILayout()\n        }\n        getLayout(nameOrIndex) {\n            const layoutManager = runtime.GetLayoutManager();\n            let layout = null;\n            if (typeof nameOrIndex === "number" || typeof nameOrIndex === "string")\n                layout = layoutManager.GetLayout(nameOrIndex);\n            else\n                throw new TypeError("expected string or number");\n            if (!layout)\n                throw new Error("invalid layout");\n            return layout.GetILayout()\n        }\n        getAllLayouts() {\n            return runtime.GetLayoutManager().GetAllLayouts().map(layout => layout.GetILayout())\n        }\n        goToLayout(nameOrIndex) {\n            const layoutManager = runtime.GetLayoutManager();\n            let layout = null;\n            if (typeof nameOrIndex === "number" || typeof nameOrIndex === "string")\n                layout = layoutManager.GetLayout(nameOrIndex);\n            else\n                throw new TypeError("expected string or number");\n            if (!layout)\n                throw new Error("invalid layout");\n            if (layoutManager.IsPendingChangeMainLayout())\n                return;\n            layoutManager.ChangeMainLayout(layout)\n        }\n        get keyboard() {\n            const ret = runtime._GetCommonScriptInterfaces().keyboard;\n            if (!ret)\n                throw new Error("runtime.keyboard used but Keyboard object missing - add it to your project first");\n            return ret\n        }\n        get mouse() {\n            const ret = runtime._GetCommonScriptInterfaces().mouse;\n            if (!ret)\n                throw new Error("runtime.mouse used but Mouse object missing - add it to your project first");\n            return ret\n        }\n        get touch() {\n            const ret = runtime._GetCommonScriptInterfaces().touch;\n            if (!ret)\n                throw new Error("runtime.touch used but Touch object missing - add it to your project first");\n            return ret\n        }\n        invokeDownload(url, filename) {\n            C3X.RequireString(url);\n            C3X.RequireString(filename);\n            runtime.InvokeDownload(url, filename)\n        }\n        getInstanceByUid(uid) {\n            C3X.RequireFiniteNumber(uid);\n            const ret = runtime.GetInstanceByUID(uid);\n            return ret ? ret.GetInterfaceClass() : null\n        }\n        sortZOrder(iterable, callback) {\n            C3X.RequireFunction(callback);\n            const layout = runtime.GetCurrentLayout();\n            for (const iinst of iterable) {\n                const inst = runtime._UnwrapIWorldInstance(iinst);\n                const wi = inst.GetWorldInfo();\n                tempZOrderList.push([wi.GetLayer().GetIndex(), wi.GetZIndex()]);\n                tempInstances.push(inst)\n            }\n            if (tempZOrderList.length === 0)\n                return;\n            tempZOrderList.sort(SortZOrderList);\n            tempInstances.sort( (a, b) => callback(a.GetInterfaceClass(), b.GetInterfaceClass()));\n            let anyChanged = false;\n            for (let i = 0, len = tempZOrderList.length; i < len; ++i) {\n                const inst = tempInstances[i];\n                const layer = layout.GetLayerByIndex(tempZOrderList[i][0]);\n                const toZ = tempZOrderList[i][1];\n                const layerInstances = layer._GetInstances();\n                if (layerInstances[toZ] !== inst) {\n                    layerInstances[toZ] = inst;\n                    inst.GetWorldInfo()._SetLayer(layer);\n                    layer.SetZIndicesChanged();\n                    anyChanged = true\n                }\n            }\n            if (anyChanged)\n                runtime.UpdateRender();\n            C3.clearArray(tempZOrderList);\n            C3.clearArray(tempInstances)\n        }\n        alert(message) {\n            return runtime.PostComponentMessageToDOMAsync("runtime", "alert", {\n                "message": message + (runtime.IsInWorker() ? " [via Web Worker]" : "")\n            })\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/IAssetManager.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    let assetManager = null;\n    self.IAssetManager = class IAssetManager {\n        constructor(assetManager_) {\n            assetManager = assetManager_;\n            Object.defineProperties(this, {\n                isWebMOpusSupported: {\n                    value: assetManager.IsAudioFormatSupported("audio\/webm; codecs=opus"),\n                    writable: false\n                }\n            })\n        }\n        fetchText(url) {\n            return assetManager.FetchText(url)\n        }\n        fetchJson(url) {\n            return assetManager.FetchJson(url)\n        }\n        fetchBlob(url) {\n            return assetManager.FetchBlob(url)\n        }\n        fetchArrayBuffer(url) {\n            return assetManager.FetchArrayBuffer(url)\n        }\n        getProjectFileUrl(url) {\n            return assetManager.GetProjectFileUrl(url)\n        }\n        getMediaFileUrl(url) {\n            if (C3.IsRelativeURL(url))\n                url = url.toLowerCase();\n            return assetManager.GetMediaFileUrl(url, assetManager.GetMediaSubfolder())\n        }\n        get mediaFolder() {\n            return assetManager.GetMediaSubfolder()\n        }\n        async decodeWebMOpus(audioContext, arrayBuffer) {\n            if (this.isWebMOpusSupported)\n                throw new Error("decodeWebMOpus(): not supported because WebM Opus is supported by the platform");\n            const decodedArrayBuffer = await assetManager.GetRuntime()._WasmDecodeWebMOpus(arrayBuffer);\n            const decodedFloats = new Float32Array(decodedArrayBuffer);\n            const audioBuffer = audioContext["createBuffer"](1, decodedFloats.length, 48E3);\n            const channelBuffer = audioBuffer["getChannelData"](0);\n            channelBuffer.set(decodedFloats);\n            return audioBuffer\n        }\n        loadScripts(...urls) {\n            return assetManager.LoadScripts(...urls)\n        }\n        compileWebAssembly(url) {\n            return assetManager.CompileWebAssembly(url)\n        }\n        loadStyleSheet(url) {\n            return assetManager.LoadStyleSheet(url)\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/IStorage.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    self.IStorage = class IStorage {\n        constructor(runtime) {\n            this._storage = runtime._GetProjectStorage()\n        }\n        getItem(key) {\n            C3X.RequireString(key);\n            return this._storage.getItem(key)\n        }\n        setItem(key, value) {\n            C3X.RequireString(key);\n            return this._storage.setItem(key, value)\n        }\n        removeItem(key) {\n            C3X.RequireString(key);\n            return this._storage.removeItem(key)\n        }\n        clear() {\n            return this._storage.clear()\n        }\n        keys() {\n            return this._storage.keys()\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/IObjectClass.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    const map = new WeakMap;\n    self.IObjectClass = class IObjectClass {\n        constructor(objectClass) {\n            map.set(this, objectClass);\n            Object.defineProperties(this, {\n                name: {\n                    value: objectClass.GetName(),\n                    writable: false\n                }\n            });\n            objectClass.GetRuntime()._MapScriptInterface(this, objectClass)\n        }\n        addEventListener(type, func) {\n            C3X.RequireString(type);\n            C3X.RequireFunction(func);\n            map.get(this).UserScriptDispatcher().addEventListener(type, func)\n        }\n        removeEventListener(type, func) {\n            C3X.RequireString(type);\n            C3X.RequireFunction(func);\n            map.get(this).UserScriptDispatcher().removeEventListener(type, func)\n        }\n        getAllInstances() {\n            return [...this.instances()]\n        }\n        getFirstInstance() {\n            return C3.first(this.instances())\n        }\n        getPickedInstances() {\n            return [...this.pickedInstances()]\n        }\n        getFirstPickedInstance() {\n            return C3.first(this.pickedInstances())\n        }\n        *instances() {\n            for (const inst of map.get(this).instancesIncludingPendingCreate())\n                yield inst.GetInterfaceClass()\n        }\n        *pickedInstances() {\n            for (const inst of map.get(this).GetCurrentSol().GetInstances())\n                yield inst.GetInterfaceClass()\n        }\n        setInstanceClass(Class) {\n            C3X.RequireFunction(Class);\n            const objectClass = map.get(this);\n            if (objectClass.GetInstanceCount() > 0)\n                throw new Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");\n            map.get(this)._SetUserScriptInstanceClass(Class)\n        }\n        createInstance(layerNameOrIndex, x, y, createHierarchy, template) {\n            C3X.RequireNumber(x);\n            C3X.RequireNumber(y);\n            if (typeof layerNameOrIndex !== "number" && typeof layerNameOrIndex !== "string")\n                throw new TypeError("invalid layer parameter");\n            const objectClass = map.get(this);\n            const runtime = objectClass.GetRuntime();\n            const layer = runtime.GetMainRunningLayout().GetLayer(layerNameOrIndex);\n            if (!layer)\n                throw new Error("invalid layer");\n            const inst = runtime.CreateInstance(objectClass, layer, x, y, createHierarchy, template);\n            if (createHierarchy)\n                layer.SortAndAddInstancesByZIndex(inst);\n            const eventSheetManager = runtime.GetEventSheetManager();\n            eventSheetManager.BlockFlushingInstances(true);\n            inst._TriggerOnCreatedOnSelfAndRelated();\n            eventSheetManager.BlockFlushingInstances(false);\n            if (!eventSheetManager.IsInEventEngine())\n                runtime.FlushPendingInstances();\n            return inst.GetInterfaceClass()\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/ILayout.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    const map = new WeakMap;\n    self.ILayout = class ILayout {\n        constructor(layout) {\n            map.set(this, layout);\n            const effectInstanceArr = [];\n            const effectList = layout.GetEffectList();\n            const effectCount = effectList.GetAllEffectTypes().length;\n            for (let i = 0; i < effectCount; ++i)\n                effectInstanceArr.push(new self.IEffectInstance(effectList,i));\n            Object.defineProperties(this, {\n                name: {\n                    value: layout.GetName(),\n                    writable: false\n                },\n                index: {\n                    value: layout.GetIndex(),\n                    writable: false\n                },\n                effects: {\n                    value: effectInstanceArr,\n                    writable: false\n                }\n            })\n        }\n        addEventListener(type, func) {\n            C3X.RequireString(type);\n            C3X.RequireFunction(func);\n            map.get(this).UserScriptDispatcher().addEventListener(type, func)\n        }\n        removeEventListener(type, func) {\n            C3X.RequireString(type);\n            C3X.RequireFunction(func);\n            map.get(this).UserScriptDispatcher().removeEventListener(type, func)\n        }\n        get width() {\n            return map.get(this).GetWidth()\n        }\n        set width(w) {\n            map.get(this).SetWidth(w)\n        }\n        get height() {\n            return map.get(this).GetHeight()\n        }\n        set height(h) {\n            map.get(this).SetHeight(h)\n        }\n        set scale(s) {\n            C3X.RequireFiniteNumber(s);\n            map.get(this).SetScale(s)\n        }\n        get scale() {\n            return map.get(this).GetScale()\n        }\n        set angle(a) {\n            C3X.RequireFiniteNumber(a);\n            map.get(this).SetAngle(a)\n        }\n        get angle() {\n            return map.get(this).GetAngle()\n        }\n        set scrollX(x) {\n            C3X.RequireNumber(x);\n            map.get(this).SetScrollX(x)\n        }\n        get scrollX() {\n            return map.get(this).GetScrollX()\n        }\n        set scrollY(y) {\n            C3X.RequireNumber(y);\n            map.get(this).SetScrollY(y)\n        }\n        get scrollY() {\n            return map.get(this).GetScrollY()\n        }\n        scrollTo(x, y) {\n            C3X.RequireNumber(x);\n            C3X.RequireNumber(y);\n            const layout = map.get(this);\n            layout.SetScrollX(x);\n            layout.SetScrollY(y)\n        }\n        getLayer(nameOrIndex) {\n            const layout = map.get(this);\n            let layer = null;\n            if (typeof nameOrIndex === "number" || typeof nameOrIndex === "string")\n                layer = layout.GetLayer(nameOrIndex);\n            else\n                throw new TypeError("expected string or number");\n            if (!layer)\n                return null;\n            return layer.GetILayer()\n        }\n        getAllLayers() {\n            return map.get(this).GetLayers().map(layer => layer.GetILayer())\n        }\n        *allLayers() {\n            for (const layer of map.get(this).allLayers())\n                yield layer.GetILayer()\n        }\n        setVanishingPoint(vpX, vpY) {\n            C3X.RequireFiniteNumber(vpX);\n            C3X.RequireFiniteNumber(vpY);\n            map.get(this).SetVanishingPointXY(vpX, vpY)\n        }\n        getVanishingPoint() {\n            return map.get(this)._GetVanishingPoint()\n        }\n        set projection(p) {\n            C3X.RequireString(p);\n            const layout = map.get(this);\n            if (p === "perspective")\n                layout.SetPerspectiveProjection();\n            else if (p === "orthographic")\n                layout.SetOrthographicProjection();\n            else\n                throw new Error("invalid projection");\n        }\n        get projection() {\n            if (map.get(this).IsOrthographicProjection())\n                return "orthographic";\n            else\n                return "perspective"\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/ILayer.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    const map = new WeakMap;\n    const BLEND_MODE_TO_INDEX = new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]]);\n    const INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map(a => [a[1], a[0]]));\n    const tempColor = C3.New(C3.Color);\n    self.ILayer = class ILayer {\n        constructor(layer) {\n            map.set(this, layer);\n            const effectInstanceArr = [];\n            const effectList = layer.GetEffectList();\n            const effectCount = effectList.GetAllEffectTypes().length;\n            for (let i = 0; i < effectCount; ++i)\n                effectInstanceArr.push(new self.IEffectInstance(effectList,i));\n            Object.defineProperties(this, {\n                name: {\n                    value: layer.GetName(),\n                    writable: false\n                },\n                index: {\n                    value: layer.GetIndex(),\n                    writable: false\n                },\n                layout: {\n                    value: layer.GetLayout().GetILayout(),\n                    writable: false\n                },\n                effects: {\n                    value: effectInstanceArr,\n                    writable: false\n                }\n            })\n        }\n        static _Unwrap(ilayer) {\n            return map.get(ilayer)\n        }\n        get parentLayer() {\n            const parent = map.get(this).GetParentLayer();\n            return parent ? parent.GetILayer() : null\n        }\n        *parentLayers() {\n            for (const parent of map.get(this).parentLayers())\n                yield parent.GetILayer()\n        }\n        *subLayers() {\n            for (const layer of map.get(this).GetSubLayers())\n                yield layer.GetILayer()\n        }\n        *allSubLayers() {\n            for (const subLayer of map.get(this).GetSubLayers())\n                for (const layer of subLayer.selfAndAllSubLayers())\n                    yield layer.GetILayer()\n        }\n        get isVisible() {\n            return map.get(this)._IsVisibleFlagSet()\n        }\n        set isVisible(v) {\n            map.get(this).SetVisible(v)\n        }\n        get isSelfAndParentsVisible() {\n            return map.get(this).IsVisible()\n        }\n        get isInteractive() {\n            return map.get(this).IsInteractive()\n        }\n        set isInteractive(i) {\n            map.get(this).SetInteractive(i)\n        }\n        get isSelfAndParentsInteractive() {\n            return map.get(this).IsSelfAndParentsInteractive()\n        }\n        get opacity() {\n            return map.get(this).GetOpacity()\n        }\n        set opacity(o) {\n            o = C3.clamp(+o, 0, 1);\n            if (isNaN(o))\n                return;\n            map.get(this).SetOpacity(o)\n        }\n        set scale(s) {\n            C3X.RequireFiniteNumber(s);\n            map.get(this).SetOwnScale(s)\n        }\n        get scale() {\n            return map.get(this).GetOwnScale()\n        }\n        set scaleRate(r) {\n            C3X.RequireFiniteNumber(r);\n            map.get(this).SetScaleRate(r)\n        }\n        get scaleRate() {\n            return map.get(this).GetScaleRate()\n        }\n        set angle(a) {\n            C3X.RequireFiniteNumber(a);\n            map.get(this).SetAngle(a)\n        }\n        get angle() {\n            return map.get(this).GetOwnAngle()\n        }\n        set parallaxX(p) {\n            C3X.RequireFiniteNumber(p);\n            map.get(this).SetParallaxX(p)\n        }\n        get parallaxX() {\n            return map.get(this).GetParallaxX()\n        }\n        set parallaxY(p) {\n            C3X.RequireFiniteNumber(p);\n            map.get(this).SetParallaxY(p)\n        }\n        get parallaxY() {\n            return map.get(this).GetParallaxY()\n        }\n        set zElevation(z) {\n            C3X.RequireFiniteNumber(z);\n            map.get(this).SetZElevation(z)\n        }\n        get zElevation() {\n            return map.get(this).GetZElevation()\n        }\n        set isTransparent(t) {\n            map.get(this).SetTransparent(t)\n        }\n        get isTransparent() {\n            return map.get(this).IsTransparent()\n        }\n        set isForceOwnTexture(f) {\n            map.get(this).SetForceOwnTexture(f)\n        }\n        get isForceOwnTexture() {\n            return map.get(this).IsForceOwnTexture()\n        }\n        set blendMode(bm) {\n            C3X.RequireString(bm);\n            const index = BLEND_MODE_TO_INDEX.get(bm);\n            if (typeof index !== "number")\n                throw new Error("invalid blend mode");\n            map.get(this).SetBlendMode(index)\n        }\n        get blendMode() {\n            return INDEX_TO_BLEND_MODE.get(map.get(this).GetBlendMode())\n        }\n        set backgroundColor(arr) {\n            C3X.RequireArray(arr);\n            if (arr.length < 3)\n                throw new Error("expected 3 elements");\n            tempColor.setRgb(arr[0], arr[1], arr[2]);\n            const layer = map.get(this);\n            const bgColor = layer.GetBackgroundColor();\n            if (bgColor.equalsIgnoringAlpha(tempColor))\n                return;\n            bgColor.copyRgb(tempColor);\n            layer.GetRuntime().UpdateRender()\n        }\n        get backgroundColor() {\n            const c = map.get(this).GetBackgroundColor();\n            return [c.getR(), c.getG(), c.getB()]\n        }\n        set scrollX(x) {\n            C3X.RequireNumber(x);\n            const layer = map.get(this);\n            layer.SetOwnScrollPositionEnabled(true);\n            layer.SetScrollX(x)\n        }\n        get scrollX() {\n            return map.get(this).GetScrollX()\n        }\n        set scrollY(y) {\n            C3X.RequireNumber(y);\n            const layer = map.get(this);\n            layer.SetOwnScrollPositionEnabled(true);\n            layer.SetScrollY(y)\n        }\n        get scrollY() {\n            return map.get(this).GetScrollY()\n        }\n        scrollTo(x, y) {\n            C3X.RequireNumber(x);\n            C3X.RequireNumber(y);\n            const layer = map.get(this);\n            layer.SetOwnScrollPositionEnabled(true);\n            layer.SetScrollX(x);\n            layer.SetScrollY(y)\n        }\n        restoreScrollPosition() {\n            map.get(this).SetOwnScrollPositionEnabled(false)\n        }\n        getViewport() {\n            return map.get(this).GetViewport().toDOMRect()\n        }\n        cssPxToLayer(clientX, clientY, z=0) {\n            C3X.RequireNumber(clientX);\n            C3X.RequireNumber(clientY);\n            C3X.RequireNumber(z);\n            const layer = map.get(this);\n            const runtime = layer.GetRuntime();\n            return layer.CanvasCssToLayer(clientX - runtime.GetCanvasClientX(), clientY - runtime.GetCanvasClientY(), z)\n        }\n        layerToCssPx(layerX, layerY, z=0) {\n            C3X.RequireNumber(layerX);\n            C3X.RequireNumber(layerY);\n            C3X.RequireNumber(z);\n            const layer = map.get(this);\n            const runtime = layer.GetRuntime();\n            const [clientX,clientY] = layer.LayerToCanvasCss(layerX, layerY, z);\n            return [clientX + runtime.GetCanvasClientX(), clientY + runtime.GetCanvasClientY()]\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/IInstance.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    const map = new WeakMap;\n    const dispatchers = new WeakMap;\n    function GetDispatcher(iinst) {\n        let dispatcher = dispatchers.get(iinst);\n        if (dispatcher)\n            return dispatcher;\n        dispatcher = C3.New(C3.Event.Dispatcher);\n        dispatchers.set(iinst, dispatcher);\n        return dispatcher\n    }\n    let initInst = null;\n    self.IInstance = class IInstance {\n        constructor() {\n            map.set(this, initInst);\n            const descriptors = {\n                runtime: {\n                    value: initInst.GetRuntime().GetIRuntime(),\n                    writable: false\n                },\n                objectType: {\n                    value: initInst.GetObjectClass().GetIObjectClass(),\n                    writable: false\n                },\n                uid: {\n                    value: initInst.GetUID(),\n                    writable: false\n                }\n            };\n            initInst._GetInstVarsScriptDescriptor(descriptors);\n            initInst._GetBehaviorsScriptDescriptor(descriptors);\n            Object.defineProperties(this, descriptors);\n            initInst.GetRuntime()._MapScriptInterface(this, initInst)\n        }\n        static _Init(inst) {\n            initInst = inst\n        }\n        static _GetInitInst() {\n            return initInst\n        }\n        _Release() {\n            const dispatcher = dispatchers.get(this);\n            if (dispatcher) {\n                dispatcher.Release();\n                dispatchers.delete(this)\n            }\n            map.delete(this)\n        }\n        addEventListener(type, func, capture) {\n            C3X.RequireString(type);\n            C3X.RequireFunction(func);\n            GetDispatcher(this).addEventListener(type, func, capture)\n        }\n        removeEventListener(type, func, capture) {\n            C3X.RequireString(type);\n            C3X.RequireFunction(func);\n            GetDispatcher(this).removeEventListener(type, func, capture)\n        }\n        dispatchEvent(e) {\n            GetDispatcher(this).dispatchEvent(e)\n        }\n        destroy() {\n            const inst = map.get(this);\n            const runtime = inst.GetRuntime();\n            runtime.DestroyInstance(inst);\n            if (!runtime.GetEventSheetManager().IsInEventEngine())\n                runtime.FlushPendingInstances()\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/IWorldInstance.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    const IInstance = self.IInstance;\n    const ILayer = self.ILayer;\n    const map = new WeakMap;\n    const BLEND_MODE_TO_INDEX = new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]]);\n    const INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map(a => [a[1], a[0]]));\n    const tempColor = C3.New(C3.Color);\n    self.IWorldInstance = class IWorldInstance extends IInstance {\n        constructor() {\n            super();\n            const inst = IInstance._GetInitInst();\n            map.set(this, inst);\n            const effectInstanceArr = [];\n            const wi = inst.GetWorldInfo();\n            const instanceEffectList = wi.GetInstanceEffectList();\n            if (instanceEffectList) {\n                const effectCount = wi.GetObjectClass().GetEffectList().GetAllEffectTypes().length;\n                for (let i = 0; i < effectCount; ++i)\n                    effectInstanceArr.push(new self.IEffectInstance(instanceEffectList,i))\n            }\n            const descriptors = {\n                effects: {\n                    value: effectInstanceArr,\n                    writable: false\n                }\n            };\n            Object.defineProperties(this, descriptors)\n        }\n        get layout() {\n            return map.get(this).GetWorldInfo().GetLayout().GetILayout()\n        }\n        get layer() {\n            return map.get(this).GetWorldInfo().GetLayer().GetILayer()\n        }\n        get x() {\n            return map.get(this).GetWorldInfo().GetX()\n        }\n        set x(v) {\n            v = +v;\n            const wi = map.get(this).GetWorldInfo();\n            if (isNaN(v) || wi.GetX() === v)\n                return;\n            wi.SetX(v);\n            wi.SetBboxChanged()\n        }\n        get y() {\n            return map.get(this).GetWorldInfo().GetY()\n        }\n        set y(v) {\n            v = +v;\n            const wi = map.get(this).GetWorldInfo();\n            if (isNaN(v) || wi.GetY() === v)\n                return;\n            wi.SetY(v);\n            wi.SetBboxChanged()\n        }\n        get zElevation() {\n            return map.get(this).GetWorldInfo().GetZElevation()\n        }\n        set zElevation(z) {\n            z = +z;\n            const inst = map.get(this);\n            const wi = inst.GetWorldInfo();\n            if (isNaN(z) || wi.GetZElevation() === z)\n                return;\n            wi.SetZElevation(z);\n            inst.GetRuntime().UpdateRender()\n        }\n        get totalZElevation() {\n            return map.get(this).GetWorldInfo().GetTotalZElevation()\n        }\n        get width() {\n            return map.get(this).GetWorldInfo().GetWidth()\n        }\n        set width(w) {\n            w = +w;\n            const wi = map.get(this).GetWorldInfo();\n            if (isNaN(w) || wi.GetWidth() === w)\n                return;\n            wi.SetWidth(w);\n            wi.SetBboxChanged()\n        }\n        get height() {\n            return map.get(this).GetWorldInfo().GetHeight()\n        }\n        set height(h) {\n            h = +h;\n            const wi = map.get(this).GetWorldInfo();\n            if (isNaN(h) || wi.GetHeight() === h)\n                return;\n            wi.SetHeight(h);\n            wi.SetBboxChanged()\n        }\n        get angle() {\n            return map.get(this).GetWorldInfo().GetAngle()\n        }\n        set angle(a) {\n            a = C3.clampAngle(+a);\n            const wi = map.get(this).GetWorldInfo();\n            if (isNaN(a) || wi.GetAngle() === a)\n                return;\n            wi.SetAngle(a);\n            wi.SetBboxChanged()\n        }\n        get angleDegrees() {\n            return C3.toDegrees(this.angle)\n        }\n        set angleDegrees(a) {\n            this.angle = C3.toRadians(a)\n        }\n        getBoundingBox() {\n            return map.get(this).GetWorldInfo().GetBoundingBox().toDOMRect()\n        }\n        getBoundingQuad() {\n            return map.get(this).GetWorldInfo().GetBoundingQuad().toDOMQuad()\n        }\n        get isVisible() {\n            return map.get(this).GetWorldInfo().IsVisible()\n        }\n        set isVisible(v) {\n            v = !!v;\n            const inst = map.get(this);\n            const wi = inst.GetWorldInfo();\n            if (wi.IsVisible() === v)\n                return;\n            wi.SetVisible(v);\n            inst.GetRuntime().UpdateRender()\n        }\n        get opacity() {\n            return map.get(this).GetWorldInfo().GetOpacity()\n        }\n        set opacity(o) {\n            o = C3.clamp(+o, 0, 1);\n            const inst = map.get(this);\n            const wi = inst.GetWorldInfo();\n            if (isNaN(o) || wi.GetOpacity() === o)\n                return;\n            wi.SetOpacity(o);\n            inst.GetRuntime().UpdateRender()\n        }\n        set colorRgb(arr) {\n            C3X.RequireArray(arr);\n            if (arr.length < 3)\n                throw new Error("expected 3 elements");\n            tempColor.setRgb(arr[0], arr[1], arr[2]);\n            const inst = map.get(this);\n            const wi = inst.GetWorldInfo();\n            if (wi.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor))\n                return;\n            wi.SetUnpremultipliedColor(tempColor);\n            inst.GetRuntime().UpdateRender()\n        }\n        get colorRgb() {\n            const c = map.get(this).GetWorldInfo().GetUnpremultipliedColor();\n            return [c.getR(), c.getG(), c.getB()]\n        }\n        set blendMode(bm) {\n            C3X.RequireString(bm);\n            const index = BLEND_MODE_TO_INDEX.get(bm);\n            if (typeof index !== "number")\n                throw new Error("invalid blend mode");\n            const inst = map.get(this);\n            const wi = inst.GetWorldInfo();\n            wi.SetBlendMode(index);\n            inst.GetRuntime().UpdateRender()\n        }\n        get blendMode() {\n            return INDEX_TO_BLEND_MODE.get(map.get(this).GetWorldInfo().GetBlendMode())\n        }\n        moveToTop() {\n            map.get(this).GetWorldInfo().ZOrderMoveToTop()\n        }\n        moveToBottom() {\n            map.get(this).GetWorldInfo().ZOrderMoveToBottom()\n        }\n        moveToLayer(ilayer) {\n            C3X.RequireInstanceOf(ilayer, ILayer);\n            const layer = ILayer._Unwrap(ilayer);\n            if (!layer)\n                throw new Error("invalid layer");\n            map.get(this).GetWorldInfo().ZOrderMoveToLayer(layer)\n        }\n        moveAdjacentToInstance(other, isAfter) {\n            C3X.RequireInstanceOf(other, IWorldInstance);\n            map.get(this).GetWorldInfo().ZOrderMoveAdjacentToInstance(map.get(other), isAfter)\n        }\n        get zIndex() {\n            return map.get(this).GetWorldInfo().GetZIndex()\n        }\n        containsPoint(x, y) {\n            C3X.RequireNumber(x);\n            C3X.RequireNumber(y);\n            return map.get(this).GetWorldInfo().ContainsPoint(+x, +y)\n        }\n        testOverlap(worldInstance) {\n            C3X.RequireInstanceOf(worldInstance, IWorldInstance);\n            const a = map.get(this);\n            const b = map.get(worldInstance);\n            return a.GetRuntime().GetCollisionEngine().TestOverlap(a, b)\n        }\n        testOverlapSolid() {\n            const inst = map.get(this);\n            const overlapInst = inst.GetRuntime().GetCollisionEngine().TestOverlapSolid(inst);\n            return overlapInst ? overlapInst.GetInterfaceClass() : null\n        }\n        getParent() {\n            const parent = map.get(this).GetParent();\n            return parent ? parent.GetInterfaceClass() : null\n        }\n        getTopParent() {\n            const parent = map.get(this).GetTopParent();\n            return parent ? parent.GetInterfaceClass() : null\n        }\n        *parents() {\n            for (const parent of map.get(this).parents())\n                yield parent.GetInterfaceClass()\n        }\n        getChildCount() {\n            return map.get(this).GetChildCount()\n        }\n        getChildAt(index) {\n            const child = map.get(this).GetChildAt(index);\n            return child ? child.GetInterfaceClass() : null\n        }\n        *children() {\n            for (const child of map.get(this).children())\n                yield child.GetInterfaceClass()\n        }\n        *allChildren() {\n            for (const child of map.get(this).allChildren())\n                yield child.GetInterfaceClass()\n        }\n        addChild(ichild, opts) {\n            C3X.RequireInstanceOf(ichild, IWorldInstance);\n            C3X.RequireOptionalObject(opts);\n            if (!opts)\n                opts = {};\n            const inst = map.get(this);\n            const child = map.get(ichild);\n            inst.AddChild(child, opts)\n        }\n        removeChild(ichild) {\n            C3X.RequireInstanceOf(ichild, IWorldInstance);\n            const inst = map.get(this);\n            const child = map.get(ichild);\n            inst.RemoveChild(child)\n        }\n        removeFromParent() {\n            const inst = map.get(this);\n            if (!inst.HasParent())\n                return;\n            const parent = inst.GetParent();\n            parent.RemoveChild(inst)\n        }\n        createMesh(hsize, vsize) {\n            C3X.RequireFiniteNumber(hsize);\n            C3X.RequireFiniteNumber(vsize);\n            map.get(this).GetWorldInfo().CreateMesh(hsize, vsize)\n        }\n        releaseMesh() {\n            const wi = map.get(this).GetWorldInfo();\n            wi.ReleaseMesh();\n            wi.SetBboxChanged()\n        }\n        setMeshPoint(col, row, opts) {\n            C3X.RequireFiniteNumber(col);\n            C3X.RequireFiniteNumber(row);\n            C3X.RequireObject(opts);\n            const wi = map.get(this).GetWorldInfo();\n            if (wi.SetMeshPoint(col, row, opts))\n                wi.SetBboxChanged()\n        }\n        getMeshSize() {\n            const wi = map.get(this).GetWorldInfo();\n            if (!wi.HasMesh())\n                return [0, 0];\n            const sourceMesh = wi.GetSourceMesh();\n            return [sourceMesh.GetHSize(), sourceMesh.GetVSize()]\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/IDOMInstance.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    const map = new WeakMap;\n    self.IDOMInstance = class IDOMInstance extends self.IWorldInstance {\n        constructor() {\n            super();\n            map.set(this, self.IInstance._GetInitInst())\n        }\n        getElement() {\n            return map.get(this).GetSdkInstance()._GetElementInDOMMode()\n        }\n        focus() {\n            map.get(this).GetSdkInstance().FocusElement()\n        }\n        blur() {\n            map.get(this).GetSdkInstance().BlurElement()\n        }\n        setCssStyle(prop, val) {\n            C3X.RequireString(prop);\n            map.get(this).GetSdkInstance().SetElementCSSStyle(prop, val)\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/IBehaviorInstance.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    const map = new WeakMap;\n    const dispatchers = new WeakMap;\n    function GetDispatcher(ibehinst) {\n        let dispatcher = dispatchers.get(ibehinst);\n        if (dispatcher)\n            return dispatcher;\n        dispatcher = C3.New(C3.Event.Dispatcher);\n        dispatchers.set(ibehinst, dispatcher);\n        return dispatcher\n    }\n    let initBehInst = null;\n    self.IBehaviorInstance = class IBehaviorInstance {\n        constructor() {\n            map.set(this, initBehInst);\n            const descriptors = {\n                runtime: {\n                    value: initBehInst.GetRuntime().GetIRuntime(),\n                    writable: false\n                },\n                behavior: {\n                    value: initBehInst.GetBehavior().GetIBehavior(),\n                    writable: false\n                }\n            };\n            Object.defineProperties(this, descriptors)\n        }\n        static _Init(behInst) {\n            initBehInst = behInst\n        }\n        static _GetInitInst() {\n            return initBehInst\n        }\n        get instance() {\n            return map.get(this).GetObjectInstance().GetInterfaceClass()\n        }\n        _Release() {\n            const dispatcher = dispatchers.get(this);\n            if (dispatcher) {\n                dispatcher.Release();\n                dispatchers.delete(this)\n            }\n            map.delete(this)\n        }\n        addEventListener(type, func, capture) {\n            C3X.RequireString(type);\n            C3X.RequireFunction(func);\n            GetDispatcher(this).addEventListener(type, func, capture)\n        }\n        removeEventListener(type, func, capture) {\n            C3X.RequireString(type);\n            C3X.RequireFunction(func);\n            GetDispatcher(this).removeEventListener(type, func, capture)\n        }\n        dispatchEvent(e) {\n            GetDispatcher(this).dispatchEvent(e)\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/IBehavior.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    const map = new WeakMap;\n    self.IBehavior = class IBehavior {\n        constructor(behavior) {\n            map.set(this, behavior);\n            const descriptors = {\n                runtime: {\n                    value: behavior.GetRuntime().GetIRuntime(),\n                    writable: false\n                }\n            };\n            Object.defineProperties(this, descriptors)\n        }\n        getAllInstances() {\n            return map.get(this).GetInstances().map(inst => inst.GetInterfaceClass())\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/IEffectInstance.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    const map = new WeakMap;\n    const tempColor = C3.New(C3.Color);\n    self.IEffectInstance = class IEffectInstance {\n        constructor(effectList, index) {\n            map.set(this, effectList);\n            const descriptors = {\n                index: {\n                    value: index,\n                    writable: false\n                }\n            };\n            Object.defineProperties(this, descriptors)\n        }\n        get name() {\n            const effectTypes = map.get(this).GetAllEffectTypes();\n            return effectTypes[this.index].GetName()\n        }\n        get isActive() {\n            return map.get(this).IsEffectIndexActive(this.index)\n        }\n        set isActive(a) {\n            a = !!a;\n            const fxList = map.get(this);\n            if (fxList.IsEffectIndexActive(this.index) === a)\n                return;\n            fxList.SetEffectIndexActive(this.index, a);\n            fxList.UpdateActiveEffects();\n            fxList.GetRuntime().UpdateRender()\n        }\n        setParameter(i, v) {\n            C3X.RequireFiniteNumber(i);\n            i = Math.floor(+i);\n            const fxList = map.get(this);\n            const oldValue = fxList.GetEffectParameter(this.index, i);\n            if (oldValue === null)\n                throw new RangeError("invalid index");\n            if (oldValue instanceof C3.Color) {\n                if (!Array.isArray(v) || v.length < 3)\n                    throw new TypeError("expected array with 3 elements");\n                tempColor.setRgb(v[0], v[1], v[2]);\n                v = tempColor\n            } else if (typeof v !== "number")\n                throw new TypeError("expected number");\n            const didChange = fxList.SetEffectParameter(this.index, i, v);\n            if (didChange && fxList.IsEffectIndexActive(this.index))\n                fxList.GetRuntime().UpdateRender()\n        }\n        getParameter(i) {\n            C3X.RequireFiniteNumber(i);\n            i = Math.floor(+i);\n            const fxList = map.get(this);\n            const ret = fxList.GetEffectParameter(this.index, i);\n            if (ret === null)\n                throw new RangeError("invalid index");\n            if (ret instanceof C3.Color)\n                return [ret.getR(), ret.getG(), ret.getB()];\n            else\n                return ret\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/IAnimation.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    const map = new WeakMap;\n    self.IAnimation = class IAnimation {\n        constructor(animationInfo) {\n            map.set(this, animationInfo);\n            Object.defineProperties(this, {\n                name: {\n                    value: animationInfo.GetName(),\n                    writable: false\n                },\n                speed: {\n                    value: animationInfo.GetSpeed(),\n                    writable: false\n                },\n                isLooping: {\n                    value: animationInfo.IsLooping(),\n                    writable: false\n                },\n                repeatCount: {\n                    value: animationInfo.GetRepeatCount(),\n                    writable: false\n                },\n                repeatTo: {\n                    value: animationInfo.GetRepeatTo(),\n                    writable: false\n                },\n                isPingPong: {\n                    value: animationInfo.IsPingPong(),\n                    writable: false\n                },\n                frameCount: {\n                    value: animationInfo.GetFrameCount(),\n                    writable: false\n                }\n            })\n        }\n        getFrames() {\n            return map.get(this).GetFrames().map(f => f.GetIAnimationFrame())\n        }\n        *frames() {\n            for (const f of map.get(this).GetFrames())\n                yield f.GetIAnimationFrame()\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/IImageInfo.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    const map = new WeakMap;\n    self.IImageInfo = class IImageInfo {\n        constructor(imageInfo) {\n            map.set(this, imageInfo)\n        }\n        get width() {\n            return map.get(this).GetWidth()\n        }\n        get height() {\n            return map.get(this).GetHeight()\n        }\n    }\n    ;\n\n}\n\n\/\/ interfaces\/IAnimationFrame.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3X = self.C3X;\n    const map = new WeakMap;\n    self.IAnimationFrame = class IAnimationFrame extends self.IImageInfo {\n        constructor(animationFrameInfo) {\n            super(animationFrameInfo.GetImageInfo());\n            map.set(this, animationFrameInfo);\n            Object.defineProperties(this, {\n                duration: {\n                    value: animationFrameInfo.GetDuration(),\n                    writable: false\n                },\n                originX: {\n                    value: animationFrameInfo.GetOriginX(),\n                    writable: false\n                },\n                originY: {\n                    value: animationFrameInfo.GetOriginY(),\n                    writable: false\n                }\n            })\n        }\n    }\n    ;\n\n}\n\n\/\/ assets\/assetManager.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const VALID_LOAD_POLICIES = new Set(["local", "remote"]);\n    const EXT_TO_TYPE = new Map([["mp4", "video\/mp4"], ["webm", "video\/webm"], ["m4a", "audio\/mp4"], ["mp3", "audio\/mpeg"], ["js", "application\/javascript"], ["wasm", "application\/wasm"], ["svg", "image\/svg+xml"], ["html", "text\/html"]]);\n    function GetTypeFromFileExtension(filename) {\n        if (!filename)\n            return "";\n        const parts = filename.split(".");\n        if (parts.length < 2)\n            return "";\n        const ext = parts.at(-1).toLowerCase();\n        return EXT_TO_TYPE.get(ext) || ""\n    }\n    function AddScript(url) {\n        return new Promise( (resolve, reject) => {\n            const elem = document.createElement("script");\n            elem.onload = resolve;\n            elem.onerror = reject;\n            elem.async = false;\n            elem.type = "module";\n            elem.src = url;\n            document.head.appendChild(elem)\n        }\n        )\n    }\n    C3.AssetManager = class AssetManager extends C3.DefendedBase {\n        constructor(runtime, opts) {\n            super();\n            const exportType = opts["exportType"];\n            this._runtime = runtime;\n            this._localUrlBlobs = new Map;\n            this._localBlobUrlCache = new Map;\n            this._localBlobSWUrls = new Map;\n            this._isCordova = exportType === "cordova";\n            this._isiOSCordova = !!opts["isiOSCordova"];\n            this._isFileProtocol = !!opts["isFileProtocol"];\n            this._swClientId = opts["swClientId"];\n            this._supportedAudioFormats = opts["supportedAudioFormats"] || {};\n            this._audioFiles = new Map;\n            this._preloadSounds = false;\n            this._mediaSubfolder = "";\n            this._fontsSubfolder = "";\n            this._iconsSubfolder = "";\n            const isRemoteLoadPolicy = exportType === "html5" || exportType === "scirra-arcade" || exportType === "instant-games";\n            this._defaultLoadPolicy = isRemoteLoadPolicy ? "remote" : "local";\n            this._allAssets = [];\n            this._assetsByUrl = new Map;\n            this._webFonts = [];\n            this._loadPromises = [];\n            this._hasFinishedInitialLoad = false;\n            this._totalAssetSizeToLoad = 0;\n            this._assetSizeLoaded = 0;\n            this._lastLoadProgress = 0;\n            this._hasHadErrorLoading = false;\n            this._loadingRateLimiter = C3.New(C3.RateLimiter, () => this._FireLoadingProgressEvent(), 50);\n            this._promiseThrottle = new C3.PromiseThrottle(Math.max(C3.hardwareConcurrency, 8));\n            const localUrlBlobs = opts["previewImageBlobs"];\n            if (localUrlBlobs) {\n                const projectFileBlobs = opts["previewProjectFileBlobs"];\n                if (projectFileBlobs)\n                    Object.assign(localUrlBlobs, projectFileBlobs);\n                const projectData = opts["projectData"];\n                if (projectData)\n                    localUrlBlobs["data.json"] = projectData;\n                for (const [url,blob] of Object.entries(localUrlBlobs))\n                    this._localUrlBlobs.set(url.toLowerCase(), blob)\n            }\n            const localSWUrlMap = opts["previewProjectFileSWUrls"];\n            if (localSWUrlMap)\n                for (const [srcUrl,destUrl] of Object.entries(localSWUrlMap))\n                    this._localBlobSWUrls.set(srcUrl, destUrl);\n            this._iAssetManager = new self.IAssetManager(this)\n        }\n        Release() {\n            this._localUrlBlobs.clear();\n            for (const url of this._localBlobUrlCache.values())\n                if (url.startsWith("blob:"))\n                    URL.revokeObjectURL(url);\n            this._localBlobUrlCache.clear();\n            for (const asset of this._allAssets)\n                asset.Release();\n            C3.clearArray(this._allAssets);\n            this._assetsByUrl.clear();\n            C3.clearArray(this._loadPromises);\n            this._runtime = null\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        _SetMediaSubfolder(folder) {\n            this._mediaSubfolder = folder\n        }\n        GetMediaSubfolder() {\n            return this._mediaSubfolder\n        }\n        _SetFontsSubfolder(folder) {\n            this._fontsSubfolder = folder\n        }\n        GetFontsSubfolder() {\n            return this._fontsSubfolder\n        }\n        _SetIconsSubfolder(folder) {\n            this._iconsSubfolder = folder\n        }\n        GetIconsSubfolder() {\n            return this._iconsSubfolder\n        }\n        IsFileProtocol() {\n            return this._isFileProtocol\n        }\n        _HasLocalUrlBlob(url) {\n            return this._localUrlBlobs.has(url.toLowerCase())\n        }\n        _GetLocalUrlBlob(url) {\n            return this._localUrlBlobs.get(url.toLowerCase()) || null\n        }\n        GetLocalUrlAsBlobUrl(url) {\n            if (!this._HasLocalUrlBlob(url))\n                return url;\n            const lowerUrl = url.toLowerCase();\n            let ret = this._localBlobUrlCache.get(lowerUrl);\n            if (!ret) {\n                const blob = this._GetLocalUrlBlob(lowerUrl);\n                ret = URL.createObjectURL(blob);\n                this._localBlobUrlCache.set(lowerUrl, ret)\n            }\n            return ret\n        }\n        FetchBlob(url, loadPolicy) {\n            loadPolicy = loadPolicy || this._defaultLoadPolicy;\n            const localBlob = this._GetLocalUrlBlob(url);\n            if (localBlob)\n                return Promise.resolve(localBlob);\n            else if (C3.IsRelativeURL(url)) {\n                const lowerUrl = url.toLowerCase();\n                if (this._isCordova && this._isFileProtocol)\n                    return this.CordovaFetchLocalFileAsBlob(lowerUrl);\n                else if (loadPolicy === "local")\n                    return this._promiseThrottle.Add( () => C3.FetchBlob(lowerUrl));\n                else\n                    return C3.FetchBlob(lowerUrl)\n            } else\n                return C3.FetchBlob(url)\n        }\n        FetchArrayBuffer(url) {\n            const localBlob = this._GetLocalUrlBlob(url);\n            if (localBlob)\n                return C3.BlobToArrayBuffer(localBlob);\n            else if (C3.IsRelativeURL(url)) {\n                const lowerUrl = url.toLowerCase();\n                if (this._isCordova && this._isFileProtocol)\n                    return this.CordovaFetchLocalFileAsArrayBuffer(lowerUrl);\n                else if (this._defaultLoadPolicy === "local")\n                    return this._promiseThrottle.Add( () => C3.FetchArrayBuffer(lowerUrl));\n                else\n                    return C3.FetchArrayBuffer(lowerUrl)\n            } else\n                return C3.FetchArrayBuffer(url)\n        }\n        FetchText(url) {\n            const localBlob = this._GetLocalUrlBlob(url);\n            if (localBlob)\n                return C3.BlobToString(localBlob);\n            else if (C3.IsRelativeURL(url)) {\n                const lowerUrl = url.toLowerCase();\n                if (this._isCordova && this._isFileProtocol)\n                    return this.CordovaFetchLocalFileAsText(lowerUrl);\n                else if (this._defaultLoadPolicy === "local")\n                    return this._promiseThrottle.Add( () => C3.FetchText(lowerUrl));\n                else\n                    return C3.FetchText(lowerUrl)\n            } else\n                return C3.FetchText(url)\n        }\n        async FetchJson(url) {\n            const text = await this.FetchText(url);\n            return JSON.parse(text)\n        }\n        _CordovaFetchLocalFileAs(filename, as_) {\n            return this._runtime.PostComponentMessageToDOMAsync("runtime", "cordova-fetch-local-file", {\n                "filename": filename,\n                "as": as_\n            })\n        }\n        CordovaFetchLocalFileAsText(filename) {\n            return this._CordovaFetchLocalFileAs(filename, "text")\n        }\n        async CordovaFetchLocalFileAsBlob(filename) {\n            const buffer = await this._CordovaFetchLocalFileAs(filename, "buffer");\n            const type = GetTypeFromFileExtension(filename);\n            return new Blob([buffer],{\n                "type": type\n            })\n        }\n        async CordovaFetchLocalFileAsBlobURL(filename) {\n            filename = filename.toLowerCase();\n            let blobUrl = this._localBlobUrlCache.get(filename);\n            if (blobUrl)\n                return blobUrl;\n            const blob = await this.CordovaFetchLocalFileAsBlob(filename);\n            blobUrl = URL.createObjectURL(blob);\n            this._localBlobUrlCache.set(filename, blobUrl);\n            return blobUrl\n        }\n        CordovaFetchLocalFileAsArrayBuffer(filename) {\n            return this._CordovaFetchLocalFileAs(filename, "buffer")\n        }\n        GetMediaFileUrl(filename) {\n            if (this._HasLocalUrlBlob(filename))\n                return this.GetLocalUrlAsBlobUrl(filename);\n            else\n                return this._mediaSubfolder + filename.toLowerCase()\n        }\n        GetProjectFileUrl(url, subfolder="") {\n            if (C3.IsAbsoluteURL(url)) {\n                if (subfolder)\n                    throw new Error("cannot specify subfolder with remote URL");\n                return Promise.resolve(url)\n            } else if (this._HasLocalUrlBlob(url))\n                return Promise.resolve(this.GetLocalUrlAsBlobUrl(url));\n            else if (this._isCordova && this._isFileProtocol)\n                return this.CordovaFetchLocalFileAsBlobURL(subfolder + url);\n            else\n                return Promise.resolve(subfolder + url.toLowerCase())\n        }\n        GetProjectFileIframeUrl(url) {\n            if (C3.IsAbsoluteURL(url))\n                return Promise.resolve(url);\n            else {\n                const queryIndex = url.indexOf("?");\n                const queryStr = queryIndex === -1 ? "" : url.substr(queryIndex);\n                const urlNoSearch = queryIndex === -1 ? url : url.substr(0, queryIndex);\n                if (this._HasLocalUrlBlob(urlNoSearch)) {\n                    let localUrl = this._localBlobSWUrls.get(urlNoSearch) || this.GetLocalUrlAsBlobUrl(urlNoSearch);\n                    if (!localUrl.startsWith("blob:") && this._swClientId) {\n                        const asUrl = new URL(localUrl);\n                        const params = new URLSearchParams(queryStr);\n                        params.set("__c3_client_id", this._swClientId);\n                        asUrl.search = params.toString();\n                        localUrl = asUrl.toString()\n                    }\n                    return Promise.resolve(localUrl)\n                } else if (this._isCordova && this._isFileProtocol)\n                    return this.CordovaFetchLocalFileAsBlobURL(urlNoSearch);\n                else\n                    return Promise.resolve(url.toLowerCase())\n            }\n        }\n        LoadProjectFileUrl(url) {\n            return this.GetProjectFileUrl(url)\n        }\n        LoadImage(opts) {\n            if (opts.loadPolicy && !VALID_LOAD_POLICIES.has(opts.loadPolicy))\n                throw new Error("invalid load policy");\n            let asset = this._assetsByUrl.get(opts.url);\n            if (asset)\n                return asset;\n            asset = C3.New(C3.ImageAsset, this, {\n                url: opts.url,\n                size: opts.size || 0,\n                loadPolicy: opts.loadPolicy || this._defaultLoadPolicy\n            });\n            this._allAssets.push(asset);\n            this._assetsByUrl.set(asset.GetURL(), asset);\n            if (!this._hasFinishedInitialLoad) {\n                this._totalAssetSizeToLoad += asset.GetSize();\n                this._loadPromises.push(asset.Load().then( () => this._AddLoadedSize(asset.GetSize())))\n            }\n            return asset\n        }\n        async WaitForAllToLoad() {\n            try {\n                await Promise.all(this._loadPromises);\n                this._lastLoadProgress = 1\n            } catch (err) {\n                console.error("Error loading: ", err);\n                this._hasHadErrorLoading = true;\n                this._FireLoadingProgressEvent()\n            }\n        }\n        SetInitialLoadFinished() {\n            this._hasFinishedInitialLoad = true\n        }\n        HasHadErrorLoading() {\n            return this._hasHadErrorLoading\n        }\n        _AddLoadedSize(s) {\n            this._assetSizeLoaded += s;\n            this._loadingRateLimiter.Call()\n        }\n        _FireLoadingProgressEvent() {\n            const event = C3.New(C3.Event, "loadingprogress");\n            this._lastLoadProgress = C3.clamp(this._assetSizeLoaded \/ this._totalAssetSizeToLoad, 0, 1);\n            event.progress = this._lastLoadProgress;\n            this._runtime.Dispatcher().dispatchEvent(event)\n        }\n        GetLoadProgress() {\n            return this._lastLoadProgress\n        }\n        _SetWebFonts(arr) {\n            C3.shallowAssignArray(this._webFonts, arr);\n            if (this._webFonts.length)\n                this._loadPromises.push(this._LoadWebFonts())\n        }\n        _LoadWebFonts() {\n            if (typeof FontFace === "undefined")\n                return Promise.resolve();\n            const promises = [];\n            for (const [name,filename,size] of this._webFonts) {\n                this._totalAssetSizeToLoad += size;\n                promises.push(this._LoadWebFont(name, filename).then( () => this._AddLoadedSize(size)))\n            }\n            return Promise.all(promises)\n        }\n        async _LoadWebFont(name, filename) {\n            try {\n                const url = await this.GetProjectFileUrl(filename, this._fontsSubfolder);\n                const fontFace = new FontFace(name,`url(\'${url}\')`);\n                if (this._runtime.IsInWorker())\n                    self.fonts.add(fontFace);\n                else\n                    document.fonts.add(fontFace);\n                await fontFace.load()\n            } catch (err) {\n                console.warn(`[C3 runtime] Failed to load web font \'${name}\': `, err)\n            }\n        }\n        IsAudioFormatSupported(type) {\n            return !!this._supportedAudioFormats[type]\n        }\n        _SetAudioFiles(arr, preloadSounds) {\n            this._preloadSounds = !!preloadSounds;\n            for (const [fileName,projectFilesInfo,isMusic] of arr)\n                this._audioFiles.set(fileName, {\n                    fileName,\n                    formats: projectFilesInfo.map(si => ({\n                        type: si[0],\n                        fileExtension: si[1],\n                        fullName: fileName + si[1],\n                        fileSize: si[2]\n                    })),\n                    isMusic\n                })\n        }\n        GetPreferredAudioFile(namePart) {\n            const info = this._audioFiles.get(namePart.toLowerCase());\n            if (!info)\n                return null;\n            let webMOpusFile = null;\n            for (const formatInfo of info.formats) {\n                if (!webMOpusFile && formatInfo.type === "audio\/webm; codecs=opus")\n                    webMOpusFile = formatInfo;\n                if (this.IsAudioFormatSupported(formatInfo.type))\n                    return formatInfo\n            }\n            return webMOpusFile\n        }\n        GetProjectAudioFileUrl(namePart) {\n            const formatInfo = this.GetPreferredAudioFile(namePart);\n            if (!formatInfo)\n                return null;\n            return {\n                url: this.GetMediaFileUrl(formatInfo.fullName),\n                type: formatInfo.type\n            }\n        }\n        GetAudioToPreload() {\n            if (this._preloadSounds) {\n                const ret = [];\n                for (const info of this._audioFiles.values()) {\n                    if (info.isMusic)\n                        continue;\n                    const formatInfo = this.GetPreferredAudioFile(info.fileName);\n                    if (!formatInfo)\n                        continue;\n                    ret.push({\n                        originalUrl: info.fileName,\n                        url: this.GetMediaFileUrl(formatInfo.fullName),\n                        type: formatInfo.type,\n                        fileSize: formatInfo.fileSize\n                    })\n                }\n                return ret\n            } else\n                return []\n        }\n        GetIAssetManager() {\n            return this._iAssetManager\n        }\n        async LoadScripts(...urls) {\n            const scriptUrls = await Promise.all(urls.map(url => this.GetProjectFileUrl(url)));\n            if (this._runtime.IsInWorker())\n                if (urls.length === 1) {\n                    const url = urls[0];\n                    await self.c3_import((C3.IsRelativeURL(url) ? ".\/" : "") + url)\n                } else {\n                    const scriptStr = urls.map(url => `import "${C3.IsRelativeURL(url) ? ".\/" : ""}${url}";`).join("\\n");\n                    const blobUrl = URL.createObjectURL(new Blob([scriptStr],{\n                        type: "application\/javascript"\n                    }));\n                    await self.c3_import(blobUrl)\n                }\n            else\n                await Promise.all(scriptUrls.map(url => AddScript(url)))\n        }\n        async CompileWebAssembly(url) {\n            if (WebAssembly.compileStreaming) {\n                const fetchUrl = await this.GetProjectFileUrl(url);\n                return await WebAssembly.compileStreaming(fetch(fetchUrl))\n            } else {\n                const arrayBuffer = await C3.FetchArrayBuffer(url);\n                return await WebAssembly.compile(arrayBuffer)\n            }\n        }\n        async LoadStyleSheet(url) {\n            const fetchUrl = await this.GetProjectFileUrl(url);\n            return await this._runtime.PostComponentMessageToDOMAsync("runtime", "add-stylesheet", {\n                "url": fetchUrl\n            })\n        }\n    }\n    ;\n\n}\n\n\/\/ assets\/asset.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Asset = class Asset extends C3.DefendedBase {\n        constructor(assetManager, opts) {\n            super();\n            this._assetManager = assetManager;\n            this._runtime = assetManager.GetRuntime();\n            this._url = opts.url;\n            this._size = opts.size;\n            this._loadPolicy = opts.loadPolicy;\n            this._blob = null;\n            this._isLoaded = false;\n            this._loadPromise = null\n        }\n        Release() {\n            this._loadPromise = null;\n            this._assetManager = null;\n            this._runtime = null;\n            this._blob = null\n        }\n        GetURL() {\n            return this._url\n        }\n        GetSize() {\n            return this._size\n        }\n        Load() {\n            if (this._loadPolicy === "local" || this._blob) {\n                this._isLoaded = true;\n                return Promise.resolve()\n            }\n            if (this._loadPromise)\n                return this._loadPromise;\n            this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then(blob => {\n                this._isLoaded = true;\n                this._loadPromise = null;\n                this._blob = blob;\n                return blob\n            }\n            ).catch(err => console.error("Error loading resource: ", err));\n            return this._loadPromise\n        }\n        IsLoaded() {\n            return this._isLoaded\n        }\n        GetBlob() {\n            if (this._blob)\n                return Promise.resolve(this._blob);\n            if (this._loadPromise)\n                return this._loadPromise;\n            return this._assetManager.FetchBlob(this._url, this._loadPolicy)\n        }\n    }\n    ;\n\n}\n\n\/\/ assets\/imageAsset.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const promiseThrottle = new C3.PromiseThrottle;\n    const allImageAssets = new Set;\n    C3.ImageAsset = class ImageAsset extends C3.Asset {\n        constructor(assetManager, opts) {\n            super(assetManager, opts);\n            this._texturePromise = null;\n            this._webglTexture = null;\n            this._refCount = 0;\n            this._imageWidth = -1;\n            this._imageHeight = -1;\n            allImageAssets.add(this)\n        }\n        Release() {\n            this.ReleaseTexture();\n            if (this._refCount !== 0)\n                throw new Error("released image asset which still has texture references");\n            this._texturePromise = null;\n            allImageAssets.delete(this);\n            super.Release()\n        }\n        static OnWebGLContextLost() {\n            for (const imageAsset of allImageAssets) {\n                imageAsset._texturePromise = null;\n                imageAsset._webglTexture = null;\n                imageAsset._refCount = 0\n            }\n        }\n        LoadStaticTexture(renderer, opts) {\n            opts = opts || {};\n            this._refCount++;\n            if (this._webglTexture)\n                return Promise.resolve(this._webglTexture);\n            if (this._texturePromise)\n                return this._texturePromise;\n            opts.anisotropy = this._runtime.GetCanvasManager().GetTextureAnisotropy();\n            this._texturePromise = this.GetBlob().then(blob => promiseThrottle.Add( () => renderer.CreateStaticTextureAsync(blob, opts).then(texture => {\n                this._texturePromise = null;\n                if (this._refCount === 0) {\n                    renderer.DeleteTexture(texture);\n                    return null\n                }\n                this._webglTexture = texture;\n                this._imageWidth = texture.GetWidth();\n                this._imageHeight = texture.GetHeight();\n                return this._webglTexture\n            }\n            ))).catch(err => {\n                console.error("Failed to load texture: ", err);\n                throw err;\n            }\n            );\n            return this._texturePromise\n        }\n        ReleaseTexture() {\n            if (this._refCount <= 0)\n                throw new Error("texture released too many times");\n            this._refCount--;\n            if (this._refCount === 0 && this._webglTexture) {\n                const renderer = this._webglTexture.GetRenderer();\n                renderer.DeleteTexture(this._webglTexture);\n                this._webglTexture = null\n            }\n        }\n        GetTexture() {\n            return this._webglTexture\n        }\n        GetWidth() {\n            return this._imageWidth\n        }\n        GetHeight() {\n            return this._imageHeight\n        }\n        async LoadToDrawable() {\n            const blob = await this.GetBlob();\n            if (C3.Supports.ImageBitmapOptions)\n                return await createImageBitmap(blob, {\n                    "premultiplyAlpha": "none"\n                });\n            else if (C3.Supports.ImageBitmap)\n                return await createImageBitmap(blob);\n            else\n                return await C3.BlobToImage(blob)\n        }\n    }\n    ;\n\n}\n\n\/\/ layouts\/renderCell.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const assert = self.assert;\n    function SortByInstLastCachedZIndex(a, b) {\n        return a.GetWorldInfo()._GetLastCachedZIndex() - b.GetWorldInfo()._GetLastCachedZIndex()\n    }\n    C3.RenderCell = class RenderCell extends C3.DefendedBase {\n        constructor(grid, x, y) {\n            super();\n            this._grid = grid;\n            this._x = x;\n            this._y = y;\n            this._instances = [];\n            this._isSorted = true;\n            this._pendingRemoval = new Set;\n            this._isAnyPendingRemoval = false\n        }\n        Release() {\n            C3.clearArray(this._instances);\n            this._pendingRemoval.clear();\n            this._grid = null\n        }\n        Reset() {\n            C3.clearArray(this._instances);\n            this._isSorted = true;\n            this._pendingRemoval.clear();\n            this._isAnyPendingRemoval = false\n        }\n        SetChanged() {\n            this._isSorted = false\n        }\n        IsEmpty() {\n            if (!this._instances.length)\n                return true;\n            if (this._instances.length > this._pendingRemoval.size)\n                return false;\n            this._FlushPending();\n            return true\n        }\n        Insert(inst) {\n            if (this._pendingRemoval.has(inst)) {\n                this._pendingRemoval.delete(inst);\n                if (this._pendingRemoval.size === 0)\n                    this._isAnyPendingRemoval = false;\n                return\n            }\n            this._instances.push(inst);\n            this._isSorted = this._instances.length === 1\n        }\n        Remove(inst) {\n            this._pendingRemoval.add(inst);\n            this._isAnyPendingRemoval = true;\n            if (this._pendingRemoval.size >= 50)\n                this._FlushPending()\n        }\n        _FlushPending() {\n            if (!this._isAnyPendingRemoval)\n                return;\n            if (this._instances.length === this._pendingRemoval.size) {\n                this.Reset();\n                return\n            }\n            C3.arrayRemoveAllInSet(this._instances, this._pendingRemoval);\n            this._pendingRemoval.clear();\n            this._isAnyPendingRemoval = false\n        }\n        _EnsureSorted() {\n            if (this._isSorted)\n                return;\n            this._instances.sort(SortByInstLastCachedZIndex);\n            this._isSorted = true\n        }\n        Dump(result) {\n            this._FlushPending();\n            this._EnsureSorted();\n            if (this._instances.length)\n                result.push(this._instances)\n        }\n    }\n    ;\n\n}\n\n\/\/ layouts\/renderGrid.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.RenderGrid = class RenderGrid extends C3.DefendedBase {\n        constructor(cellWidth, cellHeight) {\n            super();\n            this._cellWidth = cellWidth;\n            this._cellHeight = cellHeight;\n            this._cells = C3.New(C3.PairMap)\n        }\n        Release() {\n            this._cells.Release();\n            this._cells = null\n        }\n        GetCell(x, y, createIfMissing) {\n            let ret = this._cells.Get(x, y);\n            if (ret)\n                return ret;\n            else if (createIfMissing) {\n                ret = C3.New(C3.RenderCell, this, x, y);\n                this._cells.Set(x, y, ret);\n                return ret\n            } else\n                return null\n        }\n        XToCell(x) {\n            return Math.floor(x \/ this._cellWidth)\n        }\n        YToCell(y) {\n            return Math.floor(y \/ this._cellHeight)\n        }\n        Update(inst, oldRange, newRange) {\n            if (oldRange)\n                for (let x = oldRange.getLeft(), lenx = oldRange.getRight(); x <= lenx; ++x)\n                    for (let y = oldRange.getTop(), leny = oldRange.getBottom(); y <= leny; ++y) {\n                        if (newRange && newRange.containsPoint(x, y))\n                            continue;\n                        const cell = this.GetCell(x, y, false);\n                        if (!cell)\n                            continue;\n                        cell.Remove(inst);\n                        if (cell.IsEmpty())\n                            this._cells.Delete(x, y)\n                    }\n            if (newRange)\n                for (let x = newRange.getLeft(), lenx = newRange.getRight(); x <= lenx; ++x)\n                    for (let y = newRange.getTop(), leny = newRange.getBottom(); y <= leny; ++y) {\n                        if (oldRange && oldRange.containsPoint(x, y))\n                            continue;\n                        this.GetCell(x, y, true).Insert(inst)\n                    }\n        }\n        QueryRange(rc, result) {\n            let x = this.XToCell(rc.getLeft());\n            const ystart = this.YToCell(rc.getTop());\n            const lenx = this.XToCell(rc.getRight());\n            const leny = this.YToCell(rc.getBottom());\n            for (; x <= lenx; ++x)\n                for (let y = ystart; y <= leny; ++y) {\n                    const cell = this.GetCell(x, y, false);\n                    if (!cell)\n                        continue;\n                    cell.Dump(result)\n                }\n        }\n        MarkRangeChanged(rc) {\n            let x = rc.getLeft();\n            const ystart = rc.getTop();\n            const lenx = rc.getRight();\n            const leny = rc.getBottom();\n            for (; x <= lenx; ++x)\n                for (let y = ystart; y <= leny; ++y) {\n                    const cell = this.GetCell(x, y, false);\n                    if (!cell)\n                        continue;\n                    cell.SetChanged()\n                }\n        }\n    }\n    ;\n\n}\n\n\/\/ layouts\/layer.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const tmpRect = new C3.Rect;\n    const tmpQuad = new C3.Quad;\n    const renderCellArr = [];\n    const tmpDestRect = new C3.Rect;\n    const tmpSrcRect = new C3.Rect;\n    const glMatrix = self.glMatrix;\n    const vec3 = glMatrix.vec3;\n    const vec4 = glMatrix.vec4;\n    const mat4 = glMatrix.mat4;\n    const tempMat4 = mat4.create();\n    const tempVec3 = vec3.create();\n    const tempVec4 = vec4.create();\n    const camVector = vec3.create();\n    const lookVector = vec3.create();\n    const upVector = vec3.create();\n    const tempVec2 = C3.New(C3.Vector2);\n    const tempRect = C3.New(C3.Rect);\n    function SortByInstLastCachedZIndex(a, b) {\n        return a.GetWorldInfo()._GetLastCachedZIndex() - b.GetWorldInfo()._GetLastCachedZIndex()\n    }\n    function SortByInstZElevation(a, b) {\n        return a.GetWorldInfo().GetZElevation() - b.GetWorldInfo().GetZElevation()\n    }\n    const tempInstanceList1 = [];\n    const tempInstanceList2 = [];\n    const tempInstancesByCameraDist = [];\n    C3.Layer = class Layer extends C3.DefendedBase {\n        constructor(layout, parentLayer, data) {\n            super();\n            this._layout = layout;\n            this._runtime = layout.GetRuntime();\n            this._parentLayer = parentLayer;\n            this._name = data[0];\n            this._index = -1;\n            this._sid = data[2];\n            this._isVisible = !!data[3];\n            this._isInteractive = !!data[13];\n            this._backgroundColor = C3.New(C3.Color);\n            this._backgroundColor.setFromJSON(data[4].map(x => x \/ 255));\n            this._isTransparent = !!data[5];\n            this._parallaxX = data[6];\n            this._parallaxY = data[7];\n            this._color = C3.New(C3.Color, 1, 1, 1, data[8]);\n            this._premultipliedColor = C3.New(C3.Color);\n            this._isForceOwnTexture = data[9];\n            this._renderAs3d = data[17];\n            this._useCameraDistanceDrawOrder = data[18];\n            this._useRenderCells = data[10];\n            this._scaleRate = data[11];\n            this._blendMode = data[12];\n            this._curRenderTarget = null;\n            this._scale = 1;\n            this._zElevation = data[16];\n            this._angle = 0;\n            this._scrollX = 0;\n            this._scrollY = 0;\n            this._hasOwnScrollPosition = false;\n            this._viewport = C3.New(C3.Rect);\n            this._viewportZ0 = C3.New(C3.Rect);\n            this._viewport3D = C3.New(C3.Rect);\n            this._isViewportChanged = true;\n            this._projectionMatrix = mat4.create();\n            this._isProjectionMatrixChanged = true;\n            this._modelViewMatrix = mat4.create();\n            this._isMVMatrixChanged = true;\n            this._viewFrustum = C3.New(C3.Gfx.ViewFrustum);\n            this._isViewFrustumChanged = true;\n            this._startupInitialInstances = [];\n            this._initialInstancesData = data[14];\n            this._initialInstances = [];\n            this._createdGlobalUids = [];\n            this._initialUIDsToInstanceData = new Map;\n            this._instances = [];\n            this._zIndicesUpToDate = false;\n            this._anyInstanceZElevated = false;\n            const canvasManager = this._runtime.GetCanvasManager();\n            this._effectList = C3.New(C3.EffectList, this, data[15]);\n            this._effectChain = C3.New(C3.Gfx.EffectChain, canvasManager.GetEffectChainManager(), {\n                drawContent: (renderer, effectChain) => {\n                    const layer = effectChain.GetContentObject();\n                    const renderSurface = layer.GetRenderTarget();\n                    renderer.SetColor(layer.GetPremultipliedColor());\n                    renderer.DrawRenderTarget(renderSurface);\n                    renderer.InvalidateRenderTarget(renderSurface);\n                    canvasManager.ReleaseAdditionalRenderTarget(renderSurface)\n                }\n                ,\n                getShaderParameters: index => this.GetEffectList()._GetEffectChainShaderParametersForIndex(index)\n            });\n            this._needsRebuildEffectChainSteps = true;\n            this._wasDefaultColor = true;\n            this._renderGrid = null;\n            this._lastRenderList = [];\n            this._isRenderListUpToDate = false;\n            this._lastRenderCells = C3.New(C3.Rect, 0, 0, -1, -1);\n            this._curRenderCells = C3.New(C3.Rect, 0, 0, -1, -1);\n            this._iLayer = null;\n            this._UpdatePremultipliedColor();\n            if (this.UsesRenderCells())\n                this._renderGrid = C3.New(C3.RenderGrid, this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight());\n            this._subLayers = data[19].map(ld => C3.New(C3.Layer, this._layout, this, ld))\n        }\n        _Init() {\n            for (const instData of this._initialInstancesData) {\n                const objectClass = this._runtime.GetObjectClassByIndex(instData[1]);\n                this._layout._AddInitialObjectClass(objectClass);\n                if (!objectClass.GetDefaultInstanceData()) {\n                    objectClass.SetDefaultInstanceData(instData);\n                    objectClass._SetDefaultLayerIndex(this._index)\n                }\n                this._initialInstances.push(instData);\n                this._initialUIDsToInstanceData.set(instData[2], instData)\n            }\n            C3.shallowAssignArray(this._startupInitialInstances, this._initialInstances);\n            this._initialInstancesData = null;\n            this._iLayer = new self.ILayer(this)\n        }\n        Release() {\n            this._layout = null;\n            this._runtime = null\n        }\n        GetInitialInstanceData(uid) {\n            return this._initialUIDsToInstanceData.get(uid)\n        }\n        CreateInitialInstances(createdInstances) {\n            const isFirstVisit = this._layout.IsFirstVisit();\n            let k = 0;\n            const initialInstances = this._initialInstances;\n            for (let i = 0, len = initialInstances.length; i < len; ++i) {\n                const instData = initialInstances[i];\n                const objectClass = this._runtime.GetObjectClassByIndex(instData[1]);\n                let keep = true;\n                if (!objectClass.HasPersistBehavior() || isFirstVisit) {\n                    const inst = this._runtime.CreateInstanceFromData(instData, this, true);\n                    createdInstances.push(inst);\n                    if (objectClass.IsGlobal()) {\n                        keep = false;\n                        this._createdGlobalUids.push(inst.GetUID())\n                    }\n                }\n                if (keep) {\n                    initialInstances[k] = initialInstances[i];\n                    ++k\n                }\n            }\n            C3.truncateArray(initialInstances, k);\n            this._runtime.FlushPendingInstances();\n            this.SetZIndicesChanged()\n        }\n        _AddInstance(inst, addToGrid) {\n            const wi = inst.GetWorldInfo();\n            if (wi.GetLayer() !== this)\n                throw new Error("instance added to wrong layer");\n            this._instances.push(inst);\n            if (wi.GetZElevation() !== 0)\n                this._anyInstanceZElevated = true;\n            if (addToGrid && this.UsesRenderCells())\n                inst.GetWorldInfo().SetBboxChanged();\n            this.SetZIndicesChanged()\n        }\n        _MaybeAddInstance(inst) {\n            if (this._instances.includes(inst))\n                return;\n            this._instances.push(inst);\n            if (inst.GetWorldInfo().GetZElevation() !== 0)\n                this._anyInstanceZElevated = true;\n            this.SetZIndicesChanged()\n        }\n        _PrependInstance(inst, addToGrid) {\n            const wi = inst.GetWorldInfo();\n            if (wi.GetLayer() !== this)\n                throw new Error("instance added to wrong layer");\n            this._instances.unshift(inst);\n            if (wi.GetZElevation() !== 0)\n                this._anyInstanceZElevated = true;\n            this.SetZIndicesChanged();\n            if (addToGrid && this.UsesRenderCells())\n                inst.GetWorldInfo().SetBboxChanged()\n        }\n        _RemoveInstance(inst, removeFromGrid) {\n            const index = this._instances.indexOf(inst);\n            if (index < 0)\n                return;\n            if (removeFromGrid && this.UsesRenderCells())\n                inst.GetWorldInfo()._RemoveFromRenderCells();\n            this._instances.splice(index, 1);\n            this.SetZIndicesChanged();\n            this._MaybeResetAnyInstanceZElevatedFlag()\n        }\n        _SetAnyInstanceZElevated() {\n            this._anyInstanceZElevated = true\n        }\n        _MaybeResetAnyInstanceZElevatedFlag() {\n            if (this._instances.length === 0)\n                this._anyInstanceZElevated = false\n        }\n        _SortInstancesByLastCachedZIndex(isPersistMode) {\n            if (isPersistMode) {\n                const assignedZIndices = new Set;\n                for (const inst of this._instances) {\n                    const cachedZIndex = inst.GetWorldInfo()._GetLastCachedZIndex();\n                    if (cachedZIndex >= 0)\n                        assignedZIndices.add(cachedZIndex)\n                }\n                let index = -1;\n                for (const inst of this._instances) {\n                    const wi = inst.GetWorldInfo();\n                    if (wi._GetLastCachedZIndex() >= 0)\n                        continue;\n                    ++index;\n                    while (assignedZIndices.has(index))\n                        ++index;\n                    wi._SetZIndex(index)\n                }\n            }\n            this._instances.sort(SortByInstLastCachedZIndex)\n        }\n        _Start() {}\n        _End() {\n            for (const inst of this._instances)\n                if (!inst.GetObjectClass().IsGlobal())\n                    this._runtime.DestroyInstance(inst);\n            this._runtime.FlushPendingInstances();\n            C3.clearArray(this._instances);\n            this._anyInstanceZElevated = false;\n            this.SetZIndicesChanged()\n        }\n        RecreateInitialObjects(objectClass, rc, offsetX, offsetY, createHierarchy) {\n            const eventSheetManager = this._runtime.GetEventSheetManager();\n            const allObjectClasses = this._runtime.GetAllObjectClasses();\n            const isFamily = objectClass.IsFamily();\n            const ret = [];\n            for (const instData of this._initialInstances) {\n                const worldData = instData[0];\n                const x = worldData[0];\n                const y = worldData[1];\n                if (!rc.containsPoint(x, y))\n                    continue;\n                const objectType = allObjectClasses[instData[1]];\n                if (objectType !== objectClass)\n                    if (isFamily) {\n                        if (!objectClass.FamilyHasMember(objectType))\n                            continue\n                    } else\n                        continue;\n                let createOnLayer = this;\n                const runningLayout = this._runtime.GetCurrentLayout();\n                if (this.GetLayout() !== runningLayout) {\n                    createOnLayer = runningLayout.GetLayerByName(this.GetName());\n                    if (!createOnLayer)\n                        createOnLayer = runningLayout.GetLayerByIndex(this.GetIndex())\n                }\n                const inst = this._runtime.CreateInstanceFromData(instData, createOnLayer, false, undefined, undefined, false, createHierarchy);\n                createOnLayer.SortAndAddInstancesByZIndex(inst);\n                const wi = inst.GetWorldInfo();\n                wi.OffsetXY(offsetX, offsetY);\n                wi.SetBboxChanged();\n                eventSheetManager.BlockFlushingInstances(true);\n                inst._TriggerOnCreatedOnSelfAndRelated();\n                eventSheetManager.BlockFlushingInstances(false);\n                ret.push(inst)\n            }\n            return ret\n        }\n        GetInstanceCount() {\n            return this._instances.length\n        }\n        GetLayout() {\n            return this._layout\n        }\n        GetName() {\n            return this._name\n        }\n        _SetIndex(i) {\n            this._index = i\n        }\n        GetIndex() {\n            return this._index\n        }\n        GetSID() {\n            return this._sid\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetDevicePixelRatio() {\n            return this._runtime.GetDevicePixelRatio()\n        }\n        GetEffectList() {\n            return this._effectList\n        }\n        GetEffectChain() {\n            this._MaybeRebuildEffectChainSteps();\n            return this._effectChain\n        }\n        _MaybeRebuildEffectChainSteps() {\n            const isDefaultColor = this.HasDefaultColor();\n            if (!this._needsRebuildEffectChainSteps && isDefaultColor === this._wasDefaultColor)\n                return;\n            const activeEffectTypes = this.GetEffectList().GetActiveEffectTypes();\n            this._effectChain.BuildSteps(activeEffectTypes.map(e => e.GetShaderProgram()), {\n                indexMap: activeEffectTypes.map(e => e.GetIndex()),\n                forcePreDraw: !isDefaultColor,\n                useFullSurface: true\n            });\n            this._needsRebuildEffectChainSteps = false;\n            this._wasDefaultColor = isDefaultColor\n        }\n        UpdateActiveEffects() {\n            this.GetEffectList().UpdateActiveEffects();\n            this._needsRebuildEffectChainSteps = true\n        }\n        UsesRenderCells() {\n            return this._useRenderCells && !this._useCameraDistanceDrawOrder\n        }\n        GetRenderGrid() {\n            return this._renderGrid\n        }\n        SetRenderListStale() {\n            this._isRenderListUpToDate = false\n        }\n        IsVisible() {\n            for (const layer of this.selfAndParentLayers())\n                if (!layer._IsVisibleFlagSet())\n                    return false;\n            return true\n        }\n        _IsVisibleFlagSet() {\n            return this._isVisible\n        }\n        SetVisible(v) {\n            v = !!v;\n            if (this._isVisible === v)\n                return;\n            this._isVisible = v;\n            this._runtime.UpdateRender()\n        }\n        SetInteractive(i) {\n            this._isInteractive = !!i\n        }\n        IsInteractive() {\n            return this._isInteractive\n        }\n        IsSelfAndParentsInteractive() {\n            for (const layer of this.selfAndParentLayers())\n                if (!layer.IsInteractive())\n                    return false;\n            return true\n        }\n        SetOwnScrollPositionEnabled(e) {\n            e = !!e;\n            if (this._hasOwnScrollPosition === e)\n                return;\n            this._hasOwnScrollPosition = e;\n            if (e) {\n                const layout = this.GetLayout();\n                this._scrollX = layout.GetScrollX();\n                this._scrollY = layout.GetScrollY()\n            }\n            this._SetMVMatrixChanged();\n            this._runtime.UpdateRender()\n        }\n        IsOwnScrollPositionEnabled() {\n            return this._hasOwnScrollPosition\n        }\n        SetScrollX(x) {\n            const layout = this.GetLayout();\n            const lbound = layout.GetScrollLeftBound();\n            const rbound = layout.GetScrollRightBound();\n            if (x > rbound)\n                x = rbound;\n            if (x < lbound)\n                x = lbound;\n            if (this._scrollX !== x) {\n                this._scrollX = x;\n                if (this.IsOwnScrollPositionEnabled()) {\n                    this._SetMVMatrixChanged();\n                    this._runtime.UpdateRender()\n                }\n            }\n        }\n        SetScrollY(y) {\n            const layout = this.GetLayout();\n            const ubound = layout.GetScrollTopBound();\n            const bbound = layout.GetScrollBottomBound();\n            if (y > bbound)\n                y = bbound;\n            if (y < ubound)\n                y = ubound;\n            if (this._scrollY !== y) {\n                this._scrollY = y;\n                if (this.IsOwnScrollPositionEnabled()) {\n                    this._SetMVMatrixChanged();\n                    this._runtime.UpdateRender()\n                }\n            }\n        }\n        GetScrollX() {\n            if (this.IsOwnScrollPositionEnabled())\n                return this._scrollX;\n            else\n                return this.GetLayout().GetScrollX()\n        }\n        GetScrollY() {\n            if (this.IsOwnScrollPositionEnabled())\n                return this._scrollY;\n            else\n                return this.GetLayout().GetScrollY()\n        }\n        GetViewport() {\n            this._MaybeUpdateViewport();\n            return this._viewport\n        }\n        _GetViewportZ0() {\n            this._MaybeUpdateViewport();\n            return this._viewportZ0\n        }\n        GetViewport3D() {\n            this._MaybeUpdateViewport();\n            return this._viewport3D\n        }\n        _GetVanishingPoint() {\n            const layout = this.GetLayout();\n            return [layout.GetVanishingPointX(), layout.GetVanishingPointY()]\n        }\n        GetDefaultCameraZ(viewH) {\n            return this._runtime.GetDefaultCameraZ(viewH)\n        }\n        GetViewportForZ(z, outRect) {\n            const viewportZ0 = this._GetViewportZ0();\n            if (z === 0)\n                outRect.copy(viewportZ0);\n            else {\n                let midX = viewportZ0.midX();\n                let midY = viewportZ0.midY();\n                const scaleFactor = this.Get2DScaleFactorToZ(z);\n                const viewW = viewportZ0.width() \/ scaleFactor;\n                const viewH = viewportZ0.height() \/ scaleFactor;\n                const [vpX,vpY] = this._GetVanishingPoint();\n                if (vpX !== .5 || vpY !== .5) {\n                    const cameraZ = this.GetCameraZ();\n                    const runtime = this._runtime;\n                    const zf = this.GetDefaultCameraZ() \/ cameraZ;\n                    let camOffX = (vpX - .5) * runtime.GetViewportWidth() \/ zf;\n                    let camOffY = (vpY - .5) * runtime.GetViewportHeight() \/ zf;\n                    const a = this.GetAngle();\n                    if (a !== 0) {\n                        tempVec2.set(camOffX, camOffY);\n                        tempVec2.rotate(a);\n                        camOffX = tempVec2.getX();\n                        camOffY = tempVec2.getY()\n                    }\n                    const zProg = C3.unlerp(cameraZ, 0, z);\n                    midX += C3.lerp(camOffX, 0, zProg);\n                    midY += C3.lerp(camOffY, 0, zProg)\n                }\n                outRect.set(midX - viewW \/ 2, midY - viewH \/ 2, midX + viewW \/ 2, midY + viewH \/ 2)\n            }\n        }\n        GetOpacity() {\n            return this._color.getA()\n        }\n        SetOpacity(o) {\n            o = C3.clamp(o, 0, 1);\n            if (this._color.getA() === o)\n                return;\n            this._color.setA(o);\n            this._UpdatePremultipliedColor();\n            this._runtime.UpdateRender()\n        }\n        _UpdatePremultipliedColor() {\n            this._premultipliedColor.copy(this._color);\n            this._premultipliedColor.premultiply()\n        }\n        GetPremultipliedColor() {\n            return this._premultipliedColor\n        }\n        HasDefaultColor() {\n            return this._color.equalsRgba(1, 1, 1, 1)\n        }\n        GetScaleRate() {\n            return this._scaleRate\n        }\n        SetScaleRate(r) {\n            if (this._scaleRate === r)\n                return;\n            this._scaleRate = r;\n            this._SetMVMatrixChanged();\n            this._runtime.UpdateRender()\n        }\n        GetParallaxX() {\n            return this._parallaxX\n        }\n        GetParallaxY() {\n            return this._parallaxY\n        }\n        SetParallax(px, py) {\n            if (this._parallaxX === px && this._parallaxY === py)\n                return;\n            this._parallaxX = px;\n            this._parallaxY = py;\n            this._SetMVMatrixChanged();\n            this._runtime.UpdateRender();\n            if (this._parallaxX !== 1 || this._parallaxY !== 1)\n                for (const inst of this._instances)\n                    inst.GetObjectClass()._SetAnyInstanceParallaxed(true)\n        }\n        SetParallaxX(px) {\n            this.SetParallax(px, this.GetParallaxY())\n        }\n        SetParallaxY(py) {\n            this.SetParallax(this.GetParallaxX(), py)\n        }\n        SetZElevation(z) {\n            if (this._zElevation === z)\n                return;\n            this._zElevation = z;\n            this._runtime.UpdateRender()\n        }\n        GetZElevation() {\n            return this._zElevation\n        }\n        SetAngle(a) {\n            a = C3.clampAngle(a);\n            if (this._angle === a)\n                return;\n            this._angle = a;\n            this._SetMVMatrixChanged();\n            this._runtime.UpdateRender()\n        }\n        GetAngle() {\n            return C3.clampAngle(this._layout.GetAngle() + this._angle)\n        }\n        GetOwnAngle() {\n            return this._angle\n        }\n        HasInstances() {\n            return this._instances.length > 0\n        }\n        _GetInstances() {\n            return this._instances\n        }\n        _GetInstancesInDrawOrder() {\n            if (this.RendersIn3DMode() && this._useCameraDistanceDrawOrder) {\n                C3.shallowAssignArray(tempInstancesByCameraDist, this._GetInstances());\n                tempInstancesByCameraDist.sort( (a, b) => this._SortInstancesByCameraDistance(a, b));\n                return tempInstancesByCameraDist\n            } else\n                return this._GetInstances()\n        }\n        _AppendAllInstancesIncludingSubLayersInDrawOrder(arr) {\n            C3.appendArray(arr, this._GetInstancesInDrawOrder());\n            for (const subLayer of this._subLayers)\n                if (subLayer.IsVisible() && subLayer.GetOpacity() > 0)\n                    subLayer._AppendAllInstancesIncludingSubLayersInDrawOrder(arr)\n        }\n        _SortInstancesByCameraDistance(a, b) {\n            const camVec = this.GetLayout().Get3DCameraPosition();\n            const camX = camVec[0];\n            const camY = camVec[1];\n            const camZ = camVec[2];\n            const wiA = a.GetWorldInfo();\n            const wiB = b.GetWorldInfo();\n            const dxA = wiA.GetX() - camX;\n            const dyA = wiA.GetY() - camY;\n            const dzA = wiA.GetZElevation() - camZ;\n            const dxB = wiB.GetX() - camX;\n            const dyB = wiB.GetY() - camY;\n            const dzB = wiB.GetZElevation() - camZ;\n            return dxB * dxB + dyB * dyB + dzB * dzB - (dxA * dxA + dyA * dyA + dzA * dzA)\n        }\n        GetBackgroundColor() {\n            return this._backgroundColor\n        }\n        IsTransparent() {\n            return this._isTransparent\n        }\n        SetTransparent(t) {\n            t = !!t;\n            if (this._isTransparent === t)\n                return;\n            this._isTransparent = t;\n            this._runtime.UpdateRender()\n        }\n        IsForceOwnTexture() {\n            return this._isForceOwnTexture\n        }\n        SetForceOwnTexture(f) {\n            f = !!f;\n            if (this._isForceOwnTexture === f)\n                return;\n            this._isForceOwnTexture = f;\n            this._runtime.UpdateRender()\n        }\n        RendersIn2DMode() {\n            return !this.GetRuntime().Uses3DFeatures() || !this._renderAs3d\n        }\n        RendersIn3DMode() {\n            return !this.RendersIn2DMode()\n        }\n        Has3DCamera() {\n            return this.RendersIn3DMode() && this.GetLayout().Is3DCameraEnabled()\n        }\n        SelfAndAllSubLayersHave3DCamera() {\n            if (!this.Has3DCamera())\n                return false;\n            for (const subLayer of this._subLayers)\n                if (!subLayer.SelfAndAllSubLayersHave3DCamera())\n                    return false;\n            return true\n        }\n        SetBlendMode(bm) {\n            if (this._blendMode === bm)\n                return;\n            this._blendMode = bm;\n            this._runtime.UpdateRender()\n        }\n        GetBlendMode() {\n            return this._blendMode\n        }\n        IsRootLayer() {\n            return !this._parentLayer\n        }\n        GetParentLayer() {\n            return this._parentLayer\n        }\n        GetSubLayers() {\n            return this._subLayers\n        }\n        HasAnySubLayers() {\n            return this._subLayers.length > 0\n        }\n        HasAnyVisibleSubLayer() {\n            for (const subLayer of this._subLayers)\n                if (subLayer.ShouldDraw())\n                    return true;\n            return false\n        }\n        *selfAndAllSubLayers() {\n            for (const subLayer of this._subLayers)\n                yield*subLayer.selfAndAllSubLayers();\n            yield this\n        }\n        *parentLayers() {\n            let parentLayer = this.GetParentLayer();\n            while (parentLayer) {\n                yield parentLayer;\n                parentLayer = parentLayer.GetParentLayer()\n            }\n        }\n        *selfAndParentLayers() {\n            yield this;\n            yield*this.parentLayers()\n        }\n        IsTransformCompatibleWith(otherLayer) {\n            return this === otherLayer || this._parallaxX === otherLayer._parallaxX && this._parallaxY === otherLayer._parallaxY && this._scale === otherLayer._scale && this._scaleRate === otherLayer._scaleRate && this._angle === otherLayer._angle && this.GetScrollX() === otherLayer.GetScrollX() && this.GetScrollY() === otherLayer.GetScrollY()\n        }\n        SaveTransform() {\n            return {\n                "parallaxX": this.GetParallaxX(),\n                "parallaxY": this.GetParallaxY(),\n                "scale": this.GetOwnScale(),\n                "scaleRate": this.GetScaleRate(),\n                "angle": this.GetOwnAngle(),\n                "hasOwnScroll": this.IsOwnScrollPositionEnabled(),\n                "scrollX": this.GetScrollX(),\n                "scrollY": this.GetScrollY()\n            }\n        }\n        RestoreTransform(t) {\n            this.SetParallax(t["parallaxX"], t["parallaxY"]);\n            this.SetOwnScale(t["scale"]);\n            this.SetScaleRate(t["scaleRate"]);\n            this.SetAngle(t["angle"]);\n            this.SetOwnScrollPositionEnabled(t["hasOwnScroll"]);\n            this.SetScrollX(t["scrollX"]);\n            this.SetScrollY(t["scrollY"]);\n            this._MaybeUpdateViewport()\n        }\n        _RemoveAllInstancesInSet(s) {\n            if (s.size === 0)\n                return;\n            const numRemoved = C3.arrayRemoveAllInSet(this._instances, s);\n            if (numRemoved > 0) {\n                this._MaybeResetAnyInstanceZElevatedFlag();\n                this.SetZIndicesChanged()\n            }\n        }\n        SetZIndicesChanged() {\n            this._zIndicesUpToDate = false;\n            this._isRenderListUpToDate = false\n        }\n        _UpdateZIndices() {\n            if (this._zIndicesUpToDate)\n                return;\n            this._instances.sort(SortByInstZElevation);\n            if (this.UsesRenderCells())\n                for (let i = 0, len = this._instances.length; i < len; ++i) {\n                    const wi = this._instances[i].GetWorldInfo();\n                    wi._SetZIndex(i);\n                    this._renderGrid.MarkRangeChanged(wi.GetRenderCellRange())\n                }\n            else\n                for (let i = 0, len = this._instances.length; i < len; ++i)\n                    this._instances[i].GetWorldInfo()._SetZIndex(i);\n            this._zIndicesUpToDate = true\n        }\n        MoveInstanceAdjacent(inst, other, isAfter) {\n            const instWi = inst.GetWorldInfo();\n            const otherWi = other.GetWorldInfo();\n            if (instWi.GetLayer() !== this || otherWi.GetLayer() !== this)\n                throw new Error("can\'t arrange Z order unless both objects on this layer");\n            const myZ = instWi.GetZIndex();\n            let insertZ = otherWi.GetZIndex();\n            if (myZ === insertZ + (isAfter ? 1 : -1))\n                return false;\n            C3.arrayRemove(this._instances, myZ);\n            if (myZ < insertZ)\n                insertZ--;\n            if (isAfter)\n                insertZ++;\n            if (insertZ === this._instances.length)\n                this._instances.push(inst);\n            else\n                this._instances.splice(insertZ, 0, inst);\n            this.SetZIndicesChanged();\n            return true\n        }\n        _MergeSortedZArrays(a, b) {\n            const ret = [];\n            let i = 0\n              , j = 0\n              , lena = a.length\n              , lenb = b.length;\n            while (i < lena && j < lenb) {\n                const ai = a[i];\n                const bj = b[j];\n                if (ai.GetWorldInfo()._GetLastCachedZIndex() < bj.GetWorldInfo()._GetLastCachedZIndex()) {\n                    ret.push(ai);\n                    ++i\n                } else {\n                    ret.push(bj);\n                    ++j\n                }\n            }\n            for (; i < lena; ++i)\n                ret.push(a[i]);\n            for (; j < lenb; ++j)\n                ret.push(b[j]);\n            return ret\n        }\n        _MergeAllSortedZArrays_pass(arr) {\n            const ret = [];\n            const len = arr.length;\n            for (let i = 0; i < len - 1; i += 2) {\n                const arr1 = arr[i];\n                const arr2 = arr[i + 1];\n                ret.push(this._MergeSortedZArrays(arr1, arr2))\n            }\n            if (len % 2 === 1)\n                ret.push(arr[len - 1]);\n            return ret\n        }\n        _MergeAllSortedZArrays(arr) {\n            while (arr.length > 1)\n                arr = this._MergeAllSortedZArrays_pass(arr);\n            return arr[0]\n        }\n        _GetRenderCellInstancesToDraw() {\n            this._UpdateZIndices();\n            C3.clearArray(renderCellArr);\n            this._renderGrid.QueryRange(this.GetViewport(), renderCellArr);\n            if (!renderCellArr.length)\n                return [];\n            if (renderCellArr.length === 1)\n                return renderCellArr[0];\n            return this._MergeAllSortedZArrays(renderCellArr)\n        }\n        ShouldDraw() {\n            return this.IsVisible() && this.GetOpacity() > 0 && this._DrawsAnyContentInSelfOrSubLayers()\n        }\n        _DrawsAnyContentInSelfOrSubLayers() {\n            if (this.HasInstances() || !this.IsTransparent())\n                return true;\n            for (const subLayer of this._subLayers)\n                if (subLayer._DrawsAnyContentInSelfOrSubLayers())\n                    return true;\n            return false\n        }\n        UsesOwnTexture() {\n            return this.IsForceOwnTexture() || !this.HasDefaultColor() || this.GetBlendMode() !== 0 || this._effectList.HasAnyActiveEffect()\n        }\n        SelfOrAnySubLayerUsesOwnTexture() {\n            if (this.UsesOwnTexture())\n                return true;\n            for (const subLayer of this._subLayers)\n                if (subLayer.SelfOrAnySubLayerUsesOwnTexture())\n                    return true;\n            return false\n        }\n        GetRenderTarget() {\n            return this._curRenderTarget\n        }\n        Get2DScaleFactorToZ(z) {\n            if (this._layout.IsOrthographicProjection())\n                return 1;\n            else {\n                const camZ = this.GetCameraZ();\n                return camZ \/ (camZ - z)\n            }\n        }\n        GetCameraZ(viewH) {\n            return this.GetDefaultCameraZ(viewH) \/ this.GetNormalScale()\n        }\n        _SetMVMatrixChanged() {\n            this._isMVMatrixChanged = true;\n            this._isViewFrustumChanged = true;\n            this._isViewportChanged = true\n        }\n        _GetModelViewMatrix(renderer) {\n            if (this._isMVMatrixChanged) {\n                this._CalculateModelViewMatrix(renderer, this._modelViewMatrix, 0, 0, null);\n                this._isMVMatrixChanged = false\n            }\n            return this._modelViewMatrix\n        }\n        GetCameraPosition() {\n            if (this.Has3DCamera()) {\n                const camPos = this.GetLayout().Get3DCameraPosition();\n                return [camPos[0], camPos[1], camPos[2]]\n            } else\n                return this._Get2DCameraPosition()\n        }\n        _Get2DCameraPosition(offX=0, offY=0, viewH=0) {\n            const runtime = this._runtime;\n            const layout = this.GetLayout();\n            const parallaxOriginX = runtime.GetParallaxXOrigin();\n            const parallaxOriginY = runtime.GetParallaxYOrigin();\n            let scrollOriginX = (this.GetScrollX() - parallaxOriginX) * this._parallaxX + parallaxOriginX;\n            let scrollOriginY = (this.GetScrollY() - parallaxOriginY) * this._parallaxY + parallaxOriginY;\n            if (runtime.IsPixelRoundingEnabled()) {\n                scrollOriginX = Math.round(scrollOriginX);\n                scrollOriginY = Math.round(scrollOriginY)\n            }\n            let camX = scrollOriginX + offX;\n            let camY = scrollOriginY + offY;\n            const camZ = layout.IsOrthographicProjection() ? this.GetDefaultCameraZ(viewH) : this.GetCameraZ(viewH);\n            const [vpX,vpY] = this._GetVanishingPoint();\n            if (vpX !== .5 || vpY !== .5) {\n                const zf = this.GetDefaultCameraZ(viewH) \/ camZ;\n                let camOffX = (vpX - .5) * runtime.GetViewportWidth() \/ zf;\n                let camOffY = (vpY - .5) * runtime.GetViewportHeight() \/ zf;\n                const a = this.GetAngle();\n                if (a !== 0) {\n                    tempVec2.set(camOffX, camOffY);\n                    tempVec2.rotate(a);\n                    camOffX = tempVec2.getX();\n                    camOffY = tempVec2.getY()\n                }\n                camX += camOffX;\n                camY += camOffY\n            }\n            return [camX, camY, camZ]\n        }\n        _CalculateModelViewMatrix(renderer, outMat, offX, offY, viewH) {\n            const runtime = this._runtime;\n            const layout = this.GetLayout();\n            if (this.Has3DCamera()) {\n                vec3.copy(camVector, layout.Get3DCameraPosition());\n                vec3.copy(lookVector, layout.Get3DCameraLookAt());\n                vec3.copy(upVector, layout.Get3DCameraUpVector());\n                const parallaxOriginX = runtime.GetParallaxXOrigin();\n                const parallaxOriginY = runtime.GetParallaxYOrigin();\n                const lookDx = lookVector[0] - camVector[0];\n                const lookDy = lookVector[1] - camVector[1];\n                const lookDz = lookVector[2] - camVector[2];\n                camVector[0] = (camVector[0] - parallaxOriginX) * this._parallaxX + parallaxOriginX;\n                camVector[1] = (camVector[1] - parallaxOriginY) * this._parallaxY + parallaxOriginY;\n                camVector[2] *= Math.max(this._parallaxX, this._parallaxY);\n                lookVector[0] = camVector[0] + lookDx;\n                lookVector[1] = camVector[1] + lookDy;\n                lookVector[2] = camVector[2] + lookDz\n            } else {\n                const [camX,camY,camZ] = this._Get2DCameraPosition(offX, offY, viewH);\n                vec3.set(camVector, camX, camY, camZ);\n                vec3.set(lookVector, camX, camY, camZ - 100);\n                const a = this.GetAngle();\n                if (a === 0)\n                    vec3.set(upVector, 0, 1, 0);\n                else\n                    vec3.set(upVector, Math.sin(a), Math.cos(a), 0)\n            }\n            renderer.CalculateLookAtModelView(outMat, camVector, lookVector, upVector, viewH || runtime.GetViewportHeight())\n        }\n        _SetProjectionMatrixChanged() {\n            this._isProjectionMatrixChanged = true;\n            this._isViewFrustumChanged = true;\n            this._isViewportChanged = true\n        }\n        _GetProjectionMatrix(renderer) {\n            if (this._isProjectionMatrixChanged) {\n                this._CalculateProjectionMatrix(renderer);\n                this._isProjectionMatrixChanged = false\n            }\n            return this._projectionMatrix\n        }\n        _CalculateProjectionMatrix(renderer) {\n            const canvasManager = this._runtime.GetCanvasManager();\n            const [vpX,vpY] = this._GetVanishingPoint();\n            if (this._layout.IsOrthographicProjection())\n                renderer.CalculateOrthographicMatrix(this._projectionMatrix, canvasManager.GetDrawWidth(), canvasManager.GetDrawHeight());\n            else if (vpX === .5 && vpY === .5)\n                mat4.copy(this._projectionMatrix, canvasManager.GetDefaultProjectionMatrix());\n            else {\n                const drawW = canvasManager.GetDrawWidth();\n                const drawH = canvasManager.GetDrawHeight();\n                renderer.CalculatePerspectiveMatrix(this._projectionMatrix, drawW \/ drawH, vpX, vpY)\n            }\n        }\n        _SetTransform(renderer, updateProjection=true, offX=0, offY=0, viewH=0) {\n            if (updateProjection)\n                renderer.SetProjectionMatrix(this._GetProjectionMatrix(renderer));\n            let modelViewMatrix = null;\n            if (offX === 0 && offY === 0 && viewH === 0)\n                modelViewMatrix = this._GetModelViewMatrix(renderer);\n            else {\n                this._CalculateModelViewMatrix(renderer, tempMat4, offX, offY, viewH);\n                modelViewMatrix = tempMat4\n            }\n            renderer.SetModelViewMatrix(modelViewMatrix)\n        }\n        PrepareForDraw(renderer) {\n            this._SetTransform(renderer);\n            renderer.SetBaseZ(this.GetZElevation())\n        }\n        Draw(renderer, destinationRenderTarget, isFirstToTarget) {\n            const canvasManager = this._runtime.GetCanvasManager();\n            const useOwnTexture = this.UsesOwnTexture();\n            let ownRenderTarget = null;\n            let layerQuery = null;\n            if (this._runtime.IsGPUProfiling())\n                if (renderer.IsWebGL()) {\n                    const timingsBuffer = canvasManager.GetLayerTimingsBuffer(this);\n                    if (timingsBuffer) {\n                        layerQuery = timingsBuffer.AddTimeElapsedQuery();\n                        renderer.StartQuery(layerQuery)\n                    }\n                } else if (renderer.IsWebGPU())\n                    renderer.WriteTimestamp((this.GetIndex() + 1) * 2);\n            if (useOwnTexture) {\n                const rtOpts = {\n                    sampling: this._runtime.GetSampling(),\n                    isSampled: true,\n                    canReadPixels: renderer.IsWebGPU() ? this._runtime.UsesAnyBackgroundBlending() : false\n                };\n                if (canvasManager.GetCurrentFullscreenScalingQuality() === "low") {\n                    rtOpts.width = canvasManager.GetDrawWidth();\n                    rtOpts.height = canvasManager.GetDrawHeight()\n                }\n                ownRenderTarget = this._runtime.GetAdditionalRenderTarget(rtOpts);\n                this._curRenderTarget = ownRenderTarget;\n                renderer.SetRenderTarget(ownRenderTarget);\n                if (this.IsTransparent())\n                    renderer.ClearRgba(0, 0, 0, 0)\n            } else {\n                this._curRenderTarget = destinationRenderTarget;\n                renderer.SetRenderTarget(destinationRenderTarget)\n            }\n            if (!this.IsTransparent())\n                renderer.Clear(this._backgroundColor);\n            this._layout._DrawLayerList(renderer, this._curRenderTarget, this._subLayers, useOwnTexture && this.IsTransparent());\n            this._SetTransform(renderer);\n            renderer.SetBaseZ(this.GetZElevation());\n            renderer.SetDepthEnabled(this.RendersIn3DMode());\n            if (this.GetNormalScale() > Number.EPSILON) {\n                this._UpdateZIndices();\n                const useRenderCells = this.UsesRenderCells() && this.GetZElevation() === 0 && !this._anyInstanceZElevated;\n                if (this.Has3DCamera())\n                    this._DrawInstances_3DCamera(renderer);\n                else if (useRenderCells)\n                    this._DrawInstances_RenderCells(renderer);\n                else\n                    this._DrawInstances(renderer, this._GetInstancesInDrawOrder())\n            }\n            renderer.SetBaseZ(0);\n            renderer.SetCurrentZ(0);\n            if (useOwnTexture) {\n                renderer.SetDepthEnabled(false);\n                this._DrawLayerOwnTextureToRenderTarget(renderer, ownRenderTarget, destinationRenderTarget, isFirstToTarget)\n            }\n            if (layerQuery)\n                renderer.EndQuery(layerQuery);\n            if (this._runtime.IsGPUProfiling() && renderer.IsWebGPU())\n                renderer.WriteTimestamp((this.GetIndex() + 1) * 2 + 1);\n            this._curRenderTarget = null\n        }\n        _DrawInstances(renderer, instances) {\n            const viewport = this.GetViewport();\n            const renderTarget = this._curRenderTarget;\n            const isOrthographic = this.GetLayout().IsOrthographicProjection();\n            const hasVanishingPointOutsideViewport = this.GetLayout().HasVanishingPointOutsideViewport();\n            let lastInst = null;\n            for (let i = 0, len = instances.length; i < len; ++i) {\n                const inst = instances[i];\n                if (inst === lastInst)\n                    continue;\n                lastInst = inst;\n                const wi = inst.GetWorldInfo();\n                if (wi.IsVisible() && wi.IsInViewport(viewport, hasVanishingPointOutsideViewport, isOrthographic))\n                    this._DrawInstanceMaybeWithEffects(inst, wi, renderer, renderTarget)\n            }\n        }\n        _DrawInstances_3DCamera(renderer) {\n            const renderTarget = this._curRenderTarget;\n            const viewFrustum = this._GetViewFrustum();\n            const coplanarInstances = tempInstanceList1;\n            const postRenderInstances = tempInstanceList2;\n            const instances = this._GetInstancesInDrawOrder();\n            for (let i = 0, len = instances.length; i < len; ) {\n                const inst = instances[i];\n                const wi = inst.GetWorldInfo();\n                if (!wi.IsVisible() || !wi.IsInViewport3D(viewFrustum)) {\n                    ++i;\n                    continue\n                }\n                if (!inst.RendersToOwnZPlane() || wi.GetDepth() > 0)\n                    postRenderInstances.push(inst);\n                const startZ = inst.GetWorldInfo().GetTotalZElevation();\n                coplanarInstances.push(inst);\n                let endIndex = i + 1;\n                for (; endIndex < len; ++endIndex) {\n                    const nextInst = instances[endIndex];\n                    const nextWi = nextInst.GetWorldInfo();\n                    if (!nextWi.IsVisible() || !nextWi.IsInViewport3D(viewFrustum))\n                        continue;\n                    if (nextWi.GetTotalZElevation() !== startZ)\n                        break;\n                    if (!nextInst.RendersToOwnZPlane()) {\n                        postRenderInstances.push(nextInst);\n                        continue\n                    }\n                    if (nextWi.GetDepth() > 0)\n                        postRenderInstances.push(nextInst);\n                    coplanarInstances.push(nextInst)\n                }\n                if (coplanarInstances.length === 1 && !coplanarInstances[0].MustMitigateZFighting()) {\n                    this._DrawInstanceMaybeWithEffects(inst, wi, renderer, renderTarget);\n                    for (let j = 0, lenj = postRenderInstances.length; j < lenj; ++j) {\n                        const postInst = postRenderInstances[j];\n                        if (postInst === inst)\n                            continue;\n                        const postWi = postInst.GetWorldInfo();\n                        const postWiLayer = postWi.GetLayer();\n                        postWiLayer._DrawInstanceMaybeWithEffects(postInst, postWi, renderer, renderTarget)\n                    }\n                } else {\n                    this._DrawCoplanarInstances_3DCamera(renderer, coplanarInstances);\n                    for (let j = 0, lenj = postRenderInstances.length; j < lenj; ++j) {\n                        const postInst = postRenderInstances[j];\n                        const postWi = postInst.GetWorldInfo();\n                        postWi._SetDrawNonBackFacesOnly(true);\n                        this._DrawInstanceMaybeWithEffects(postInst, postWi, renderer, renderTarget);\n                        postWi._SetDrawNonBackFacesOnly(false)\n                    }\n                }\n                i = endIndex;\n                C3.clearArray(coplanarInstances);\n                C3.clearArray(postRenderInstances)\n            }\n        }\n        _DrawCoplanarInstances_3DCamera(renderer, instances) {\n            const renderTarget = this._curRenderTarget;\n            renderer.CoplanarStartStencilPass();\n            for (let i = 0, len = instances.length; i < len; ++i) {\n                const inst = instances[i];\n                const wi = inst.GetWorldInfo();\n                wi._SetDrawBackFaceOnly(true);\n                this._DrawInstance(inst, wi, renderer)\n            }\n            renderer.CoplanarStartColorPass();\n            for (let i = 0, len = instances.length; i < len; ++i) {\n                const inst = instances[i];\n                const wi = inst.GetWorldInfo();\n                this._DrawInstanceMaybeWithEffects(inst, wi, renderer, renderTarget);\n                wi._SetDrawBackFaceOnly(false)\n            }\n            renderer.CoplanarRestoreStandardRendering()\n        }\n        _DrawInstances_RenderCells(renderer) {\n            const renderGrid = this._renderGrid;\n            const curRenderCells = this._curRenderCells;\n            const lastRenderCells = this._lastRenderCells;\n            const viewport = this.GetViewport();\n            let instancesToDraw;\n            curRenderCells.set(renderGrid.XToCell(viewport.getLeft()), renderGrid.YToCell(viewport.getTop()), renderGrid.XToCell(viewport.getRight()), renderGrid.YToCell(viewport.getBottom()));\n            if (!this._isRenderListUpToDate || !curRenderCells.equals(lastRenderCells)) {\n                instancesToDraw = this._GetRenderCellInstancesToDraw();\n                this._isRenderListUpToDate = true;\n                lastRenderCells.copy(curRenderCells)\n            } else\n                instancesToDraw = this._lastRenderList;\n            this._DrawInstances(renderer, instancesToDraw);\n            if (instancesToDraw !== this._lastRenderList)\n                C3.shallowAssignArray(this._lastRenderList, instancesToDraw)\n        }\n        _DrawInstanceMaybeWithEffects(inst, wi, renderer, renderTarget) {\n            if (wi.HasAnyActiveEffect())\n                this._DrawInstanceWithEffectsAndRestore(inst, wi, renderer, renderTarget);\n            else\n                this._DrawInstance(inst, wi, renderer)\n        }\n        _DrawInstance(inst, wi, renderer) {\n            const wiStateGroup = wi.GetRendererStateGroup();\n            if (renderer.GetCurrentStateGroup() !== wiStateGroup)\n                wiStateGroup.Apply();\n            inst.Draw(renderer)\n        }\n        _DrawInstanceWithEffectsAndRestore(inst, wi, renderer, renderTarget) {\n            if (this._DrawInstanceWithEffects(inst, wi, renderer, renderTarget, null))\n                this._SetTransform(renderer)\n        }\n        _DrawInstanceWithEffects(inst, wi, renderer, renderTarget, opts) {\n            const effectChain = wi.GetInstanceEffectList().GetEffectChain();\n            effectChain.Render(renderer, renderTarget, {\n                contentObject: inst,\n                blendMode: wi.GetBlendMode(),\n                devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(),\n                time: inst.GetInstanceGameTime(),\n                layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetNormalScale(),\n                layerAngle: this.GetAngle(),\n                layoutRect: wi.GetBoundingBox(),\n                drawSurfaceRect: effectChain.CanSkipCalculatingDrawSurfaceRect() ? null : this._InstanceBoxToDrawSurface(wi),\n                drawContentHook: opts && opts.drawContentHook,\n                compositOffX: opts && opts.compositOffX,\n                compositOffY: opts && opts.compositOffY,\n                updateOwnProjection: opts && opts.updateOwnProjection\n            });\n            renderer.SetBaseZ(this.GetZElevation());\n            return effectChain.DidChangeTransform()\n        }\n        _DrawLayerOwnTextureToRenderTarget(renderer, ownRenderTarget, destinationRenderTarget, isFirstToTarget) {\n            const activeEffectTypes = this._effectList.GetActiveEffectTypes();\n            const runtime = this._runtime;\n            if (activeEffectTypes.length === 0) {\n                renderer.SetRenderTarget(destinationRenderTarget);\n                renderer.SetTextureFillMode();\n                if (isFirstToTarget && this._blendMode === 0 && this.HasDefaultColor())\n                    renderer.CopyRenderTarget(ownRenderTarget);\n                else {\n                    renderer.SetBlendMode(this._blendMode);\n                    renderer.SetColor(this._premultipliedColor);\n                    renderer.DrawRenderTarget(ownRenderTarget)\n                }\n                renderer.InvalidateRenderTarget(ownRenderTarget);\n                runtime.ReleaseAdditionalRenderTarget(ownRenderTarget)\n            } else\n                this.GetEffectChain().Render(renderer, destinationRenderTarget, {\n                    contentObject: this,\n                    blendMode: this.GetBlendMode(),\n                    devicePixelRatio: runtime.GetEffectDevicePixelRatioParam(),\n                    layerScale: runtime.GetEffectLayerScaleParam() * this.GetNormalScale(),\n                    layerAngle: this.GetAngle(),\n                    layoutRect: this.GetViewport(),\n                    drawSurfaceRect: null,\n                    invalidateRenderTargets: true\n                })\n        }\n        GetOwnScale() {\n            return this._scale\n        }\n        SetOwnScale(s) {\n            if (this._scale === s)\n                return;\n            this._scale = s;\n            this._layout.BoundScrolling();\n            this._SetMVMatrixChanged();\n            this._runtime.UpdateRender()\n        }\n        GetRenderScale() {\n            return this.GetNormalScale() * this._runtime.GetRenderScale()\n        }\n        GetDisplayScale() {\n            return this.GetNormalScale() * this._runtime.GetDisplayScale()\n        }\n        GetNormalScale() {\n            return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1\n        }\n        _MaybeUpdateViewport() {\n            if (!this._isViewportChanged)\n                return;\n            this._isViewportChanged = false;\n            const parallaxOriginX = this._runtime.GetParallaxXOrigin();\n            const parallaxOriginY = this._runtime.GetParallaxYOrigin();\n            const scrollOriginX = (this.GetScrollX() - parallaxOriginX) * this._parallaxX + parallaxOriginX;\n            const scrollOriginY = (this.GetScrollY() - parallaxOriginY) * this._parallaxY + parallaxOriginY;\n            const normalScale = this.GetNormalScale();\n            const scaledViewportWidth = this._runtime.GetViewportWidth() \/ normalScale;\n            const scaledViewportHeight = this._runtime.GetViewportHeight() \/ normalScale;\n            let px = scrollOriginX - scaledViewportWidth \/ 2;\n            let py = scrollOriginY - scaledViewportHeight \/ 2;\n            if (this._runtime.IsPixelRoundingEnabled()) {\n                px = Math.round(px);\n                py = Math.round(py)\n            }\n            const viewportZ0 = this._viewportZ0;\n            viewportZ0.set(px, py, px + scaledViewportWidth, py + scaledViewportHeight);\n            const myAngle = this.GetAngle();\n            if (myAngle !== 0) {\n                tmpRect.copy(viewportZ0);\n                tmpRect.offset(-viewportZ0.midX(), -viewportZ0.midY());\n                tmpQuad.setFromRotatedRect(tmpRect, myAngle);\n                tmpQuad.getBoundingBox(tmpRect);\n                tmpRect.offset(viewportZ0.midX(), viewportZ0.midY());\n                viewportZ0.copy(tmpRect)\n            }\n            const layerZ = this._zElevation;\n            this.GetViewportForZ(layerZ, this._viewport);\n            if (this.Has3DCamera())\n                this.CalculateViewport3D(layerZ, this._viewport3D);\n            else\n                this._viewport3D.copy(this._viewport)\n        }\n        CalculateViewport3D(z, outRect) {\n            const canvasManager = this._runtime.GetCanvasManager();\n            const canvasWidth = canvasManager.GetCssWidth();\n            const canvasHeight = canvasManager.GetCssHeight();\n            const [tlx,tly] = this.CanvasCssToLayer(0, 0, z);\n            const [trx,try_] = this.CanvasCssToLayer(canvasWidth, 0, z);\n            const [brx,bry] = this.CanvasCssToLayer(canvasWidth, canvasHeight, z);\n            const [blx,bly] = this.CanvasCssToLayer(0, canvasHeight, z);\n            let left = Math.min(tlx, trx, brx, blx);\n            let top = Math.min(tly, try_, bry, bly);\n            let right = Math.max(tlx, trx, brx, blx);\n            let bottom = Math.max(tly, try_, bry, bly);\n            if (!isFinite(left))\n                left = -Infinity;\n            if (!isFinite(top))\n                top = -Infinity;\n            if (!isFinite(right))\n                right = Infinity;\n            if (!isFinite(bottom))\n                bottom = Infinity;\n            outRect.set(left, top, right, bottom)\n        }\n        CanvasCssToLayer(ptx, pty, z=0) {\n            return this._CanvasToLayer(ptx, pty, z, this.GetDisplayScale())\n        }\n        DrawSurfaceToLayer(ptx, pty, z=0) {\n            return this._CanvasToLayer(ptx, pty, z, this.GetRenderScale() * this.GetDevicePixelRatio())\n        }\n        _CanvasToLayer(canvasX, canvasY, zElevation, displayScale) {\n            const runtime = this._runtime;\n            const renderer = runtime.GetRenderer();\n            const normalScale = this.GetNormalScale();\n            const scaledViewportWidth = runtime.GetViewportWidth() \/ normalScale;\n            const scaledViewportHeight = runtime.GetViewportHeight() \/ normalScale;\n            const viewport = tempVec4;\n            vec4.set(viewport, 0, 0, scaledViewportWidth, scaledViewportHeight);\n            canvasX = canvasX \/ displayScale;\n            canvasY = viewport[3] - canvasY \/ displayScale;\n            const matP = this._GetProjectionMatrix(renderer);\n            const matMV = this._GetModelViewMatrix(renderer);\n            const objectCoord = tempVec3;\n            const result = C3.Gfx.UnprojectScreenToWorldZ(canvasX, canvasY, zElevation, matMV, matP, viewport, objectCoord);\n            if (result)\n                return [objectCoord[0], objectCoord[1]];\n            else\n                return [NaN, NaN]\n        }\n        CanvasCssToLayer_DefaultTransform(ptx, pty) {\n            const scale = this._scale;\n            const scaleRate = this._scaleRate;\n            const parallaxX = this._parallaxX;\n            const parallaxY = this._parallaxY;\n            const angle = this._angle;\n            this._scale = 1;\n            this._scaleRate = 1;\n            this._parallaxX = 1;\n            this._parallaxY = 1;\n            this._angle = 0;\n            this._SetMVMatrixChanged();\n            const ret = this.CanvasCssToLayer(ptx, pty);\n            this._scale = scale;\n            this._scaleRate = scaleRate;\n            this._parallaxX = parallaxX;\n            this._parallaxY = parallaxY;\n            this._angle = angle;\n            this._SetMVMatrixChanged();\n            return ret\n        }\n        LayerToCanvasCss(ptx, pty, z=0) {\n            return this._LayerToCanvas(ptx, pty, z, this.GetDisplayScale())\n        }\n        LayerToDrawSurface(ptx, pty, z=0) {\n            return this._LayerToCanvas(ptx, pty, z, this.GetRenderScale() * this.GetDevicePixelRatio())\n        }\n        _LayerToCanvas(layerX, layerY, zElevation, displayScale) {\n            const runtime = this._runtime;\n            const renderer = runtime.GetRenderer();\n            const normalScale = this.GetNormalScale();\n            const scaledViewportWidth = runtime.GetViewportWidth() \/ normalScale;\n            const scaledViewportHeight = runtime.GetViewportHeight() \/ normalScale;\n            const viewport = tempVec4;\n            vec4.set(viewport, 0, 0, scaledViewportWidth, scaledViewportHeight);\n            const matP = this._GetProjectionMatrix(renderer);\n            const matMV = this._GetModelViewMatrix(renderer);\n            const windowCoord = tempVec3;\n            const result = C3.Gfx.Project(layerX, layerY, zElevation, matMV, matP, viewport, windowCoord);\n            if (result)\n                return [windowCoord[0] * displayScale, (viewport[3] - windowCoord[1]) * displayScale];\n            else\n                return [NaN, NaN]\n        }\n        _GetLayerToDrawSurfaceScale(size, zElevation) {\n            size *= this.GetRenderScale() * this.GetDevicePixelRatio();\n            if (zElevation !== 0)\n                size *= this.Get2DScaleFactorToZ(zElevation);\n            return size\n        }\n        _InstanceBoxToDrawSurface(wi) {\n            const bbox = wi.GetBoundingBox();\n            const z = wi.GetTotalZElevation();\n            const depth = wi.GetDepth();\n            const topZ = z + depth;\n            const bbLeft = bbox.getLeft();\n            const bbTop = bbox.getTop();\n            const bbRight = bbox.getRight();\n            const bbBottom = bbox.getBottom();\n            if (this.Has3DCamera()) {\n                if (this._IsPointBehindNearPlane(bbLeft, bbTop, z) || this._IsPointBehindNearPlane(bbRight, bbTop, z) || this._IsPointBehindNearPlane(bbRight, bbBottom, z) || this._IsPointBehindNearPlane(bbLeft, bbBottom, z))\n                    return null;\n                if (depth > 0)\n                    if (this._IsPointBehindNearPlane(bbLeft, bbTop, topZ) || this._IsPointBehindNearPlane(bbRight, bbTop, topZ) || this._IsPointBehindNearPlane(bbRight, bbBottom, topZ) || this._IsPointBehindNearPlane(bbLeft, bbBottom, topZ))\n                        return null\n            } else if (topZ >= this.GetCameraZ())\n                return null;\n            let[stlx,stly] = this.LayerToDrawSurface(bbLeft, bbTop, z);\n            let[sbrx,sbry] = this.LayerToDrawSurface(bbRight, bbBottom, z);\n            if (this.GetAngle() !== 0 || depth > 0 || this.Has3DCamera()) {\n                const [strx,stry] = this.LayerToDrawSurface(bbRight, bbTop, z);\n                const [sblx,sbly] = this.LayerToDrawSurface(bbLeft, bbBottom, z);\n                if (depth > 0) {\n                    const [stlxTop,stlyTop] = this.LayerToDrawSurface(bbLeft, bbTop, topZ);\n                    const [strxTop,stryTop] = this.LayerToDrawSurface(bbRight, bbTop, topZ);\n                    const [sbrxTop,sbryTop] = this.LayerToDrawSurface(bbRight, bbBottom, topZ);\n                    const [sblxTop,sblyTop] = this.LayerToDrawSurface(bbLeft, bbBottom, topZ);\n                    let temp = Math.min(stlx, sbrx, strx, sblx, stlxTop, strxTop, sbrxTop, sblxTop);\n                    sbrx = Math.max(stlx, sbrx, strx, sblx, stlxTop, strxTop, sbrxTop, sblxTop);\n                    stlx = temp;\n                    temp = Math.min(stly, sbry, stry, sbly, stlyTop, stryTop, sbryTop, sblyTop);\n                    sbry = Math.max(stly, sbry, stry, sbly, stlyTop, stryTop, sbryTop, sblyTop);\n                    stly = temp\n                } else {\n                    let temp = Math.min(stlx, sbrx, strx, sblx);\n                    sbrx = Math.max(stlx, sbrx, strx, sblx);\n                    stlx = temp;\n                    temp = Math.min(stly, sbry, stry, sbly);\n                    sbry = Math.max(stly, sbry, stry, sbly);\n                    stly = temp\n                }\n            }\n            tmpRect.set(stlx, stly, sbrx, sbry);\n            return tmpRect\n        }\n        _GetViewFrustum() {\n            if (this._isViewFrustumChanged) {\n                this._UpdateViewFrustum();\n                this._isViewFrustumChanged = false\n            }\n            return this._viewFrustum\n        }\n        _UpdateViewFrustum() {\n            const renderer = this._runtime.GetRenderer();\n            const matP = this._GetProjectionMatrix(renderer);\n            const matMV = this._GetModelViewMatrix(renderer);\n            this._viewFrustum.CalculatePlanes(matMV, matP)\n        }\n        _IsPointBehindNearPlane(x, y, z) {\n            return this._GetViewFrustum().IsBehindNearPlane(x, y, z)\n        }\n        _SaveToJson() {\n            const o = {\n                "s": this.GetOwnScale(),\n                "a": this.GetOwnAngle(),\n                "v": this._IsVisibleFlagSet(),\n                "i": this.IsInteractive(),\n                "bc": this._backgroundColor.toJSON(),\n                "t": this.IsTransparent(),\n                "sx": this._scrollX,\n                "sy": this._scrollY,\n                "hosp": this._hasOwnScrollPosition,\n                "px": this.GetParallaxX(),\n                "py": this.GetParallaxY(),\n                "c": this._color.toJSON(),\n                "sr": this.GetScaleRate(),\n                "fx": this._effectList.SaveToJson(),\n                "cg": this._createdGlobalUids\n            };\n            return o\n        }\n        _LoadFromJson(o) {\n            this._scale = o["s"];\n            this._angle = o["a"];\n            this._isVisible = !!o["v"];\n            this._isInteractive = o.hasOwnProperty("i") ? o["i"] : true;\n            this._backgroundColor.setFromJSON(o["bc"]);\n            this._isTransparent = !!o["t"];\n            if (o.hasOwnProperty("sx"))\n                this._scrollX = o["sx"];\n            if (o.hasOwnProperty("sy"))\n                this._scrollY = o["sy"];\n            if (o.hasOwnProperty("hosp"))\n                this._hasOwnScrollPosition = !!o["hosp"];\n            this._parallaxX = o["px"];\n            this._parallaxY = o["py"];\n            this._color.setFromJSON(o["c"]);\n            this._scaleRate = o["sr"];\n            C3.shallowAssignArray(this._createdGlobalUids, o["cg"]);\n            C3.shallowAssignArray(this._initialInstances, this._startupInitialInstances);\n            const tempSet = new Set(this._createdGlobalUids);\n            let j = 0;\n            for (let i = 0, len = this._initialInstances.length; i < len; ++i)\n                if (!tempSet.has(this._initialInstances[i][2])) {\n                    this._initialInstances[j] = this._initialInstances[i];\n                    ++j\n                }\n            C3.truncateArray(this._initialInstances, j);\n            this._effectList.LoadFromJson(o["fx"]);\n            this._needsRebuildEffectChainSteps = true;\n            this._SortInstancesByLastCachedZIndex(false);\n            this.SetZIndicesChanged();\n            this._SetMVMatrixChanged();\n            this._SetProjectionMatrixChanged()\n        }\n        GetILayer() {\n            return this._iLayer\n        }\n        SortAndAddInstancesByZIndex(inst) {\n            if (this._instances.includes(inst))\n                return;\n            if (inst.HasChildren()) {\n                const instances = [...inst.allChildren()];\n                instances.push(inst);\n                instances.sort( (f, s) => {\n                    const firstZIndex = f.GetWorldInfo().GetSceneGraphZIndex();\n                    const secondZIndex = s.GetWorldInfo().GetSceneGraphZIndex();\n                    return firstZIndex - secondZIndex\n                }\n                );\n                for (const instanceToAdd of instances) {\n                    if (!instanceToAdd.IsInContainer())\n                        continue;\n                    for (const instanceToAddSibling of instanceToAdd.siblings()) {\n                        if (instances.includes(instanceToAddSibling))\n                            continue;\n                        const siblingAndChildren = [...instanceToAddSibling.allChildren()];\n                        siblingAndChildren.push(instanceToAddSibling);\n                        siblingAndChildren.sort( (f, s) => {\n                            const firstZIndex = f.GetWorldInfo().GetSceneGraphZIndex();\n                            const secondZIndex = s.GetWorldInfo().GetSceneGraphZIndex();\n                            return firstZIndex - secondZIndex\n                        }\n                        );\n                        if (!siblingAndChildren || !siblingAndChildren.length)\n                            continue;\n                        instances.splice(instances.length, 0, ...siblingAndChildren)\n                    }\n                }\n                for (const instance of instances)\n                    this._AddInstance(instance, true)\n            } else {\n                this._AddInstance(inst, true);\n                if (!inst.IsInContainer())\n                    return;\n                for (const sibling of inst.siblings()) {\n                    const siblingAndChildren = [...sibling.allChildren()];\n                    siblingAndChildren.push(sibling);\n                    siblingAndChildren.sort( (f, s) => {\n                        const firstZIndex = f.GetWorldInfo().GetSceneGraphZIndex();\n                        const secondZIndex = s.GetWorldInfo().GetSceneGraphZIndex();\n                        return firstZIndex - secondZIndex\n                    }\n                    );\n                    if (!siblingAndChildren || !siblingAndChildren.length)\n                        continue;\n                    for (const instance of siblingAndChildren)\n                        this._AddInstance(instance, true)\n                }\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ layouts\/layout.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3Debugger = self.C3Debugger;\n    const assert = self.assert;\n    const tempDestRect = C3.New(C3.Rect);\n    const tempSrcRect = C3.New(C3.Rect);\n    const tempLayoutRect = C3.New(C3.Rect);\n    const tempColor = C3.New(C3.Color);\n    const glMatrix = self.glMatrix;\n    const vec3 = glMatrix.vec3;\n    const tempRender3dList = [];\n    const tempInstanceList1 = [];\n    const tempInstanceList2 = [];\n    const tempInstanceList3 = [];\n    function vec3EqualsXYZ(v, x, y, z) {\n        return v[0] === Math.fround(x) && v[1] === Math.fround(y) && v[2] === Math.fround(z)\n    }\n    let lastLayerPreparedForDrawing = null;\n    function MaybePrepareLayerDraw(layer, renderer) {\n        if (lastLayerPreparedForDrawing === layer)\n            return;\n        layer.PrepareForDraw(renderer);\n        lastLayerPreparedForDrawing = layer\n    }\n    C3.Layout = class Layout extends C3.DefendedBase {\n        constructor(layoutManager, index, data) {\n            super();\n            this._layoutManager = layoutManager;\n            this._runtime = layoutManager.GetRuntime();\n            this._name = data[0];\n            this._originalWidth = data[1];\n            this._originalHeight = data[2];\n            this._width = data[1];\n            this._height = data[2];\n            this._isUnboundedScrolling = !!data[3];\n            this._isOrthographicProjection = !!data[4];\n            this._vanishingPointX = data[5];\n            this._vanishingPointY = data[6];\n            this._eventSheetName = data[7];\n            this._eventSheet = null;\n            this._sid = data[8];\n            this._index = index;\n            this._scrollX = 0;\n            this._scrollY = 0;\n            this._scale = 1;\n            this._angle = 0;\n            this._initialObjectClasses = new Set;\n            this._textureLoadedTypes = new Set;\n            this._textureLoadPendingPromises = new Set;\n            this._createdInstances = [];\n            this._initialNonWorld = [];\n            this._is3dCameraEnabled = false;\n            this._cam3dposition = vec3.create();\n            this._cam3dlook = vec3.create();\n            this._cam3dup = vec3.create();\n            this._rootLayers = [];\n            this._allLayersFlat = [];\n            this._layersByName = new Map;\n            this._layersBySid = new Map;\n            const canvasManager = this._runtime.GetCanvasManager();\n            this._effectList = C3.New(C3.EffectList, this, data[11]);\n            this._effectChain = C3.New(C3.Gfx.EffectChain, canvasManager.GetEffectChainManager(), {\n                drawContent: (renderer, effectChain) => {\n                    const layout = effectChain.GetContentObject();\n                    const renderSurface = layout.GetRenderTarget();\n                    renderer.ResetColor();\n                    renderer.DrawRenderTarget(renderSurface);\n                    renderer.InvalidateRenderTarget(renderSurface);\n                    canvasManager.ReleaseAdditionalRenderTarget(renderSurface)\n                }\n                ,\n                getShaderParameters: index => this.GetEffectList()._GetEffectChainShaderParametersForIndex(index)\n            });\n            this._needsRebuildEffectChainSteps = true;\n            this._wasFullScreenQualityLow = false;\n            this._curRenderTarget = null;\n            this._persistData = {};\n            this._isFirstVisit = true;\n            this._iLayout = new self.ILayout(this);\n            this._userScriptDispatcher = C3.New(C3.Event.Dispatcher);\n            for (const layerData of data[9])\n                this._rootLayers.push(C3.New(C3.Layer, this, null, layerData));\n            this._allLayersFlat = [...this.allLayers()];\n            for (let i = 0, len = this._allLayersFlat.length; i < len; ++i) {\n                const layer = this._allLayersFlat[i];\n                layer._SetIndex(i);\n                layer._Init();\n                this._layersByName.set(layer.GetName().toLowerCase(), layer);\n                this._layersBySid.set(layer.GetSID(), layer)\n            }\n            for (const instData of data[10]) {\n                const objectClass = this._runtime.GetObjectClassByIndex(instData[1]);\n                if (!objectClass)\n                    throw new Error("missing nonworld object class");\n                if (!objectClass.GetDefaultInstanceData())\n                    objectClass.SetDefaultInstanceData(instData);\n                this._initialNonWorld.push(instData);\n                this._AddInitialObjectClass(objectClass)\n            }\n        }\n        Release() {\n            for (const l of this._allLayersFlat)\n                l.Release();\n            C3.clearArray(this._allLayersFlat);\n            this._textureLoadPendingPromises.clear();\n            this._eventSheet = null;\n            this._layoutManager = null;\n            this._runtime = null\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetName() {\n            return this._name\n        }\n        GetSID() {\n            return this._sid\n        }\n        GetIndex() {\n            return this._index\n        }\n        GetEffectList() {\n            return this._effectList\n        }\n        GetEffectChain() {\n            this._MaybeRebuildEffectChainSteps();\n            return this._effectChain\n        }\n        _MaybeRebuildEffectChainSteps() {\n            const isFullscreenQualityLow = this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality() === "low";\n            if (!this._needsRebuildEffectChainSteps && this._wasFullScreenQualityLow === isFullscreenQualityLow)\n                return;\n            const activeEffectTypes = this.GetEffectList().GetActiveEffectTypes();\n            this._effectChain.BuildSteps(activeEffectTypes.map(e => e.GetShaderProgram()), {\n                indexMap: activeEffectTypes.map(e => e.GetIndex()),\n                forcePostDraw: isFullscreenQualityLow,\n                useFullSurface: true\n            });\n            this._needsRebuildEffectChainSteps = false;\n            this._wasFullScreenQualityLow = isFullscreenQualityLow\n        }\n        UpdateActiveEffects() {\n            this.GetEffectList().UpdateActiveEffects();\n            this._needsRebuildEffectChainSteps = true\n        }\n        GetMinLayerScale() {\n            let m = this._allLayersFlat[0].GetNormalScale();\n            for (let i = 1, len = this._allLayersFlat.length; i < len; ++i) {\n                const layer = this._allLayersFlat[i];\n                if (layer.GetParallaxX() === 0 && layer.GetParallaxY() === 0)\n                    continue;\n                m = Math.min(m, layer.GetNormalScale())\n            }\n            return m\n        }\n        _GetScrollBoundMarginHorizontal() {\n            return .5 * this._runtime.GetViewportWidth() \/ this.GetMinLayerScale()\n        }\n        _GetScrollBoundMarginVertical() {\n            return .5 * this._runtime.GetViewportHeight() \/ this.GetMinLayerScale()\n        }\n        GetScrollLeftBound() {\n            if (this.IsUnboundedScrolling())\n                return -Infinity;\n            else\n                return this._GetScrollBoundMarginHorizontal()\n        }\n        GetScrollRightBound() {\n            if (this.IsUnboundedScrolling())\n                return Infinity;\n            else\n                return this.GetWidth() - this._GetScrollBoundMarginHorizontal()\n        }\n        GetScrollTopBound() {\n            if (this.IsUnboundedScrolling())\n                return -Infinity;\n            else\n                return this._GetScrollBoundMarginVertical()\n        }\n        GetScrollBottomBound() {\n            if (this.IsUnboundedScrolling())\n                return Infinity;\n            else\n                return this.GetHeight() - this._GetScrollBoundMarginVertical()\n        }\n        SetScrollX(x) {\n            const lbound = this.GetScrollLeftBound();\n            const rbound = this.GetScrollRightBound();\n            if (x > rbound)\n                x = rbound;\n            if (x < lbound)\n                x = lbound;\n            if (this._scrollX !== x) {\n                this._scrollX = x;\n                this._SetAllLayersMVChanged();\n                this._runtime.UpdateRender()\n            }\n        }\n        GetScrollX() {\n            return this._scrollX\n        }\n        SetScrollY(y) {\n            const ubound = this.GetScrollTopBound();\n            const bbound = this.GetScrollBottomBound();\n            if (y > bbound)\n                y = bbound;\n            if (y < ubound)\n                y = ubound;\n            if (this._scrollY !== y) {\n                this._scrollY = y;\n                this._SetAllLayersMVChanged();\n                this._runtime.UpdateRender()\n            }\n        }\n        GetScrollY() {\n            return this._scrollY\n        }\n        IsUnboundedScrolling() {\n            return this._isUnboundedScrolling\n        }\n        BoundScrolling() {\n            this.SetScrollX(this.GetScrollX());\n            this.SetScrollY(this.GetScrollY());\n            for (const layer of this._allLayersFlat)\n                if (layer.IsOwnScrollPositionEnabled()) {\n                    layer.SetScrollX(layer.GetScrollX());\n                    layer.SetScrollY(layer.GetScrollY())\n                }\n        }\n        SetVanishingPointXY(vpX, vpY) {\n            if (this._vanishingPointX === vpX && this._vanishingPointY === vpY)\n                return;\n            this._vanishingPointX = vpX;\n            this._vanishingPointY = vpY;\n            if (this.IsPerspectiveProjection()) {\n                this._SetAllLayersProjectionChanged();\n                this._SetAllLayersMVChanged();\n                this._runtime.UpdateRender()\n            }\n        }\n        GetVanishingPointX() {\n            if (this.IsOrthographicProjection())\n                return .5;\n            else\n                return this._vanishingPointX\n        }\n        GetVanishingPointY() {\n            if (this.IsOrthographicProjection())\n                return .5;\n            else\n                return this._vanishingPointY\n        }\n        HasVanishingPointOutsideViewport() {\n            const vpX = this.GetVanishingPointX();\n            const vpY = this.GetVanishingPointY();\n            return vpX < 0 || vpX > 1 || vpY < 0 || vpY > 1\n        }\n        SetPerspectiveProjection() {\n            if (!this._isOrthographicProjection)\n                return;\n            this._isOrthographicProjection = false;\n            this._SetAllLayersProjectionChanged();\n            this._SetAllLayersMVChanged();\n            this._runtime.UpdateRender()\n        }\n        SetOrthographicProjection() {\n            if (this._isOrthographicProjection)\n                return;\n            this._isOrthographicProjection = true;\n            this._SetAllLayersProjectionChanged();\n            this._SetAllLayersMVChanged();\n            this._runtime.UpdateRender()\n        }\n        IsOrthographicProjection() {\n            return this._isOrthographicProjection\n        }\n        IsPerspectiveProjection() {\n            return !this.IsOrthographicProjection()\n        }\n        Set3DCameraEnabled(e) {\n            e = !!e;\n            if (this._is3dCameraEnabled === e)\n                return;\n            this._is3dCameraEnabled = e;\n            this._SetAllLayersMVChanged();\n            this._runtime.UpdateRender()\n        }\n        Is3DCameraEnabled() {\n            return this._is3dCameraEnabled\n        }\n        Set3DCameraOrientation(camX, camY, camZ, lookX, lookY, lookZ, upX, upY, upZ) {\n            if (vec3EqualsXYZ(this._cam3dposition, camX, camY, camZ) && vec3EqualsXYZ(this._cam3dlook, lookX, lookY, lookZ) && vec3EqualsXYZ(this._cam3dup, upX, upY, upZ))\n                return;\n            vec3.set(this._cam3dposition, camX, camY, camZ);\n            vec3.set(this._cam3dlook, lookX, lookY, lookZ);\n            vec3.set(this._cam3dup, upX, upY, upZ);\n            this.Set3DCameraChanged()\n        }\n        Set3DCameraChanged() {\n            this._SetAllLayersMVChanged();\n            this._runtime.UpdateRender()\n        }\n        Get3DCameraPosition() {\n            return this._cam3dposition\n        }\n        Get3DCameraLookAt() {\n            return this._cam3dlook\n        }\n        Get3DCameraUpVector() {\n            return this._cam3dup\n        }\n        GetScale() {\n            return this._scale\n        }\n        SetScale(s) {\n            if (this._scale === s)\n                return;\n            this._scale = s;\n            this._SetAllLayersMVChanged();\n            this.BoundScrolling();\n            this._runtime.UpdateRender()\n        }\n        SetAngle(a) {\n            a = C3.clampAngle(a);\n            if (this._angle === a)\n                return;\n            this._angle = a;\n            this._SetAllLayersMVChanged();\n            this._runtime.UpdateRender()\n        }\n        GetAngle() {\n            return this._angle\n        }\n        GetWidth() {\n            return this._width\n        }\n        SetWidth(w) {\n            if (!isFinite(w) || w < 1)\n                return;\n            this._width = w\n        }\n        GetHeight() {\n            return this._height\n        }\n        SetHeight(h) {\n            if (!isFinite(h) || h < 1)\n                return;\n            this._height = h\n        }\n        GetEventSheet() {\n            return this._eventSheet\n        }\n        *allLayers() {\n            for (const rootLayer of this._rootLayers)\n                yield*rootLayer.selfAndAllSubLayers()\n        }\n        GetLayers() {\n            return this._allLayersFlat\n        }\n        GetLayerCount() {\n            return this._allLayersFlat.length\n        }\n        GetLayer(p) {\n            if (typeof p === "number")\n                return this.GetLayerByIndex(p);\n            else\n                return this.GetLayerByName(p.toString())\n        }\n        GetLayerByIndex(i) {\n            i = C3.clamp(Math.floor(i), 0, this._allLayersFlat.length - 1);\n            return this._allLayersFlat[i]\n        }\n        GetLayerByName(name) {\n            return this._layersByName.get(name.toLowerCase()) || null\n        }\n        GetLayerBySID(sid) {\n            return this._layersBySid.get(sid) || null\n        }\n        _SetAllLayersProjectionChanged() {\n            for (const layer of this._allLayersFlat)\n                layer._SetProjectionMatrixChanged()\n        }\n        _SetAllLayersMVChanged() {\n            for (const layer of this._allLayersFlat)\n                layer._SetMVMatrixChanged()\n        }\n        SaveTransform() {\n            return {\n                "scrollX": this.GetScrollX(),\n                "scrollY": this.GetScrollY(),\n                "scale": this.GetScale(),\n                "angle": this.GetAngle(),\n                "vpX": this.GetVanishingPointX(),\n                "vpY": this.GetVanishingPointY()\n            }\n        }\n        RestoreTransform(t) {\n            this.SetScrollX(t["scrollX"]);\n            this.SetScrollY(t["scrollY"]);\n            this.SetScale(t["scale"]);\n            this.SetAngle(t["angle"]);\n            this.SetVanishingPointXY(t["vpX"], t["vpY"])\n        }\n        GetLayoutBackgroundColor() {\n            let firstDrawLayer = this._rootLayers.filter(l => l.ShouldDraw())[0];\n            while (firstDrawLayer) {\n                if (!firstDrawLayer.IsTransparent()) {\n                    tempColor.copyRgb(firstDrawLayer.GetBackgroundColor());\n                    tempColor.setA(1);\n                    return tempColor\n                } else if (firstDrawLayer.UsesOwnTexture()) {\n                    tempColor.setRgba(0, 0, 0, 0);\n                    return tempColor\n                }\n                firstDrawLayer = firstDrawLayer.GetSubLayers().filter(l => l.ShouldDraw())[0]\n            }\n            tempColor.setRgba(0, 0, 0, 0);\n            return tempColor\n        }\n        IsFirstVisit() {\n            return this._isFirstVisit\n        }\n        _GetInitialObjectClasses() {\n            return [...this._initialObjectClasses]\n        }\n        _AddInitialObjectClass(objectClass) {\n            if (objectClass.IsInContainer())\n                for (const containerType of objectClass.GetContainer().GetObjectTypes())\n                    this._initialObjectClasses.add(containerType);\n            else\n                this._initialObjectClasses.add(objectClass)\n        }\n        _GetTextureLoadedObjectTypes() {\n            return [...this._textureLoadedTypes]\n        }\n        _Load(previousLayout, renderer) {\n            if (previousLayout === this || !renderer)\n                return Promise.resolve();\n            if (previousLayout) {\n                C3.CopySet(this._textureLoadedTypes, previousLayout._textureLoadedTypes);\n                previousLayout._textureLoadedTypes.clear()\n            }\n            const promises = [];\n            for (const oc of this._initialObjectClasses)\n                if (!this._textureLoadedTypes.has(oc)) {\n                    promises.push(oc.LoadTextures(renderer));\n                    this._textureLoadedTypes.add(oc)\n                }\n            return Promise.all(promises)\n        }\n        async MaybeLoadTexturesFor(objectClass) {\n            if (objectClass.IsFamily())\n                throw new Error("cannot load textures for family");\n            const renderer = this._runtime.GetRenderer();\n            if (!renderer || renderer.IsContextLost() || this._textureLoadedTypes.has(objectClass))\n                return;\n            this._textureLoadedTypes.add(objectClass);\n            const loadPromise = objectClass.LoadTextures(renderer);\n            this._AddPendingTextureLoadPromise(loadPromise);\n            await loadPromise;\n            objectClass.OnDynamicTextureLoadComplete();\n            this._runtime.UpdateRender()\n        }\n        _AddPendingTextureLoadPromise(promise) {\n            this._textureLoadPendingPromises.add(promise);\n            promise.then( () => this._textureLoadPendingPromises.delete(promise)).catch( () => this._textureLoadPendingPromises.delete(promise))\n        }\n        WaitForPendingTextureLoadsToComplete() {\n            return Promise.all([...this._textureLoadPendingPromises])\n        }\n        MaybeUnloadTexturesFor(objectClass) {\n            if (objectClass.IsFamily() || objectClass.GetInstanceCount() > 0)\n                throw new Error("cannot unload textures");\n            const renderer = this._runtime.GetRenderer();\n            if (!renderer || !this._textureLoadedTypes.has(objectClass))\n                return;\n            this._textureLoadedTypes.delete(objectClass);\n            objectClass.ReleaseTextures(renderer)\n        }\n        _Unload(nextLayout, renderer) {\n            if (nextLayout === this || !renderer)\n                return;\n            for (const oc of this._textureLoadedTypes)\n                if (!oc.IsGlobal() && !nextLayout._initialObjectClasses.has(oc)) {\n                    oc.ReleaseTextures();\n                    this._textureLoadedTypes.delete(oc)\n                }\n        }\n        _OnWebGLContextLost() {\n            this._textureLoadedTypes.clear()\n        }\n        async _StartRunning(isFirstLayout) {\n            const runtime = this._runtime;\n            const layoutManager = this._layoutManager;\n            const eventSheetManager = runtime.GetEventSheetManager();\n            if (this._eventSheetName) {\n                this._eventSheet = eventSheetManager.GetEventSheetByName(this._eventSheetName);\n                this._eventSheet._UpdateDeepIncludes()\n            }\n            layoutManager._SetMainRunningLayout(this);\n            this._width = this._originalWidth;\n            this._height = this._originalHeight;\n            this._scrollX = runtime.GetOriginalViewportWidth() \/ 2;\n            this._scrollY = runtime.GetOriginalViewportHeight() \/ 2;\n            this.BoundScrolling();\n            this._SetAllLayersProjectionChanged();\n            this._SetAllLayersMVChanged();\n            this._MoveGlobalObjectsToThisLayout(isFirstLayout);\n            this._runtime.SetUsingCreatePromises(true);\n            this._CreateInitialInstances();\n            if (!this._isFirstVisit)\n                this._CreatePersistedInstances();\n            this._CreateAndLinkContainerInstances(this._createdInstances);\n            this._CreateInitialNonWorldInstances();\n            layoutManager.ClearPendingChangeLayout();\n            runtime.FlushPendingInstances();\n            this._runtime.SetUsingCreatePromises(false);\n            const createPromises = this._runtime.GetCreatePromises();\n            await Promise.all(createPromises);\n            C3.clearArray(createPromises);\n            if (!runtime.IsLoadingState()) {\n                for (const inst of this._createdInstances)\n                    inst.SetupInitialSceneGraphConnections();\n                for (const inst of this._createdInstances)\n                    inst._TriggerOnCreated()\n            }\n            C3.clearArray(this._createdInstances);\n            await Promise.all([...this._initialObjectClasses].map(oc => oc.PreloadTexturesWithInstances(this._runtime.GetRenderer())));\n            if (isFirstLayout) {\n                runtime.Dispatcher().dispatchEvent(new C3.Event("beforefirstlayoutstart"));\n                await runtime.DispatchUserScriptEventAsyncWait(new C3.Event("beforeprojectstart"))\n            }\n            await this.DispatchUserScriptEventAsyncWait(new C3.Event("beforelayoutstart"));\n            if (!runtime.IsLoadingState())\n                await runtime.TriggerAsync(C3.Plugins.System.Cnds.OnLayoutStart, null, null);\n            runtime.Dispatcher().dispatchEvent(new C3.Event("afterlayoutstart"));\n            await this.DispatchUserScriptEventAsyncWait(new C3.Event("afterlayoutstart"));\n            if (isFirstLayout) {\n                runtime.Dispatcher().dispatchEvent(new C3.Event("afterfirstlayoutstart"));\n                await runtime.DispatchUserScriptEventAsyncWait(new C3.Event("afterprojectstart"))\n            }\n            eventSheetManager._RunQueuedTriggers(layoutManager);\n            await this.WaitForPendingTextureLoadsToComplete();\n            this._isFirstVisit = false\n        }\n        _MoveGlobalObjectsToThisLayout(isFirstLayout) {\n            for (const objectClass of this._runtime.GetAllObjectClasses()) {\n                if (objectClass.IsFamily() || !objectClass.IsWorldType())\n                    continue;\n                for (const inst of objectClass.GetInstances()) {\n                    const wi = inst.GetWorldInfo();\n                    const oldLayer = wi.GetLayer();\n                    const layerIndex = C3.clamp(oldLayer.GetIndex(), 0, this._allLayersFlat.length - 1);\n                    const newLayer = this._allLayersFlat[layerIndex];\n                    wi._SetLayer(newLayer);\n                    newLayer._MaybeAddInstance(inst)\n                }\n            }\n            if (!isFirstLayout)\n                for (const layer of this._allLayersFlat)\n                    layer._SortInstancesByLastCachedZIndex(false)\n        }\n        _CreateInitialInstances() {\n            for (const layer of this._allLayersFlat) {\n                layer.CreateInitialInstances(this._createdInstances);\n                layer._Start()\n            }\n        }\n        _CreatePersistedInstances() {\n            let uidsChanged = false;\n            for (const [sidStr,typeData] of Object.entries(this._persistData)) {\n                const objectClass = this._runtime.GetObjectClassBySID(parseInt(sidStr, 10));\n                if (!objectClass || objectClass.IsFamily() || !objectClass.HasPersistBehavior())\n                    continue;\n                for (const instData of typeData) {\n                    let layer = null;\n                    if (objectClass.IsWorldType()) {\n                        layer = this.GetLayerBySID(instData["w"]["l"]);\n                        if (!layer)\n                            continue\n                    }\n                    const inst = this._runtime.CreateInstanceFromData(objectClass, layer, false, 0, 0, true);\n                    inst.LoadFromJson(instData);\n                    uidsChanged = true;\n                    this._createdInstances.push(inst)\n                }\n                C3.clearArray(typeData)\n            }\n            for (const layer of this._allLayersFlat) {\n                layer._SortInstancesByLastCachedZIndex(true);\n                layer.SetZIndicesChanged()\n            }\n            if (uidsChanged) {\n                this._runtime.FlushPendingInstances();\n                this._runtime._RefreshUidMap()\n            }\n        }\n        _CreateAndLinkContainerInstances(createdInstances) {\n            for (const inst of createdInstances) {\n                if (!inst.IsInContainer())\n                    continue;\n                const wi = inst.GetWorldInfo();\n                const iid = inst.GetIID();\n                for (const containerType of inst.GetObjectClass().GetContainer().objectTypes()) {\n                    if (containerType === inst.GetObjectClass())\n                        continue;\n                    const instances = containerType.GetInstances();\n                    if (instances.length > iid)\n                        inst._AddSibling(instances[iid]);\n                    else {\n                        let s;\n                        if (wi)\n                            s = this._runtime.CreateInstanceFromData(containerType, wi.GetLayer(), true, wi.GetX(), wi.GetY(), true);\n                        else\n                            s = this._runtime.CreateInstanceFromData(containerType, null, true, 0, 0, true);\n                        this._runtime.FlushPendingInstances();\n                        containerType._UpdateIIDs();\n                        inst._AddSibling(s);\n                        createdInstances.push(s)\n                    }\n                }\n            }\n        }\n        _CreateInitialNonWorldInstances() {\n            for (const instData of this._initialNonWorld) {\n                const objectClass = this._runtime.GetObjectClassByIndex(instData[1]);\n                if (!objectClass.IsInContainer())\n                    this._runtime.CreateInstanceFromData(instData, null, true)\n            }\n        }\n        _CreateGlobalNonWorlds() {\n            const createdInstances = [];\n            const initialNonWorld = this._initialNonWorld;\n            let k = 0;\n            for (let i = 0, len = initialNonWorld.length; i < len; ++i) {\n                const instData = initialNonWorld[i];\n                const objectClass = this._runtime.GetObjectClassByIndex(instData[1]);\n                if (objectClass.IsGlobal()) {\n                    if (!objectClass.IsInContainer() || !objectClass.GetContainer().HasAnyWorldType())\n                        createdInstances.push(this._runtime.CreateInstanceFromData(instData, null, true))\n                } else {\n                    initialNonWorld[k] = instData;\n                    ++k\n                }\n            }\n            C3.truncateArray(initialNonWorld, k);\n            this._runtime.FlushPendingInstances();\n            this._CreateAndLinkContainerInstances(createdInstances)\n        }\n        RecreateInitialObjects(objectClass, rc, srcLayer, offsetX, offsetY, createHierarchy) {\n            if (srcLayer)\n                return srcLayer.RecreateInitialObjects(objectClass, rc, offsetX, offsetY, createHierarchy);\n            else {\n                const ret = [];\n                for (const layer of this._allLayersFlat)\n                    ret.push(layer.RecreateInitialObjects(objectClass, rc, offsetX, offsetY, createHierarchy));\n                return ret.flat()\n            }\n        }\n        async _StopRunning() {\n            const layoutManager = this._layoutManager;\n            if (!this._runtime.IsLoadingState())\n                await this._runtime.TriggerAsync(C3.Plugins.System.Cnds.OnLayoutEnd, null, null);\n            layoutManager.SetIsEndingLayout(true);\n            this._runtime.GetEventSheetManager().ClearAllScheduledWaits();\n            if (!this._isFirstVisit)\n                this._SavePersistData();\n            for (const layer of this._allLayersFlat)\n                layer._End();\n            for (const objectClass of this._runtime.GetAllObjectClasses()) {\n                if (objectClass.IsGlobal() || objectClass.IsWorldType() || objectClass.GetPlugin().IsSingleGlobal() || objectClass.IsFamily())\n                    continue;\n                for (const inst of objectClass.GetInstances())\n                    this._runtime.DestroyInstance(inst);\n                this._runtime.FlushPendingInstances()\n            }\n            layoutManager.SetIsEndingLayout(false);\n            if (layoutManager.GetMainRunningLayout() === this)\n                layoutManager._SetMainRunningLayout(null)\n        }\n        _SaveInstanceToPersist(inst) {\n            const sidStr = inst.GetObjectClass().GetSID().toString();\n            if (!this._persistData.hasOwnProperty(sidStr))\n                this._persistData[sidStr] = [];\n            const typePersist = this._persistData[sidStr];\n            typePersist.push(inst.SaveToJson())\n        }\n        _SavePersistData() {\n            for (const layer of this._allLayersFlat) {\n                layer._UpdateZIndices();\n                for (const inst of layer._GetInstances()) {\n                    const objectClass = inst.GetObjectClass();\n                    if (!objectClass.IsGlobal() && objectClass.HasPersistBehavior())\n                        this._SaveInstanceToPersist(inst)\n                }\n            }\n        }\n        ResetPersistData() {\n            this._persistData = {};\n            this._isFirstVisit = true\n        }\n        GetRenderTarget() {\n            return this._curRenderTarget\n        }\n        UsesOwnTexture() {\n            const runtime = this._runtime;\n            const isWebGL = runtime.GetRenderer().IsWebGL();\n            return runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality() === "low" || isWebGL && runtime.UsesAnyBackgroundBlending() || runtime.GetCompositingMode() === "low-latency" || this._effectList.HasAnyActiveEffect() || isWebGL && runtime.Uses3DFeatures()\n        }\n        Draw(renderer) {\n            const canvasManager = this._runtime.GetCanvasManager();\n            const useOwnTexture = this.UsesOwnTexture();\n            if (useOwnTexture) {\n                if (this._runtime.GetCompositingMode() !== "low-latency") {\n                    renderer.SetRenderTarget(null);\n                    renderer.ClearRgba(0, 0, 0, 0)\n                }\n                const rtOpts = {\n                    sampling: this._runtime.GetSampling(),\n                    isSampled: renderer.IsWebGPU() || this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect(),\n                    canReadPixels: renderer.IsWebGPU() ? this._runtime.UsesAnyBackgroundBlending() : false\n                };\n                if (canvasManager.GetCurrentFullscreenScalingQuality() === "low") {\n                    rtOpts.width = canvasManager.GetDrawWidth();\n                    rtOpts.height = canvasManager.GetDrawHeight()\n                }\n                this._curRenderTarget = this._runtime.GetAdditionalRenderTarget(rtOpts)\n            } else\n                this._curRenderTarget = null;\n            renderer.SetRenderTarget(this._curRenderTarget);\n            renderer.Clear(this.GetLayoutBackgroundColor());\n            if (this._runtime.Uses3DFeatures())\n                renderer.ClearDepth();\n            this._DrawLayerList(renderer, this._curRenderTarget, this._rootLayers, true);\n            if (useOwnTexture) {\n                renderer.SetDepthEnabled(false);\n                this._DrawLayoutOwnTextureToRenderTarget(renderer, this._curRenderTarget)\n            }\n            this._curRenderTarget = null\n        }\n        _DrawLayerList(renderer, destRenderTarget, layersArr, canCopyFirstLayer) {\n            const layersToDraw = layersArr.filter(l => l.ShouldDraw());\n            for (let i = 0, len = layersToDraw.length; i < len; ) {\n                const layer = layersToDraw[i];\n                if (layer.SelfAndAllSubLayersHave3DCamera() && !layer.SelfOrAnySubLayerUsesOwnTexture()) {\n                    tempRender3dList.push(layer);\n                    for (let j = i + 1; j < len; ++j) {\n                        const nextLayer = layersToDraw[j];\n                        if (nextLayer.SelfAndAllSubLayersHave3DCamera() && !nextLayer.SelfOrAnySubLayerUsesOwnTexture())\n                            tempRender3dList.push(layersToDraw[j]);\n                        else\n                            break\n                    }\n                    if (tempRender3dList.length >= 2 || tempRender3dList.length === 1 && tempRender3dList[0].HasAnyVisibleSubLayer()) {\n                        this._Draw3DLayers(renderer, destRenderTarget, tempRender3dList);\n                        i += tempRender3dList.length;\n                        C3.clearArray(tempRender3dList);\n                        continue\n                    }\n                    C3.clearArray(tempRender3dList)\n                }\n                layer.Draw(renderer, destRenderTarget, canCopyFirstLayer && i === 0);\n                ++i\n            }\n        }\n        _DrawLayoutOwnTextureToRenderTarget(renderer, ownRenderTarget) {\n            const activeEffectTypes = this._effectList.GetActiveEffectTypes();\n            const runtime = this._runtime;\n            if (activeEffectTypes.length === 0) {\n                renderer.SetRenderTarget(null);\n                renderer.SetTextureFillMode();\n                renderer.CopyRenderTarget(ownRenderTarget);\n                renderer.InvalidateRenderTarget(ownRenderTarget);\n                runtime.ReleaseAdditionalRenderTarget(ownRenderTarget)\n            } else {\n                tempLayoutRect.set(0, 0, runtime.GetViewportWidth(), runtime.GetViewportHeight());\n                this.GetEffectChain().Render(renderer, null, {\n                    contentObject: this,\n                    blendMode: 3,\n                    devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(),\n                    layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetScale(),\n                    layerAngle: this.GetAngle(),\n                    layoutRect: tempLayoutRect,\n                    drawSurfaceRect: null,\n                    invalidateRenderTargets: true\n                })\n            }\n        }\n        _Draw3DLayers(renderer, renderTarget, layerList) {\n            if (!layerList[0].IsTransparent()) {\n                tempColor.copyRgb(layerList[0].GetBackgroundColor());\n                tempColor.setA(1);\n                renderer.Clear(tempColor)\n            }\n            const canvasManager = this._runtime.GetCanvasManager();\n            renderer.SetDepthEnabled(true);\n            const fullInstanceList = tempInstanceList1;\n            const coplanarInstances = tempInstanceList2;\n            const postRenderInstances = tempInstanceList3;\n            for (const layer of layerList) {\n                layer._UpdateZIndices();\n                layer._AppendAllInstancesIncludingSubLayersInDrawOrder(fullInstanceList)\n            }\n            const firstLayer = layerList[0];\n            let layerQuery = null;\n            if (this._runtime.IsGPUProfiling())\n                if (renderer.IsWebGL()) {\n                    const timingsBuffer = canvasManager.GetLayerTimingsBuffer(firstLayer);\n                    if (timingsBuffer) {\n                        layerQuery = timingsBuffer.AddTimeElapsedQuery();\n                        renderer.StartQuery(layerQuery)\n                    }\n                } else if (renderer.IsWebGPU())\n                    renderer.WriteTimestamp((firstLayer.GetIndex() + 1) * 2);\n            for (let i = 0, len = fullInstanceList.length; i < len; ) {\n                const inst = fullInstanceList[i];\n                const wi = inst.GetWorldInfo();\n                const wiLayer = wi.GetLayer();\n                if (!wi.IsVisible() || !wi.IsInViewport3D(wiLayer._GetViewFrustum())) {\n                    ++i;\n                    continue\n                }\n                if (!inst.RendersToOwnZPlane() || wi.GetDepth() > 0)\n                    postRenderInstances.push(inst);\n                const startZ = inst.GetWorldInfo().GetTotalZElevation();\n                coplanarInstances.push(inst);\n                let endIndex = i + 1;\n                for (; endIndex < len; ++endIndex) {\n                    const nextInst = fullInstanceList[endIndex];\n                    const nextWi = nextInst.GetWorldInfo();\n                    if (!nextWi.IsVisible() || !nextWi.IsInViewport3D(nextWi.GetLayer()._GetViewFrustum()))\n                        continue;\n                    if (nextWi.GetTotalZElevation() !== startZ)\n                        break;\n                    if (!nextInst.RendersToOwnZPlane()) {\n                        postRenderInstances.push(nextInst);\n                        continue\n                    }\n                    if (nextWi.GetDepth() > 0)\n                        postRenderInstances.push(nextInst);\n                    coplanarInstances.push(nextInst)\n                }\n                if (coplanarInstances.length === 1 && !coplanarInstances[0].MustMitigateZFighting()) {\n                    MaybePrepareLayerDraw(wiLayer, renderer);\n                    wiLayer._DrawInstanceMaybeWithEffects(inst, wi, renderer, renderTarget);\n                    for (let j = 0, lenj = postRenderInstances.length; j < lenj; ++j) {\n                        const postInst = postRenderInstances[j];\n                        if (postInst === inst)\n                            continue;\n                        const postWi = postInst.GetWorldInfo();\n                        const postWiLayer = postWi.GetLayer();\n                        MaybePrepareLayerDraw(postWiLayer, renderer);\n                        postWiLayer._DrawInstanceMaybeWithEffects(postInst, postWi, renderer, renderTarget)\n                    }\n                } else {\n                    this._Draw3DLayersCoplanarInstances(renderer, renderTarget, coplanarInstances);\n                    for (let j = 0, lenj = postRenderInstances.length; j < lenj; ++j) {\n                        const postInst = postRenderInstances[j];\n                        const postWi = postInst.GetWorldInfo();\n                        const postWiLayer = postWi.GetLayer();\n                        postWi._SetDrawNonBackFacesOnly(true);\n                        MaybePrepareLayerDraw(postWiLayer, renderer);\n                        postWiLayer._DrawInstanceMaybeWithEffects(postInst, postWi, renderer, renderTarget);\n                        postWi._SetDrawNonBackFacesOnly(false)\n                    }\n                }\n                i = endIndex;\n                C3.clearArray(coplanarInstances);\n                C3.clearArray(postRenderInstances)\n            }\n            if (layerQuery)\n                renderer.EndQuery(layerQuery);\n            if (this._runtime.IsGPUProfiling() && renderer.IsWebGPU())\n                renderer.WriteTimestamp((firstLayer.GetIndex() + 1) * 2 + 1);\n            C3.clearArray(fullInstanceList);\n            lastLayerPreparedForDrawing = null\n        }\n        _Draw3DLayersCoplanarInstances(renderer, renderTarget, instances) {\n            renderer.CoplanarStartStencilPass();\n            for (let i = 0, len = instances.length; i < len; ++i) {\n                const inst = instances[i];\n                const wi = inst.GetWorldInfo();\n                const layer = wi.GetLayer();\n                wi._SetDrawBackFaceOnly(true);\n                MaybePrepareLayerDraw(layer, renderer);\n                layer._DrawInstance(inst, wi, renderer)\n            }\n            renderer.CoplanarStartColorPass();\n            for (let i = 0, len = instances.length; i < len; ++i) {\n                const inst = instances[i];\n                const wi = inst.GetWorldInfo();\n                const layer = wi.GetLayer();\n                MaybePrepareLayerDraw(layer, renderer);\n                layer._DrawInstanceMaybeWithEffects(inst, wi, renderer, renderTarget);\n                wi._SetDrawBackFaceOnly(false)\n            }\n            renderer.CoplanarRestoreStandardRendering()\n        }\n        _SaveToJson() {\n            const o = {\n                "sx": this.GetScrollX(),\n                "sy": this.GetScrollY(),\n                "s": this.GetScale(),\n                "a": this.GetAngle(),\n                "w": this.GetWidth(),\n                "h": this.GetHeight(),\n                "ortho": this.IsOrthographicProjection(),\n                "vpX": this.GetVanishingPointX(),\n                "vpY": this.GetVanishingPointY(),\n                "fv": this._isFirstVisit,\n                "persist": this._persistData,\n                "fx": this._effectList.SaveToJson(),\n                "layers": {}\n            };\n            for (const layer of this._allLayersFlat)\n                o["layers"][layer.GetSID().toString()] = layer._SaveToJson();\n            return o\n        }\n        _LoadFromJson(o) {\n            this._scrollX = o["sx"];\n            this._scrollY = o["sy"];\n            this._scale = o["s"];\n            this._angle = o["a"];\n            this._width = o["w"];\n            this._height = o["h"];\n            this._isOrthographicProjection = !!o["ortho"];\n            if (o.hasOwnProperty("vpX"))\n                this._vanishingPointX = o["vpX"];\n            if (o.hasOwnProperty("vpY"))\n                this._vanishingPointY = o["vpY"];\n            this._isFirstVisit = !!o["fv"];\n            this._persistData = o["persist"];\n            this._effectList.LoadFromJson(o["fx"]);\n            this._needsRebuildEffectChainSteps = true;\n            for (const [sidStr,data] of Object.entries(o["layers"])) {\n                const sid = parseInt(sidStr, 10);\n                const layer = this.GetLayerBySID(sid);\n                if (!layer)\n                    continue;\n                layer._LoadFromJson(data)\n            }\n            this._SetAllLayersProjectionChanged();\n            this._SetAllLayersMVChanged()\n        }\n        GetILayout() {\n            return this._iLayout\n        }\n        UserScriptDispatcher() {\n            return this._userScriptDispatcher\n        }\n        DispatchUserScriptEvent(e) {\n            e.layout = this.GetILayout();\n            const runtime = this._runtime;\n            const shouldTime = runtime.IsDebug() && !runtime.GetEventSheetManager().IsInEventEngine();\n            if (shouldTime)\n                C3Debugger.StartMeasuringScriptTime();\n            this._userScriptDispatcher.dispatchEvent(e);\n            if (shouldTime)\n                C3Debugger.AddScriptTime()\n        }\n        DispatchUserScriptEventAsyncWait(e) {\n            e.layout = this.GetILayout();\n            return this._userScriptDispatcher.dispatchEventAndWaitAsync(e)\n        }\n    }\n    ;\n\n}\n\n\/\/ layouts\/layoutManager.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.LayoutManager = class LayoutManager extends C3.DefendedBase {\n        constructor(runtime) {\n            super();\n            this._runtime = runtime;\n            this._allLayouts = [];\n            this._layoutsByName = new Map;\n            this._layoutsBySid = new Map;\n            this._mainRunningLayout = null;\n            this._runningSubLayouts = [];\n            this._firstLayout = null;\n            this._isEndingLayout = 0;\n            this._pendingChangeLayout = null\n        }\n        Release() {\n            this._runtime = null;\n            this._mainRunningLayout = null;\n            this._firstLayout = null;\n            this._pendingChangeLayout = null;\n            C3.clearArray(this._allLayouts);\n            this._layoutsByName.clear();\n            this._layoutsBySid.clear();\n            C3.clearArray(this._runningSubLayouts)\n        }\n        Create(layoutData) {\n            const layout = C3.New(C3.Layout, this, this._allLayouts.length, layoutData);\n            this._allLayouts.push(layout);\n            this._layoutsByName.set(layout.GetName().toLowerCase(), layout);\n            this._layoutsBySid.set(layout.GetSID(), layout)\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        SetFirstLayout(layout) {\n            this._firstLayout = layout\n        }\n        GetFirstLayout() {\n            if (this._firstLayout)\n                return this._firstLayout;\n            if (this._allLayouts.length)\n                return this._allLayouts[0];\n            throw new Error("no first layout");\n        }\n        GetLayoutByName(name) {\n            return this._layoutsByName.get(name.toLowerCase()) || null\n        }\n        GetLayoutBySID(sid) {\n            return this._layoutsBySid.get(sid) || null\n        }\n        GetLayoutByIndex(index) {\n            index = C3.clamp(Math.floor(index), 0, this._allLayouts.length - 1);\n            return this._allLayouts[index]\n        }\n        GetLayout(p) {\n            if (typeof p === "number")\n                return this.GetLayoutByIndex(p);\n            else\n                return this.GetLayoutByName(p.toString())\n        }\n        GetAllLayouts() {\n            return this._allLayouts\n        }\n        _SetMainRunningLayout(layout) {\n            this._mainRunningLayout = layout\n        }\n        GetMainRunningLayout() {\n            return this._mainRunningLayout\n        }\n        _AddRunningSubLayout(layout) {\n            if (this._runningSubLayouts.includes(layout))\n                throw new Error("layout already running");\n            this._runningSubLayouts.push(layout)\n        }\n        _RemoveRunningSubLayout(layout) {\n            const i = this._runningSubLayouts.indexOf(layout);\n            if (i === -1)\n                throw new Error("layout not running");\n            this._runningSubLayouts.splice(i, 1)\n        }\n        *runningLayouts() {\n            if (this._mainRunningLayout)\n                yield this._mainRunningLayout;\n            if (this._runningSubLayouts.length)\n                yield*this._runningSubLayouts\n        }\n        IsLayoutRunning(layout) {\n            return this._mainRunningLayout === layout || this._runningSubLayouts.includes(layout)\n        }\n        SetIsEndingLayout(e) {\n            if (e)\n                this._isEndingLayout++;\n            else {\n                if (this._isEndingLayout <= 0)\n                    throw new Error("already unset");\n                this._isEndingLayout--\n            }\n        }\n        IsEndingLayout() {\n            return this._isEndingLayout > 0\n        }\n        ChangeMainLayout(layout) {\n            this._pendingChangeLayout = layout\n        }\n        ClearPendingChangeLayout() {\n            this._pendingChangeLayout = null\n        }\n        IsPendingChangeMainLayout() {\n            return !!this._pendingChangeLayout\n        }\n        GetPendingChangeMainLayout() {\n            return this._pendingChangeLayout\n        }\n        SetAllLayerProjectionChanged() {\n            const runningLayout = this.GetMainRunningLayout();\n            if (!runningLayout)\n                return;\n            runningLayout._SetAllLayersProjectionChanged()\n        }\n        SetAllLayerMVChanged() {\n            const runningLayout = this.GetMainRunningLayout();\n            if (!runningLayout)\n                return;\n            runningLayout._SetAllLayersMVChanged()\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/timelineManager.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const NAMES_REGEXP = new RegExp("<(.+?)>","g");\n    C3.TimelineManager = class TimelineManager extends C3.DefendedBase {\n        constructor(runtime) {\n            super();\n            this._runtime = runtime;\n            this._timelineDataManager = C3.New(C3.TimelineDataManager);\n            this._pluginInstance = null;\n            this._timelines = [];\n            this._timelinesByName = new Map;\n            this._objectClassToTimelineMap = new Map;\n            this._timelinesCreatedByTemplate = new Map;\n            this._scheduledTimelines = [];\n            this._playingTimelines = [];\n            this._markedForRemovalTimelines = [];\n            this._hasRuntimeListeners = false;\n            this._changingLayout = false;\n            this._isTickingTimelines = false;\n            this._tickFunc = () => this._OnTick();\n            this._tick2Func = () => this._OnTick2();\n            this._beforeLayoutChange = () => this._OnBeforeChangeLayout();\n            this._layoutChange = () => this._OnAfterChangeLayout();\n            this._instanceDestroy = e => this._OnInstanceDestroy(e.instance);\n            this._beforeLoad = e => this._OnBeforeLoad();\n            this._afterLoad = e => this._OnAfterLoad();\n            this._afterLayoutStart = e => this._OnAfterLayoutStart();\n            this._destroyedWhileLoadingState = [];\n            this._renderChange = 0\n        }\n        Release() {\n            this.RemoveRuntimeListeners();\n            this._tickFunc = null;\n            this._tick2Func = null;\n            this._beforeLayoutChange = null;\n            this._layoutChange = null;\n            this._instanceDestroy = null;\n            this._afterLoad = null;\n            for (const timeline of this._timelines) {\n                timeline.Stop();\n                timeline.Release()\n            }\n            C3.clearArray(this._timelines);\n            this._timelines = null;\n            this._timelineDataManager.Release();\n            this._timelineDataManager = null;\n            C3.clearArray(this._scheduledTimelines);\n            this._scheduledTimelines = null;\n            C3.clearArray(this._playingTimelines);\n            this._playingTimelines = null;\n            C3.clearArray(this._markedForRemovalTimelines);\n            this._markedForRemovalTimelines = null;\n            this._timelinesByName.clear();\n            this._timelinesByName = null;\n            this._objectClassToTimelineMap.clear();\n            this._objectClassToTimelineMap = null;\n            this._timelinesCreatedByTemplate.clear();\n            this._timelinesCreatedByTemplate = null;\n            C3.clearArray(this._destroyedWhileLoadingState);\n            this._destroyedWhileLoadingState = null;\n            this._runtime = null\n        }\n        AddRuntimeListeners() {\n            const dispatcher = this._runtime.Dispatcher();\n            dispatcher.addEventListener("pretick", this._tickFunc);\n            dispatcher.addEventListener("tick2", this._tick2Func);\n            dispatcher.addEventListener("beforelayoutchange", this._beforeLayoutChange);\n            dispatcher.addEventListener("layoutchange", this._layoutChange);\n            dispatcher.addEventListener("instancedestroy", this._instanceDestroy);\n            dispatcher.addEventListener("beforeload", this._beforeLoad);\n            dispatcher.addEventListener("afterload", this._afterLoad);\n            dispatcher.addEventListener("afterlayoutstart", this._afterLayoutStart)\n        }\n        RemoveRuntimeListeners() {\n            const dispatcher = this._runtime.Dispatcher();\n            dispatcher.removeEventListener("pretick", this._tickFunc);\n            dispatcher.removeEventListener("tick2", this._tick2Func);\n            dispatcher.removeEventListener("beforelayoutchange", this._beforeLayoutChange);\n            dispatcher.removeEventListener("layoutchange", this._layoutChange);\n            dispatcher.removeEventListener("instancedestroy", this._instanceDestroy);\n            dispatcher.removeEventListener("beforeload", this._beforeLoad);\n            dispatcher.removeEventListener("afterload", this._afterLoad);\n            dispatcher.removeEventListener("afterlayoutstart", this._afterLayoutStart)\n        }\n        Create(timelineData) {\n            this._timelineDataManager.Add(timelineData);\n            const timeline = C3.TimelineState.CreateInitial(timelineData, this);\n            this.Add(timeline);\n            this.SetTimelineObjectClassesToMap(timeline);\n            this._timelinesCreatedByTemplate.set(timeline.GetName(), 0)\n        }\n        CreateFromTemplate(template) {\n            const timelineDataManager = this.GetTimelineDataManager();\n            const templateName = template.GetTemplateName();\n            const timelineDataItem = timelineDataManager.Get(templateName);\n            const timeline = C3.TimelineState.CreateFromTemplate(`${templateName}:${this._timelinesCreatedByTemplate.get(templateName)}`, timelineDataItem, this);\n            this._IncreaseTemplateTimelinesCount(templateName);\n            this.Add(timeline);\n            return timeline\n        }\n        _IncreaseTemplateTimelinesCount(templateName) {\n            this._timelinesCreatedByTemplate.set(templateName, this._timelinesCreatedByTemplate.get(templateName) + 1)\n        }\n        _SetCreatedTemplateTimelinesCount() {\n            for (const timeline of this._timelines) {\n                if (timeline.IsTemplate())\n                    continue;\n                const templateName = timeline.GetTemplateName();\n                this._IncreaseTemplateTimelinesCount(templateName)\n            }\n        }\n        _ClearCreatedTemplateTimelinesCount() {\n            for (const templateName of this._timelinesCreatedByTemplate.keys())\n                this._timelinesCreatedByTemplate.set(templateName, 0)\n        }\n        Add(timeline) {\n            this._timelines.push(timeline);\n            this._timelinesByName.set(timeline.GetName().toLowerCase(), timeline)\n        }\n        Remove(timeline) {\n            timeline.Removed();\n            if (timeline.IsTemplate())\n                return;\n            C3.arrayFindRemove(this._timelines, timeline);\n            C3.arrayFindRemove(this._scheduledTimelines, timeline);\n            C3.arrayFindRemove(this._playingTimelines, timeline);\n            C3.arrayFindRemove(this._markedForRemovalTimelines, timeline);\n            this._timelinesByName.delete(timeline.GetName().toLowerCase());\n            this.RemoveTimelineFromObjectClassMap(timeline);\n            if (!timeline.IsReleased())\n                timeline.Release()\n        }\n        Trigger(method) {\n            this._runtime.Trigger(method, this._pluginInstance, null)\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetTimelineDataManager() {\n            return this._timelineDataManager\n        }\n        SetPluginInstance(inst) {\n            this._pluginInstance = inst\n        }\n        GetPluginInstance() {\n            return this._pluginInstance\n        }\n        *GetTimelines() {\n            for (const timeline of this._timelines)\n                yield timeline\n        }\n        SetTimelineObjectClassToMap(objectClass, timeline) {\n            if (!this._objectClassToTimelineMap.has(objectClass))\n                this._objectClassToTimelineMap.set(objectClass, new Set);\n            this._objectClassToTimelineMap.get(objectClass).add(timeline)\n        }\n        SetTimelineObjectClassesToMap(timeline) {\n            for (const objectClass of timeline.GetObjectClasses())\n                this.SetTimelineObjectClassToMap(objectClass, timeline)\n        }\n        RemoveTimelineFromObjectClassMap(timeline) {\n            for (const [objectClass,timelines] of this._objectClassToTimelineMap.entries())\n                if (timelines.has(timeline)) {\n                    timelines.delete(timeline);\n                    if (timelines.size === 0)\n                        this._objectClassToTimelineMap.delete(objectClass)\n                }\n        }\n        GetTimelinesForObjectClass(objectClass) {\n            if (!this._objectClassToTimelineMap.has(objectClass))\n                return;\n            return this._objectClassToTimelineMap.get(objectClass)\n        }\n        GetTimelineOfTemplateForInstances(templateTimeline, instancesObject) {\n            if (!instancesObject)\n                return;\n            for (const timeline of this._timelines) {\n                const found = instancesObject.every(io => {\n                    return timeline.HasTrackInstance(io.instance, io.trackId)\n                }\n                );\n                if (found)\n                    if (timeline.GetName().includes(templateTimeline.GetName()))\n                        return timeline\n            }\n        }\n        GetTimelineByName(name) {\n            return this._timelinesByName.get(name.toLowerCase()) || null\n        }\n        GetScheduledOrPlayingTimelineByName(name) {\n            for (const timeline of this._scheduledTimelines)\n                if (timeline.GetName() === name)\n                    return timeline;\n            for (const timeline of this._playingTimelines)\n                if (timeline.GetName() === name)\n                    return timeline;\n            return null\n        }\n        *GetTimelinesByName(name) {\n            if (NAMES_REGEXP.test(name)) {\n                NAMES_REGEXP.lastIndex = 0;\n                let match;\n                const uniqueNames = new Set;\n                do {\n                    match = NAMES_REGEXP.exec(name);\n                    if (match) {\n                        const names = match[1].split(",");\n                        for (const name of names)\n                            uniqueNames.add(name)\n                    }\n                } while (match);\n                for (const name of uniqueNames.values()) {\n                    const timeline = this.GetTimelineByName(name);\n                    if (timeline)\n                        yield timeline\n                }\n                uniqueNames.clear()\n            } else {\n                const timeline = this.GetTimelineByName(name);\n                if (timeline)\n                    yield timeline\n            }\n        }\n        *GetTimelinesByTags(tags) {\n            for (const timeline of this._timelines)\n                if (timeline.HasTags(tags))\n                    yield timeline\n        }\n        AddScheduledTimeline(timeline) {\n            if (!this._scheduledTimelines.includes(timeline))\n                this._scheduledTimelines.push(timeline);\n            this._MaybeEnableRuntimeListeners()\n        }\n        RemovePlayingTimeline(timeline) {\n            C3.arrayFindRemove(this._playingTimelines, timeline);\n            this._MaybeDisableRuntimeListeners()\n        }\n        ScheduleTimeline(timeline) {\n            if (this._playingTimelines.includes(timeline)) {\n                timeline.SetPlaying(true);\n                timeline.SetScheduled(false);\n                timeline.SetMarkedForRemoval(false)\n            } else {\n                timeline.SetPlaying(false);\n                timeline.SetScheduled(true);\n                timeline.SetMarkedForRemoval(false);\n                if (!this._scheduledTimelines.includes(timeline))\n                    this._scheduledTimelines.push(timeline)\n            }\n            this._MaybeEnableRuntimeListeners()\n        }\n        DeScheduleTimeline(timeline) {\n            timeline.SetPlaying(false);\n            timeline.SetScheduled(false);\n            timeline.ResolvePlayPromise();\n            C3.arrayFindRemove(this._scheduledTimelines, timeline);\n            this._MaybeDisableRuntimeListeners()\n        }\n        CompleteTimeline(timeline) {\n            timeline.SetPlaying(false);\n            timeline.SetScheduled(false);\n            if (this._playingTimelines.includes(timeline)) {\n                timeline.SetMarkedForRemoval(true);\n                this._markedForRemovalTimelines.push(timeline);\n                C3.arrayFindRemove(this._playingTimelines, timeline)\n            }\n        }\n        CompleteTimelineBeforeChangeOfLayout(timeline) {\n            timeline.SetPlaying(false);\n            timeline.SetScheduled(false);\n            timeline.SetMarkedForRemoval(false);\n            timeline.SetPlaybackRate(1);\n            C3.arrayFindRemove(this._playingTimelines, timeline)\n        }\n        CompleteTimelineAndResolve(timeline) {\n            this.CompleteTimeline(timeline);\n            timeline.ResolvePlayPromise()\n        }\n        _OnTick() {\n            if (this.GetRuntime().IsLoadingState())\n                return;\n            if (!this._hasRuntimeListeners)\n                return;\n            if (this._changingLayout)\n                return;\n            this._isTickingTimelines = true;\n            while (this._scheduledTimelines.length) {\n                const t = this._scheduledTimelines.pop();\n                t.SetInitialState();\n                if (t.GetRenderChange() !== 0)\n                    this._renderChange = 1;\n                this._playingTimelines.push(t)\n            }\n            const dt = this._runtime._GetDtFast();\n            const dt1 = this._runtime.GetDt1();\n            const ts = this._runtime.GetTimeScale();\n            for (let i = this._playingTimelines.length - 1; i >= 0; i--)\n                this._playingTimelines[i].Tick(dt, ts, dt1);\n            this._isTickingTimelines = false;\n            if (this._renderChange !== 0)\n                this.GetRuntime().UpdateRender()\n        }\n        _OnTick2() {\n            if (this.GetRuntime().IsLoadingState())\n                return;\n            if (!this._hasRuntimeListeners)\n                return;\n            if (this._changingLayout)\n                return;\n            let timelinesToRemove;\n            for (let i = 0, l = this._markedForRemovalTimelines.length; i < l; i++) {\n                const t = this._markedForRemovalTimelines[i];\n                if (!timelinesToRemove)\n                    timelinesToRemove = new Set;\n                t.Removed();\n                this._MaybeExecuteTimelineFinishTriggers(t);\n                timelinesToRemove.add(t)\n            }\n            if (timelinesToRemove) {\n                C3.arrayRemoveAllInSet(this._markedForRemovalTimelines, timelinesToRemove);\n                this._renderChange = 0;\n                for (let i = 0, l = this._playingTimelines.length; i < l; i++)\n                    if (this._playingTimelines[i].GetRenderChange() !== 0) {\n                        this._renderChange = 1;\n                        break\n                    }\n            }\n            this._MaybeDisableRuntimeListeners()\n        }\n        _MaybeExecuteTimelineFinishTriggers(timeline) {\n            if (timeline.IsReleased())\n                return;\n            if (!timeline.HasValidTracks())\n                return;\n            if (timeline.IsComplete() && timeline.InitialStateSet())\n                timeline.FinishTriggers()\n        }\n        _MaybeEnableRuntimeListeners() {\n            if (this._hasRuntimeListeners)\n                return;\n            this._hasRuntimeListeners = true\n        }\n        _MaybeDisableRuntimeListeners() {\n            if (this._markedForRemovalTimelines.length)\n                return;\n            if (this._playingTimelines.length)\n                return;\n            if (this._scheduledTimelines.length)\n                return;\n            if (this._isTickingTimelines)\n                return;\n            this._hasRuntimeListeners = false\n        }\n        _OnBeforeChangeLayout() {\n            this._changingLayout = true;\n            while (this._scheduledTimelines.length)\n                this.DeScheduleTimeline(this._scheduledTimelines.pop());\n            const timelinesToRemove = new Set;\n            for (const t of this._playingTimelines) {\n                const remove = t._OnBeforeChangeLayout();\n                if (remove) {\n                    t.Removed();\n                    timelinesToRemove.add(t)\n                }\n            }\n            C3.arrayRemoveAllInSet(this._playingTimelines, timelinesToRemove);\n            timelinesToRemove.clear();\n            for (const t of this._markedForRemovalTimelines) {\n                const remove = t._OnBeforeChangeLayout();\n                if (remove) {\n                    t.Removed();\n                    timelinesToRemove.add(t)\n                }\n            }\n            C3.arrayRemoveAllInSet(this._markedForRemovalTimelines, timelinesToRemove);\n            this._MaybeDisableRuntimeListeners();\n            for (const timeline of this._timelines)\n                timeline.CleanCaches()\n        }\n        _OnAfterChangeLayout() {\n            this._changingLayout = false\n        }\n        _OnInstanceDestroy(instance) {\n            const objectClass = instance.GetObjectClass();\n            const timelines = this.GetTimelinesForObjectClass(objectClass);\n            if (!timelines)\n                return;\n            if (this._runtime.IsLoadingState())\n                this._destroyedWhileLoadingState.push(instance);\n            else\n                for (const timeline of timelines) {\n                    if (timeline.IsTemplate())\n                        continue;\n                    if (timeline.IsReleased()) {\n                        this.Remove(timeline);\n                        continue\n                    }\n                    if (!timeline.HasValidTracks()) {\n                        this._MaybeExecuteTimelineFinishTriggers(timeline);\n                        this.Remove(timeline)\n                    }\n                }\n        }\n        _OnBeforeLoad() {\n            for (const timeline of this._scheduledTimelines.map(t => t)) {\n                this._MaybeExecuteTimelineFinishTriggers(timeline);\n                this.Remove(timeline)\n            }\n            for (const timeline of this._playingTimelines.map(t => t)) {\n                this._MaybeExecuteTimelineFinishTriggers(timeline);\n                this.Remove(timeline)\n            }\n        }\n        _OnAfterLoad() {\n            for (const destroyedInstance of this._destroyedWhileLoadingState)\n                this._OnInstanceDestroy(destroyedInstance);\n            C3.clearArray(this._destroyedWhileLoadingState)\n        }\n        _OnAfterLayoutStart() {\n            const layoutManager = this._runtime.GetLayoutManager();\n            const runningLayout = layoutManager.GetMainRunningLayout();\n            if (!runningLayout)\n                return;\n            for (const timeline of this._timelines) {\n                const startOnLayout = timeline.GetStartOnLayout();\n                if (!startOnLayout)\n                    continue;\n                if (runningLayout.GetName() === startOnLayout)\n                    this.ScheduleTimeline(timeline)\n            }\n        }\n        _SaveToJson() {\n            return {\n                "timelinesJson": this._SaveTimelinesToJson(),\n                "scheduledTimelinesJson": this._SaveScheduledTimelinesToJson(),\n                "playingTimelinesJson": this._SavePlayingTimelinesToJson(),\n                "markedForRemovalTimelinesJson": this._SaveMarkedForRemovalTimelinesToJson(),\n                "hasRuntimeListeners": this._hasRuntimeListeners,\n                "changingLayout": this._changingLayout,\n                "isTickingTimelines": this._isTickingTimelines\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            this._ClearCreatedTemplateTimelinesCount();\n            this._LoadTimelinesFromJson(o["timelinesJson"]);\n            this._LoadScheduledTimelinesFromJson(o["scheduledTimelinesJson"]);\n            this._LoadPlayingTimelinesFromJson(o["playingTimelinesJson"]);\n            this._LoadMarkedForRemovalTimelinesFromJson(o["markedForRemovalTimelinesJson"]);\n            this._hasRuntimeListeners = !o["hasRuntimeListeners"];\n            this._changingLayout = !!o["changingLayout"];\n            this._isTickingTimelines = !!o["isTickingTimelines"];\n            this._SetCreatedTemplateTimelinesCount();\n            this._MaybeEnableRuntimeListeners();\n            this._MaybeDisableRuntimeListeners()\n        }\n        _SaveTimelinesToJson() {\n            return this._timelines.map(timelineState => timelineState._SaveToJson())\n        }\n        _LoadTimelinesFromJson(timelinesJson) {\n            for (const timelineJson of timelinesJson) {\n                let timeline = this.GetTimelineByName(timelineJson["name"]);\n                if (timeline)\n                    timeline._LoadFromJson(timelineJson);\n                else {\n                    const templateName = this._GetTemplateNameFromJson(timelineJson);\n                    if (!templateName)\n                        continue;\n                    const templateTimeline = this.GetTimelineByName(templateName);\n                    timeline = this.CreateFromTemplate(templateTimeline);\n                    timeline._LoadFromJson(timelineJson)\n                }\n                if (!timeline.HasTracks())\n                    this.Remove(timeline)\n            }\n        }\n        _GetTemplateNameFromJson(timelineJson) {\n            const name = timelineJson["name"];\n            const nameParts = name.split(":");\n            if (!nameParts || nameParts.length !== 2)\n                return null;\n            return nameParts[0]\n        }\n        _SaveScheduledTimelinesToJson() {\n            return this._SaveTimelines(this._scheduledTimelines)\n        }\n        _LoadScheduledTimelinesFromJson(scheduledTimelinesJson) {\n            this._LoadTimelines(scheduledTimelinesJson, this._scheduledTimelines)\n        }\n        _SavePlayingTimelinesToJson() {\n            return this._SaveTimelines(this._playingTimelines)\n        }\n        _LoadPlayingTimelinesFromJson(playingTimelinesJson) {\n            this._LoadTimelines(playingTimelinesJson, this._playingTimelines)\n        }\n        _SaveMarkedForRemovalTimelinesToJson() {\n            return this._SaveTimelines(this._markedForRemovalTimelines)\n        }\n        _LoadMarkedForRemovalTimelinesFromJson(markedForRemovalTimelinesJson) {\n            this._LoadTimelines(markedForRemovalTimelinesJson, this._markedForRemovalTimelines)\n        }\n        _IsTimelineInJson(timeline, json) {\n            if (!json)\n                return false;\n            for (const name of json)\n                if (name === timeline.GetName())\n                    return true;\n            return false\n        }\n        _SaveTimelines(collection) {\n            return collection.map(t => t.GetName())\n        }\n        _LoadTimelines(timelinesJson, collection) {\n            const timelinesToRemove = new Set;\n            for (const timeline of collection)\n                if (!this._IsTimelineInJson(timeline, timelinesJson))\n                    timelinesToRemove.add(timeline);\n            C3.arrayRemoveAllInSet(collection, timelinesToRemove);\n            if (timelinesJson) {\n                const ff = tn => t => t.GetName() === tn;\n                for (const name of timelinesJson) {\n                    const timeline = this.GetTimelineByName(name);\n                    if (timeline) {\n                        const t = collection.find(ff(name));\n                        if (!t)\n                            collection.push(timeline)\n                    }\n                }\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/state\/timelineState.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const PING_PONG_BEGIN = 0;\n    const PING_PONG_END = 1;\n    C3.TimelineState = class Timeline extends C3.DefendedBase {\n        constructor(name, timelineDataItem, timelineManager) {\n            super();\n            this._runtime = timelineManager.GetRuntime();\n            this._timelineManager = timelineManager;\n            this._timelineDataItem = timelineDataItem;\n            this._name = name;\n            this._tracks = [];\n            this._tracksLength = 0;\n            this._beforeAndAfterTracks = null;\n            this._beforeAndAfterTracksLength = 0;\n            this.CreateTrackStates();\n            this._playPromise = null;\n            this._playResolve = null;\n            this._playheadTime = 0;\n            this._playbackRate = 1;\n            this._pingPongState = PING_PONG_BEGIN;\n            this._currentRepeatCount = 1;\n            this._isPlaying = false;\n            this._isScheduled = false;\n            this._initialStateSet = false;\n            this._complete = true;\n            this._released = false;\n            this._markedForRemoval = false;\n            this._completedTick = -1;\n            this._implicitPause = false;\n            this._isTemplate = false;\n            this._finishedTriggers = false;\n            this._firstTick = false;\n            this._lastDelta = NaN;\n            this._tags = [""];\n            this._stringTags = "";\n            this._tagsChanged = false;\n            this._renderChange = 0;\n            this._hasNestedContent = 0\n        }\n        static CreateInitial(timelineDataJson, timelineManager) {\n            const timelineDataManager = timelineManager.GetTimelineDataManager();\n            const nameId = timelineDataManager.GetNameId();\n            const timelineDataItem = timelineDataManager.Get(timelineDataJson[nameId]);\n            const timeline = C3.New(C3.TimelineState, timelineDataJson[nameId], timelineDataItem, timelineManager);\n            timeline.SetIsTemplate(true);\n            return timeline\n        }\n        static CreateFromTemplate(name, timelineDataItem, timelineManager) {\n            return C3.New(C3.TimelineState, name, timelineDataItem, timelineManager)\n        }\n        Release() {\n            if (this.IsReleased())\n                return;\n            const dispatcher = this._runtime.Dispatcher();\n            this._timelineManager.DeScheduleTimeline(this);\n            this._timelineManager.CompleteTimelineAndResolve(this);\n            for (const track of this._tracks)\n                track.Release();\n            C3.clearArray(this._tracks);\n            this._tracks = null;\n            this._runtime = null;\n            this._timelineManager = null;\n            this._timelineDataItem = null;\n            this._released = true;\n            this._playPromise = null;\n            this._playResolve = null;\n            this.FireReleaseEvent(dispatcher)\n        }\n        FireReleaseEvent(dispatcher) {\n            const event = C3.New(C3.Event, "timelinestatereleased");\n            event.timelineState = this;\n            dispatcher.dispatchEvent(event)\n        }\n        CreateTrackStates() {\n            for (const trackDataItem of this._timelineDataItem.GetTrackData().trackDataItems())\n                this._tracksLength = this._tracks.push(C3.TrackState.Create(this, trackDataItem))\n        }\n        GetTimelineManager() {\n            return this._timelineManager\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetTracks() {\n            return this._tracks\n        }\n        GetSimilarPropertyTracks(instance, sourceAdapter, propertyName) {\n            if (!this._hasNestedContent)\n                return;\n            let ret;\n            for (let i = 0; i < this._tracks.length; i++) {\n                let track = this._tracks[i];\n                if (instance !== track.GetInstance())\n                    continue;\n                const propertyTrack = track.GetPropertyTrack(propertyName);\n                if (!propertyTrack)\n                    continue;\n                if (sourceAdapter.constructor !== propertyTrack.GetSourceAdapter().constructor)\n                    continue;\n                if (!ret)\n                    ret = [];\n                ret.push(propertyTrack)\n            }\n            return ret\n        }\n        HasTracks() {\n            return !!this._tracks.length\n        }\n        GetTrackById(trackId) {\n            for (const track of this._tracks)\n                if (C3.equalsNoCase(track.GetId(), trackId))\n                    return track;\n            return null\n        }\n        GetTrackByName(name) {\n            for (const track of this._tracks) {\n                if (track.IsInstanceTrack())\n                    continue;\n                if (C3.equalsNoCase(track.GetName(), name))\n                    return track\n            }\n            return null\n        }\n        SetName(name) {\n            this._name = name\n        }\n        GetName() {\n            return this._name\n        }\n        GetTimelineDataItem() {\n            return this._timelineDataItem\n        }\n        GetTemplateName() {\n            return this._timelineDataItem.GetName()\n        }\n        GetTotalTime() {\n            return this._timelineDataItem.GetTotalTime()\n        }\n        SetTotalTime(tt) {\n            this._timelineDataItem.SetTotalTime(tt)\n        }\n        GetStep() {\n            return this._timelineDataItem.GetStep()\n        }\n        SetStep(s) {\n            this._timelineDataItem.SetStep(s)\n        }\n        GetInterpolationMode() {\n            return this._timelineDataItem.GetInterpolationMode()\n        }\n        SetInterpolationMode(im) {\n            this._timelineDataItem.SetInterpolationMode(im)\n        }\n        GetResultMode() {\n            return this._timelineDataItem.GetResultMode()\n        }\n        SetResultMode(rm) {\n            this._timelineDataItem.GetResultMode(rm)\n        }\n        SetEase(e) {\n            for (const track of this.GetTracks())\n                track.SetEase(e)\n        }\n        GetLoop() {\n            return this._timelineDataItem.GetLoop()\n        }\n        SetLoop(l) {\n            return this._timelineDataItem.SetLoop(l)\n        }\n        GetPingPong() {\n            return this._timelineDataItem.GetPingPong()\n        }\n        SetPingPong(p) {\n            return this._timelineDataItem.SetPingPong(p)\n        }\n        GetRepeatCount() {\n            return this._timelineDataItem.GetRepeatCount()\n        }\n        SetPlaybackRate(r) {\n            return this._playbackRate = r\n        }\n        GetPlaybackRate() {\n            return this._playbackRate\n        }\n        GetStartOnLayout() {\n            return this._timelineDataItem.GetStartOnLayout()\n        }\n        GetTransformWithSceneGraph() {\n            return this._timelineDataItem.GetTransformWithSceneGraph()\n        }\n        IsForwardPlayBack() {\n            if (!this.IsPlaying())\n                return true;\n            return this._playbackRate > 0\n        }\n        GetPlayPromise() {\n            if (this._playPromise)\n                return this._playPromise;\n            this._playPromise = new Promise(resolve => {\n                this._playResolve = resolve\n            }\n            );\n            return this._playPromise\n        }\n        ResolvePlayPromise() {\n            if (!this._playPromise)\n                return;\n            this._playResolve();\n            this._playPromise = null;\n            this._playResolve = null\n        }\n        SetTags(tags) {\n            this._tags = C3.TimelineState._GetTagArray(tags);\n            this._tagsChanged = true\n        }\n        GetTags() {\n            return this._tags\n        }\n        GetStringTags() {\n            if (this._tagsChanged)\n                this._stringTags = this._tags.join(" ");\n            this._tagsChanged = false;\n            return this._stringTags\n        }\n        HasTags(tags) {\n            if (!this._tags)\n                return false;\n            if (!this._tags.length)\n                return false;\n            const t = C3.TimelineState._GetTagArray(tags);\n            if (!t)\n                return false;\n            if (!t.length)\n                return false;\n            return t.every(C3.TimelineState._HasTag, this)\n        }\n        OnStarted() {\n            if (!C3.Plugins.Timeline || this.constructor !== C3.TimelineState)\n                return;\n            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(this);\n            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimelineStarted);\n            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimelineStartedByName);\n            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimelineStartedByTags);\n            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnAnyTimelineStarted);\n            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(null)\n        }\n        OnCompleted() {\n            this._completedTick = this._runtime.GetTickCount()\n        }\n        FinishTriggers() {\n            if (this._finishedTriggers)\n                return;\n            this._finishedTriggers = true;\n            if (!C3.Plugins.Timeline || this.constructor !== C3.TimelineState)\n                return;\n            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(this);\n            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimelineFinished);\n            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimelineFinishedByName);\n            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimelineFinishedByTags);\n            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnAnyTimelineFinished);\n            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(null)\n        }\n        SetPlaying(p) {\n            this._isPlaying = p\n        }\n        IsCompletedTick() {\n            return this._completedTick === this._runtime.GetTickCount()\n        }\n        IsPlaying(playingOnly=false) {\n            if (this.IsCompletedTick())\n                return true;\n            if (this.IsScheduled() && !playingOnly)\n                return true;\n            return this._isPlaying\n        }\n        _IsPlaying() {\n            return this.IsPlaying(true)\n        }\n        IsPaused() {\n            return this._IsPaused()\n        }\n        _IsPaused() {\n            if (this.IsReleased())\n                return false;\n            if (this.IsScheduled())\n                return false;\n            if (this._IsPlaying())\n                return false;\n            if (this.IsComplete())\n                return false;\n            return true\n        }\n        SetScheduled(s) {\n            this._isScheduled = s\n        }\n        IsScheduled() {\n            return this._isScheduled\n        }\n        SetComplete(c) {\n            this._complete = c;\n            const t = this.GetTime();\n            if (t <= 0 || t >= this.GetTotalTime())\n                this._complete = true\n        }\n        IsComplete() {\n            return this._complete\n        }\n        IsReleased() {\n            return this._released\n        }\n        SetMarkedForRemoval(mfr) {\n            this._markedForRemoval = mfr\n        }\n        IsMarkedForRemoval() {\n            return this._markedForRemoval\n        }\n        SetImplicitPause(ip) {\n            this._implicitPause = ip\n        }\n        IsImplicitPause() {\n            return this._implicitPause\n        }\n        SetIsTemplate(it) {\n            this._isTemplate = !!it\n        }\n        IsTemplate() {\n            return this._isTemplate\n        }\n        InitialStateSet() {\n            return this._initialStateSet\n        }\n        GetTime() {\n            return this._playheadTime\n        }\n        SetTime(time) {\n            const lastGlobalTime = this.GetTime();\n            this._SetTime(time);\n            this.SetComplete(false);\n            if (!this.IsComplete())\n                this.SetImplicitPause(true);\n            if (!this._IsPlaying() && !this.IsScheduled() && this._initialStateSet)\n                ;\n            else if (!this._IsPlaying() && !this.IsScheduled() && !this._initialStateSet)\n                this.SetInitialStateFromSetTime();\n            else if (this._IsPlaying())\n                this.Stop();\n            else if (this.IsScheduled()) {\n                this._timelineManager.DeScheduleTimeline(this);\n                this.SetInitialStateFromSetTime()\n            }\n            this._SetUpdateStateBefore();\n            this._Interpolate(this.GetTime(), false, true, true, lastGlobalTime);\n            this._SetUpdateStateAfter();\n            if (this._renderChange)\n                this.GetRuntime().UpdateRender();\n            this._OnSetTime()\n        }\n        _SetTime(time) {\n            if (!C3.IsFiniteNumber(time))\n                time = this.GetTotalTime();\n            if (time < 0)\n                this._playheadTime = 0;\n            else if (time >= this.GetTotalTime())\n                this._playheadTime = this.GetTotalTime();\n            else\n                this._playheadTime = time\n        }\n        _SetTimeAndReset(time) {\n            if (!C3.IsFiniteNumber(time))\n                time = this.GetTotalTime();\n            if (time < 0)\n                this._playheadTime = 0;\n            else if (time >= this.GetTotalTime())\n                this._playheadTime = this.GetTotalTime();\n            else\n                this._playheadTime = time;\n            for (const track of this._tracks)\n                track.SetResetState()\n        }\n        _OnSetTime() {\n            if (!C3.Plugins.Timeline || this.constructor !== C3.TimelineState)\n                return;\n            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(this);\n            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimeSet);\n            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimeSetByName);\n            this._timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnTimeSetByTags);\n            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(null)\n        }\n        _CanResume() {\n            if (this.GetLoop())\n                return true;\n            else if (this.GetPingPong() && this._pingPongState === PING_PONG_END)\n                if (this.IsForwardPlayBack()) {\n                    if (this.GetTime() >= this.GetTotalTime())\n                        return false\n                } else {\n                    if (this.GetTime() <= 0)\n                        return false\n                }\n            else if (!this.GetLoop() && !this.GetPingPong())\n                if (this.IsForwardPlayBack()) {\n                    if (this.GetTime() >= this.GetTotalTime())\n                        return false\n                } else if (this.GetTime() <= 0)\n                    return false;\n            return true\n        }\n        Resume() {\n            if (this.IsReleased())\n                return;\n            if (this._CanResume())\n                this.Play(true)\n        }\n        Play(resume=false) {\n            if (this.IsReleased())\n                return false;\n            if (this.IsScheduled())\n                return false;\n            if (this._IsPlaying() && this.IsCompletedTick())\n                return this._SchedulePlayingTimeline();\n            if (this._IsPlaying())\n                return false;\n            if (!this.IsComplete() && !resume && !this.IsImplicitPause())\n                return false;\n            return this._ScheduleStoppedTimeline()\n        }\n        _SchedulePlayingTimeline() {\n            this.SetImplicitPause(false);\n            this._timelineManager.RemovePlayingTimeline(this);\n            this._timelineManager.ScheduleTimeline(this);\n            this.GetPlayPromise();\n            return true\n        }\n        _ScheduleStoppedTimeline() {\n            this.SetImplicitPause(false);\n            this._timelineManager.ScheduleTimeline(this);\n            this.GetPlayPromise();\n            return true\n        }\n        Stop(completed=false) {\n            if (this.IsReleased())\n                return;\n            this.SetComplete(completed);\n            this._timelineManager.CompleteTimeline(this);\n            if (this.IsComplete())\n                this.ResolvePlayPromise()\n        }\n        Reset(render=true, beforeChangeLayout=false) {\n            if (this.IsReleased())\n                return;\n            if (!this._IsPlaying() && this.IsScheduled())\n                return this._timelineManager.DeScheduleTimeline(this);\n            if (this.IsComplete())\n                return;\n            this.Stop(true);\n            if (this.IsForwardPlayBack())\n                this._SetTime(0);\n            else\n                this._SetTime(this.GetTotalTime());\n            const time = this.GetTime();\n            this._SetUpdateStateBefore();\n            if (beforeChangeLayout)\n                this._InterpolateBeforeChangeLayout(time);\n            else\n                this._Interpolate(time, false, false, true);\n            if (render)\n                this._OnSetTime();\n            this._SetUpdateStateAfter();\n            if (this._renderChange && render)\n                this.GetRuntime().UpdateRender()\n        }\n        ResetBeforeChangeLayout() {\n            this.Reset(false, true)\n        }\n        _InterpolateBeforeChangeLayout(time) {\n            this._Interpolate(time, false, false, true, NaN, false, true)\n        }\n        _OnBeforeChangeLayout() {\n            if (this.IsReleased())\n                return true;\n            if (!this.GetRuntime().IsLoadingState())\n                if (this.HasValidGlobalTracks())\n                    return false;\n            this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this);\n            if (!this.GetRuntime().IsLoadingState())\n                this.ResetBeforeChangeLayout();\n            return true\n        }\n        SetInitialStateFromSetTime() {\n            this.SetInitialState(true)\n        }\n        SetInitialState(fromSetTime) {\n            if (this.IsMarkedForRemoval())\n                return;\n            if (fromSetTime) {\n                this._initialStateSet = true;\n                this._firstTick = true;\n                this._SetUpdateStateBefore();\n                for (const track of this._tracks)\n                    track.SetInitialState();\n                this._SetUpdateStateAfter()\n            } else {\n                this.SetPlaying(true);\n                this.SetScheduled(false);\n                this.OnStarted();\n                if (this.IsComplete()) {\n                    this._completedTick = -1;\n                    this._pingPongState = PING_PONG_BEGIN;\n                    this._currentRepeatCount = 1;\n                    this._complete = false;\n                    this._finishedTriggers = false;\n                    this._initialStateSet = true;\n                    this._firstTick = true;\n                    if (this.IsForwardPlayBack())\n                        this._SetTime(0);\n                    else\n                        this._SetTime(this.GetTotalTime());\n                    this._SetUpdateStateBefore();\n                    for (const track of this._tracks)\n                        track.SetInitialState();\n                    this._SetUpdateStateAfter()\n                } else {\n                    this._firstTick = true;\n                    this._SetUpdateStateBefore();\n                    for (const track of this._tracks)\n                        track.SetResumeState();\n                    this._SetUpdateStateAfter()\n                }\n            }\n        }\n        GetRenderChange() {\n            return this._renderChange\n        }\n        _SetUpdateStateBefore() {\n            this._hasNestedContent = 0;\n            for (const track of this._tracks)\n                if (track.IsNested())\n                    this._hasNestedContent = 1\n        }\n        _SetUpdateStateAfter() {\n            this._renderChange = 0;\n            for (const track of this._tracks) {\n                track._SetUpdateState();\n                if (this._renderChange === 0 && track.GetRenderChange() === 1)\n                    this._renderChange = 1;\n                if (!this._beforeAndAfterTracks && track.GetNeedsBeforeAndAfter() === 1) {\n                    if (!this._beforeAndAfterTracks)\n                        this._beforeAndAfterTracks = [];\n                    this._beforeAndAfterTracksLength = this._beforeAndAfterTracks.push(track)\n                }\n            }\n        }\n        Tick(deltaTime, timeScale, deltaTime1) {\n            if (deltaTime === 0 && this._lastDelta === 0)\n                return;\n            this._lastDelta = deltaTime;\n            const lastTime = this._playheadTime;\n            const newDeltaTime = deltaTime * timeScale * this._playbackRate;\n            const newTime = lastTime + newDeltaTime;\n            const totalTime = this._timelineDataItem._totalTime;\n            if (newTime < 0)\n                this._playheadTime = 0;\n            else if (newTime >= totalTime)\n                this._playheadTime = totalTime;\n            else\n                this._playheadTime = newTime;\n            let complete = false;\n            let ensureValue = false;\n            const loop = this.GetLoop();\n            const pingPong = this.GetPingPong();\n            if (!loop && !pingPong)\n                if (this._playbackRate > 0) {\n                    if (this._playheadTime >= totalTime)\n                        if (this._currentRepeatCount < this.GetRepeatCount()) {\n                            this._currentRepeatCount++;\n                            this._SetTimeAndReset(0);\n                            ensureValue = true\n                        } else {\n                            this._SetTime(totalTime);\n                            complete = true\n                        }\n                } else {\n                    if (this._playheadTime <= 0)\n                        if (this._currentRepeatCount < this.GetRepeatCount()) {\n                            this._currentRepeatCount++;\n                            this._SetTimeAndReset(totalTime);\n                            ensureValue = true\n                        } else {\n                            this._SetTime(0);\n                            complete = true\n                        }\n                }\n            else if (loop && !pingPong)\n                if (this._playbackRate > 0) {\n                    if (this._playheadTime >= totalTime) {\n                        this._SetTimeAndReset(0);\n                        ensureValue = true\n                    }\n                } else {\n                    if (this._playheadTime <= 0) {\n                        this._SetTimeAndReset(totalTime);\n                        ensureValue = true\n                    }\n                }\n            else if (!loop && pingPong)\n                if (this._playbackRate > 0) {\n                    if (this._playheadTime >= totalTime) {\n                        this._SetTime(totalTime);\n                        this.SetPlaybackRate(this.GetPlaybackRate() * -1);\n                        ensureValue = true;\n                        if (this._pingPongState === PING_PONG_END)\n                            if (this._currentRepeatCount < this.GetRepeatCount()) {\n                                this._currentRepeatCount++;\n                                this._pingPongState = PING_PONG_BEGIN\n                            } else\n                                complete = true;\n                        else if (this._pingPongState === PING_PONG_BEGIN)\n                            this._pingPongState = PING_PONG_END\n                    }\n                } else {\n                    if (this._playheadTime <= 0) {\n                        this._SetTime(0);\n                        this.SetPlaybackRate(this.GetPlaybackRate() * -1);\n                        ensureValue = true;\n                        if (this._pingPongState === PING_PONG_END)\n                            if (this._currentRepeatCount < this.GetRepeatCount()) {\n                                this._currentRepeatCount++;\n                                this._pingPongState = PING_PONG_BEGIN\n                            } else\n                                complete = true;\n                        else if (this._pingPongState === PING_PONG_BEGIN)\n                            this._pingPongState = PING_PONG_END\n                    }\n                }\n            else if (loop && pingPong)\n                if (this._playbackRate > 0) {\n                    if (this._playheadTime >= totalTime) {\n                        this._SetTime(totalTime);\n                        this.SetPlaybackRate(this.GetPlaybackRate() * -1);\n                        ensureValue = true\n                    }\n                } else if (this._playheadTime <= 0) {\n                    this._SetTime(0);\n                    this.SetPlaybackRate(this.GetPlaybackRate() * -1);\n                    ensureValue = true\n                }\n            let i;\n            const l = this._tracksLength;\n            if (complete) {\n                for (i = 0; i < l; i++)\n                    this._tracks[i].SetEndState();\n                this.Stop(true);\n                this.OnCompleted();\n                return\n            }\n            const bal = this._beforeAndAfterTracksLength;\n            for (i = 0; i < bal; i++)\n                this._beforeAndAfterTracks[i].BeforeInterpolate();\n            if (this._hasNestedContent === 1)\n                for (i = 0; i < l; i++) {\n                    const track = this._tracks[i];\n                    const startOffset = track.GetStartOffset();\n                    const localTime = this._playheadTime - startOffset;\n                    const lastLocalTime = lastTime - startOffset;\n                    if (localTime < 0 && lastLocalTime > 0) {\n                        if (startOffset < 0)\n                            this._playheadTime = 0;\n                        else if (startOffset >= totalTime)\n                            this._playheadTime = totalTime;\n                        else\n                            this._playheadTime = startOffset;\n                        track.Interpolate(startOffset, true, false, ensureValue, this._firstTick, false)\n                    } else\n                        track.Interpolate(this._playheadTime, true, false, ensureValue, this._firstTick, false)\n                }\n            else\n                for (i = 0; i < l; i++)\n                    this._tracks[i].Interpolate(this._playheadTime, true, false, ensureValue, this._firstTick, false);\n            for (i = 0; i < bal; i++)\n                this._beforeAndAfterTracks[i].AfterInterpolate();\n            if (this._firstTick)\n                this._firstTick = false\n        }\n        _Interpolate(time, isTicking=false, setTime=false, ensureValue=false, lastTime=NaN, onTickCall=false, ignoreGlobals=false) {\n            for (const track of this._tracks)\n                track.BeforeInterpolate();\n            for (const track of this._tracks) {\n                let t = time;\n                if (typeof lastTime === "number" && !isNaN(lastTime)) {\n                    const globalTime = this.GetTime();\n                    const localTime = globalTime - track.GetStartOffset();\n                    const lastLocalTime = lastTime - track.GetStartOffset();\n                    if (localTime < 0 && lastLocalTime > 0) {\n                        t = track.GetStartOffset();\n                        this._SetTime(t)\n                    }\n                }\n                track.Interpolate(t, isTicking, setTime, ensureValue, this._firstTick, ignoreGlobals)\n            }\n            for (const track of this._tracks)\n                track.AfterInterpolate();\n            if (this._firstTick && onTickCall)\n                this._firstTick = false\n        }\n        AddTrack() {\n            const trackDataItem = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem();\n            const track = C3.TrackState.Create(this, trackDataItem);\n            this._tracksLength = this._tracks.push(track);\n            return track\n        }\n        Removed() {\n            if (this.IsReleased())\n                return;\n            for (const track of this._tracks)\n                track.TimelineRemoved()\n        }\n        CleanCaches() {\n            for (const track of this._tracks)\n                track.CleanCaches()\n        }\n        ClearTrackInstances() {\n            for (const track of this._tracks)\n                track.ClearInstance()\n        }\n        SetTrackInstance(trackId, instance) {\n            if (!instance)\n                return;\n            for (const track of this._tracks) {\n                if (!track.IsInstanceTrack())\n                    continue;\n                if (trackId) {\n                    if (track.GetId() !== trackId)\n                        continue;\n                    track.SetInstance(instance);\n                    this._timelineManager.SetTimelineObjectClassToMap(instance.GetObjectClass(), this);\n                    break\n                } else {\n                    if (track.HasInstance())\n                        continue;\n                    track.SetInstance(instance);\n                    this._timelineManager.SetTimelineObjectClassToMap(instance.GetObjectClass(), this);\n                    break\n                }\n            }\n        }\n        HasTrackInstance(instance, trackId) {\n            for (const track of this._tracks) {\n                if (!track.IsInstanceTrack())\n                    continue;\n                if (trackId) {\n                    if (trackId === track.GetId() && instance === track.GetInstance())\n                        return true\n                } else if (instance === track.GetInstance())\n                    return true\n            }\n            return false\n        }\n        HasValidTracks() {\n            return this._tracks.some(t => {\n                if (t.IsInstanceTrack())\n                    return t.CanInstanceBeValid();\n                else\n                    return true\n            }\n            )\n        }\n        HasValidGlobalTracks() {\n            return this._tracks.some(t => {\n                if (t.IsInstanceTrack()) {\n                    if (!t.CanInstanceBeValid())\n                        return false;\n                    const objectClass = t.GetObjectClass();\n                    if (!objectClass)\n                        return false;\n                    return objectClass.IsGlobal()\n                } else\n                    return false\n            }\n            )\n        }\n        GetPropertyTrack(propertyName) {\n            for (const track of this.GetTracks())\n                for (const propertyTrack of track.GetPropertyTracks())\n                    if (propertyTrack.GetPropertyName() === propertyName)\n                        return propertyTrack\n        }\n        GetTrackFromInstance(instance) {\n            for (const track of this._tracks)\n                if (instance === track.GetInstance())\n                    return track;\n            return null\n        }\n        GetKeyframeWithTags(tags) {\n            let tagsArray = tags ? tags.split(" ") : [];\n            const tagsSet = new Set(tagsArray.map(t => t.toLowerCase().trim()));\n            tagsArray = [...tagsSet.values()];\n            for (const track of this.GetTracks())\n                for (const keyframeDataItem of track.GetKeyframeDataItems()) {\n                    const hasAllTags = tagsArray.every(t => keyframeDataItem.HasTag(t));\n                    if (hasAllTags)\n                        return keyframeDataItem\n                }\n        }\n        GetObjectClasses() {\n            const ret = [];\n            for (const track of this.GetTracks())\n                ret.push(track.GetObjectClass());\n            return ret.filter(oc => oc)\n        }\n        _SaveToJson() {\n            return {\n                "tracksJson": this._SaveTracksToJson(),\n                "name": this._name,\n                "playheadTime": this.GetTime(),\n                "playbackRate": this._playbackRate,\n                "pingPongState": this._pingPongState,\n                "currentRepeatCount": this._currentRepeatCount,\n                "isPlaying": this._isPlaying,\n                "isScheduled": this._isScheduled,\n                "initialStateSet": this._initialStateSet,\n                "finishedTriggers": this._finishedTriggers,\n                "complete": this._complete,\n                "released": this._released,\n                "markedForRemoval": this._markedForRemoval,\n                "completedTick": this._completedTick,\n                "implicitPause": this._implicitPause,\n                "isTemplate": this._isTemplate,\n                "tags": this._tags.join(" "),\n                "stringTags": this._stringTags,\n                "tagsChanged": this._tagsChanged,\n                "firstTick": this._firstTick\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            this._LoadTracksFromJson(o["tracksJson"]);\n            this._name = o["name"];\n            this._playheadTime = o["playheadTime"];\n            this._playbackRate = o["playbackRate"];\n            this._pingPongState = o["pingPongState"];\n            this._currentRepeatCount = o["currentRepeatCount"];\n            this._isPlaying = !!o["isPlaying"];\n            this._isScheduled = !!o["isScheduled"];\n            this._initialStateSet = !!o["initialStateSet"];\n            this._finishedTriggers = o.hasOwnProperty("finishedTriggers") ? !!o["finishedTriggers"] : false;\n            this._complete = !!o["complete"];\n            this._released = !!o["released"];\n            this._markedForRemoval = !!o["markedForRemoval"];\n            this._completedTick = o["completedTick"];\n            this._implicitPause = !!o["implicitPause"];\n            this._isTemplate = !!o["isTemplate"];\n            this._tags = o["tags"].split(" ");\n            this._stringTags = o["stringTags"];\n            this._tagsChanged = !!o["tagsChanged"];\n            this._firstTick = !!o["firstTick"]\n        }\n        _SaveTracksToJson() {\n            return this._tracks.map(trackState => trackState._SaveToJson())\n        }\n        _LoadTracksFromJson(tracksJson) {\n            tracksJson.forEach( (trackJson, i) => {\n                const track = this._tracks[i];\n                track._LoadFromJson(trackJson)\n            }\n            );\n            this._tracks.filter(track => track.CanInstanceBeValid())\n        }\n        static _HasTag(tag) {\n            const tags = this.GetTags();\n            if (tag === "")\n                return tags.length === 1 && tags[0] === "";\n            return tags.map(t => t.toLowerCase()).includes(tag.toLowerCase())\n        }\n        static _GetTagArray(tags) {\n            if (C3.IsArray(tags))\n                return tags.slice(0);\n            if (C3.IsString(tags))\n                return tags.split(" ")\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/state\/trackState.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const INSTANCE_TRACK = 0;\n    const VALUE_TRACK = 1;\n    const AUDIO_TRACK = 2;\n    C3.TrackState = class Track extends C3.DefendedBase {\n        constructor(timeline, trackDataItem) {\n            super();\n            this._timeline = timeline;\n            this._trackDataItem = trackDataItem;\n            this._trackData = trackDataItem.GetTrackData();\n            this._instanceUid = NaN;\n            this._objectClassIndex = NaN;\n            this._instance = null;\n            this._worldInfo = null;\n            this._isNested = trackDataItem.GetStartOffset() > 0;\n            this._initialStateOfNestedSet = false;\n            this._endStateOfNestedSet = false;\n            this._lastKeyframeDataItem = null;\n            this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray();\n            this._propertyTracks = [];\n            this.CreatePropertyTrackStates();\n            this._worldInfoChange = 0;\n            this._renderChange = 0;\n            this._needsBeforeAndAfter = 0\n        }\n        static Create(timeline, trackDataItem) {\n            return C3.New(C3.TrackState, timeline, trackDataItem)\n        }\n        Release() {\n            this._keyframeDataItems = null;\n            for (const propertyTrack of this._propertyTracks)\n                propertyTrack.Release();\n            C3.clearArray(this._propertyTracks);\n            this._propertyTracks = null;\n            this._timeline = null;\n            this._instance = null;\n            this._worldInfo = null;\n            this._trackDataItem = null;\n            this._lastKeyframeDataItem = null\n        }\n        CreatePropertyTrackStates() {\n            for (const propertyTrackDataItem of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems())\n                this._propertyTracks.push(C3.PropertyTrackState.Create(this, propertyTrackDataItem))\n        }\n        TimelineRemoved() {\n            for (const propertyTrack of this._propertyTracks)\n                propertyTrack.TimelineRemoved()\n        }\n        CleanCaches() {\n            for (const propertyTrack of this._propertyTracks)\n                propertyTrack.CleanCaches();\n            this._instance = null;\n            this._worldInfo = null\n        }\n        GetTimeline() {\n            return this._timeline\n        }\n        GetRuntime() {\n            return this._timeline.GetRuntime()\n        }\n        GetKeyframeDataItems() {\n            if (this._keyframeDataItems)\n                return this._keyframeDataItems;\n            this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray();\n            return this._keyframeDataItems\n        }\n        GetPropertyTracks() {\n            return this._propertyTracks\n        }\n        GetPropertyTrack(propertyName) {\n            for (let i = 0; i < this._propertyTracks.length; i++) {\n                const propertyTrack = this._propertyTracks[i];\n                if (propertyTrack.GetPropertyName() === propertyName)\n                    return propertyTrack\n            }\n        }\n        MaybeGetInstance() {\n            if (!this._instance)\n                this.GetInstance()\n        }\n        IsInstanceValid() {\n            if (!this._instance)\n                return false;\n            return !this._instance.IsDestroyed()\n        }\n        CanInstanceBeValid() {\n            if (!this.IsInstanceTrack())\n                return false;\n            const uid = this.GetInstanceUID();\n            const instance = this.GetRuntime().GetInstanceByUID(uid);\n            if (!instance)\n                return false;\n            return !instance.IsDestroyed()\n        }\n        GetObjectClass() {\n            if (!this.IsInstanceTrack())\n                return;\n            const index = this.GetObjectClassIndex();\n            if (index === -1)\n                return;\n            return this.GetRuntime().GetObjectClassByIndex(index)\n        }\n        ClearInstance() {\n            this._instance = null;\n            this._instanceUid = -1;\n            this._worldInfo = null;\n            this._objectClassIndex = -1\n        }\n        HasInstance() {\n            return !!this._instance\n        }\n        GetInstance() {\n            if (this._instance && this.IsInstanceValid())\n                return this._instance;\n            const uid = this.GetInstanceUID();\n            this._instance = this.GetRuntime().GetInstanceByUID(uid);\n            return this._instance\n        }\n        SetInstance(instance) {\n            if (this._instance === instance)\n                return;\n            this.CleanCaches();\n            this._instance = instance;\n            this._objectClassIndex = instance.GetObjectClass().GetIndex();\n            this._instanceUid = instance.GetUID();\n            this._worldInfo = instance.GetWorldInfo();\n            for (const item of this.propertyTrackItems()) {\n                const propertyTrack = item.propertyTrack;\n                const sourceAdapter = item.sourceAdapter;\n                const id = propertyTrack.GetSourceAdapterId();\n                switch (id) {\n                case "instance-variable":\n                    {\n                        const index = sourceAdapter.GetEditorIndex();\n                        const objectClass = instance.GetObjectClass();\n                        const i = objectClass.GetInstanceVariableIndexByName(item.name);\n                        const name = objectClass.GetInstanceVariableName(i);\n                        const type = objectClass.GetInstanceVariableType(i);\n                        if (name === item.name && type === item.type)\n                            sourceAdapter.UpdateInstanceVariableIndex(i);\n                        break\n                    }\n                case "behavior":\n                    {\n                        const timelineBehaviorType = item.behaviorType;\n                        const trackObjectClass = this.GetObjectClass();\n                        const objectClass = instance.GetObjectClass();\n                        const instanceBehaviorType = sourceAdapter.GetBehaviorType(objectClass);\n                        if (timelineBehaviorType && instanceBehaviorType) {\n                            const name = timelineBehaviorType.GetName();\n                            const templateBehaviorIndex = trackObjectClass.GetBehaviorIndexByName(name);\n                            const instanceBehaviorIndex = objectClass.GetBehaviorIndexByName(name);\n                            const propertyIndex = sourceAdapter.GetEditorIndex();\n                            sourceAdapter.UpdateBehaviorTypeSid(instanceBehaviorType.GetSID())\n                        }\n                        break\n                    }\n                }\n            }\n        }\n        *propertyTrackItems() {\n            for (const propertyTrack of this._propertyTracks) {\n                const sourceAdapter = propertyTrack.GetSourceAdapter();\n                const objectClass = this.GetObjectClass();\n                const ret = {\n                    propertyTrack: propertyTrack,\n                    sourceAdapter: sourceAdapter\n                };\n                switch (propertyTrack.GetSourceAdapterId()) {\n                case "world-instance":\n                    {\n                        ret.property = propertyTrack.GetPropertyName();\n                        break\n                    }\n                case "instance-variable":\n                    {\n                        const index = sourceAdapter.GetEditorIndex();\n                        ret.name = objectClass.GetInstanceVariableName(index);\n                        ret.type = objectClass.GetInstanceVariableType(index);\n                        break\n                    }\n                case "effect":\n                    {\n                        const effectList = objectClass.GetEffectList();\n                        const effectType = sourceAdapter.GetEffectType(effectList);\n                        ret.effectType = effectType;\n                        break\n                    }\n                case "behavior":\n                    {\n                        const behaviorType = sourceAdapter.GetBehaviorType(objectClass);\n                        ret.behaviorType = behaviorType;\n                        break\n                    }\n                case "plugin":\n                    {\n                        ret.plugin = objectClass.GetPlugin();\n                        break\n                    }\n                case "value":\n                    {\n                        break\n                    }\n                }\n                yield ret\n            }\n        }\n        GetWorldInfo() {\n            if (this._worldInfo && this.IsInstanceValid())\n                return this._worldInfo;\n            const instance = this.GetInstance();\n            if (instance)\n                this._worldInfo = instance.GetWorldInfo();\n            return this._worldInfo\n        }\n        GetTrackDataItem() {\n            return this._trackDataItem\n        }\n        GetInstanceUID() {\n            if (this._instanceUid)\n                return this._instanceUid;\n            return this._trackDataItem.GetInstanceUID()\n        }\n        SetInstanceUID(uid) {\n            this._trackDataItem.SetInstanceUID(uid)\n        }\n        GetInterpolationMode() {\n            return this._trackDataItem.GetInterpolationMode()\n        }\n        SetInterpolationMode(im) {\n            this._trackDataItem.SetInterpolationMode(im)\n        }\n        GetResultMode() {\n            return this._trackDataItem.GetResultMode()\n        }\n        GetId() {\n            return this._trackDataItem.GetId()\n        }\n        GetStartOffset() {\n            return this._trackDataItem.GetStartOffset()\n        }\n        GetLocalTotalTime() {\n            return this._trackDataItem.GetLocalTotalTime()\n        }\n        SetLocalTotalTime(t) {\n            this._trackDataItem.SetLocalTotalTime(t)\n        }\n        SetResultMode(rm) {\n            this._trackDataItem.SetResultMode(rm)\n        }\n        SetEase(e) {\n            for (const keyframeDataItem of this.GetKeyframeDataItems())\n                keyframeDataItem.SetEase(e);\n            for (const propertyTrack of this.GetPropertyTracks())\n                propertyTrack.SetEase(e)\n        }\n        GetEnable() {\n            return this._trackDataItem.GetEnable()\n        }\n        SetEnable(e) {\n            this._trackDataItem.SetEnable(e)\n        }\n        GetObjectClassIndex() {\n            if (!isNaN(this._objectClassIndex))\n                return this._objectClassIndex;\n            return this._trackDataItem.GetObjectClassIndex()\n        }\n        SetObjectClassIndex(objectClassIndex) {\n            this._trackDataItem.SetObjectClassIndex(objectClassIndex)\n        }\n        SetOriginalWidth(w) {\n            this._trackDataItem.SetOriginalWidth(w)\n        }\n        GetOriginalWidth() {\n            const instance = this.GetInstance();\n            if (instance) {\n                const sdkIntance = instance.GetSdkInstance();\n                if (sdkIntance.IsOriginalSizeKnown())\n                    return instance.GetSdkInstance().GetOriginalWidth()\n            }\n            return this._trackDataItem.GetOriginalWidth()\n        }\n        SetOriginalHeight(h) {\n            this._trackDataItem.SetOriginalHeight(h)\n        }\n        GetOriginalHeight() {\n            const instance = this.GetInstance();\n            if (instance) {\n                const sdkIntance = instance.GetSdkInstance();\n                if (sdkIntance.IsOriginalSizeKnown())\n                    return instance.GetSdkInstance().GetOriginalHeight()\n            }\n            return this._trackDataItem.GetOriginalHeight()\n        }\n        GetType() {\n            return this._trackDataItem.GetType()\n        }\n        GetName() {\n            return this._trackDataItem.GetName()\n        }\n        IsInstanceTrack() {\n            return this.GetType() === INSTANCE_TRACK\n        }\n        IsValueTrack() {\n            return this.GetType() === VALUE_TRACK\n        }\n        IsAudioTrack() {\n            return this.GetType() === AUDIO_TRACK\n        }\n        GetWorldInfoChange() {\n            return this._worldInfoChange\n        }\n        GetRenderChange() {\n            return this._renderChange\n        }\n        GetNeedsBeforeAndAfter() {\n            return this._needsBeforeAndAfter\n        }\n        IsNested() {\n            return this._isNested\n        }\n        SetResetState() {\n            for (const propertyTrack of this._propertyTracks)\n                propertyTrack.SetResetState()\n        }\n        SetInitialState() {\n            this.MaybeGetInstance();\n            if (!this.IsInstanceValid() && this.IsInstanceTrack())\n                return;\n            const timeline = this.GetTimeline();\n            const isForwardPlayBack = timeline.IsForwardPlayBack();\n            const time = isForwardPlayBack ? 0 : this.GetLocalTotalTime();\n            for (const propertyTrack of this._propertyTracks) {\n                propertyTrack.SetInitialState(time);\n                if (this._worldInfoChange === 0 && propertyTrack.GetWorldInfoChange() === 1)\n                    this._worldInfoChange = 1;\n                if (this._renderChange === 0 && propertyTrack.GetRenderChange() === 1)\n                    this._renderChange = 1\n            }\n            this._needsBeforeAndAfter = 0;\n            const nba = this._propertyTracks.some(pt => pt.GetNeedsBeforeAndAfter());\n            if (nba)\n                this._needsBeforeAndAfter = 1;\n            this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(time);\n            this._initialStateOfNestedSet = false;\n            this._endStateOfNestedSet = false;\n            this.Interpolate(time);\n            this.OnKeyframeReached(this._GetLastKeyFrameBeforeTime(time))\n        }\n        SetResumeState() {\n            this.MaybeGetInstance();\n            if (!this.IsInstanceValid() && this.IsInstanceTrack())\n                return;\n            const playbackDirection = this._timeline.IsForwardPlayBack();\n            const time = this._timeline.GetTime() - this.GetStartOffset();\n            this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(time);\n            for (const propertyTrack of this._propertyTracks)\n                propertyTrack.SetResumeState(time)\n        }\n        SetEndState() {\n            if (this.GetTimeline().IsComplete())\n                return;\n            this.MaybeGetInstance();\n            if (!this.IsInstanceValid() && this.IsInstanceTrack())\n                return;\n            if (!this._isNested) {\n                const time = this._timeline.GetTime();\n                const totalTime = this.GetStartOffset() + this.GetLocalTotalTime();\n                if (time >= totalTime)\n                    this.Interpolate(this.GetLocalTotalTime(), true, false, true);\n                else if (time <= 0)\n                    this.Interpolate(0, true, false, true)\n            }\n        }\n        _SetUpdateState() {\n            for (let i = 0, l = this._propertyTracks.length; i < l; i++) {\n                const propertyTrack = this._propertyTracks[i];\n                propertyTrack._SetUpdateState();\n                if (this._worldInfoChange === 0 && propertyTrack.GetWorldInfoChange() === 1)\n                    this._worldInfoChange = 1;\n                if (this._renderChange === 0 && propertyTrack.GetRenderChange() === 1)\n                    this._renderChange = 1\n            }\n        }\n        BeforeInterpolate() {\n            const l = this._propertyTracks.length;\n            for (let i = 0; i < l; i++)\n                this._propertyTracks[i].BeforeInterpolate()\n        }\n        Interpolate(time, isTicking=false, setTime=false, ensureValue=false, firstTick=false, ignoreGlobals=false) {\n            if (!this._instance)\n                this.GetInstance();\n            const instanceValid = this._instance && !this._instance.IsDestroyed();\n            const isInstanceTrack = this._trackDataItem._type === INSTANCE_TRACK;\n            if (!instanceValid && isInstanceTrack)\n                return;\n            if (ignoreGlobals && isInstanceTrack && this.GetObjectClass().IsGlobal())\n                return;\n            time = time - this.GetStartOffset();\n            if (time < 0)\n                return;\n            this.MaybeSetInitialStateOfNestedTrack(time, isTicking);\n            this.MaybeTriggerKeyframeReachedConditions(time, isTicking, firstTick);\n            for (let i = 0, l = this._propertyTracks.length; i < l; i++)\n                this._propertyTracks[i].Interpolate(time, setTime, ensureValue);\n            this.MaybeSetEndStateOfNestedTrack(time, isTicking);\n            if (this._worldInfoChange !== 0) {\n                if (!this._worldInfo)\n                    this._worldInfo = this._instance.GetWorldInfo();\n                if (this._worldInfo)\n                    this._worldInfo.SetBboxChanged()\n            }\n        }\n        AfterInterpolate() {\n            const l = this._propertyTracks.length;\n            for (let i = 0; i < l; i++)\n                this._propertyTracks[i].AfterInterpolate()\n        }\n        MaybeSetInitialStateOfNestedTrack(time, isTicking) {\n            if (!isTicking)\n                return;\n            if (!this._isNested)\n                return;\n            if (this._initialStateOfNestedSet)\n                return;\n            const timeline = this.GetTimeline();\n            if (timeline.IsForwardPlayBack()) {\n                if (time < 0)\n                    return;\n                for (const propertyTrack of this._propertyTracks)\n                    propertyTrack.Interpolate(0, false, true)\n            } else {\n                if (time > this.GetLocalTotalTime())\n                    return;\n                for (const propertyTrack of this._propertyTracks)\n                    propertyTrack.Interpolate(this.GetLocalTotalTime(), false, true)\n            }\n            for (const propertyTrack of this._propertyTracks)\n                propertyTrack.SetInitialState();\n            this._initialStateOfNestedSet = true\n        }\n        MaybeSetEndStateOfNestedTrack(time, isTicking) {\n            if (!isTicking)\n                return;\n            if (!this._isNested)\n                return;\n            if (this._endStateOfNestedSet)\n                return;\n            const timeline = this.GetTimeline();\n            if (timeline.IsForwardPlayBack()) {\n                if (time >= this.GetLocalTotalTime()) {\n                    for (const propertyTrack of this._propertyTracks)\n                        propertyTrack.Interpolate(this.GetLocalTotalTime(), false, true);\n                    this._endStateOfNestedSet = true\n                }\n            } else if (time <= 0) {\n                for (const propertyTrack of this._propertyTracks)\n                    propertyTrack.Interpolate(0, false, true);\n                this._endStateOfNestedSet = true\n            }\n        }\n        MaybeTriggerKeyframeReachedConditions(time, isTicking, firstTick) {\n            if (firstTick)\n                return;\n            if (!isTicking)\n                return;\n            if (!C3.Plugins.Timeline)\n                return;\n            const timeline = this.GetTimeline();\n            const nextKeyframe = this._lastKeyframeDataItem.GetNext();\n            const lastTime = this._lastKeyframeDataItem.GetTime();\n            const nextTime = nextKeyframe ? nextKeyframe.GetTime() : timeline.GetTotalTime();\n            if (time <= lastTime || time >= nextTime) {\n                this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(time, this._trackDataItem);\n                if (timeline.IsForwardPlayBack()) {\n                    if (nextKeyframe)\n                        this.OnKeyframeReached(this._lastKeyframeDataItem)\n                } else {\n                    const nextKeyframe = this._lastKeyframeDataItem.GetNext();\n                    if (nextKeyframe)\n                        this.OnKeyframeReached(nextKeyframe)\n                }\n            }\n        }\n        _GetLastKeyFrameBeforeTime(time) {\n            const keyframeDataItem = this._trackData.GetKeyFrameDataItemAtTime(time, this._trackDataItem);\n            if (keyframeDataItem)\n                return keyframeDataItem;\n            else\n                return this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(time, this._trackDataItem)\n        }\n        OnKeyframeReached(keyframeDataItem) {\n            const timeline = this.GetTimeline();\n            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(timeline);\n            C3.Plugins.Timeline.Cnds.SetTriggerKeyframe(keyframeDataItem);\n            const timelineManager = timeline.GetTimelineManager();\n            timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnAnyKeyframeReached);\n            timelineManager.Trigger(C3.Plugins.Timeline.Cnds.OnKeyframeReached);\n            C3.Plugins.Timeline.Cnds.SetTriggerTimeline(null);\n            C3.Plugins.Timeline.Cnds.SetTriggerKeyframe(null)\n        }\n        AddKeyframe() {\n            const keyframeData = this._trackDataItem.GetKeyframeData();\n            const keyframeDataItem = keyframeData.AddEmptyKeyframeDataItem();\n            return keyframeDataItem\n        }\n        AddPropertyTrack() {\n            const propertyTrackData = this._trackDataItem.GetPropertyTrackData();\n            const propertyTrackDataItem = propertyTrackData.AddEmptyPropertyTrackDataItem();\n            const propertyTrack = C3.PropertyTrackState.Create(this, propertyTrackDataItem);\n            this._propertyTracks.push(propertyTrack);\n            return propertyTrack\n        }\n        DeleteKeyframes(match) {\n            const keyframeData = this._trackDataItem.GetKeyframeData();\n            keyframeData.DeleteKeyframeDataItems(match)\n        }\n        DeletePropertyKeyframes(match) {\n            for (const propertyTrack of this._propertyTracks)\n                propertyTrack.DeletePropertyKeyframes(match)\n        }\n        SaveState() {\n            for (const propertyTrack of this._propertyTracks)\n                propertyTrack.SaveState()\n        }\n        CompareInitialStateWithCurrent() {\n            this.MaybeGetInstance();\n            if (!this.IsInstanceValid() && this.IsInstanceTrack())\n                return;\n            for (const propertyTrack of this._propertyTracks)\n                propertyTrack.CompareInitialStateWithCurrent()\n        }\n        CompareSaveStateWithCurrent() {\n            this.MaybeGetInstance();\n            if (!this.IsInstanceValid() && this.IsInstanceTrack())\n                return;\n            let difference = false;\n            for (const propertyTrack of this._propertyTracks) {\n                const diff = propertyTrack.CompareSaveStateWithCurrent();\n                if (!difference && diff)\n                    difference = true\n            }\n            if (difference) {\n                const keyframeDataItem = this.AddKeyframe();\n                keyframeDataItem.SetTime(this.GetTimeline().GetTime());\n                keyframeDataItem.SetEase("noease");\n                keyframeDataItem.SetEnable(true);\n                keyframeDataItem.SetTags("")\n            }\n        }\n        _SaveToJson() {\n            const instance = this.GetInstance();\n            const uid = instance ? instance.GetUID() : this.GetInstanceUID();\n            return {\n                "propertyTracksJson": this._SavePropertyTracksToJson(),\n                "lastKeyframeDataItemJson": this._SaveLastKeyframeDataItemToJson(),\n                "initialStateOfNestedSet": this._initialStateOfNestedSet,\n                "endStateOfNestedSet": this._endStateOfNestedSet,\n                "instanceUid": uid\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            this._LoadPropertyTracksFromJson(o["propertyTracksJson"]);\n            this._LoadLastKeyframeDataItemFromJson(o["lastKeyframeDataItemJson"]);\n            this._LoadInstanceFromJson(o["instanceUid"]);\n            this._initialStateOfNestedSet = false;\n            if (o.hasOwnProperty["initialStateOfNestedSet"])\n                this._initialStateOfNestedSet = o["initialStateOfNestedSet"];\n            this._endStateOfNestedSet = false;\n            if (o.hasOwnProperty["endStateOfNestedSet"])\n                this._endStateOfNestedSet = o["endStateOfNestedSet"];\n            for (const propertyTrack of this._propertyTracks) {\n                if (this._worldInfoChange === 0 && propertyTrack.GetWorldInfoChange() === 1)\n                    this._worldInfoChange = 1;\n                if (this._renderChange === 0 && propertyTrack.GetRenderChange() === 1)\n                    this._renderChange = 1\n            }\n            this._needsBeforeAndAfter = 0;\n            if (this._propertyTracks.some(pt => pt.GetNeedsBeforeAndAfter()))\n                this._needsBeforeAndAfter = 1\n        }\n        _SaveLastKeyframeDataItemToJson() {\n            const keyframeData = this._trackDataItem.GetKeyframeData();\n            return keyframeData.GetKeyframeDataItemIndex(this._lastKeyframeDataItem)\n        }\n        _SavePropertyTracksToJson() {\n            return this._propertyTracks.map(propertyTrackState => propertyTrackState._SaveToJson())\n        }\n        _LoadPropertyTracksFromJson(propertyTracksJson) {\n            propertyTracksJson.forEach( (propertyTrackJson, i) => {\n                const propertyTrack = this._propertyTracks[i];\n                propertyTrack._LoadFromJson(propertyTrackJson)\n            }\n            )\n        }\n        _LoadInstanceFromJson(uid) {\n            if (!C3.IsFiniteNumber(uid))\n                return;\n            const instance = this.GetRuntime().GetInstanceByUID(uid);\n            if (!instance)\n                return;\n            const timeline = this.GetTimeline();\n            timeline.ClearTrackInstances();\n            timeline.SetTrackInstance(this._trackDataItem.GetId(), instance)\n        }\n        _LoadLastKeyframeDataItemFromJson(lastKeyframeDataItemIndex) {\n            const keyframeData = this._trackDataItem.GetKeyframeData();\n            this._lastKeyframeDataItem = keyframeData.GetKeyframeDataItemFromIndex(lastKeyframeDataItemIndex)\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/state\/propertyTrackState.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.PropertyTrackState = class PropertyTrack extends C3.DefendedBase {\n        constructor(track, propertyTrackDataItem) {\n            super();\n            this._track = track;\n            this._propertyTrackDataItem = propertyTrackDataItem;\n            this._propertyTrackData = propertyTrackDataItem.GetPropertyTrackData();\n            this._worldInfoChange = 0;\n            this._renderChange = 0;\n            this._needsBeforeAndAfter = 0;\n            this._sourceAdapter = this.GetSourceAdapter();\n            this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();\n            this._lastPropertyKeyframeDataItem = null;\n            this._absoluteValueObject = null\n        }\n        static Create(track, propertyTrackDataItem) {\n            return C3.New(C3.PropertyTrackState, track, propertyTrackDataItem)\n        }\n        Release() {\n            this._track = null;\n            if (this._sourceAdapter) {\n                this._sourceAdapter.Release();\n                this._sourceAdapter = null\n            }\n            this._propertyKeyframeDataItems = null;\n            this._propertyTrackDataItem = null;\n            this._propertyTrackData = null\n        }\n        GetWorldInfoChange() {\n            return this._worldInfoChange\n        }\n        GetRenderChange() {\n            return this._renderChange\n        }\n        GetNeedsBeforeAndAfter() {\n            return this._needsBeforeAndAfter\n        }\n        HasAbsoluteValueObject() {\n            return !!this._absoluteValueObject\n        }\n        SetAbsoluteValueObject(avo) {\n            this._absoluteValueObject = avo\n        }\n        GetAbsoluteValueObject() {\n            return this._absoluteValueObject\n        }\n        GetTrack() {\n            return this._track\n        }\n        GetPropertyTrackDataItem() {\n            return this._propertyTrackDataItem\n        }\n        GetPropertyTrackData() {\n            return this._propertyTrackData\n        }\n        GetTimeline() {\n            return this._track.GetTimeline()\n        }\n        GetRuntime() {\n            return this._track.GetRuntime()\n        }\n        GetInstance() {\n            return this._track.GetInstance()\n        }\n        GetSourceAdapter() {\n            if (this._sourceAdapter)\n                return this._sourceAdapter;\n            const id = this._propertyTrackDataItem.GetSourceAdapterId();\n            let ret;\n            switch (id) {\n            case "behavior":\n                ret = new C3.PropertyTrackState.BehaviorSourceAdapter(this);\n                break;\n            case "effect":\n                ret = new C3.PropertyTrackState.EffectSourceAdapter(this);\n                this._renderChange = 1;\n                break;\n            case "instance-variable":\n                ret = new C3.PropertyTrackState.InstanceVariableSourceAdapter(this);\n                break;\n            case "plugin":\n                ret = new C3.PropertyTrackState.PluginSourceAdapter(this);\n                this._renderChange = 1;\n                break;\n            case "world-instance":\n                ret = new C3.PropertyTrackState.PropertySourceAdapter(this);\n                this._renderChange = 1;\n                this._worldInfoChange = 1;\n                break;\n            case "value":\n                ret = new C3.PropertyTrackState.ValueSourceAdapter(this);\n                break;\n            case "audio":\n                ret = new C3.PropertyTrackState.AudioSourceAdapter(this);\n                break\n            }\n            this._sourceAdapter = ret;\n            return this._sourceAdapter\n        }\n        GetSourceAdapterId() {\n            return this._propertyTrackDataItem.GetSourceAdapterId()\n        }\n        SetSourceAdapterId(said) {\n            this._propertyTrackDataItem.SetSourceAdapterId(said)\n        }\n        GetSourceAdapterArgs() {\n            return this._propertyTrackDataItem.GetSourceAdapterArguments()\n        }\n        SetSourceAdapterArgs(sargs) {\n            this._propertyTrackDataItem.SetSourceAdapterArguments(sargs)\n        }\n        GetSourceAdapterValue() {\n            return this.GetSourceAdapter().GetValue()\n        }\n        GetPropertyName() {\n            return this._propertyTrackDataItem.GetProperty()\n        }\n        SetPropertyName(pn) {\n            this._propertyTrackDataItem.SetProperty(pn)\n        }\n        GetPropertyType() {\n            return this._propertyTrackDataItem.GetType()\n        }\n        SetPropertyType(pt) {\n            this._propertyTrackDataItem.SetType(pt)\n        }\n        GetPropertyKeyframeType() {\n            return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType()\n        }\n        GetMin() {\n            return this._propertyTrackDataItem.GetMin()\n        }\n        SetMin(min) {\n            this._propertyTrackDataItem.SetMin(min)\n        }\n        GetMax() {\n            return this._propertyTrackDataItem.GetMax()\n        }\n        SetMax(max) {\n            this._propertyTrackDataItem.SetMax(max)\n        }\n        GetEnable() {\n            return this._propertyTrackDataItem.GetEnable()\n        }\n        SetEnable(e) {\n            this._propertyTrackDataItem.SetEnable(e)\n        }\n        GetInterpolationMode() {\n            return this._propertyTrackDataItem.GetInterpolationMode()\n        }\n        SetInterpolationMode(im) {\n            this._propertyTrackDataItem.SetInterpolationMode(im)\n        }\n        GetResultMode() {\n            return this._propertyTrackDataItem.GetResultMode()\n        }\n        SetResultMode(rm) {\n            this._propertyTrackDataItem.SetResultMode(rm)\n        }\n        SetEase(e) {\n            for (const propertyKeyframeDataItem of this.GetPropertyKeyframeDataItems())\n                propertyKeyframeDataItem.SetEase(e)\n        }\n        CanHavePropertyKeyframes() {\n            return this._propertyTrackDataItem.CanHavePropertyKeyframes()\n        }\n        GetPropertyKeyframeDataItems() {\n            if (this._propertyKeyframeDataItems)\n                return this._propertyKeyframeDataItems;\n            this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();\n            return this._propertyKeyframeDataItems\n        }\n        *GetPropertyKeyframeValues() {\n            for (const propertyKeyframeDataItem of this.GetPropertyKeyframeDataItems())\n                yield propertyKeyframeDataItem.GetValueWithResultMode()\n        }\n        TimelineRemoved() {\n            this.GetSourceAdapter().TimelineRemoved()\n        }\n        CleanCaches() {\n            this.GetSourceAdapter().CleanCaches()\n        }\n        GetCurrentState() {\n            return this.GetSourceAdapter().GetCurrentState()\n        }\n        SetResetState() {\n            this.GetSourceAdapter().SetResetState()\n        }\n        SetInitialState(time) {\n            this.GetSourceAdapter().SetInitialState();\n            this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(time);\n            this._SetUpdateState()\n        }\n        SetResumeState(time) {\n            this.GetSourceAdapter().SetResumeState();\n            this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(time)\n        }\n        _SetUpdateState() {\n            const track = this.GetTrack();\n            this._needsBeforeAndAfter = 0;\n            if (track.IsInstanceTrack()) {\n                const timeline = this.GetTimeline();\n                const instance = track.GetInstance();\n                const sourceAdapter = this.GetSourceAdapter();\n                const propertyName = this.GetPropertyName();\n                const mayNeedBeforeAndAfterInterpolate = sourceAdapter.MayNeedBeforeAndAfterInterpolate();\n                if (mayNeedBeforeAndAfterInterpolate) {\n                    const similarPropertyTracks = timeline.GetSimilarPropertyTracks(instance, sourceAdapter, propertyName);\n                    if (similarPropertyTracks && similarPropertyTracks.length)\n                        this._needsBeforeAndAfter = 1\n                } else\n                    this._needsBeforeAndAfter = 0\n            }\n        }\n        _GetLastPropertyKeyFrameBeforeTime(time) {\n            const timeline = this.GetTimeline();\n            const propertyKeyframeDataItem = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(time, this._propertyTrackDataItem);\n            if (propertyKeyframeDataItem)\n                return propertyKeyframeDataItem;\n            else if (timeline.IsForwardPlayBack())\n                return this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(time, this._propertyTrackDataItem);\n            else\n                return this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(time, this._propertyTrackDataItem)\n        }\n        BeforeInterpolate() {\n            this._sourceAdapter.BeforeInterpolate()\n        }\n        Interpolate(time, setTime=false, ensureValue=false) {\n            let start;\n            let end;\n            if (setTime)\n                start = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(time, this._propertyTrackDataItem);\n            else {\n                if (this._lastPropertyKeyframeDataItem) {\n                    const timeline = this.GetTimeline();\n                    const nextPropertyKeyframe = this._lastPropertyKeyframeDataItem.GetNext();\n                    const lastTime = this._lastPropertyKeyframeDataItem.GetTime();\n                    const nextTime = nextPropertyKeyframe ? nextPropertyKeyframe.GetTime() : timeline.GetTotalTime();\n                    if (time <= lastTime || time >= nextTime)\n                        this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(time, this._propertyTrackDataItem)\n                } else\n                    this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(time, this._propertyTrackDataItem);\n                start = this._lastPropertyKeyframeDataItem\n            }\n            if (start)\n                end = start.GetNext();\n            this._sourceAdapter.Interpolate(time, start, end, setTime, ensureValue)\n        }\n        GetInterpolatedValue(time) {\n            if (this._lastPropertyKeyframeDataItem) {\n                const timeline = this.GetTimeline();\n                const nextPropertyKeyframe = this._lastPropertyKeyframeDataItem.GetNext();\n                const lastTime = this._lastPropertyKeyframeDataItem.GetTime();\n                const nextTime = nextPropertyKeyframe ? nextPropertyKeyframe.GetTime() : timeline.GetTotalTime();\n                if (time <= lastTime || time >= nextTime)\n                    this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(time, this._propertyTrackDataItem)\n            } else\n                this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(time, this._propertyTrackDataItem);\n            const start = this._lastPropertyKeyframeDataItem;\n            const end = start.GetNext();\n            return this._sourceAdapter.GetInterpolatedValue(time, start, end)\n        }\n        AfterInterpolate() {\n            this._sourceAdapter.AfterInterpolate()\n        }\n        static GetStartPropertyKeyframeForTime(time, propertyTrack) {\n            const propertyTrackDataItem = propertyTrack.GetPropertyTrackDataItem();\n            const propertyTrackData = propertyTrack._propertyTrackData;\n            return propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(time, propertyTrackDataItem)\n        }\n        static GetEndPropertyKeyframeForTime(time, propertyTrack) {\n            const propertyTrackDataItem = propertyTrack.GetPropertyTrackDataItem();\n            const propertyTrackData = propertyTrack._propertyTrackData;\n            return propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(time, propertyTrackDataItem)\n        }\n        AddPropertyKeyframe() {\n            const propertyKeyframeData = this._propertyTrackDataItem.GetPropertyKeyframeData();\n            const propertyKeyframeDataItem = propertyKeyframeData.AddEmptyPropertyKeyframeDataItem();\n            this._lastPropertyKeyframeDataItem = null;\n            return propertyKeyframeDataItem\n        }\n        DeletePropertyKeyframes(match) {\n            this._lastPropertyKeyframeDataItem = null;\n            const propertyKeyframeData = this._propertyTrackDataItem.GetPropertyKeyframeData();\n            propertyKeyframeData.DeletePropertyKeyframeDataItems(match)\n        }\n        SaveState() {\n            this.GetSourceAdapter().SaveState()\n        }\n        CompareInitialStateWithCurrent() {\n            const difference = this.GetSourceAdapter().CompareInitialStateWithCurrent();\n            if (difference) {\n                const propertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem);\n                const currentState = this.GetSourceAdapter().GetCurrentState();\n                propertyKeyframeDataItem.SetAbsoluteValue(currentState)\n            }\n        }\n        CompareSaveStateWithCurrent() {\n            const difference = this.GetSourceAdapter().CompareSaveStateWithCurrent();\n            if (difference)\n                this.AddPropertyKeyframeAtCurrentTime();\n            this.GetSourceAdapter().ClearSaveState();\n            return difference\n        }\n        AddPropertyKeyframeAtCurrentTime() {\n            const time = this.GetTimeline().GetTime();\n            const sourceAdapter = this.GetSourceAdapter();\n            const startPropertyKeyframe = C3.PropertyTrackState.GetStartPropertyKeyframeForTime(time, this);\n            const propertyKeyframeDataItem = this.AddPropertyKeyframe();\n            propertyKeyframeDataItem.SetType(startPropertyKeyframe.GetType());\n            propertyKeyframeDataItem.SetTime(time);\n            propertyKeyframeDataItem.SetEase(startPropertyKeyframe.GetEase());\n            propertyKeyframeDataItem.SetEnable(true);\n            propertyKeyframeDataItem.SetValue(sourceAdapter.GetValueAtTime());\n            propertyKeyframeDataItem.SetAbsoluteValue(sourceAdapter.GetCurrentState())\n        }\n        _SaveToJson() {\n            return {\n                "sourceAdapterJson": this.GetSourceAdapter()._SaveToJson()\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            this.GetSourceAdapter()._LoadFromJson(o["sourceAdapterJson"])\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/state\/propertySourceAdapters\/propertySourceAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const NS = C3.PropertyTrackState;\n    NS.PropertySourceAdapter = class PropertySourceAdapter {\n        constructor(propertyTrack) {\n            this._propertyTrack = propertyTrack;\n            this._propertyAdapter = null;\n            this.GetPropertyAdapter()\n        }\n        Release() {\n            if (this._propertyAdapter) {\n                this._propertyAdapter.Release();\n                this._propertyAdapter = null\n            }\n            this._propertyTrack = null\n        }\n        MayNeedBeforeAndAfterInterpolate() {\n            return this._propertyAdapter.MayNeedBeforeAndAfterInterpolate()\n        }\n        GetPropertyTrack() {\n            return this._propertyTrack\n        }\n        TimelineRemoved() {\n            if (this._propertyAdapter)\n                this._propertyAdapter.TimelineRemoved()\n        }\n        CleanCaches() {\n            if (this._propertyAdapter)\n                this._propertyAdapter.CleanCaches()\n        }\n        GetPropertyAdapter() {\n            if (this._propertyAdapter)\n                return this._propertyAdapter;\n            this._propertyAdapter = this._CreatePropertyAdapter();\n            return this._propertyAdapter\n        }\n        GetEditorIndex() {}\n        GetIndex() {\n            return this.GetEditorIndex()\n        }\n        GetTarget() {}\n        SetResetState() {\n            this.GetPropertyAdapter().SetResetState()\n        }\n        SetInitialState() {\n            this.GetPropertyAdapter().SetInitialState()\n        }\n        SetResumeState() {\n            this.GetPropertyAdapter().SetResumeState()\n        }\n        BeforeInterpolate() {\n            this._propertyAdapter.BeforeChangeProperty()\n        }\n        Interpolate(time, start, end, setTime, ensureValue) {\n            const type = this._propertyTrack.GetPropertyKeyframeType();\n            let value;\n            switch (type) {\n            case "numeric":\n                {\n                    value = NS.NumericTypeAdapter.Interpolate(time, start, end, this._propertyTrack);\n                    break\n                }\n            case "angle":\n                {\n                    value = NS.AngleTypeAdapter.Interpolate(time, start, end, this._propertyTrack);\n                    break\n                }\n            case "boolean":\n                {\n                    value = NS.BooleanTypeAdapter.Interpolate(time, start, end, this._propertyTrack);\n                    break\n                }\n            case "color":\n                {\n                    value = NS.ColorTypeAdapter.Interpolate(time, start, end, this._propertyTrack);\n                    break\n                }\n            case "text":\n                {\n                    value = NS.TextTypeAdapter.Interpolate(time, start, end, this._propertyTrack);\n                    break\n                }\n            }\n            this._propertyAdapter.ChangeProperty(time, value, start, end, setTime, ensureValue)\n        }\n        GetInterpolatedValue(time, start, end) {\n            switch (this._propertyTrack.GetPropertyKeyframeType()) {\n            case "numeric":\n                return NS.NumericTypeAdapter.Interpolate(time, start, end, this._propertyTrack);\n            case "angle":\n                return NS.AngleTypeAdapter.Interpolate(time, start, end, this._propertyTrack);\n            case "boolean":\n                return NS.BooleanTypeAdapter.Interpolate(time, start, end, this._propertyTrack);\n            case "color":\n                return NS.ColorTypeAdapter.Interpolate(time, start, end, this._propertyTrack);\n            case "text":\n                return NS.TextTypeAdapter.Interpolate(time, start, end, this._propertyTrack)\n            }\n        }\n        AfterInterpolate() {\n            this._propertyAdapter.AfterChangeProperty()\n        }\n        SaveState() {\n            this.GetPropertyAdapter().SetSaveState()\n        }\n        ClearSaveState() {\n            this.GetPropertyAdapter().ClearSaveState()\n        }\n        GetCurrentState() {\n            return this.GetPropertyAdapter().GetCurrentState()\n        }\n        CompareInitialStateWithCurrent() {\n            return this.GetPropertyAdapter().CompareInitialStateWithCurrent()\n        }\n        CompareSaveStateWithCurrent() {\n            return this.GetPropertyAdapter().CompareSaveStateWithCurrent()\n        }\n        GetValueAtTime() {\n            const propertyTrack = this._propertyTrack;\n            const track = propertyTrack.GetTrack();\n            const time = track.GetTimeline().GetTime();\n            const start = NS.GetStartPropertyKeyframeForTime(time, propertyTrack);\n            const end = start.GetNext();\n            const type = propertyTrack.GetPropertyKeyframeType();\n            switch (type) {\n            case "numeric":\n                {\n                    return NS.NumericTypeAdapter.Interpolate(time, start, end, propertyTrack)\n                }\n            case "angle":\n                {\n                    return NS.AngleTypeAdapter.Interpolate(time, start, end, propertyTrack)\n                }\n            case "boolean":\n                {\n                    return NS.BooleanTypeAdapter.Interpolate(time, start, end, propertyTrack)\n                }\n            case "color":\n                {\n                    return NS.ColorTypeAdapter.Interpolate(time, start, end, propertyTrack)\n                }\n            case "text":\n                {\n                    return NS.TextTypeAdapter.Interpolate(time, start, end, propertyTrack)\n                }\n            }\n        }\n        _CreatePropertyAdapter() {\n            const pt = this._propertyTrack;\n            const type = pt.CanHavePropertyKeyframes() ? pt.GetPropertyKeyframeType() : "";\n            switch (type) {\n            case "combo":\n            case "boolean":\n            case "text":\n            case "string":\n                {\n                    return new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this)\n                }\n            case "numeric":\n            case "number":\n            case "angle":\n                {\n                    if (this._propertyTrack.GetPropertyType() === "combo")\n                        return new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this);\n                    return new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this)\n                }\n            case "color":\n            case "offsetColor":\n                {\n                    return new NS.PropertyInterpolationAdapter.ColorInterpolationAdapter(this)\n                }\n            default:\n                {\n                    return new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this)\n                }\n            }\n        }\n        _SaveToJson() {\n            return {\n                "propertyAdapterJson": this.GetPropertyAdapter()._SaveToJson()\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            this.GetPropertyAdapter()._LoadFromJson(o["propertyAdapterJson"])\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/state\/propertySourceAdapters\/instanceVariableSourceAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const INDEX = 0;\n    class InstanceVariableSourceAdapter extends C3.PropertyTrackState.PropertySourceAdapter {\n        constructor(propertyTrack) {\n            super(propertyTrack);\n            this._updatedIndex = NaN\n        }\n        GetEditorIndex() {\n            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[INDEX]\n        }\n        GetIndex() {\n            if (this._updatedIndex)\n                return this._updatedIndex;\n            return super.GetIndex()\n        }\n        GetTarget() {\n            return this._propertyTrack.GetTrack().GetInstance()\n        }\n        UpdateInstanceVariableIndex(index) {\n            const i = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[INDEX];\n            if (i === index)\n                return;\n            this._updatedIndex = index\n        }\n        Interpolate(time, start, end, setTime, ensureValue) {\n            if (!this.GetPropertyAdapter().CanChange(start.GetValue()))\n                return;\n            super.Interpolate(time, start, end, setTime, ensureValue)\n        }\n        GetInterpolatedValue(time, start, end) {\n            if (!this.GetPropertyAdapter().CanChange(start.GetValue()))\n                return;\n            return super.GetInterpolatedValue(time, start, end)\n        }\n        _SaveToJson() {\n            return Object.assign(super._SaveToJson(), {\n                "index": this._updatedIndex\n            })\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            super._LoadFromJson(o);\n            this._updatedIndex = o["index"]\n        }\n    }\n    C3.PropertyTrackState.InstanceVariableSourceAdapter = InstanceVariableSourceAdapter;\n\n}\n\n\/\/ timelines\/state\/propertySourceAdapters\/behaviorSourceAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const SID = 0;\n    const INDEX = 1;\n    const NAME = 2;\n    class BehaviorSourceAdapter extends C3.PropertyTrackState.PropertySourceAdapter {\n        constructor(propertyTrack) {\n            super(propertyTrack);\n            this._sid = NaN\n        }\n        GetEditorIndex() {\n            const dataItem = this._propertyTrack.GetPropertyTrackDataItem();\n            return dataItem.GetSourceAdapterArguments()[INDEX]\n        }\n        GetTarget() {\n            const dataItem = this._propertyTrack.GetPropertyTrackDataItem();\n            const track = this._propertyTrack.GetTrack();\n            const sid = this._sid ? this._sid : dataItem.GetSourceAdapterArguments()[SID];\n            const instance = track.GetInstance();\n            const index = instance.GetBehaviorIndexBySID(sid);\n            const behaviorInstance = instance.GetBehaviorInstances()[index];\n            return behaviorInstance.GetSdkInstance()\n        }\n        GetBehaviorType(objectClass) {\n            const dataItem = this._propertyTrack.GetPropertyTrackDataItem();\n            const name = dataItem.GetSourceAdapterArguments()[NAME];\n            return objectClass.GetBehaviorTypeByName(name)\n        }\n        UpdateBehaviorTypeSid(sid) {\n            const dataItem = this._propertyTrack.GetPropertyTrackDataItem();\n            if (dataItem.GetSourceAdapterArguments()[SID] === sid)\n                return;\n            this._sid = sid\n        }\n        Interpolate(time, start, end, setTime, ensureValue) {\n            const track = this._propertyTrack.GetTrack();\n            const instance = track.GetInstance();\n            if (!this.GetBehaviorType(instance.GetObjectClass()))\n                return;\n            super.Interpolate(time, start, end, setTime, ensureValue)\n        }\n        GetInterpolatedValue(time, start, end) {\n            const track = this._propertyTrack.GetTrack();\n            const instance = track.GetInstance();\n            if (!this.GetBehaviorType(instance.GetObjectClass()))\n                return;\n            return super.GetInterpolatedValue(time, start, end)\n        }\n        _SaveToJson() {\n            return Object.assign(super._SaveToJson(), {\n                "sid": this._sid\n            })\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            super._LoadFromJson(o);\n            this._sid = o["sid"]\n        }\n    }\n    C3.PropertyTrackState.BehaviorSourceAdapter = BehaviorSourceAdapter;\n\n}\n\n\/\/ timelines\/state\/propertySourceAdapters\/effectSourceAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const NAME = 0;\n    const INDEX = 1;\n    class EffectSourceAdapter extends C3.PropertyTrackState.PropertySourceAdapter {\n        constructor(propertyTrack) {\n            super(propertyTrack)\n        }\n        GetEditorIndex() {\n            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[INDEX]\n        }\n        GetTarget() {\n            const pTrack = this._propertyTrack;\n            const track = pTrack.GetTrack();\n            const worldInfo = track.GetWorldInfo();\n            const instanceEffectList = worldInfo.GetInstanceEffectList();\n            const effectList = instanceEffectList.GetEffectList();\n            const effectType = this.GetEffectType(effectList);\n            const effectIndex = effectType.GetIndex();\n            if (instanceEffectList.IsEffectIndexActive(effectIndex))\n                return instanceEffectList.GetEffectParametersForIndex(effectIndex);\n            return null\n        }\n        GetEffectType(effectList) {\n            const pTrack = this._propertyTrack;\n            const name = pTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[NAME];\n            return effectList.GetEffectTypeByName(name)\n        }\n        Interpolate(time, start, end, setTime, ensureValue) {\n            if (!this._IsEffectActive())\n                return;\n            super.Interpolate(time, start, end, setTime, ensureValue)\n        }\n        GetInterpolatedValue(time, start, end) {\n            if (!this._IsEffectActive())\n                return;\n            return super.GetInterpolatedValue(time, start, end)\n        }\n        _IsEffectActive() {\n            const pTrack = this._propertyTrack;\n            const track = pTrack.GetTrack();\n            const worldInfo = track.GetWorldInfo();\n            const instanceEffectList = worldInfo.GetInstanceEffectList();\n            const effectList = instanceEffectList.GetEffectList();\n            const effectType = this.GetEffectType(effectList);\n            if (!effectType)\n                return;\n            const effectIndex = effectType.GetIndex();\n            return instanceEffectList.IsEffectIndexActive(effectIndex)\n        }\n    }\n    C3.PropertyTrackState.EffectSourceAdapter = EffectSourceAdapter;\n\n}\n\n\/\/ timelines\/state\/propertySourceAdapters\/pluginSourceAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const INDEX = 0;\n    class PluginSourceAdapter extends C3.PropertyTrackState.PropertySourceAdapter {\n        constructor(propertyTrack) {\n            super(propertyTrack)\n        }\n        GetEditorIndex() {\n            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[INDEX]\n        }\n        GetTarget() {\n            return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance()\n        }\n        Interpolate(time, start, end, setTime, ensureValue) {\n            const track = this._propertyTrack.GetTrack();\n            const templatePlugin = track.GetObjectClass().GetPlugin();\n            const currentPlugin = track.GetInstance().GetObjectClass().GetPlugin();\n            if (templatePlugin !== currentPlugin)\n                return;\n            super.Interpolate(time, start, end, setTime, ensureValue)\n        }\n        GetInterpolatedValue(time, start, end) {\n            const track = this._propertyTrack.GetTrack();\n            const templatePlugin = track.GetObjectClass().GetPlugin();\n            const currentPlugin = track.GetInstance().GetObjectClass().GetPlugin();\n            if (templatePlugin !== currentPlugin)\n                return;\n            return super.GetInterpolatedValue(time, start, end)\n        }\n    }\n    C3.PropertyTrackState.PluginSourceAdapter = PluginSourceAdapter;\n\n}\n\n\/\/ timelines\/state\/propertySourceAdapters\/valueSourceAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    class ValueSourceAdapter extends C3.PropertyTrackState.PropertySourceAdapter {\n        constructor(propertyTrack) {\n            super(propertyTrack);\n            this._value = 0;\n            this._init = false\n        }\n        MayNeedBeforeAndAfterInterpolate() {\n            return false\n        }\n        SetInitialState() {\n            const propertyTrackData = this._propertyTrack.GetPropertyTrackData();\n            let propertyTrackDataItem = this._propertyTrack.GetPropertyTrackDataItem();\n            propertyTrackDataItem = propertyTrackData.GetFirstPropertyKeyframeDataItem(propertyTrackDataItem);\n            this._value = propertyTrackDataItem.GetValueWithResultMode()\n        }\n        SetResumeState() {}\n        GetValue() {\n            if (!this._init)\n                this._propertyTrack.Interpolate(0);\n            return this._value\n        }\n        Interpolate(time, start, end, setTime, ensureValue) {\n            this._value = C3.PropertyTrackState.NumericTypeAdapter.Interpolate(time, start, end, this._propertyTrack);\n            this._init = true\n        }\n        SaveState() {}\n        ClearSaveState() {}\n        GetCurrentState() {\n            return this._value\n        }\n        CompareInitialStateWithCurrent() {\n            return false\n        }\n        CompareSaveStateWithCurrent() {\n            return false\n        }\n        _SaveToJson() {\n            return {\n                "value": this._value,\n                "init": this._init\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            this._value = o["value"];\n            this._init = o.hasOwnProperty("init") ? o["init"] : true\n        }\n    }\n    C3.PropertyTrackState.ValueSourceAdapter = ValueSourceAdapter;\n\n}\n\n\/\/ timelines\/state\/propertySourceAdapters\/audioSourceAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const PROJECT_FILE = 0;\n    const PROJECT_FILE_NAME = 0;\n    const PROJECT_FILE_TYPE = 1;\n    const START_OFFSET = 1;\n    const AUDIO_DURATION = 2;\n    const AUDIO_TAG = 3;\n    class AudioSourceAdapter extends C3.PropertyTrackState.PropertySourceAdapter {\n        constructor(propertyTrack) {\n            super(propertyTrack);\n            this._audioPlaybackStarted = false;\n            this._sdkInstance = null;\n            this._actions = null;\n            this._expressions = null;\n            this._timeline = this._propertyTrack.GetTimeline();\n            this._track = this._propertyTrack.GetTrack();\n            this._sourceAdapterArgs = this._propertyTrack.GetSourceAdapterArgs();\n            this._fileArgs = this._sourceAdapterArgs[PROJECT_FILE];\n            this._startOffsetTime = this._sourceAdapterArgs[START_OFFSET];\n            if (this._sourceAdapterArgs[AUDIO_TAG])\n                this._audioTag = this._sourceAdapterArgs[AUDIO_TAG];\n            else\n                this._audioTag = Math.random().toString(36).slice(2);\n            this._pauseTime = NaN;\n            this._pauseVolume = NaN;\n            this._volume = NaN;\n            this._audioSource = null;\n            this._Initialize()\n        }\n        Release() {\n            super.Release();\n            this._sdkInstance = null;\n            this._actions = null;\n            this._expressions = null;\n            this._timeline = null;\n            this._track = null;\n            this._sourceAdapterArgs = null;\n            this._fileArgs = null;\n            this._audioSource = null\n        }\n        _Initialize() {\n            if (!self.C3.Plugins.Audio)\n                return;\n            const runtime = this._propertyTrack.GetRuntime();\n            const audioObjectClass = runtime.GetObjectClassByName("audio");\n            if (audioObjectClass)\n                this._sdkInstance = audioObjectClass.GetSingleGlobalInstance().GetSdkInstance();\n            this._actions = self.C3.Plugins.Audio.Acts;\n            this._expressions = self.C3.Plugins.Audio.Exps\n        }\n        _MaybeSetAudioSource() {\n            if (this._audioSource)\n                return;\n            const track = this._propertyTrack.GetTrack();\n            const audioSourcePropertyTrack = track.GetPropertyTrack("audioSource");\n            if (audioSourcePropertyTrack)\n                this._audioSource = audioSourcePropertyTrack.GetSourceAdapter()\n        }\n        _GetPauseVolume() {\n            const track = this._propertyTrack.GetTrack();\n            const volumePropertyTrack = track.GetPropertyTrack("volume");\n            if (volumePropertyTrack)\n                return volumePropertyTrack.GetSourceAdapter()._pauseVolume;\n            else\n                return this._pauseVolume\n        }\n        TimelineRemoved() {\n            super.TimelineRemoved();\n            this._audioPlaybackStarted = false;\n            if (this._sdkInstance) {\n                if (this._expressions) {\n                    this._pauseTime = this._expressions.PlaybackTime.call(this._sdkInstance, this._audioTag);\n                    this._pauseVolume = this._expressions.Volume.call(this._sdkInstance, this._audioTag)\n                }\n                if (this._actions)\n                    this._actions.Stop.call(this._sdkInstance, this._audioTag)\n            }\n        }\n        GetAudioTag() {\n            return this._audioTag\n        }\n        GetVolume() {\n            return this._volume\n        }\n        SetVolume(v) {\n            this._volume = v\n        }\n        SetInitialState() {\n            super.SetInitialState();\n            this._pauseTime = NaN;\n            this._audioPlaybackStarted = false\n        }\n        SetResumeState() {\n            super.SetResumeState();\n            const timeline = this._propertyTrack.GetTimeline();\n            const time = timeline.GetTime();\n            this._pauseTime = time - this._startOffsetTime;\n            switch (this._propertyTrack.GetPropertyName()) {\n            case "audioSource":\n                {\n                    break\n                }\n            case "volume":\n                {\n                    this._pauseVolume = this._propertyTrack.GetInterpolatedValue(time);\n                    break\n                }\n            }\n            this._audioPlaybackStarted = false\n        }\n        Interpolate(time, start, end, setTime, ensureValue) {\n            if (!this._sdkInstance)\n                return;\n            switch (this._propertyTrack.GetPropertyName()) {\n            case "audioSource":\n                {\n                    if (!this._timeline.IsForwardPlayBack())\n                        return;\n                    if (setTime) {\n                        if (this._actions)\n                            this._actions.Stop.call(this._sdkInstance, this._audioTag);\n                        return\n                    }\n                    if (time < this._startOffsetTime) {\n                        this._audioPlaybackStarted = false;\n                        return\n                    }\n                    const aPlaybackRate = this._expressions.PlaybackRate.call(this._sdkInstance, this._audioTag);\n                    const tPlaybackRate = this._timeline.GetPlaybackRate();\n                    if (tPlaybackRate !== aPlaybackRate)\n                        this._actions.SetPlaybackRate.call(this._sdkInstance, this._audioTag, tPlaybackRate);\n                    if (this._audioPlaybackStarted)\n                        return;\n                    this._audioPlaybackStarted = true;\n                    if (isNaN(this._pauseTime)) {\n                        const thenTime = self["performance"].now();\n                        const startDeltaTime = time - this._startOffsetTime;\n                        const state = this._sdkInstance.GetAudioContextState();\n                        if (state === "suspended") {\n                            this._audioPlaybackStarted = false;\n                            return\n                        }\n                        const nowTime = self["performance"].now();\n                        const postToDOMDeltaTime = (nowTime - thenTime) \/ 1E3;\n                        const startPlaybackOffset = startDeltaTime + postToDOMDeltaTime;\n                        if (this._actions) {\n                            let startVolume = this.GetVolume();\n                            if (isNaN(startVolume)) {\n                                this.SetVolume(0);\n                                startVolume = 0\n                            } else\n                                this.SetVolume(startVolume);\n                            this._actions.Play.call(this._sdkInstance, this._fileArgs, 0, startVolume, this._audioTag, startPlaybackOffset)\n                        }\n                    } else {\n                        const startTime = this._pauseTime;\n                        this._pauseTime = NaN;\n                        const startVolume = this._GetPauseVolume();\n                        this._pauseVolume = NaN;\n                        const state = this._sdkInstance.GetAudioContextState();\n                        if (state === "suspended") {\n                            this._audioPlaybackStarted = false;\n                            return\n                        }\n                        if (this._actions) {\n                            this.SetVolume(startVolume);\n                            this._actions.Play.call(this._sdkInstance, this._fileArgs, 0, startVolume, this._audioTag, startTime)\n                        }\n                    }\n                    break\n                }\n            case "volume":\n                {\n                    this._MaybeSetAudioSource();\n                    super.Interpolate(time, start, end, setTime, ensureValue)\n                }\n            }\n        }\n        GetInterpolatedValue(time, start, end) {\n            if (!this._sdkInstance)\n                return;\n            switch (this._propertyTrack.GetPropertyName()) {\n            case "audioSource":\n                {\n                    return\n                }\n            case "volume":\n                {\n                    this._MaybeSetAudioSource();\n                    return super.GetInterpolatedValue(time, start, end)\n                }\n            }\n        }\n        Getter(wi, track) {\n            if (this._audioSource)\n                return this._audioSource.GetVolume();\n            return 0\n        }\n        Setter(wi, value, track, interpolationAdapter) {\n            if (this._audioSource)\n                this._audioSource.SetVolume(this.Getter() + value);\n            if (this._actions && this._audioSource)\n                this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume())\n        }\n        AbsoluteSetter(wi, value, track) {\n            if (this._audioSource)\n                this._audioSource.SetVolume(value);\n            if (this._actions && this._audioSource)\n                this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume())\n        }\n        DoesRounding() {\n            return true\n        }\n        _SaveToJson() {\n            return {\n                "audioPlaybackStarted": this._audioPlaybackStarted,\n                "audioTag": this._audioTag,\n                "pauseTime": this._pauseTime,\n                "pauseVolume": this._pauseVolume,\n                "volume": this._volume\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            this._audioPlaybackStarted = o["audioPlaybackStarted"];\n            this._audioTag = o["audioTag"];\n            this._pauseTime = o["pauseTime"];\n            this._pauseVolume = o["pauseVolume"];\n            this._volume = o["volume"];\n            this._Initialize()\n        }\n    }\n    C3.PropertyTrackState.AudioSourceAdapter = AudioSourceAdapter;\n\n}\n\n\/\/ timelines\/state\/propertyInterpolationAdapters\/propertyInterpolationAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.PropertyTrackState.PropertyInterpolationAdapter = class PropertyInterpolationAdapter {\n        constructor(sourceAdapter) {\n            this._sourceAdapter = sourceAdapter;\n            this._propertyTrack = sourceAdapter.GetPropertyTrack();\n            this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo();\n            this._property = this._propertyTrack.GetPropertyName();\n            this._firstAbsoluteUpdate = false;\n            this._saveState = null;\n            this._target = null\n        }\n        Release() {\n            this._sourceAdapter = null;\n            this._propertyTrack = null;\n            this._worldInfo = null;\n            this._saveState = null;\n            this._target = null\n        }\n        MayNeedBeforeAndAfterInterpolate() {\n            return false\n        }\n        TimelineRemoved() {}\n        CleanCaches() {\n            this._worldInfo = null;\n            this._saveState = null;\n            this._target = null\n        }\n        GetSourceAdapter() {\n            return this._sourceAdapter\n        }\n        GetPropertyTrack() {\n            return this._propertyTrack\n        }\n        GetWorldInfo() {\n            if (this._worldInfo)\n                return this._worldInfo;\n            this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo();\n            return this._worldInfo\n        }\n        SetFirstAbsoluteUpdate(f) {\n            this._firstAbsoluteUpdate = !!f\n        }\n        GetFirstAbsoluteUpdate() {\n            return this._firstAbsoluteUpdate\n        }\n        SetResetState() {}\n        SetInitialState() {}\n        SetResumeState() {}\n        SetSaveState() {\n            this._saveState = this.GetCurrentState()\n        }\n        ClearSaveState() {\n            this._saveState = null\n        }\n        GetCurrentState() {}\n        CompareInitialStateWithCurrent() {}\n        CompareSaveStateWithCurrent() {}\n        CanChange(value) {\n            const targetType = typeof this._Getter();\n            const newType = typeof value;\n            return targetType === newType\n        }\n        BeforeChangeProperty() {}\n        ChangeProperty(time, value, start, end, setTime) {}\n        AfterChangeProperty() {}\n        _FirstKeyframeGetter() {\n            const propertyKeyframeDataItem = this._PickTimelinePlaybackMode( () => {\n                const propertyTrackDataItem = this._propertyTrack.GetPropertyTrackDataItem();\n                const propertyTrackData = this._propertyTrack.GetPropertyTrackData();\n                return propertyTrackData.GetFirstPropertyKeyframeDataItem(propertyTrackDataItem)\n            }\n            , () => {\n                const propertyTrackDataItem = this._propertyTrack.GetPropertyTrackDataItem();\n                const propertyTrackData = this._propertyTrack.GetPropertyTrackData();\n                return propertyTrackData.GetLastPropertyKeyframeDataItem(propertyTrackDataItem)\n            }\n            );\n            return propertyKeyframeDataItem.GetAbsoluteValue()\n        }\n        _CurrentKeyframeGetter() {\n            const timeline = this._propertyTrack.GetTimeline();\n            const time = timeline.GetTime() - this._propertyTrack.GetTrack().GetStartOffset();\n            const propertyKeyframe = this._PickTimelinePlaybackMode( () => {\n                const propertyTrackDataItem = this._propertyTrack.GetPropertyTrackDataItem();\n                const propertyTrackData = this._propertyTrack.GetPropertyTrackData();\n                return propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(time, propertyTrackDataItem)\n            }\n            , () => {\n                const propertyTrackDataItem = this._propertyTrack.GetPropertyTrackDataItem();\n                const propertyTrackData = this._propertyTrack.GetPropertyTrackData();\n                const ret = propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(time, propertyTrackDataItem);\n                if (!ret)\n                    return propertyTrackData.GetLastPropertyKeyframeDataItem(propertyTrackDataItem);\n                return ret\n            }\n            );\n            return propertyKeyframe.GetAbsoluteValue()\n        }\n        _PickTimelinePlaybackMode(forwardFunc, backwardFunc) {\n            const timeline = this._propertyTrack.GetTimeline();\n            return timeline.IsForwardPlayBack() ? forwardFunc() : backwardFunc()\n        }\n        _PickResultMode(relativeFunc, absoluteFunc) {\n            const resultMode = this._propertyTrack.GetResultMode();\n            return resultMode === "relative" ? relativeFunc() : absoluteFunc()\n        }\n        _PickFirstAbsoluteUpdate(firstFunc, otherFunc) {\n            if (this.GetFirstAbsoluteUpdate()) {\n                this.SetFirstAbsoluteUpdate(false);\n                return firstFunc()\n            } else\n                return otherFunc()\n        }\n        _GetAbsoluteInitialValue(keyframeValue) {}\n        _GetIndex() {\n            return this._sourceAdapter.GetIndex()\n        }\n        _GetTarget() {\n            if (this._target)\n                return this._target;\n            this._target = this._sourceAdapter.GetTarget();\n            return this._target\n        }\n        _PickSource(bFunc, eFunc, ivFunc, pFunc, wiFunc, aFunc) {\n            const id = this._propertyTrack.GetSourceAdapterId();\n            switch (id) {\n            case "behavior":\n                return bFunc();\n            case "effect":\n                return eFunc();\n            case "instance-variable":\n                return ivFunc();\n            case "plugin":\n                return pFunc();\n            case "world-instance":\n                return wiFunc();\n            case "audio":\n                return aFunc()\n            }\n        }\n        _SaveToJson() {\n            return {\n                "firstAbsoluteUpdate": this._firstAbsoluteUpdate,\n                "saveState": this._saveState\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            this._firstAbsoluteUpdate = o["firstAbsoluteUpdate"];\n            this._saveState = o["saveState"]\n        }\n        _GetPropertyKeyframeStubs(propertyTracks, firstOnly=false) {\n            const ret = [];\n            for (const propertyTrack of propertyTracks) {\n                const startOffset = propertyTrack.GetTrack().GetStartOffset();\n                for (const propertyKeyframeDataItem of propertyTrack.GetPropertyKeyframeDataItems())\n                    if (firstOnly && propertyKeyframeDataItem.GetTime() === 0)\n                        ret.push({\n                            time: startOffset + propertyKeyframeDataItem.GetTime(),\n                            value: propertyKeyframeDataItem.GetAbsoluteValue()\n                        });\n                    else if (!firstOnly)\n                        ret.push({\n                            time: startOffset + propertyKeyframeDataItem.GetTime(),\n                            value: propertyKeyframeDataItem.GetAbsoluteValue()\n                        })\n            }\n            return ret.sort( (f, s) => f.time - s.time)\n        }\n        _GetLastPropertyKeyframeStub(timeline, time, propertyKeyframeStubs) {\n            return this._GetPropertyKeyframeStubLowerThanPlayhead(time, propertyKeyframeStubs)\n        }\n        _GetPropertyKeyframeStubLowerThanPlayhead(time, propertyKeyframeStubs) {\n            for (let i = propertyKeyframeStubs.length - 1; i >= 0; i--) {\n                const stubTime = propertyKeyframeStubs[i].time;\n                if (stubTime <= time)\n                    return propertyKeyframeStubs[i]\n            }\n            return null\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/state\/propertyInterpolationAdapters\/colorInterpolationAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const TMP_COLORS_MAP = new Map;\n    const TMP_COLOR = [0, 0, 0];\n    class ColorInterpolationAdapter extends C3.PropertyTrackState.PropertyInterpolationAdapter {\n        constructor(sourceAdapter) {\n            super(sourceAdapter)\n        }\n        SetResetState() {}\n        SetInitialState() {}\n        SetResumeState() {}\n        GetCurrentState() {\n            const id = this._propertyTrack.GetSourceAdapterId();\n            const target = this._GetTarget();\n            const index = this._GetIndex();\n            switch (id) {\n            case "behavior":\n                return this._ToColorArray(target.GetPropertyValueByIndex(index));\n            case "effect":\n                return this._ToColorArray(target[index]);\n            case "plugin":\n                return this._ToColorArray(target.GetPropertyValueByIndex(index));\n            case "world-instance":\n                return this._ToColorArray(this._Getter())\n            }\n        }\n        CompareInitialStateWithCurrent() {\n            const firstKeyframeColor = this._FirstKeyframeGetter();\n            return !this._CompareColors(firstKeyframeColor, this._Getter())\n        }\n        CompareSaveStateWithCurrent() {\n            if (C3.IsNullOrUndefined(this._saveState))\n                return false;\n            return !this._CompareColors(this._saveState, this._Getter())\n        }\n        _CompareColors(fColor, sColor) {\n            fColor = this._GetColorFromArray(fColor);\n            sColor = this._GetColorFromArray(sColor);\n            return fColor.equalsIgnoringAlpha(sColor)\n        }\n        _FirstKeyframeGetter() {\n            const color = super._FirstKeyframeGetter();\n            return this._GetColorFromArray(color)\n        }\n        _CurrentKeyframeGetter() {\n            const color = super._CurrentKeyframeGetter();\n            return this._GetColorFromArray(color)\n        }\n        _GetAbsoluteInitialValue(value) {}\n        _ToColorArray(color) {\n            if (C3.IsInstanceOf(color, C3.Color))\n                return color.toArray().slice(0, 3);\n            return color.slice(0, 3)\n        }\n        _GetColorFromArray(color) {\n            if (C3.IsInstanceOf(color, C3.Color))\n                return color;\n            return new C3.Color(color[0],color[1],color[2],1)\n        }\n        CanChange(value) {\n            return true\n        }\n        MayNeedBeforeAndAfterInterpolate() {\n            return true\n        }\n        BeforeChangeProperty() {\n            const timeline = this._propertyTrack.GetTimeline();\n            const instance = this._propertyTrack.GetInstance();\n            const sourceAdapter = this._propertyTrack.GetSourceAdapter();\n            const propertyTracks = timeline.GetSimilarPropertyTracks(instance, sourceAdapter, this._property);\n            if (propertyTracks && propertyTracks.length > 1) {\n                if (!TMP_COLORS_MAP.has(instance))\n                    TMP_COLORS_MAP.set(instance, new Map);\n                const instanceMap = TMP_COLORS_MAP.get(instance);\n                const id = this._propertyTrack.GetSourceAdapterId();\n                if (!instanceMap.has(id))\n                    instanceMap.set(id, new Map);\n                const sourceMap = instanceMap.get(id);\n                if (!sourceMap.has(this._property))\n                    sourceMap.set(this._property, {\n                        used: false,\n                        color: new C3.Color(0,0,0,1)\n                    })\n            }\n        }\n        _GetTmpColor(instance, sourceId, propertyName) {\n            const tmpColorObj = TMP_COLORS_MAP.get(instance).get(sourceId).get(propertyName);\n            tmpColorObj.used = true;\n            return tmpColorObj.color\n        }\n        ChangeProperty(time, value, start, end, setTime) {\n            const timeline = this._propertyTrack.GetTimeline();\n            const track = this._propertyTrack.GetTrack();\n            const instance = this._propertyTrack.GetInstance();\n            const sourceAdapter = this._propertyTrack.GetSourceAdapter();\n            const sourceAdapterId = this._propertyTrack.GetSourceAdapterId();\n            const property = this._property;\n            const propertyTracks = timeline.GetSimilarPropertyTracks(instance, sourceAdapter, property);\n            if (propertyTracks && propertyTracks.length > 1) {\n                const propertyKeyframeStubs = this._GetPropertyKeyframeStubs(propertyTracks, true);\n                const stub = this._GetLastPropertyKeyframeStub(timeline, timeline.GetTime(), propertyKeyframeStubs);\n                if (stub) {\n                    const startOffset = track.GetStartOffset();\n                    const t = stub.time - startOffset;\n                    if (t === 0)\n                        this._GetTmpColor(instance, sourceAdapterId, this._property).addRgb(value[0], value[1], value[2]);\n                    else {\n                        if (t < 0)\n                            return;\n                        const r = value[0];\n                        const g = value[1];\n                        const b = value[2];\n                        const v = this._propertyTrack.Interpolate(t, false, true);\n                        const dr = C3.Color.DiffChannel(r, v[0]);\n                        const dg = C3.Color.DiffChannel(g, v[1]);\n                        const db = C3.Color.DiffChannel(b, v[2]);\n                        this._GetTmpColor(instance, sourceAdapterId, this._property).addRgb(dr, dg, db)\n                    }\n                }\n            } else\n                this._Setter(value[0], value[1], value[2])\n        }\n        AfterChangeProperty() {\n            const instance = this._propertyTrack.GetInstance();\n            if (!TMP_COLORS_MAP.has(instance))\n                return;\n            const instanceMap = TMP_COLORS_MAP.get(instance);\n            const id = this._propertyTrack.GetSourceAdapterId();\n            if (!instanceMap.has(id))\n                return;\n            const sourceMap = instanceMap.get(id);\n            if (!sourceMap.has(this._property))\n                return;\n            const tmpColorObj = sourceMap.get(this._property);\n            const used = tmpColorObj.used;\n            const color = tmpColorObj.color;\n            if (used)\n                this._Setter(color.getR(), color.getG(), color.getB());\n            if (sourceMap.size === 0)\n                instanceMap.delete(id);\n            if (instanceMap.size === 0)\n                TMP_COLORS_MAP.delete(instance)\n        }\n        _Getter() {\n            const id = this._propertyTrack.GetSourceAdapterId();\n            const target = this._GetTarget();\n            const index = this._GetIndex();\n            switch (id) {\n            case "behavior":\n                return this._GetColorFromArray(target.GetPropertyValueByIndex(index));\n            case "effect":\n                return target[index].clone();\n            case "plugin":\n                return this._GetColorFromArray(target.GetPropertyValueByIndex(index));\n            case "world-instance":\n                return this.GetWorldInfo().GetUnpremultipliedColor().clone()\n            }\n        }\n        _Setter(r, g, b) {\n            const id = this._propertyTrack.GetSourceAdapterId();\n            const target = this._GetTarget();\n            const index = this._GetIndex();\n            switch (id) {\n            case "behavior":\n                TMP_COLOR[0] = r;\n                TMP_COLOR[1] = g;\n                TMP_COLOR[2] = b;\n                target.SetPropertyValueByIndex(index, TMP_COLOR);\n                break;\n            case "effect":\n                target[index].setRgb(r, g, b);\n                break;\n            case "plugin":\n                TMP_COLOR[0] = r;\n                TMP_COLOR[1] = g;\n                TMP_COLOR[2] = b;\n                target.SetPropertyValueByIndex(index, TMP_COLOR);\n                break;\n            case "world-instance":\n                this.GetWorldInfo().SetUnpremultipliedColorRGB(r, g, b);\n                break\n            }\n        }\n        _SaveToJson() {}\n        _LoadFromJson(o) {}\n    }\n    C3.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = ColorInterpolationAdapter;\n\n}\n\n\/\/ timelines\/state\/propertyInterpolationAdapters\/noInterpolationAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const NS = C3.PropertyTrackState;\n    class NoInterpolationAdapter extends C3.PropertyTrackState.PropertyInterpolationAdapter {\n        constructor(sourceAdapter) {\n            super(sourceAdapter)\n        }\n        SetResetState() {}\n        SetInitialState() {}\n        SetResumeState() {}\n        GetCurrentState() {\n            return this._Getter()\n        }\n        CompareInitialStateWithCurrent() {\n            const firstKeyframeValue = this._FirstKeyframeGetter();\n            return firstKeyframeValue !== this.GetCurrentState()\n        }\n        CompareSaveStateWithCurrent() {\n            if (C3.IsNullOrUndefined(this._saveState))\n                return false;\n            return this._saveState !== this.GetCurrentState()\n        }\n        MayNeedBeforeAndAfterInterpolate() {\n            return false\n        }\n        ChangeProperty(time, value, start, end, setTime) {\n            const propertyTrack = this._propertyTrack;\n            const track = propertyTrack.GetTrack();\n            const id = propertyTrack.GetSourceAdapterId();\n            const timeline = propertyTrack.GetTimeline();\n            const instance = track.GetInstance();\n            const sourceAdapter = propertyTrack.GetSourceAdapter();\n            const property = this._property;\n            const propertyTracks = timeline.GetSimilarPropertyTracks(instance, sourceAdapter, property);\n            if (propertyTracks && propertyTracks.length > 1) {\n                const propertyKeyframeStubs = this._GetPropertyKeyframeStubs(propertyTracks);\n                const t = time + track.GetStartOffset();\n                const stub = this._GetLastPropertyKeyframeStub(timeline, t, propertyKeyframeStubs);\n                if (stub)\n                    value = stub.value\n            }\n            const type = propertyTrack.GetPropertyKeyframeType();\n            switch (type) {\n            case "numeric":\n                {\n                    if (!NS.NumericTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), value, id))\n                        return;\n                    break\n                }\n            case "angle":\n                {\n                    if (!NS.AngleTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), value, id))\n                        return;\n                    break\n                }\n            case "boolean":\n                {\n                    if (!NS.BooleanTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), value, id))\n                        return;\n                    break\n                }\n            case "color":\n                {\n                    if (!NS.ColorTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), value, id))\n                        return;\n                    break\n                }\n            case "text":\n                {\n                    if (!NS.TextTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), value, id))\n                        return;\n                    break\n                }\n            }\n            this._Setter(value)\n        }\n        _Getter() {\n            const id = this._propertyTrack.GetSourceAdapterId();\n            const target = this._GetTarget();\n            const index = this._GetIndex();\n            switch (id) {\n            case "behavior":\n                return target.GetPropertyValueByIndex(index);\n            case "effect":\n                return target[index];\n            case "instance-variable":\n                return target.GetInstanceVariableValue(index);\n            case "plugin":\n                return target.GetPropertyValueByIndex(index)\n            }\n        }\n        _Setter(value) {\n            const id = this._propertyTrack.GetSourceAdapterId();\n            const target = this._GetTarget();\n            const index = this._GetIndex();\n            switch (id) {\n            case "behavior":\n                target.SetPropertyValueByIndex(index, value);\n                break;\n            case "effect":\n                target[index] = value;\n                break;\n            case "instance-variable":\n                target.SetInstanceVariableValue(index, value);\n                break;\n            case "plugin":\n                target.SetPropertyValueByIndex(index, value);\n                break\n            }\n        }\n    }\n    C3.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = NoInterpolationAdapter;\n\n}\n\n\/\/ timelines\/state\/propertyInterpolationAdapters\/numericInterpolationAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const NS = C3.PropertyTrackState.PropertyInterpolationAdapter;\n    const INSTANCE_FUNC_MAP = new Map;\n    const add = (prop, setter, absolute_setter, getter, round, fRound=false, init=null, reset=null) => {\n        INSTANCE_FUNC_MAP.set(prop, {\n            setter,\n            absolute_setter,\n            getter,\n            round,\n            fRound,\n            init,\n            reset\n        })\n    }\n    ;\n    add("offsetX", (wi, v, t, a) => {\n        if (a._propertyTrack.GetResultMode() === "relative")\n            wi.OffsetX(v, t.GetTimeline().GetTransformWithSceneGraph());\n        else\n            wi.OffsetX(v)\n    }\n    , (wi, v) => wi.SetX(v), wi => wi.GetX(), true);\n    add("offsetY", (wi, v, t, a) => {\n        if (a._propertyTrack.GetResultMode() === "relative")\n            wi.OffsetY(v, t.GetTimeline().GetTransformWithSceneGraph());\n        else\n            wi.OffsetY(v)\n    }\n    , (wi, v) => wi.SetY(v), wi => wi.GetY(), true);\n    add("offsetWidth", (wi, v) => wi.OffsetWidth(v), (wi, v) => wi.SetWidth(v), wi => wi.GetWidth(), true);\n    add("offsetHeight", (wi, v) => wi.OffsetHeight(v), (wi, v) => wi.SetHeight(v), wi => wi.GetHeight(), true);\n    add("offsetAngle", (wi, v) => wi.OffsetAngle(v), (wi, v) => wi.SetAngle(v), wi => wi.GetAngle(), false);\n    add("offsetOpacity", (wi, v, t, a) => {\n        const o = wi.GetOpacity();\n        const nv = o + v;\n        const min = 0;\n        const max = 1;\n        if (a._clampAccumulator === 0) {\n            if (nv > max)\n                a._clampAccumulator += nv - max;\n            else if (nv < min)\n                a._clampAccumulator += nv;\n            wi.OffsetOpacity(v)\n        } else {\n            const nv = wi.GetOpacity() + v;\n            if (v > 0 && a._clampAccumulator > 0) {\n                if (nv > max)\n                    a._clampAccumulator += nv - max\n            } else if (v > 0 && a._clampAccumulator < 0) {\n                a._clampAccumulator += v;\n                if (a._clampAccumulator > 0)\n                    a._clampAccumulator = 0\n            } else if (v < 0 && a._clampAccumulator > 0) {\n                a._clampAccumulator += v;\n                if (a._clampAccumulator < 0)\n                    a._clampAccumulator = 0\n            } else if (v < 0 && a._clampAccumulator < 0)\n                if (nv < min)\n                    a._clampAccumulator += nv\n        }\n    }\n    , (wi, v) => {\n        wi.SetOpacity(v)\n    }\n    , wi => {\n        return wi.GetOpacity()\n    }\n    , false, true, a => {\n        a._clampAccumulator = 0;\n        switch (a._propertyTrack.GetResultMode()) {\n        case "relative":\n            {\n                const propertyTrackData = a._propertyTrack.GetPropertyTrackData();\n                const propertyTrackDataItem = a._propertyTrack.GetPropertyTrackDataItem();\n                const propertyKeyframeData = propertyTrackDataItem.GetPropertyKeyframeData();\n                const propertyKeyframeDataItems = propertyKeyframeData.GetPropertyKeyframeDataItemArray();\n                let startingAbsoluteOpacity = a.GetWorldInfo().GetOpacity();\n                let currentAbsoluteOpacity = startingAbsoluteOpacity;\n                for (const propertyKeyframeDataItem of propertyKeyframeDataItems) {\n                    const time = propertyKeyframeDataItem.GetTime();\n                    const currentRelativeOpacity = a._propertyTrack.GetInterpolatedValue(time);\n                    currentAbsoluteOpacity = startingAbsoluteOpacity + currentRelativeOpacity;\n                    currentAbsoluteOpacity = C3.clamp(currentAbsoluteOpacity, 0, 1)\n                }\n                a._totalForewardOpacityDelta = startingAbsoluteOpacity - currentAbsoluteOpacity;\n                a._totalForewardOpacityDelta = Math.round((a._totalForewardOpacityDelta + Number.EPSILON) * 100) \/ 100;\n                currentAbsoluteOpacity = startingAbsoluteOpacity;\n                for (let i = propertyKeyframeDataItems.length - 1; i >= 0; i--) {\n                    const time = propertyKeyframeDataItems[i].GetTime();\n                    const currentRelativeOpacity = a._propertyTrack.GetInterpolatedValue(time);\n                    currentAbsoluteOpacity -= currentRelativeOpacity;\n                    currentAbsoluteOpacity = C3.clamp(currentAbsoluteOpacity, 0, 1)\n                }\n                a._totalBackwardOpacityDelta = currentAbsoluteOpacity;\n                a._totalBackwardOpacityDelta = Math.round((a._totalBackwardOpacityDelta + Number.EPSILON) * 100) \/ 100;\n                break\n            }\n        case "absolute":\n            {\n                break\n            }\n        }\n    }\n    , a => {\n        switch (a._propertyTrack.GetResultMode()) {\n        case "relative":\n            {\n                a._clampAccumulator = 0;\n                const wi = a.GetWorldInfo();\n                let currentOpacity = wi.GetOpacity();\n                currentOpacity = Math.round((currentOpacity + Number.EPSILON) * 100) \/ 100;\n                if (a._propertyTrack.GetTimeline().IsForwardPlayBack()) {\n                    wi.SetOpacity(currentOpacity + a._totalForewardOpacityDelta);\n                    a._lastValue = 0\n                } else {\n                    wi.SetOpacity(currentOpacity - a._totalBackwardOpacityDelta);\n                    a._lastValue = a.GetSourceAdapter().GetValueAtTime()\n                }\n                break\n            }\n        case "absolute":\n            {\n                break\n            }\n        }\n    }\n    );\n    add("offsetOriginX", (wi, v) => wi.OffsetOriginX(v), (wi, v) => wi.SetOriginX(v), wi => wi.GetOriginX(), false);\n    add("offsetOriginY", (wi, v) => wi.OffsetOriginY(v), (wi, v) => wi.SetOriginY(v), wi => wi.GetOriginY(), false);\n    add("offsetZElevation", (wi, v) => wi.OffsetZElevation(v), (wi, v) => wi.SetZElevation(v), wi => wi.GetZElevation(), true);\n    add("offsetScaleX", (wi, v, t, a) => {\n        const mirrorFactor = wi.GetWidth() < 0 ? -1 : 1;\n        if (wi.GetTransformWithParentWidth())\n            wi.OffsetWidth(t.GetOriginalWidth() * mirrorFactor * v);\n        else\n            wi.OffsetWidth(t.GetOriginalWidth() * mirrorFactor * v)\n    }\n    , (wi, v, t) => {\n        wi.SetWidth(t.GetOriginalWidth() * v)\n    }\n    , (wi, t) => {\n        const mirrorFactor = wi.GetWidth() < 0 ? -1 : 1;\n        if (wi.GetTransformWithParentWidth()) {\n            const parentWi = wi.GetParent();\n            const parentTrack = t.GetTimeline().GetTrackFromInstance(parentWi.GetInstance());\n            let parentScale = NaN;\n            if (parentTrack)\n                parentScale = parentWi.GetWidth() \/ parentTrack.GetOriginalWidth();\n            else {\n                const sdki = parentWi.GetInstance().GetSdkInstance();\n                if (sdki.IsOriginalSizeKnown())\n                    parentScale = parentWi.GetWidth() \/ sdki.GetOriginalWidth();\n                else\n                    parentScale = 1\n            }\n            return wi.GetWidth() * mirrorFactor \/ (t.GetOriginalWidth() * parentScale)\n        } else\n            return wi.GetWidth() * mirrorFactor \/ t.GetOriginalWidth()\n    }\n    , false);\n    add("offsetScaleY", (wi, v, t, a) => {\n        const flipFactor = wi.GetHeight() < 0 ? -1 : 1;\n        if (wi.GetTransformWithParentHeight())\n            wi.OffsetHeight(t.GetOriginalHeight() * flipFactor * v);\n        else\n            wi.OffsetHeight(t.GetOriginalHeight() * flipFactor * v)\n    }\n    , (wi, v, t) => {\n        wi.SetHeight(t.GetOriginalHeight() * v)\n    }\n    , (wi, t) => {\n        const flipFactor = wi.GetHeight() < 0 ? -1 : 1;\n        if (wi.GetTransformWithParentHeight()) {\n            const parentWi = wi.GetParent();\n            const parentTrack = t.GetTimeline().GetTrackFromInstance(parentWi.GetInstance());\n            let parentScale = NaN;\n            if (parentTrack)\n                parentScale = parentWi.GetHeight() \/ parentTrack.GetOriginalHeight();\n            else {\n                const sdki = parentWi.GetInstance().GetSdkInstance();\n                if (sdki.IsOriginalSizeKnown())\n                    parentScale = parentWi.GetHeight() \/ sdki.GetOriginalHeight();\n                else\n                    parentScale = 1\n            }\n            return wi.GetHeight() * flipFactor \/ (t.GetOriginalHeight() * parentScale)\n        } else\n            return wi.GetHeight() * flipFactor \/ t.GetOriginalHeight()\n    }\n    , false);\n    class NumericInterpolationAdapter extends C3.PropertyTrackState.PropertyInterpolationAdapter {\n        constructor(sourceAdapter) {\n            super(sourceAdapter);\n            this._lastValue = 0;\n            this._clampAccumulator = 0;\n            this._totalForewardOpacityDelta = 0;\n            this._totalBackwardOpacityDelta = 0;\n            this._instance_getter = null;\n            this._instance_setter = null;\n            this._instance_absolute_setter = null;\n            this._reset_action = null;\n            this._init_action = null;\n            this._source_adapter_getter = null;\n            this._source_adapter_setter = null;\n            this._source_adapter_absolute_setter = null;\n            this._round = false;\n            this._fRound = false;\n            if (C3.IsInstanceOf(this._propertyTrack.GetTimeline(), C3.TweenState))\n                this._typeAdapter = new C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this);\n            else\n                this._typeAdapter = new C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this);\n            const property = this._propertyTrack.GetPropertyName();\n            switch (this._propertyTrack.GetSourceAdapterId()) {\n            case "world-instance":\n                {\n                    const p = INSTANCE_FUNC_MAP.get(property);\n                    this._instance_getter = p.getter;\n                    this._instance_setter = p.setter;\n                    this._instance_absolute_setter = p.absolute_setter;\n                    this._round = p.round;\n                    this._fRound = p.fRound;\n                    this._init_action = p.init;\n                    this._reset_action = p.reset;\n                    break\n                }\n            case "audio":\n                {\n                    this._source_adapter_getter = sourceAdapter.Getter;\n                    this._source_adapter_setter = sourceAdapter.Setter;\n                    this._source_adapter_absolute_setter = sourceAdapter.AbsoluteSetter;\n                    this._round = !!sourceAdapter.DoesRounding();\n                    this._fRound = false;\n                    break\n                }\n            }\n        }\n        Release() {\n            this._typeAdapter = null;\n            this._instance_getter = null;\n            this._instance_setter = null;\n            this._instance_absolute_setter = null;\n            super.Release()\n        }\n        MayNeedBeforeAndAfterInterpolate() {\n            return this._typeAdapter.MayNeedBeforeAndAfterInterpolate()\n        }\n        GetLastValue() {\n            return this._lastValue\n        }\n        SetLastValue(v) {\n            this._lastValue = v\n        }\n        SetResetState() {\n            if (this._reset_action)\n                this._reset_action(this)\n        }\n        SetInitialState() {\n            const initValue = this._typeAdapter.SetInitialState();\n            if (typeof initValue === "number")\n                this._lastValue = initValue;\n            if (this._init_action)\n                this._init_action(this)\n        }\n        SetResumeState() {\n            const resumeValue = this._typeAdapter.SetResumeState();\n            if (typeof resumeValue === "number")\n                this._lastValue = resumeValue\n        }\n        GetCurrentState() {\n            return this._Getter()\n        }\n        CompareInitialStateWithCurrent() {\n            const firstKeyframeValue = this._FirstKeyframeGetter();\n            return firstKeyframeValue !== this.GetCurrentState()\n        }\n        CompareSaveStateWithCurrent() {\n            if (C3.IsNullOrUndefined(this._saveState))\n                return false;\n            return this._saveState !== this.GetCurrentState()\n        }\n        BeforeChangeProperty() {\n            this._typeAdapter.BeforeChangeProperty()\n        }\n        ChangeProperty(time, value, start, end, setTime, ensureValue, normalizedValue) {\n            return this._typeAdapter.ChangeProperty(time, value, start, end, setTime, ensureValue, normalizedValue)\n        }\n        AfterChangeProperty() {\n            this._typeAdapter.AfterChangeProperty()\n        }\n        _Getter() {\n            const target = this._GetTarget();\n            const index = this._GetIndex();\n            const wi = this.GetWorldInfo();\n            const track = this._propertyTrack.GetTrack();\n            const id = this._propertyTrack.GetSourceAdapterId();\n            switch (id) {\n            case "behavior":\n                return target.GetPropertyValueByIndex(index);\n            case "effect":\n                return target[index];\n            case "instance-variable":\n                return target.GetInstanceVariableValue(index);\n            case "plugin":\n                return target.GetPropertyValueByIndex(index);\n            case "world-instance":\n                return this._instance_getter(wi, track);\n            case "audio":\n                return this._source_adapter_getter.call(this.GetSourceAdapter(), wi, track)\n            }\n        }\n        _Setter(value, start, end) {\n            const target = this._GetTarget();\n            const index = this._GetIndex();\n            const wi = this.GetWorldInfo();\n            const track = this._propertyTrack.GetTrack();\n            const id = this._propertyTrack.GetSourceAdapterId();\n            switch (id) {\n            case "behavior":\n                target.OffsetPropertyValueByIndex(index, value);\n                break;\n            case "effect":\n                target[index] += value;\n                break;\n            case "instance-variable":\n                target.SetInstanceVariableOffset(index, value);\n                break;\n            case "plugin":\n                target.OffsetPropertyValueByIndex(index, value);\n                break;\n            case "world-instance":\n                this._instance_setter(wi, value, track, this);\n                break;\n            case "audio":\n                this._source_adapter_setter.call(this.GetSourceAdapter(), wi, value, track, this);\n                break\n            }\n        }\n        _SetterAbsolute(value, start, end) {\n            const target = this._GetTarget();\n            const index = this._GetIndex();\n            const wi = this.GetWorldInfo();\n            const track = this._propertyTrack.GetTrack();\n            const id = this._propertyTrack.GetSourceAdapterId();\n            switch (id) {\n            case "behavior":\n                target.SetPropertyValueByIndex(index, value);\n                break;\n            case "effect":\n                target[index] = value;\n                break;\n            case "instance-variable":\n                target.SetInstanceVariableValue(index, value);\n                break;\n            case "plugin":\n                target.SetPropertyValueByIndex(index, value);\n                break;\n            case "world-instance":\n                this._instance_absolute_setter(wi, value, track);\n                break;\n            case "audio":\n                this._source_adapter_absolute_setter.call(this.GetSourceAdapter(), wi, value, track);\n                break\n            }\n        }\n        _MaybeEnsureValue(time, start, end, setTime, lastValue, currentValue) {\n            this._typeAdapter._MaybeEnsureValue(time, start, end, setTime, lastValue, currentValue)\n        }\n        _AddDelta(value, start, end) {\n            const stringValue = value.toString();\n            const decimalsString = stringValue.split(".")[1] || "";\n            const decimalPlaces = decimalsString.length;\n            const v = this._Getter();\n            let rv;\n            if (decimalPlaces === 0)\n                if (this._round)\n                    rv = Math.round(v);\n                else if (this._fRound)\n                    rv = Math.round((v + Number.EPSILON) * 100) \/ 100;\n                else\n                    rv = v;\n            else if (this._round)\n                rv = Number(C3.toFixed(v, decimalPlaces));\n            else\n                rv = v;\n            this._Setter(rv - v, start, end)\n        }\n        _SaveToJson() {\n            return Object.assign(super._SaveToJson(), {\n                "v": this._lastValue,\n                "a": this._clampAccumulator,\n                "fod": this._totalForewardOpacityDelta,\n                "bod": this._totalBackwardOpacityDelta\n            })\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            super._LoadFromJson(o);\n            this._lastValue = o["v"];\n            this._clampAccumulator = o["a"];\n            this._totalForewardOpacityDelta = C3.IsFiniteNumber(o["fod"]) ? o["fod"] : 0;\n            this._totalBackwardOpacityDelta = C3.IsFiniteNumber(o["bod"]) ? o["bod"] : 0\n        }\n    }\n    C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = NumericInterpolationAdapter;\n\n}\n\n\/\/ timelines\/state\/propertyInterpolationAdapters\/numericInterpolationAdapterForTimeline.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    class AbsoluteValueObject {\n        constructor(propertyTracks) {\n            this._used = false;\n            this._value = 0;\n            this._propertyTracks = propertyTracks;\n            for (let i = 0, l = this._propertyTracks.length; i < l; i++)\n                this._propertyTracks[i].SetAbsoluteValueObject(this)\n        }\n        GetPropertyTracks() {\n            return this._propertyTracks\n        }\n        SetUsed() {\n            this._used = true\n        }\n        GetUsed() {\n            return this._used\n        }\n        SetValue(v) {\n            this._value = v\n        }\n        GetValue() {\n            return this._value\n        }\n        Reset() {\n            this._used = false;\n            this._value = 0\n        }\n    }\n    class NumericInterpolationAdapterForTimeline {\n        constructor(numericInterpolationAdapter) {\n            this._numericInterpolationAdapter = numericInterpolationAdapter\n        }\n        Release() {\n            this._numericInterpolationAdapter = null\n        }\n        SetInitialState() {\n            const adapter = this._numericInterpolationAdapter;\n            const propertyTrack = this._numericInterpolationAdapter.GetPropertyTrack();\n            return adapter._PickResultMode( () => {\n                return adapter._PickTimelinePlaybackMode( () => 0, () => adapter.GetSourceAdapter().GetValueAtTime())\n            }\n            , () => {}\n            )\n        }\n        SetResumeState() {}\n        MayNeedBeforeAndAfterInterpolate() {\n            const adapter = this._numericInterpolationAdapter;\n            const propertyTrack = this._numericInterpolationAdapter.GetPropertyTrack();\n            switch (propertyTrack.GetResultMode()) {\n            case "relative":\n                {\n                    return false\n                }\n            case "absolute":\n                {\n                    return true\n                }\n            }\n        }\n        BeforeChangeProperty() {\n            const adapter = this._numericInterpolationAdapter;\n            const propertyTrack = this._numericInterpolationAdapter.GetPropertyTrack();\n            const property = propertyTrack.GetPropertyName();\n            switch (propertyTrack.GetResultMode()) {\n            case "relative":\n                {\n                    break\n                }\n            case "absolute":\n                {\n                    if (propertyTrack.HasAbsoluteValueObject()) {\n                        const valueObj = propertyTrack.GetAbsoluteValueObject();\n                        valueObj.Reset()\n                    } else {\n                        const timeline = propertyTrack.GetTimeline();\n                        const instance = propertyTrack.GetInstance();\n                        const sourceAdapter = propertyTrack.GetSourceAdapter();\n                        const similarPropertyTracks = timeline.GetSimilarPropertyTracks(instance, sourceAdapter, property);\n                        if (similarPropertyTracks && similarPropertyTracks.length > 1)\n                            new AbsoluteValueObject(similarPropertyTracks)\n                    }\n                    break\n                }\n            }\n        }\n        ChangeProperty(time, value, start, end, setTime, ensureValue) {\n            const adapter = this._numericInterpolationAdapter;\n            const propertyTrack = this._numericInterpolationAdapter.GetPropertyTrack();\n            switch (propertyTrack.GetResultMode()) {\n            case "relative":\n                {\n                    const lastValue = adapter.GetLastValue();\n                    adapter._Setter(value - lastValue, start, end);\n                    if (ensureValue)\n                        this._MaybeEnsureValue(time, start, end, setTime, lastValue, value);\n                    adapter.SetLastValue(value);\n                    break\n                }\n            case "absolute":\n                {\n                    const timeline = propertyTrack.GetTimeline();\n                    const track = propertyTrack.GetTrack();\n                    const instance = propertyTrack.GetInstance();\n                    const sourceAdapter = propertyTrack.GetSourceAdapter();\n                    if (propertyTrack.HasAbsoluteValueObject()) {\n                        const absoluteValueObject = propertyTrack.GetAbsoluteValueObject();\n                        const similarpropertyTracks = absoluteValueObject.GetPropertyTracks();\n                        const propertyKeyframeStubs = adapter._GetPropertyKeyframeStubs(similarpropertyTracks, true);\n                        const stub = adapter._GetLastPropertyKeyframeStub(timeline, timeline.GetTime(), propertyKeyframeStubs);\n                        if (stub) {\n                            const startOffset = track.GetStartOffset();\n                            const t = stub.time - startOffset;\n                            if (t === 0) {\n                                absoluteValueObject.SetUsed();\n                                absoluteValueObject.SetValue(absoluteValueObject.GetValue() + value)\n                            } else {\n                                if (t < 0)\n                                    return;\n                                const v = propertyTrack.GetInterpolatedValue(t);\n                                absoluteValueObject.SetUsed();\n                                absoluteValueObject.SetValue(absoluteValueObject.GetValue() + (value - v))\n                            }\n                        }\n                    } else\n                        adapter._SetterAbsolute(value);\n                    break\n                }\n            }\n        }\n        AfterChangeProperty() {\n            const adapter = this._numericInterpolationAdapter;\n            const propertyTrack = this._numericInterpolationAdapter.GetPropertyTrack();\n            switch (propertyTrack.GetResultMode()) {\n            case "relative":\n                {\n                    break\n                }\n            case "absolute":\n                {\n                    if (propertyTrack.HasAbsoluteValueObject()) {\n                        const absoluteValueObject = propertyTrack.GetAbsoluteValueObject();\n                        if (absoluteValueObject.GetUsed())\n                            adapter._SetterAbsolute(absoluteValueObject.GetValue())\n                    }\n                    break\n                }\n            }\n        }\n        _MaybeEnsureValue(time, start, end, setTime, lastValue, currentValue) {\n            const adapter = this._numericInterpolationAdapter;\n            if (setTime)\n                return;\n            if (start && time === start.GetTime())\n                adapter._AddDelta(start.GetValueWithResultMode(), start, end);\n            else if (end && time === end.GetTime())\n                adapter._AddDelta(end.GetValueWithResultMode(), start, end);\n            else if (currentValue - lastValue === 0)\n                adapter._AddDelta(start.GetValueWithResultMode(), start, end)\n        }\n    }\n    C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = NumericInterpolationAdapterForTimeline;\n\n}\n\n\/\/ timelines\/state\/propertyInterpolationAdapters\/numericInterpolationAdapterForTween.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    class NumericInterpolationAdapterForTween {\n        constructor(numericInterpolationAdapter) {\n            this._numericInterpolationAdapter = numericInterpolationAdapter\n        }\n        Release() {\n            this._numericInterpolationAdapter = null\n        }\n        SetInitialState() {\n            const adapter = this._numericInterpolationAdapter;\n            adapter.SetFirstAbsoluteUpdate(true);\n            return this._GetAbsoluteInitialValue(adapter._FirstKeyframeGetter())\n        }\n        SetResumeState() {\n            const adapter = this._numericInterpolationAdapter;\n            if (adapter._FirstKeyframeGetter() === adapter._CurrentKeyframeGetter())\n                return;\n            adapter.SetFirstAbsoluteUpdate(true);\n            return this._GetAbsoluteInitialValue(adapter._CurrentKeyframeGetter())\n        }\n        MayNeedBeforeAndAfterInterpolate() {\n            return false\n        }\n        BeforeChangeProperty() {}\n        ChangeProperty(time, value, start, end, setTime, ensureValue) {\n            const adapter = this._numericInterpolationAdapter;\n            const lastValue = adapter.GetLastValue();\n            switch (adapter.GetPropertyTrack().GetResultMode()) {\n            case "relative":\n                {\n                    adapter._Setter(value - lastValue, start, end);\n                    if (ensureValue)\n                        this._MaybeEnsureValue(time, start, end, setTime, lastValue, value);\n                    break\n                }\n            case "absolute":\n                {\n                    if (adapter.GetFirstAbsoluteUpdate()) {\n                        adapter.SetFirstAbsoluteUpdate(false);\n                        adapter._Setter(lastValue, start, end)\n                    } else {\n                        adapter._Setter(value - lastValue, start, end);\n                        if (ensureValue)\n                            this._MaybeEnsureValue(time, start, end, setTime, lastValue, value)\n                    }\n                    break\n                }\n            }\n            adapter.SetLastValue(value)\n        }\n        AfterChangeProperty() {}\n        _GetAbsoluteInitialValue(keyframeValue) {\n            const adapter = this._numericInterpolationAdapter;\n            return keyframeValue - adapter.GetCurrentState()\n        }\n        _MaybeEnsureValue(time, start, end, setTime, lastValue, currentValue) {\n            const adapter = this._numericInterpolationAdapter;\n            if (setTime)\n                if (start && time === start.GetTime())\n                    adapter._AddDelta(start.GetValueWithResultMode(), start, end);\n                else if (end && time === end.GetTime())\n                    adapter._AddDelta(end.GetValueWithResultMode(), start, end);\n                else {\n                    if (!end)\n                        adapter._AddDelta(start.GetValueWithResultMode(), start, end)\n                }\n            else if (start && time === start.GetTime())\n                adapter._AddDelta(start.GetValueWithResultMode(), start, end);\n            else if (end && time === end.GetTime())\n                adapter._AddDelta(end.GetValueWithResultMode(), start, end);\n            else if (currentValue - lastValue === 0)\n                adapter._AddDelta(start.GetValueWithResultMode(), start, end)\n        }\n    }\n    C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween = NumericInterpolationAdapterForTween;\n\n}\n\n\/\/ timelines\/state\/propertyTypeAdapters\/numericTypeAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const Ease = self.Ease;\n    C3.PropertyTrackState.NumericTypeAdapter = class NumericTypeAdapter {\n        constructor() {}\n        static WillChange(index, source, newValue, type) {\n            let oldValue;\n            switch (type) {\n            case "behavior":\n                oldValue = source.GetPropertyValueByIndex(index);\n                break;\n            case "effect":\n                oldValue = source[index];\n                break;\n            case "instance-variable":\n                oldValue = source.GetInstanceVariableValue(index);\n                break;\n            case "plugin":\n                oldValue = source.GetPropertyValueByIndex(index);\n                break\n            }\n            if (oldValue === newValue)\n                return false;\n            return true\n        }\n        static Interpolate(time, start, end, propertyTrack) {\n            if (!end) {\n                let propertyTrackDataItem = propertyTrack.GetPropertyTrackDataItem();\n                const propertyTrackData = propertyTrack.GetPropertyTrackData();\n                propertyTrackDataItem = propertyTrackData.GetLastPropertyKeyframeDataItem(propertyTrackDataItem);\n                return propertyTrackDataItem.GetValueWithResultMode()\n            }\n            let mode = propertyTrack.GetInterpolationMode();\n            if (mode === "default")\n                mode = "continuous";\n            if (propertyTrack.GetPropertyType() === "combo")\n                mode = "discrete";\n            if (mode === "discrete")\n                return start.GetValueWithResultMode();\n            else if (mode === "continuous" || mode === "step") {\n                if (mode === "step") {\n                    const step = propertyTrack.GetTimeline().GetStep();\n                    if (step !== 0) {\n                        const s = 1 \/ step;\n                        time = Math.floor(time * s) \/ s\n                    }\n                }\n                const sv = start.GetValueWithResultMode();\n                const ev = end.GetValueWithResultMode();\n                const startAddon = start.GetAddOn("cubic-bezier");\n                const endAddon = end.GetAddOn("cubic-bezier");\n                const doCubicBezier = startAddon && startAddon.GetStartEnable() && endAddon && endAddon.GetEndEnable();\n                if (!doCubicBezier && sv === ev)\n                    return sv;\n                const st = start.GetTime();\n                const et = end.GetTime();\n                const n = C3.normalize(time, st, et);\n                const e = start.GetEase();\n                let ret;\n                if (doCubicBezier) {\n                    const dt = et - st;\n                    ret = Ease.GetRuntimeEase(e)(dt * n, 0, 1, dt);\n                    ret = Ease.GetRuntimeEase("cubicbezier")(ret, sv, sv + startAddon.GetStartAnchor(), ev + endAddon.GetEndAnchor(), ev)\n                } else\n                    ret = Ease.GetRuntimeEase(e)((et - st) * n, sv, ev - sv, et - st);\n                if (propertyTrack.GetPropertyType() === "integer")\n                    return Math.floor(ret);\n                return ret\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/state\/propertyTypeAdapters\/angleTypeAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.PropertyTrackState.AngleTypeAdapter = class AngleTypeAdapter {\n        constructor() {}\n        static WillChange(index, source, newValue, type) {\n            let oldValue;\n            switch (type) {\n            case "behavior":\n                oldValue = source.GetPropertyValueByIndex(index);\n                break;\n            case "effect":\n                oldValue = source[index];\n                break;\n            case "instance-variable":\n                oldValue = source.GetInstanceVariableValue(index);\n                break;\n            case "plugin":\n                oldValue = source.GetPropertyValueByIndex(index);\n                break\n            }\n            if (oldValue === newValue)\n                return false;\n            return true\n        }\n        static Interpolate(time, start, end, propertyTrack) {\n            if (!end) {\n                let propertyTrackDataItem = propertyTrack.GetPropertyTrackDataItem();\n                const propertyTrackData = propertyTrack.GetPropertyTrackData();\n                propertyTrackDataItem = propertyTrackData.GetLastPropertyKeyframeDataItem(propertyTrackDataItem);\n                return propertyTrackDataItem.GetValueWithResultMode()\n            }\n            let mode = propertyTrack.GetInterpolationMode();\n            if (mode === "default")\n                mode = "continuous";\n            if (propertyTrack.GetPropertyType() === "combo")\n                mode = "discrete";\n            if (mode === "discrete")\n                return start.GetValueWithResultMode();\n            else if (mode === "continuous" || mode === "step") {\n                if (mode === "step") {\n                    const step = propertyTrack.GetTimeline().GetStep();\n                    if (step !== 0) {\n                        const s = 1 \/ step;\n                        time = Math.floor(time * s) \/ s\n                    }\n                }\n                const st = start.GetTime();\n                const et = end.GetTime();\n                const sv = start.GetValueWithResultMode();\n                const ev = end.GetValueWithResultMode();\n                const angleAddon = start.GetAddOn("angle");\n                if (angleAddon) {\n                    const revolutions = angleAddon.GetRevolutions();\n                    if (sv === ev && revolutions === 0)\n                        return sv;\n                    const n = C3.normalize(time, st, et);\n                    const easeFunc = self.Ease.GetRuntimeEase(start.GetEase());\n                    const easeRes = easeFunc(n, 0, 1, 1);\n                    switch (angleAddon.GetDirection()) {\n                    case "closest":\n                        return C3.angleLerp(sv, ev, easeRes, revolutions);\n                    case "clockwise":\n                        return C3.angleLerpClockwise(sv, ev, easeRes, revolutions);\n                    case "anti-clockwise":\n                        return C3.angleLerpAntiClockwise(sv, ev, easeRes, revolutions)\n                    }\n                } else {\n                    if (sv === ev)\n                        return sv;\n                    const n = C3.normalize(time, st, et);\n                    const easeFunc = self.Ease.GetRuntimeEase(start.GetEase());\n                    return C3.angleLerp(sv, ev, easeFunc(n, 0, 1, 1))\n                }\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/state\/propertyTypeAdapters\/booleanTypeAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.PropertyTrackState.BooleanTypeAdapter = class BooleanTypeAdapter {\n        constructor() {}\n        static WillChange(index, source, newValue, type) {\n            let oldValue;\n            switch (type) {\n            case "behavior":\n                oldValue = source.GetPropertyValueByIndex(index);\n                break;\n            case "effect":\n                oldValue = source[index];\n                break;\n            case "instance-variable":\n                oldValue = source.GetInstanceVariableValue(index);\n                break;\n            case "plugin":\n                oldValue = source.GetPropertyValueByIndex(index);\n                break\n            }\n            if (!!oldValue === !!newValue)\n                return false;\n            return true\n        }\n        static Interpolate(time, start, end, propertyTrack) {\n            if (!end) {\n                let propertyTrackDataItem = propertyTrack.GetPropertyTrackDataItem();\n                const propertyTrackData = propertyTrack.GetPropertyTrackData();\n                propertyTrackDataItem = propertyTrackData.GetLastPropertyKeyframeDataItem(propertyTrackDataItem);\n                return propertyTrackDataItem.GetValueWithResultMode() ? 1 : 0\n            }\n            return start.GetValueWithResultMode() ? 1 : 0\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/state\/propertyTypeAdapters\/colorTypeAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const TEMP_COLOR_ARRAY = [0, 0, 0];\n    const TEMP_COLOR_ARRAY_2 = [0, 0, 0];\n    const TEMP_COLOR_ARRAY_3 = [0, 0, 0];\n    C3.PropertyTrackState.ColorTypeAdapter = class ColorTypeAdapter {\n        constructor() {}\n        static WillChange(index, source, newValue, type) {\n            let oldValue;\n            switch (type) {\n            case "behavior":\n                oldValue = source.GetPropertyValueByIndex(index);\n                break;\n            case "effect":\n                oldValue = source[index];\n                break;\n            case "instance-variable":\n                oldValue = source.GetInstanceVariableValue(index);\n                break;\n            case "plugin":\n                oldValue = source.GetPropertyValueByIndex(index);\n                break\n            }\n            if (Array.isArray(newValue)) {\n                TEMP_COLOR_ARRAY[0] = newValue[0];\n                TEMP_COLOR_ARRAY[1] = newValue[1];\n                TEMP_COLOR_ARRAY[2] = newValue[2]\n            } else {\n                TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(newValue);\n                TEMP_COLOR_ARRAY[0] = Math.floor(TEMP_COLOR_ARRAY_3.getR() * 255);\n                TEMP_COLOR_ARRAY[1] = Math.floor(TEMP_COLOR_ARRAY_3.getG() * 255);\n                TEMP_COLOR_ARRAY[2] = Math.floor(TEMP_COLOR_ARRAY_3.getB() * 255)\n            }\n            if (Array.isArray(oldValue)) {\n                TEMP_COLOR_ARRAY_2[0] = oldValue[0];\n                TEMP_COLOR_ARRAY_2[1] = oldValue[1];\n                TEMP_COLOR_ARRAY_2[2] = oldValue[2]\n            } else {\n                TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(oldValue);\n                TEMP_COLOR_ARRAY_2[0] = Math.floor(TEMP_COLOR_ARRAY_3.getR() * 255);\n                TEMP_COLOR_ARRAY_2[1] = Math.floor(TEMP_COLOR_ARRAY_3.getG() * 255);\n                TEMP_COLOR_ARRAY_2[2] = Math.floor(TEMP_COLOR_ARRAY_3.getB() * 255)\n            }\n            if (TEMP_COLOR_ARRAY[0] !== TEMP_COLOR_ARRAY_2[0])\n                return true;\n            if (TEMP_COLOR_ARRAY[1] !== TEMP_COLOR_ARRAY_2[1])\n                return true;\n            if (TEMP_COLOR_ARRAY[2] !== TEMP_COLOR_ARRAY_2[2])\n                return true;\n            return false\n        }\n        static Interpolate(time, start, end, propertyTrack) {\n            if (!end) {\n                let propertyTrackDataItem = propertyTrack.GetPropertyTrackDataItem();\n                const propertyTrackData = propertyTrack.GetPropertyTrackData();\n                propertyTrackDataItem = propertyTrackData.GetLastPropertyKeyframeDataItem(propertyTrackDataItem);\n                const color = propertyTrackDataItem.GetValueWithResultMode();\n                TEMP_COLOR_ARRAY[0] = color[0];\n                TEMP_COLOR_ARRAY[1] = color[1];\n                TEMP_COLOR_ARRAY[2] = color[2];\n                return TEMP_COLOR_ARRAY\n            }\n            let mode = propertyTrack.GetInterpolationMode();\n            if (mode === "default")\n                mode = "continuous";\n            if (mode === "discrete") {\n                const color = start.GetValueWithResultMode();\n                TEMP_COLOR_ARRAY[0] = color[0];\n                TEMP_COLOR_ARRAY[1] = color[1];\n                TEMP_COLOR_ARRAY[2] = color[2];\n                return TEMP_COLOR_ARRAY\n            } else if (mode === "continuous" || mode === "step") {\n                if (mode === "step") {\n                    const step = propertyTrack.GetTimeline().GetStep();\n                    if (step !== 0) {\n                        const s = 1 \/ step;\n                        time = Math.floor(time * s) \/ s\n                    }\n                }\n                const st = start.GetTime();\n                const et = end.GetTime();\n                const sv = start.GetValueWithResultMode();\n                const ev = end.GetValueWithResultMode();\n                const n = C3.normalize(time, st, et);\n                const e = start.GetEase();\n                const sr = sv[0];\n                const sg = sv[1];\n                const sb = sv[2];\n                const er = ev[0];\n                const eg = ev[1];\n                const eb = ev[2];\n                const easeFunc = self.Ease.GetRuntimeEase(e);\n                const d = et - st;\n                const dn = d * n;\n                if (sr === er)\n                    TEMP_COLOR_ARRAY[0] = sr;\n                else\n                    TEMP_COLOR_ARRAY[0] = easeFunc(dn, sr, er - sr, d);\n                if (sg === eg)\n                    TEMP_COLOR_ARRAY[1] = sg;\n                else\n                    TEMP_COLOR_ARRAY[1] = easeFunc(dn, sg, eg - sg, d);\n                if (sb === eb)\n                    TEMP_COLOR_ARRAY[2] = sb;\n                else\n                    TEMP_COLOR_ARRAY[2] = easeFunc(dn, sb, eb - sb, d);\n                return TEMP_COLOR_ARRAY\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/state\/propertyTypeAdapters\/textTypeAdapter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.PropertyTrackState.TextTypeAdapter = class TextTypeAdapter {\n        constructor() {}\n        static WillChange(index, source, newValue, type) {\n            let oldValue;\n            switch (type) {\n            case "behavior":\n                oldValue = source.GetPropertyValueByIndex(index);\n                break;\n            case "effect":\n                oldValue = source[index];\n                break;\n            case "instance-variable":\n                oldValue = source.GetInstanceVariableValue(index);\n                break;\n            case "plugin":\n                oldValue = source.GetPropertyValueByIndex(index);\n                break\n            }\n            if (oldValue === newValue)\n                return false;\n            return true\n        }\n        static Interpolate(time, start, end, propertyTrack) {\n            if (!end) {\n                let propertyTrackDataItem = propertyTrack.GetPropertyTrackDataItem();\n                const propertyTrackData = propertyTrack.GetPropertyTrackData();\n                propertyTrackDataItem = propertyTrackData.GetLastPropertyKeyframeDataItem(propertyTrackDataItem);\n                return propertyTrackDataItem.GetValueWithResultMode()\n            }\n            return start.GetValueWithResultMode()\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/data\/timelineDataManager.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.TimelineDataManager = class TimelineDataManager {\n        constructor() {\n            this._timelineDataItems = new Map\n        }\n        Release() {\n            for (const timelineDataItem of this._timelineDataItems.values())\n                timelineDataItem.Release();\n            this._timelineDataItems.clear();\n            this._timelineDataItems = null\n        }\n        Add(data) {\n            const timelineDataItem = new C3.TimelineDataItem(data);\n            const name = timelineDataItem.GetName();\n            this._timelineDataItems.set(name, timelineDataItem)\n        }\n        Get(name) {\n            return this._timelineDataItems.get(name)\n        }\n        GetNameId() {\n            return 0\n        }\n        static _CreateDataItems(items, jsonItems, dataItemConstructor, dataContainer) {\n            if (!jsonItems)\n                return;\n            for (const jsonItem of jsonItems)\n                C3.TimelineDataManager._CreateDataItem("create", jsonItem, items, dataItemConstructor, dataContainer)\n        }\n        static _LoadDataItemsFromJson(items, jsonItems, dataItemConstructor, dataContainer) {\n            if (items.length)\n                jsonItems.forEach( (jsonItem, index) => {\n                    items[index]._LoadFromJson(jsonItem)\n                }\n                );\n            else\n                jsonItems.forEach(jsonItem => {\n                    C3.TimelineDataManager._CreateDataItem("load", jsonItem, items, dataItemConstructor, dataContainer)\n                }\n                )\n        }\n        static _CreateDataItem(mode, json, items, dataItemConstructor, dataContainer) {\n            let dataItem;\n            if (typeof dataItemConstructor === "function")\n                switch (mode) {\n                case "load":\n                    dataItem = new dataItemConstructor(null,dataContainer);\n                    break;\n                case "create":\n                    dataItem = new dataItemConstructor(json,dataContainer);\n                    break\n                }\n            else if (typeof dataItemConstructor === "object") {\n                const prop = dataItemConstructor.prop;\n                const value = json[prop];\n                const cnstrctr = dataItemConstructor.map.get(value);\n                switch (mode) {\n                case "load":\n                    dataItem = new cnstrctr(null,dataContainer);\n                    break;\n                case "create":\n                    dataItem = new cnstrctr(json,dataContainer);\n                    break\n                }\n            }\n            switch (mode) {\n            case "load":\n                dataItem._LoadFromJson(json);\n                items.push(dataItem);\n                break;\n            case "create":\n                if (typeof dataItem.GetEnable === "function" && !dataItem.GetEnable())\n                    return dataItem.Release();\n                items.push(dataItem);\n                break\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/data\/timelineData.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const NAME = 0;\n    const TOTAL_TIME = 1;\n    const STEP = 2;\n    const INTERPOLATION_MODE = 3;\n    const RESULT_MODE = 4;\n    const TRACKS = 5;\n    const LOOP = 6;\n    const PING_PONG = 7;\n    const REPEAT_COUNT = 8;\n    const START_ON_LAYOUT = 9;\n    const TRANSFORM_WITH_SCENE_GRAPH = 10;\n    C3.TimelineDataItem = class TimelineDataItem {\n        constructor(timelineDataJson) {\n            this._name = "";\n            this._totalTime = NaN;\n            this._step = 0;\n            this._interpolationMode = "default";\n            this._resultMode = "default";\n            this._loop = false;\n            this._pingPong = false;\n            this._repeatCount = 1;\n            this._trackData = null;\n            this._startOnLayout = "";\n            this._transformWithSceneGraph = false;\n            if (!timelineDataJson)\n                return;\n            this._name = timelineDataJson[NAME];\n            this._totalTime = timelineDataJson[TOTAL_TIME];\n            this._step = timelineDataJson[STEP];\n            this._interpolationMode = timelineDataJson[INTERPOLATION_MODE];\n            this._resultMode = timelineDataJson[RESULT_MODE];\n            this._loop = !!timelineDataJson[LOOP];\n            this._pingPong = !!timelineDataJson[PING_PONG];\n            this._repeatCount = timelineDataJson[REPEAT_COUNT];\n            this._startOnLayout = timelineDataJson[START_ON_LAYOUT];\n            this._transformWithSceneGraph = !!timelineDataJson[TRANSFORM_WITH_SCENE_GRAPH];\n            this._trackData = new C3.TrackData(timelineDataJson[TRACKS],this)\n        }\n        Release() {\n            this._trackData.Release();\n            this._trackData = null\n        }\n        GetTrackData() {\n            if (!this._trackData)\n                this._trackData = new C3.TrackData(null,this);\n            return this._trackData\n        }\n        GetName() {\n            return this._name\n        }\n        SetName(n) {\n            this._name = n\n        }\n        GetTotalTime() {\n            return this._totalTime\n        }\n        SetTotalTime(tt) {\n            this._totalTime = tt\n        }\n        GetStep() {\n            return this._step\n        }\n        SetStep(s) {\n            this._step = s\n        }\n        GetInterpolationMode() {\n            return this._interpolationMode\n        }\n        SetInterpolationMode(im) {\n            this._interpolationMode = im\n        }\n        GetResultMode() {\n            return this._resultMode\n        }\n        SetResultMode(rm) {\n            this._resultMode = rm\n        }\n        GetLoop() {\n            return this._loop\n        }\n        SetLoop(l) {\n            this._loop = l\n        }\n        GetPingPong() {\n            return this._pingPong\n        }\n        SetPingPong(p) {\n            this._pingPong = p\n        }\n        GetRepeatCount() {\n            return this._repeatCount\n        }\n        GetStartOnLayout() {\n            return this._startOnLayout\n        }\n        GetTransformWithSceneGraph() {\n            return this._transformWithSceneGraph\n        }\n        _SaveToJson() {\n            return {\n                "trackDataJson": this._trackData._SaveToJson(),\n                "name": this._name,\n                "totalTime": this._totalTime,\n                "step": this._step,\n                "interpolationMode": this._interpolationMode,\n                "resultMode": this._resultMode,\n                "loop": this._loop,\n                "pingPong": this._pingPong,\n                "repeatCount": this._repeatCount,\n                "startOnLayout": this._startOnLayout,\n                "transformWithSceneGraph": !!this._transformWithSceneGraph\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            this.GetTrackData()._LoadFromJson(o["trackDataJson"]);\n            this._name = o["name"];\n            this._totalTime = o["totalTime"];\n            this._step = o["step"];\n            this._interpolationMode = o["interpolationMode"];\n            this._resultMode = o["resultMode"];\n            this._loop = o["loop"];\n            this._pingPong = o["pingPong"];\n            this._repeatCount = o["repeatCount"];\n            this._startOnLayout = o["startOnLayout"];\n            this._transformWithSceneGraph = !!o["transformWithSceneGraph"]\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/data\/trackData.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const WI_DATA = 0;\n    const OC_INDEX = 1;\n    const WI_UID = 2;\n    const INTERPOLATION_MODE = 1;\n    const RESULT_MODE = 2;\n    const ENABLED = 3;\n    const KEYFRAMES = 4;\n    const PROPERTY_TRACKS = 5;\n    const ID = 6;\n    const NESTED_DATA = 7;\n    const START_OFFSET = 0;\n    const LOCAL_TOTAL_TIME = 1;\n    const WI_ADDITIONAL_DATA = 8;\n    const ORIGINAL_WIDTH = 0;\n    const ORIGINAL_HEIGHT = 1;\n    const TRACK_TYPE = 9;\n    const TRACK_NAME = 10;\n    class TrackDataItem {\n        constructor(trackDataJson, trackData) {\n            this._trackData = trackData;\n            this._instanceData = null;\n            this._additionalInstanceData = null;\n            this._instanceUid = NaN;\n            this._objectClassIndex = NaN;\n            this._interpolationMode = "default";\n            this._resultMode = "default";\n            this._enabled = false;\n            this._keyframeData = null;\n            this._propertyTrackData = null;\n            this._id = "";\n            this._nestedData = null;\n            this._startOffset = 0;\n            this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime();\n            this._type = 0;\n            this._name = "";\n            if (!trackDataJson)\n                return;\n            if (trackDataJson[WI_DATA]) {\n                this._instanceData = trackDataJson[WI_DATA];\n                this._instanceUid = trackDataJson[WI_DATA][WI_UID];\n                this._objectClassIndex = trackDataJson[WI_DATA][OC_INDEX]\n            }\n            this._interpolationMode = trackDataJson[INTERPOLATION_MODE];\n            this._resultMode = trackDataJson[RESULT_MODE];\n            this._enabled = !!trackDataJson[ENABLED];\n            if (trackDataJson[ID])\n                this._id = trackDataJson[ID];\n            if (trackDataJson[NESTED_DATA]) {\n                this._nestedData = trackDataJson[NESTED_DATA];\n                this._startOffset = trackDataJson[NESTED_DATA][START_OFFSET];\n                this._localTotalTime = trackDataJson[NESTED_DATA][LOCAL_TOTAL_TIME]\n            }\n            if (trackDataJson[WI_ADDITIONAL_DATA])\n                this._additionalInstanceData = trackDataJson[WI_ADDITIONAL_DATA];\n            if (trackDataJson[WI_ADDITIONAL_DATA])\n                this._additionalInstanceData = trackDataJson[WI_ADDITIONAL_DATA];\n            if (trackDataJson[TRACK_TYPE])\n                this._type = trackDataJson[TRACK_TYPE];\n            if (trackDataJson[TRACK_NAME])\n                this._name = trackDataJson[TRACK_NAME];\n            this._keyframeData = new C3.KeyframeData(trackDataJson[KEYFRAMES],this);\n            this._propertyTrackData = new C3.PropertyTrackData(trackDataJson[PROPERTY_TRACKS],this)\n        }\n        Release() {\n            this._instanceData = null;\n            this._trackData = null;\n            if (this._keyframeData) {\n                this._keyframeData.Release();\n                this._keyframeData = null\n            }\n            if (this._propertyTrackData) {\n                this._propertyTrackData.Release();\n                this._propertyTrackData = null\n            }\n            this._nestedData = null\n        }\n        GetTrackData() {\n            return this._trackData\n        }\n        GetKeyframeData() {\n            if (!this._keyframeData)\n                this._keyframeData = new C3.KeyframeData(null,this);\n            return this._keyframeData\n        }\n        GetPropertyTrackData() {\n            if (!this._propertyTrackData)\n                this._propertyTrackData = new C3.PropertyTrackData(null,this);\n            return this._propertyTrackData\n        }\n        GetInstanceData() {\n            return this._instanceData\n        }\n        GetObjectClassIndex() {\n            return this._objectClassIndex\n        }\n        SetObjectClassIndex(index) {\n            this._objectClassIndex = index\n        }\n        GetInstanceUID() {\n            return this._instanceUid\n        }\n        SetInstanceUID(uid) {\n            this._instanceUid = uid\n        }\n        GetInterpolationMode() {\n            return this._interpolationMode\n        }\n        SetInterpolationMode(im) {\n            this._interpolationMode = im\n        }\n        GetResultMode() {\n            return this._resultMode\n        }\n        SetResultMode(rm) {\n            this._resultMode = rm\n        }\n        GetEnable() {\n            return this._enabled\n        }\n        SetEnable(e) {\n            this._enabled = !!e\n        }\n        GetId() {\n            return this._id\n        }\n        GetStartOffset() {\n            return this._startOffset\n        }\n        GetLocalTotalTime() {\n            return this._localTotalTime\n        }\n        SetLocalTotalTime(t) {\n            this._localTotalTime = t\n        }\n        GetOriginalWidth() {\n            return this._additionalInstanceData[ORIGINAL_WIDTH]\n        }\n        SetOriginalWidth(w) {\n            if (!this._additionalInstanceData)\n                this._additionalInstanceData = [];\n            this._additionalInstanceData[ORIGINAL_WIDTH] = w\n        }\n        GetOriginalHeight() {\n            if (!this._additionalInstanceData)\n                this._additionalInstanceData = [];\n            return this._additionalInstanceData[ORIGINAL_HEIGHT]\n        }\n        SetOriginalHeight(h) {\n            if (!this._additionalInstanceData)\n                this._additionalInstanceData = [];\n            this._additionalInstanceData[ORIGINAL_HEIGHT] = h\n        }\n        GetType() {\n            return this._type\n        }\n        GetName() {\n            return this._name\n        }\n        _SaveToJson() {\n            return {\n                "keyframeDataJson": this._keyframeData._SaveToJson(),\n                "propertyTrackDataJson": this._propertyTrackData._SaveToJson(),\n                "instanceData": this._instanceData,\n                "additionalInstanceData": this._additionalInstanceData,\n                "instanceUid": this._instanceUid,\n                "objectClassIndex": this._objectClassIndex,\n                "interpolationMode": this._interpolationMode,\n                "resultMode": this._resultMode,\n                "enabled": this._enabled,\n                "id": this._id,\n                "nestedData": this._nestedData,\n                "type": this._type,\n                "name": this._name\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            this._instanceData = o["instanceData"];\n            this._instanceUid = o["instanceUid"];\n            this._objectClassIndex = o["objectClassIndex"];\n            this._interpolationMode = o["interpolationMode"];\n            this._resultMode = o["resultMode"];\n            this._enabled = o["enabled"];\n            this._id = o["id"];\n            this._type = o["type"] ? o["type"] : 0;\n            this._name = o["name"] ? o["name"] : "";\n            this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime();\n            if (o["nestedData"]) {\n                this._nestedData = o["nestedData"];\n                this._startOffset = this._nestedData[START_OFFSET];\n                this._localTotalTime = this._nestedData[LOCAL_TOTAL_TIME]\n            }\n            if (o["additionalInstanceData"])\n                this._additionalInstanceData = o["additionalInstanceData"];\n            this.GetKeyframeData()._LoadFromJson(o["keyframeDataJson"]);\n            this.GetPropertyTrackData()._LoadFromJson(o["propertyTrackDataJson"])\n        }\n    }\n    C3.TrackData = class TrackData {\n        constructor(tracksDataJson, timelineDataItem) {\n            this._timelineDataItem = timelineDataItem;\n            this._trackDataItems = [];\n            C3.TimelineDataManager._CreateDataItems(this._trackDataItems, tracksDataJson, TrackDataItem, this)\n        }\n        Release() {\n            this._timelineDataItem = null;\n            for (const trackDataItem of this._trackDataItems)\n                trackDataItem.Release();\n            C3.clearArray(this._trackDataItems);\n            this._trackDataItems = null\n        }\n        GetTimelineDataItem() {\n            return this._timelineDataItem\n        }\n        AddEmptyTrackDataItem() {\n            const trackDataItem = new TrackDataItem(null,this);\n            this._trackDataItems.push(trackDataItem);\n            return trackDataItem\n        }\n        GetFirstKeyframeDataItem(trackDataItem) {\n            return trackDataItem.GetKeyframeData().GetKeyframeDataItemArray()[0]\n        }\n        GetLastKeyframeDataItem(trackDataItem) {\n            const keyframeDataItems = trackDataItem.GetKeyframeData().GetKeyframeDataItemArray();\n            return keyframeDataItems.at(-1)\n        }\n        GetKeyFrameDataItemAtTime(time, trackDataItem) {\n            const keyframeDataItems = trackDataItem.GetKeyframeData().GetKeyframeDataItemArray();\n            const l = keyframeDataItems.length;\n            for (let i = 0; i < l; i++) {\n                const keyframeDataItem = keyframeDataItems[i];\n                if (keyframeDataItem.GetTime() === time)\n                    return keyframeDataItem\n            }\n        }\n        GetFirstKeyFrameDataItemHigherThan(time, trackDataItem) {\n            const keyframeDataItems = trackDataItem.GetKeyframeData().GetKeyframeDataItemArray();\n            const l = keyframeDataItems.length;\n            for (let i = 0; i < l; i++) {\n                const keyframeDataItem = keyframeDataItems[i];\n                if (keyframeDataItem.GetTime() > time)\n                    return keyframeDataItem\n            }\n        }\n        GetFirstKeyFrameDataItemHigherOrEqualThan(time, trackDataItem) {\n            const keyframeDataItems = trackDataItem.GetKeyframeData().GetKeyframeDataItemArray();\n            const l = keyframeDataItems.length;\n            for (let i = 0; i < l; i++) {\n                const keyframeDataItem = keyframeDataItems[i];\n                if (keyframeDataItem.GetTime() >= time)\n                    return keyframeDataItem\n            }\n        }\n        GetFirstKeyFrameDataItemLowerOrEqualThan(time, trackDataItem) {\n            const keyframeDataItems = trackDataItem.GetKeyframeData().GetKeyframeDataItemArray();\n            for (let i = keyframeDataItems.length - 1; i >= 0; i--) {\n                const keyframeDataItem = keyframeDataItems[i];\n                if (keyframeDataItem.GetTime() <= time)\n                    return keyframeDataItem\n            }\n        }\n        *trackDataItems() {\n            for (const trackDataItem of this._trackDataItems)\n                yield trackDataItem\n        }\n        _SaveToJson() {\n            return {\n                "trackDataItemsJson": this._trackDataItems.map(trackDataItem => trackDataItem._SaveToJson())\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            C3.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, o["trackDataItemsJson"], TrackDataItem, this)\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/data\/propertyTrackData.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const SOURCE_DATA = 0;\n    const SOURCE = 0;\n    const PROPERTY = 1;\n    const TYPE = 2;\n    const MIN = 3;\n    const MAX = 4;\n    const INTERPOLATION_MODE = 5;\n    const RESULT_MODE = 6;\n    const ENABLED = 7;\n    const PROPERTY_KEYFRAMES = 8;\n    const CAN_HAVE_PROPERTY_KEYFRAMES = 9;\n    class PropertyTrackDataItem {\n        constructor(propertyTrackDataJson, propertyTrackData) {\n            this._propertyTrackData = propertyTrackData;\n            this._sourceAdapterId = "";\n            this._sourceAdapterArguments = null;\n            this._property = null;\n            this._type = null;\n            this._min = NaN;\n            this._max = NaN;\n            this._interpolationMode = "default";\n            this._resultMode = "default";\n            this._enabled = false;\n            this._propertyKeyframeData = null;\n            this._canHavePropertyKeyframes = true;\n            if (!propertyTrackDataJson)\n                return;\n            this._sourceAdapterId = propertyTrackDataJson[SOURCE_DATA][SOURCE];\n            this._sourceAdapterArguments = propertyTrackDataJson[SOURCE_DATA].slice(1);\n            this._property = propertyTrackDataJson[PROPERTY];\n            this._type = propertyTrackDataJson[TYPE];\n            this._min = propertyTrackDataJson[MIN];\n            this._max = propertyTrackDataJson[MAX];\n            this._interpolationMode = propertyTrackDataJson[INTERPOLATION_MODE];\n            this._resultMode = propertyTrackDataJson[RESULT_MODE];\n            this._enabled = !!propertyTrackDataJson[ENABLED];\n            this._propertyKeyframeData = new C3.PropertyKeyframeData(propertyTrackDataJson[PROPERTY_KEYFRAMES],this);\n            this._canHavePropertyKeyframes = propertyTrackDataJson[CAN_HAVE_PROPERTY_KEYFRAMES]\n        }\n        Release() {\n            this._propertyKeyframeData.Release();\n            this._propertyKeyframeData = null;\n            this._propertyTrackData = null;\n            this._sourceAdapterArguments = null\n        }\n        GetPropertyTrackData() {\n            return this._propertyTrackData\n        }\n        GetPropertyKeyframeData() {\n            if (!this._propertyKeyframeData)\n                this._propertyKeyframeData = new C3.PropertyKeyframeData(null,this);\n            return this._propertyKeyframeData\n        }\n        GetSourceAdapterId() {\n            return this._sourceAdapterId\n        }\n        SetSourceAdapterId(said) {\n            this._sourceAdapterId = said\n        }\n        GetSourceAdapterArguments() {\n            return this._sourceAdapterArguments\n        }\n        SetSourceAdapterArguments(sargs) {\n            this._sourceAdapterArguments = sargs\n        }\n        GetProperty() {\n            return this._property\n        }\n        SetProperty(p) {\n            this._property = p\n        }\n        GetType() {\n            return this._type\n        }\n        SetType(t) {\n            this._type = t\n        }\n        GetMin() {\n            return this._min\n        }\n        SetMin(min) {\n            this._min = min\n        }\n        GetMax() {\n            return this._max\n        }\n        SetMax(max) {\n            this._max = max\n        }\n        GetInterpolationMode() {\n            return this._interpolationMode\n        }\n        SetInterpolationMode(im) {\n            this._interpolationMode = im\n        }\n        GetResultMode() {\n            return this._resultMode\n        }\n        SetResultMode(rm) {\n            this._resultMode = rm\n        }\n        GetEnable() {\n            return this._enabled\n        }\n        SetEnable(e) {\n            this._enabled = !!e\n        }\n        CanHavePropertyKeyframes() {\n            return !!this._canHavePropertyKeyframes\n        }\n        _SaveToJson() {\n            return {\n                "propertyKeyframeDataJson": this._propertyKeyframeData._SaveToJson(),\n                "sourceAdapterId": this._sourceAdapterId,\n                "sourceAdapterArguments": this._sourceAdapterArguments,\n                "property": this._property,\n                "type": this._type,\n                "min": this._min,\n                "max": this._max,\n                "interpolationMode": this._interpolationMode,\n                "resultMode": this._resultMode,\n                "enabled": this._enabled,\n                "canHavePropertyKeyframes": this._canHavePropertyKeyframes\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            this._sourceAdapterId = o["sourceAdapterId"];\n            this._sourceAdapterArguments = o["sourceAdapterArguments"];\n            this._property = o["property"];\n            this._type = o["type"];\n            this._min = o["min"];\n            this._max = o["max"];\n            this._interpolationMode = o["interpolationMode"];\n            this._resultMode = o["resultMode"];\n            this._enabled = o["enabled"];\n            this._canHavePropertyKeyframes = o["canHavePropertyKeyframes"];\n            this.GetPropertyKeyframeData()._LoadFromJson(o["propertyKeyframeDataJson"])\n        }\n    }\n    C3.PropertyTrackData = class PropertyTrackData {\n        constructor(propertyTracksDataJson, trackDataItem) {\n            this._trackDataItem = trackDataItem;\n            this._propertyTrackDataItems = [];\n            C3.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, propertyTracksDataJson, PropertyTrackDataItem, this)\n        }\n        Release() {\n            this._trackDataItem = null;\n            for (const propertyTrackDataItem of this._propertyTrackDataItems)\n                propertyTrackDataItem.Release();\n            C3.clearArray(this._propertyTrackDataItems);\n            this._propertyTrackDataItems = null\n        }\n        GetTrackDataItem() {\n            return this._trackDataItem\n        }\n        AddEmptyPropertyTrackDataItem() {\n            const propertyTrackDataItem = new PropertyTrackDataItem(null,this);\n            this._propertyTrackDataItems.push(propertyTrackDataItem);\n            return propertyTrackDataItem\n        }\n        GetFirstPropertyKeyframeDataItem(propertyTrackDataItem) {\n            const propertyKeyframeData = propertyTrackDataItem.GetPropertyKeyframeData();\n            return propertyKeyframeData.GetPropertyKeyframeDataItemArray()[0]\n        }\n        GetLastPropertyKeyframeDataItem(propertyTrackDataItem) {\n            const propertyKeyframeData = propertyTrackDataItem.GetPropertyKeyframeData();\n            const propertyKeyframeDataItems = propertyKeyframeData.GetPropertyKeyframeDataItemArray();\n            return propertyKeyframeDataItems.at(-1)\n        }\n        GetPropertyKeyFrameDataItemAtTime(time, propertyTrackDataItem) {\n            const propertyKeyframeData = propertyTrackDataItem.GetPropertyKeyframeData();\n            const propertyKeyframeDataItems = propertyKeyframeData.GetPropertyKeyframeDataItemArray();\n            const l = propertyKeyframeDataItems.length;\n            for (let i = 0; i < l; i++) {\n                const propertyKeyframeDataItem = propertyKeyframeDataItems[i];\n                if (propertyKeyframeDataItem.GetTime() === time)\n                    return propertyKeyframeDataItem\n            }\n        }\n        GetFirstPropertyKeyFrameDataItemHigherThan(time, propertyTrackDataItem) {\n            const propertyKeyframeData = propertyTrackDataItem.GetPropertyKeyframeData();\n            const propertyKeyframeDataItems = propertyKeyframeData.GetPropertyKeyframeDataItemArray();\n            const l = propertyKeyframeDataItems.length;\n            for (let i = 0; i < l; i++) {\n                const propertyKeyframeDataItem = propertyKeyframeDataItems[i];\n                if (propertyKeyframeDataItem.GetTime() > time)\n                    return propertyKeyframeDataItem\n            }\n        }\n        GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(time, propertyTrackDataItem) {\n            const propertyKeyframeData = propertyTrackDataItem.GetPropertyKeyframeData();\n            const propertyKeyframeDataItems = propertyKeyframeData.GetPropertyKeyframeDataItemArray();\n            const l = propertyKeyframeDataItems.length;\n            for (let i = 0; i < l; i++) {\n                const propertyKeyframeDataItem = propertyKeyframeDataItems[i];\n                if (propertyKeyframeDataItem.GetTime() >= time)\n                    return propertyKeyframeDataItem\n            }\n        }\n        GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(time, propertyTrackDataItem) {\n            const propertyKeyframeData = propertyTrackDataItem.GetPropertyKeyframeData();\n            const propertyKeyframeDataItems = propertyKeyframeData.GetPropertyKeyframeDataItemArray();\n            for (let i = propertyKeyframeDataItems.length - 1; i >= 0; i--) {\n                const propertyKeyframeDataItem = propertyKeyframeDataItems[i];\n                if (propertyKeyframeDataItem.GetTime() <= time)\n                    return propertyKeyframeDataItem\n            }\n        }\n        *propertyTrackDataItems() {\n            for (const propertyTrackDataItem of this._propertyTrackDataItems)\n                yield propertyTrackDataItem\n        }\n        _SaveToJson() {\n            return {\n                "propertyTrackDataItemsJson": this._propertyTrackDataItems.map(propertyTrackDataItem => propertyTrackDataItem._SaveToJson())\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            C3.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, o["propertyTrackDataItemsJson"], PropertyTrackDataItem, this)\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/data\/keyframeData.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const TIME = 0;\n    const EASE = 1;\n    const ENABLE = 2;\n    const TAGS = 3;\n    class KeyframeDataItem {\n        constructor(keyframeDataJson, keyframeData) {\n            this._keyframeData = keyframeData;\n            this._time = -1;\n            this._ease = "noease";\n            this._enable = false;\n            this._tags = null;\n            this._lowerTags = null;\n            if (!keyframeDataJson)\n                return;\n            this._time = keyframeDataJson[TIME];\n            this._ease = keyframeDataJson[EASE];\n            this._enable = !!keyframeDataJson[ENABLE];\n            const tagStr = keyframeDataJson[TAGS];\n            this._tags = tagStr ? tagStr.split(" ") : [];\n            this._lowerTags = new Set(this._tags.map(t => t.toLowerCase()));\n            this._next = null\n        }\n        Release() {\n            this._keyframeData = null;\n            C3.clearArray(this._tags);\n            this._tags = null;\n            this._lowerTags.clear();\n            this._lowerTags = null\n        }\n        GetKeyframeData() {\n            return this._keyframeData\n        }\n        GetNext() {\n            return this._next\n        }\n        SetNext(next) {\n            this._next = next\n        }\n        GetTime() {\n            return this._time\n        }\n        SetTime(t) {\n            this._time = t;\n            this._keyframeData._LinkKeyframeDataItems()\n        }\n        GetEase() {\n            return this._ease\n        }\n        SetEase(e) {\n            this._ease = e\n        }\n        GetEnable() {\n            return this._enable\n        }\n        SetEnable(e) {\n            this._enable = !!e\n        }\n        GetTags() {\n            return this._tags\n        }\n        SetTags(t) {\n            this._tags = t ? t.split(" ") : [];\n            this._lowerTags = new Set(this._tags.map(t => t.toLowerCase()))\n        }\n        GetLowerTags() {\n            return this._lowerTags\n        }\n        HasTag(tag) {\n            return this._lowerTags.has(tag.toLowerCase())\n        }\n        _SaveToJson() {\n            return {\n                "time": this._time,\n                "ease": this._ease,\n                "enable": this._enable,\n                "tags": this._tags\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            this._time = o["time"];\n            this._ease = o["ease"];\n            this._enable = o["enable"];\n            this._tags = o["tags"];\n            this._lowerTags = new Set(this._tags.map(t => t.toLowerCase()))\n        }\n    }\n    C3.KeyframeData = class KeyframeData {\n        constructor(keyframesDataJson, trackDataItem) {\n            this._trackDataItem = trackDataItem;\n            this._keyframeDataItems = [];\n            C3.TimelineDataManager._CreateDataItems(this._keyframeDataItems, keyframesDataJson, KeyframeDataItem, this);\n            this._LinkKeyframeDataItems()\n        }\n        Release() {\n            this._trackDataItem = null;\n            for (const keyframeDataItem of this._keyframeDataItems)\n                keyframeDataItem.Release();\n            C3.clearArray(this._keyframeDataItems);\n            this._keyframeDataItems = null\n        }\n        _LinkKeyframeDataItems() {\n            this._keyframeDataItems.sort( (first, second) => first.GetTime() - second.GetTime());\n            for (let i = 0; i < this._keyframeDataItems.length; i++) {\n                const current = this._keyframeDataItems[i];\n                current.SetNext(this._keyframeDataItems[i + 1])\n            }\n        }\n        GetTrackDataItem() {\n            return this._trackDataItem\n        }\n        GetKeyframeDataItemCount() {\n            return this._keyframeDataItems.length\n        }\n        GetKeyframeDataItemArray() {\n            return this._keyframeDataItems\n        }\n        AddEmptyKeyframeDataItem() {\n            const keyframeDataItem = new KeyframeDataItem(null,this);\n            this._keyframeDataItems.push(keyframeDataItem);\n            this._LinkKeyframeDataItems();\n            return keyframeDataItem\n        }\n        DeleteKeyframeDataItems(match) {\n            for (const keyframeDataItem of this._keyframeDataItems) {\n                if (!match(keyframeDataItem))\n                    continue;\n                const index = this._keyframeDataItems.indexOf(keyframeDataItem);\n                if (index === -1)\n                    continue;\n                keyframeDataItem.Release();\n                this._keyframeDataItems.splice(index, 1)\n            }\n            this.SortKeyframeDataItems();\n            this._LinkKeyframeDataItems()\n        }\n        SortKeyframeDataItems() {\n            this._keyframeDataItems.sort( (a, b) => a.GetTime() - b.GetTime())\n        }\n        GetKeyframeDataItemIndex(keyframeDataItem) {\n            return this._keyframeDataItems.indexOf(keyframeDataItem)\n        }\n        GetKeyframeDataItemFromIndex(index) {\n            return this._keyframeDataItems[index]\n        }\n        *keyframeDataItems() {\n            for (const keyframeDataItem of this._keyframeDataItems)\n                yield keyframeDataItem\n        }\n        *keyframeDataItemsReverse() {\n            for (let i = this._keyframeDataItems.length - 1; i >= 0; i--)\n                yield this._keyframeDataItems[i]\n        }\n        _SaveToJson() {\n            return {\n                "keyframeDataItemsJson": this._keyframeDataItems.map(keyframeDataItem => keyframeDataItem._SaveToJson())\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            C3.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, o["keyframeDataItemsJson"], KeyframeDataItem, this);\n            this._LinkKeyframeDataItems()\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/data\/propertyKeyframeData.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const VALUE_DATA = 0;\n    const VALUE_DATA_VALUE = 0;\n    const VALUE_DATA_ABSOLUTE_VALUE = 1;\n    const VALUE_DATA_TYPE = 2;\n    const TIME = 1;\n    const EASE = 2;\n    const ENABLE = 3;\n    const ADDONS = 4;\n    class PropertyKeyframeDataItem {\n        constructor(propertyKeyframeDataJson, propertyKeyframeData) {\n            this._propertyKeyframeData = propertyKeyframeData;\n            this._value = null;\n            this._aValue = null;\n            this._type = "";\n            this._time = NaN;\n            this._ease = "noease";\n            this._enable = false;\n            this._addonData = null;\n            this._addonInstance = undefined;\n            if (!propertyKeyframeDataJson)\n                return;\n            this._value = propertyKeyframeDataJson[VALUE_DATA][VALUE_DATA_VALUE];\n            this._aValue = propertyKeyframeDataJson[VALUE_DATA][VALUE_DATA_ABSOLUTE_VALUE];\n            this._type = propertyKeyframeDataJson[VALUE_DATA][VALUE_DATA_TYPE];\n            this._time = propertyKeyframeDataJson[TIME];\n            this._ease = propertyKeyframeDataJson[EASE];\n            this._enable = !!propertyKeyframeDataJson[ENABLE];\n            this._addonData = null;\n            if (!!propertyKeyframeDataJson[ADDONS])\n                this._addonData = new C3.AddonData(propertyKeyframeDataJson[ADDONS],this);\n            this._next = null\n        }\n        Release() {\n            this._propertyKeyframeData = null;\n            if (this._addonData) {\n                this._addonData.Release();\n                this._addonData = null\n            }\n        }\n        GetAddonData() {\n            return this._addonData\n        }\n        SetNext(next) {\n            this._next = next\n        }\n        GetNext() {\n            return this._next\n        }\n        GetValue() {\n            return this._value\n        }\n        SetValue(value) {\n            if (this._type === "color" && C3.IsFiniteNumber(value)) {\n                this._value[0] = C3.GetRValue(value);\n                this._value[1] = C3.GetGValue(value);\n                this._value[2] = C3.GetBValue(value)\n            } else\n                this._value = value\n        }\n        GetAbsoluteValue() {\n            return this._aValue\n        }\n        SetAbsoluteValue(aValue) {\n            if (this._type === "color" && C3.IsFiniteNumber(aValue)) {\n                this._aValue[0] = C3.GetRValue(aValue);\n                this._aValue[1] = C3.GetGValue(aValue);\n                this._aValue[2] = C3.GetBValue(aValue)\n            } else\n                this._aValue = aValue\n        }\n        GetValueWithResultMode() {\n            const rm = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();\n            if (rm === "relative")\n                return this.GetValue();\n            else if (rm === "absolute")\n                return this.GetAbsoluteValue()\n        }\n        GetType() {\n            return this._type\n        }\n        SetType(t) {\n            this._type = t\n        }\n        GetTime() {\n            return this._time\n        }\n        SetTime(t) {\n            this._time = t;\n            this._propertyKeyframeData._LinkPropertyKeyframeDataItems()\n        }\n        GetEase() {\n            return this._ease\n        }\n        SetEase(e) {\n            this._ease = e\n        }\n        GetEnable() {\n            return this._enable\n        }\n        SetEnable(e) {\n            this._enable = !!e\n        }\n        GetAddOn(id) {\n            if (!this._addonData)\n                return;\n            if (this._addonInstance || this._addonInstance === null)\n                return this._addonInstance;\n            const addonArray = this._addonData.GetAddDataItemArray();\n            if (!addonArray) {\n                this._addonInstance = null;\n                return this._addonInstance\n            }\n            const len = addonArray.length;\n            for (let i = 0; i < len; i++) {\n                const addon = addonArray[i];\n                if (addon.GetId() === id) {\n                    this._addonInstance = addon;\n                    return this._addonInstance\n                }\n            }\n            this._addonInstance = null;\n            return this._addonInstance\n        }\n        _SaveToJson() {\n            const aData = this._addonData;\n            return {\n                "addonDataJson": aData ? aData._SaveToJson() : aData,\n                "value": this._value,\n                "aValue": this._aValue,\n                "type": this._type,\n                "time": this._time,\n                "ease": this._ease,\n                "enable": this._enable\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            if (o["addonDataJson"])\n                this._addonData._SetFromJson(o["addonDataJson"]);\n            this._value = o["value"];\n            this._aValue = o["aValue"];\n            this._type = o["type"];\n            this._time = o["time"];\n            this._ease = o["ease"];\n            this._enable = o["enable"]\n        }\n    }\n    C3.PropertyKeyframeData = class PropertyKeyframeData {\n        constructor(propertyKeyframesDataJson, propertyTrackDataItem) {\n            this._propertyTrackDataItem = propertyTrackDataItem;\n            this._propertyKeyframeDataItems = [];\n            C3.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, propertyKeyframesDataJson, PropertyKeyframeDataItem, this);\n            this._LinkPropertyKeyframeDataItems()\n        }\n        Release() {\n            this._propertyTrackDataItem = null;\n            for (const propertyKeyframeDataItem of this._propertyKeyframeDataItems)\n                propertyKeyframeDataItem.Release();\n            C3.clearArray(this._propertyKeyframeDataItems);\n            this._propertyKeyframeDataItems = null\n        }\n        _LinkPropertyKeyframeDataItems() {\n            this._propertyKeyframeDataItems.sort( (first, second) => first.GetTime() - second.GetTime());\n            for (let i = 0; i < this._propertyKeyframeDataItems.length; i++) {\n                const current = this._propertyKeyframeDataItems[i];\n                current.SetNext(this._propertyKeyframeDataItems[i + 1])\n            }\n        }\n        AddEmptyPropertyKeyframeDataItem() {\n            const propertyKeyframeDataItem = new PropertyKeyframeDataItem(null,this);\n            this._propertyKeyframeDataItems.push(propertyKeyframeDataItem);\n            this._LinkPropertyKeyframeDataItems();\n            return propertyKeyframeDataItem\n        }\n        DeletePropertyKeyframeDataItems(match) {\n            for (const propertyKeyframeDataItem of this._propertyKeyframeDataItems) {\n                if (!match(propertyKeyframeDataItem))\n                    continue;\n                const index = this._propertyKeyframeDataItems.indexOf(propertyKeyframeDataItem);\n                if (index === -1)\n                    continue;\n                propertyKeyframeDataItem.Release();\n                this._propertyKeyframeDataItems.splice(index, 1)\n            }\n            this.SortPropertyKeyFrameDataItems();\n            this._LinkPropertyKeyframeDataItems()\n        }\n        SortPropertyKeyFrameDataItems() {\n            this._propertyKeyframeDataItems.sort( (a, b) => a.GetTime() - b.GetTime())\n        }\n        GetPropertyTrackDataItem() {\n            return this._propertyTrackDataItem\n        }\n        GetPropertyKeyframeDataItemCount() {\n            return this._propertyKeyframeDataItems.length\n        }\n        GetPropertyKeyframeDataItemArray() {\n            return this._propertyKeyframeDataItems\n        }\n        *propertyKeyframeDataItems() {\n            for (const propertyKeyframeDataItem of this._propertyKeyframeDataItems)\n                yield propertyKeyframeDataItem\n        }\n        *propertyKeyframeDataItemsReverse() {\n            for (let i = this._propertyKeyframeDataItems.length - 1; i >= 0; i--)\n                yield this._propertyKeyframeDataItems[i]\n        }\n        _SaveToJson() {\n            return {\n                "propertyKeyframeDataItemsJson": this._propertyKeyframeDataItems.map(propertyTrackDataItem => propertyTrackDataItem._SaveToJson())\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            C3.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, o["propertyKeyframeDataItemsJson"], PropertyKeyframeDataItem, this);\n            this._LinkPropertyKeyframeDataItems()\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/data\/propertyKeyframeAddonData.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const ADDON_ID = 0;\n    const ADDON_DATA = 1;\n    class AddonDataItem {\n        constructor(addonDataJson, addonData) {\n            this._addonData = addonData;\n            this._id = addonDataJson[ADDON_ID];\n            this._data = addonDataJson[ADDON_DATA]\n        }\n        Release() {\n            this._addonData = null;\n            this._data = null\n        }\n        GetAddonData() {\n            return this._addonData\n        }\n        GetId() {\n            return this._id\n        }\n        _SaveToJson() {\n            return {\n                "id": this._id,\n                "data": this._data\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            this._id = o["id"];\n            this._data = o["data"]\n        }\n    }\n    const START_ANCHOR = 0;\n    const START_ENABLE = 1;\n    const END_ANCHOR = 2;\n    const END_ENABLE = 3;\n    class AddonDataCubicBezierItem extends AddonDataItem {\n        constructor(addonDataJson, addonData) {\n            super(addonDataJson, addonData);\n            this._startAnchor = this._data[START_ANCHOR];\n            this._startEnable = !!this._data[START_ENABLE];\n            this._endAnchor = this._data[END_ANCHOR];\n            this._endEnable = !!this._data[END_ENABLE]\n        }\n        Release() {\n            super.Release()\n        }\n        GetStartAnchor() {\n            return this._startAnchor\n        }\n        GetStartEnable() {\n            return this._startEnable\n        }\n        GetEndAnchor() {\n            return this._endAnchor\n        }\n        GetEndEnable() {\n            return this._endEnable\n        }\n        _SaveToJson() {\n            return Object.assign(super._SaveToJson(), {\n                "startAnchor": this._startAnchor,\n                "startEnable": !!this._startEnable,\n                "endAnchor": this._endAnchor,\n                "endEnable": !!this._endEnable\n            })\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            super._LoadFromJson(o);\n            this._startAnchor = o["startAnchor"];\n            this._startEnable = !!o["startEnable"];\n            this._endAnchor = o["endAnchor"];\n            this._endEnable = !!o["endEnable"]\n        }\n    }\n    const DIRECTION = 0;\n    const REVOLUTIONS = 1;\n    class AddonDataAngleItem extends AddonDataItem {\n        constructor(addonDataJson, addonData) {\n            super(addonDataJson, addonData);\n            this._direction = this._data[DIRECTION];\n            this._revolutions = this._data[REVOLUTIONS]\n        }\n        Release() {\n            super.Release()\n        }\n        GetDirection() {\n            return this._direction\n        }\n        GetRevolutions() {\n            return this._revolutions\n        }\n        _SaveToJson() {\n            return Object.assign(super._SaveToJson(), {\n                "direction": this._direction,\n                "revolutions": this._revolutions\n            })\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            super._LoadFromJson(o);\n            this._direction = o["direction"];\n            this._revolutions = o["revolutions"]\n        }\n    }\n    C3.AddonData = class AddonData {\n        constructor(addonsDataJson, propertyKeyframeDataItem) {\n            this._propertyKeyframeDataItem = propertyKeyframeDataItem;\n            this._addonDataItems = [];\n            C3.TimelineDataManager._CreateDataItems(this._addonDataItems, addonsDataJson, {\n                prop: 0,\n                map: new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem]])\n            }, this)\n        }\n        Release() {\n            this._propertyKeyframeDataItem = null;\n            for (const addonDataItem of this._addonDataItems)\n                addonDataItem.Release();\n            C3.clearArray(this._addonDataItems);\n            this._addonDataItems = null\n        }\n        GetPropertyKeyframeDataItem() {\n            return this._propertyKeyframeDataItem\n        }\n        GetAddDataItemArray() {\n            return this._addonDataItems\n        }\n        *addonDataItems() {\n            for (const addonDataItem of this._addonDataItems)\n                yield addonDataItem\n        }\n        _SaveToJson() {\n            return {\n                "addonDataItemsJson": this._addonDataItems.map(addonDataItem => addonDataItem._SaveToJson())\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            C3.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, o["addonDataItemsJson"], {\n                prop: "id",\n                map: new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem]])\n            }, this)\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/tweens\/tweenState.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const INITIAL_VALUE_MODE_START_VALUE = "start-value";\n    const INITIAL_VALUE_MODE_CURRENT_STATE = "current-state";\n    const PING_PONG_BEGIN = 0;\n    const PING_PONG_END = 1;\n    let createdTweens = 0;\n    C3.TweenState = class Tween extends C3.TimelineState {\n        constructor(tweenDataItem, timelineManager) {\n            super(`tween-${createdTweens++}`, tweenDataItem, timelineManager);\n            this._id = "";\n            this._destroyInstanceOnComplete = false;\n            this._initialValueMode = INITIAL_VALUE_MODE_START_VALUE;\n            this._instance = null;\n            this._on_completed_callbacks = null;\n            this._on_started_callbacks = null;\n            this._track = null\n        }\n        FireReleaseEvent(dispatcher) {\n            const event = C3.New(C3.Event, "tweenstatereleased");\n            event.tweenState = this;\n            dispatcher.dispatchEvent(event)\n        }\n        CreateTrackStates() {\n            for (const trackDataItem of this._timelineDataItem.GetTrackData().trackDataItems())\n                this._tracks.push(C3.TweenTrackState.Create(this, trackDataItem));\n            this._track = this._tracks[0]\n        }\n        AddTrack() {\n            const trackDataItem = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem();\n            const track = C3.TweenTrackState.Create(this, trackDataItem);\n            this._tracks.push(track);\n            this._track = this._tracks[0];\n            return track\n        }\n        GetPropertyTrack(propertyName) {\n            return this._track.GetPropertyTracks()[0]\n        }\n        SetPropertyType(type) {\n            this._propertyType = type\n        }\n        GetInstance() {\n            const tracks = this.GetTracks();\n            if (!tracks || !tracks.length)\n                return;\n            const track = tracks[0];\n            this._track = track;\n            if (!track)\n                return;\n            const instance = track.GetInstance();\n            return track.IsInstanceValid() ? instance : undefined\n        }\n        AddStartedCallback(c) {\n            if (!this._on_started_callbacks)\n                this._on_started_callbacks = [];\n            this._on_started_callbacks.push(c)\n        }\n        AddCompletedCallback(c) {\n            if (!this._on_completed_callbacks)\n                this._on_completed_callbacks = [];\n            this._on_completed_callbacks.push(c)\n        }\n        RemoveStartedCallback(c) {\n            if (!this._on_started_callbacks)\n                return;\n            const index = this._on_started_callbacks.indexOf(c);\n            if (index !== -1)\n                this._on_started_callbacks.splice(index, 1)\n        }\n        RemoveCompletedCallback(c) {\n            if (!this._on_completed_callbacks)\n                return;\n            const index = this._on_completed_callbacks.indexOf(c);\n            if (index !== -1)\n                this._on_completed_callbacks.splice(index, 1)\n        }\n        SetStartValue(startValue, propertyName) {\n            for (const track of this._tracks)\n                for (const propertyTrack of track._propertyTracks) {\n                    if (propertyTrack.GetPropertyName() !== propertyName)\n                        continue;\n                    const propertyTrackData = propertyTrack.GetPropertyTrackData();\n                    const propertyTrackDataItem = propertyTrack.GetPropertyTrackDataItem();\n                    const propertyKeyframeDataItem = propertyTrackData.GetFirstPropertyKeyframeDataItem(propertyTrackDataItem);\n                    propertyKeyframeDataItem.SetValue(startValue);\n                    propertyKeyframeDataItem.SetAbsoluteValue(startValue)\n                }\n        }\n        _GetPropertyTrackState(propertyName) {\n            for (const track of this._tracks)\n                for (const propertyTrack of track._propertyTracks)\n                    if (propertyTrack.GetPropertyName() === propertyName)\n                        return propertyTrack\n        }\n        BeforeSetEndValues(properties) {\n            for (const propertyName of properties) {\n                const propertyTrackState = this._GetPropertyTrackState(propertyName);\n                this.SetStartValue(propertyTrackState.GetCurrentState(), propertyName)\n            }\n            if (this.IsForwardPlayBack()) {\n                const newTotalTime = this.GetTotalTime() - this.GetTime();\n                this.SetTotalTime(newTotalTime);\n                for (const track of this._tracks)\n                    track.SetLocalTotalTime(newTotalTime);\n                this._SetTime(0)\n            } else {\n                const newTotalTime = this.GetTime();\n                this.SetTotalTime(newTotalTime);\n                for (const track of this._tracks)\n                    track.SetLocalTotalTime(newTotalTime);\n                this._SetTime(newTotalTime)\n            }\n            this.SetInitialStateFromSetTime()\n        }\n        SetEndValue(endValue, propertyName) {\n            const propertyTrackState = this._GetPropertyTrackState(propertyName);\n            const propertyTrackData = propertyTrackState.GetPropertyTrackData();\n            const propertyTrackDataItem = propertyTrackState.GetPropertyTrackDataItem();\n            const propertyKeyframeDataItem = propertyTrackData.GetLastPropertyKeyframeDataItem(propertyTrackDataItem);\n            propertyKeyframeDataItem.SetTime(this.GetTotalTime());\n            propertyKeyframeDataItem.SetValue(endValue);\n            propertyKeyframeDataItem.SetAbsoluteValue(endValue)\n        }\n        SetId(id) {\n            this._id = id\n        }\n        GetId() {\n            return this._id\n        }\n        SetInitialValueMode(initialValueMode) {\n            this._initialValueMode = initialValueMode\n        }\n        GetInitialValueMode() {\n            return this._initialValueMode\n        }\n        SetDestroyInstanceOnComplete(releaseOnComplete) {\n            this._destroyInstanceOnComplete = releaseOnComplete\n        }\n        GetDestroyInstanceOnComplete() {\n            return this._destroyInstanceOnComplete\n        }\n        OnStarted() {\n            if (this._on_started_callbacks)\n                for (const c of this._on_started_callbacks)\n                    c(this);\n            if (this.IsComplete())\n                return;\n            for (const track of this._tracks)\n                track.CompareSaveStateWithCurrent()\n        }\n        OnCompleted() {\n            this._completedTick = this._runtime.GetTickCount()\n        }\n        FinishTriggers() {\n            if (this._finishedTriggers)\n                return;\n            this._finishedTriggers = true;\n            if (this._on_completed_callbacks)\n                for (const c of this._on_completed_callbacks)\n                    c(this)\n        }\n        SetTime(time) {\n            this._DeleteIntermediateKeyframes();\n            super.SetTime(time)\n        }\n        _SetTimeAndReset(time) {\n            if (!C3.IsFiniteNumber(time))\n                time = this.GetTotalTime();\n            if (time < 0)\n                this._playheadTime = 0;\n            else if (time >= this.GetTotalTime())\n                this._playheadTime = this.GetTotalTime();\n            else\n                this._playheadTime = time;\n            this._track.SetResetState()\n        }\n        SetInitialState(fromSetTime) {\n            if (!this.InitialStateSet() && this.GetInitialValueMode() === INITIAL_VALUE_MODE_CURRENT_STATE)\n                for (const track of this._tracks)\n                    track.CompareInitialStateWithCurrent();\n            super.SetInitialState(fromSetTime)\n        }\n        Stop(completed=false) {\n            super.Stop(completed);\n            if (this.IsComplete())\n                return;\n            for (const track of this._tracks)\n                track.SaveState()\n        }\n        Reset(render=true, beforeChangeLayout=false) {\n            this._DeleteIntermediateKeyframes();\n            super.Reset(render, beforeChangeLayout)\n        }\n        _DeleteIntermediateKeyframes() {\n            for (const track of this._tracks) {\n                const del = kf => {\n                    const time = kf.GetTime();\n                    const totalTime = this.GetTotalTime();\n                    return time !== 0 && time !== totalTime\n                }\n                ;\n                track.DeleteKeyframes(del);\n                track.DeletePropertyKeyframes(del)\n            }\n        }\n        _OnBeforeChangeLayout() {\n            if (this.IsReleased())\n                return true;\n            const instance = this.GetInstance();\n            if (instance && instance.GetObjectClass().IsGlobal())\n                return false;\n            this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this);\n            this.ResetBeforeChangeLayout();\n            return true\n        }\n        Tick(deltaTime, timeScale, deltaTime1) {\n            if (!this._instance)\n                this._instance = this.GetInstance();\n            if (!this._instance || this._instance.IsDestroyed()) {\n                this.Stop(true);\n                this.OnCompleted();\n                return\n            }\n            const instanceTimeScale = this._instance.GetTimeScale();\n            if (instanceTimeScale !== -1)\n                deltaTime = deltaTime1 * instanceTimeScale;\n            if (deltaTime === 0 && this._lastDelta === 0)\n                return;\n            this._lastDelta = deltaTime;\n            const lastTime = this._playheadTime;\n            const newDeltaTime = deltaTime * this._playbackRate;\n            const newTime = lastTime + newDeltaTime;\n            const totalTime = this._timelineDataItem._totalTime;\n            if (newTime < 0)\n                this._playheadTime = 0;\n            else if (newTime >= totalTime)\n                this._playheadTime = totalTime;\n            else\n                this._playheadTime = newTime;\n            let complete = false;\n            let ensureValue = false;\n            const loop = this.GetLoop();\n            const pingPong = this.GetPingPong();\n            if (!loop && !pingPong)\n                if (this._playbackRate > 0) {\n                    if (this._playheadTime >= totalTime)\n                        if (this._currentRepeatCount < this.GetRepeatCount()) {\n                            this._currentRepeatCount++;\n                            this._SetTimeAndReset(0);\n                            ensureValue = true\n                        } else {\n                            this._SetTime(totalTime);\n                            complete = true\n                        }\n                } else {\n                    if (this._playheadTime <= 0)\n                        if (this._currentRepeatCount < this.GetRepeatCount()) {\n                            this._currentRepeatCount++;\n                            this._SetTimeAndReset(totalTime);\n                            ensureValue = true\n                        } else {\n                            this._SetTime(0);\n                            complete = true\n                        }\n                }\n            else if (loop && !pingPong)\n                if (this._playbackRate > 0) {\n                    if (this._playheadTime >= totalTime) {\n                        this._SetTimeAndReset(0);\n                        ensureValue = true\n                    }\n                } else {\n                    if (this._playheadTime <= 0) {\n                        this._SetTimeAndReset(totalTime);\n                        ensureValue = true\n                    }\n                }\n            else if (!loop && pingPong)\n                if (this._playbackRate > 0) {\n                    if (this._playheadTime >= totalTime) {\n                        this._SetTime(totalTime);\n                        this.SetPlaybackRate(this.GetPlaybackRate() * -1);\n                        ensureValue = true;\n                        if (this._pingPongState === PING_PONG_END)\n                            if (this._currentRepeatCount < this.GetRepeatCount()) {\n                                this._currentRepeatCount++;\n                                this._pingPongState = PING_PONG_BEGIN\n                            } else\n                                complete = true;\n                        else if (this._pingPongState === PING_PONG_BEGIN)\n                            this._pingPongState = PING_PONG_END\n                    }\n                } else {\n                    if (this._playheadTime <= 0) {\n                        this._SetTime(0);\n                        this.SetPlaybackRate(this.GetPlaybackRate() * -1);\n                        ensureValue = true;\n                        if (this._pingPongState === PING_PONG_END)\n                            if (this._currentRepeatCount < this.GetRepeatCount()) {\n                                this._currentRepeatCount++;\n                                this._pingPongState = PING_PONG_BEGIN\n                            } else\n                                complete = true;\n                        else if (this._pingPongState === PING_PONG_BEGIN)\n                            this._pingPongState = PING_PONG_END\n                    }\n                }\n            else if (loop && pingPong)\n                if (this._playbackRate > 0) {\n                    if (this._playheadTime >= totalTime) {\n                        this._SetTime(totalTime);\n                        this.SetPlaybackRate(this.GetPlaybackRate() * -1);\n                        ensureValue = true\n                    }\n                } else if (this._playheadTime <= 0) {\n                    this._SetTime(0);\n                    this.SetPlaybackRate(this.GetPlaybackRate() * -1);\n                    ensureValue = true\n                }\n            if (complete) {\n                this._track.SetEndState();\n                this.Stop(true);\n                this.OnCompleted();\n                return\n            }\n            this._track.Interpolate(this._playheadTime, true, false, ensureValue, this._firstTick, false);\n            if (this._firstTick)\n                this._firstTick = false\n        }\n        _SaveToJson() {\n            const ret = super._SaveToJson();\n            const tweenDataItem = this.GetTimelineDataItem();\n            return Object.assign(ret, {\n                "tweenDataItemJson": tweenDataItem._SaveToJson(),\n                "id": this._id,\n                "destroyInstanceOnComplete": this._destroyInstanceOnComplete,\n                "initialValueMode": this._initialValueMode\n            })\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            const tweenDataItem = this.GetTimelineDataItem();\n            tweenDataItem._LoadFromJson(o["tweenDataItemJson"]);\n            super._LoadFromJson(o);\n            this._id = o["id"];\n            this._destroyInstanceOnComplete = o["destroyInstanceOnComplete"];\n            this._initialValueMode = o["initialValueMode"]\n        }\n        static IsPlaying(tween) {\n            return tween.IsPlaying()\n        }\n        static IsPaused(tween) {\n            return tween.IsPaused()\n        }\n        static Build(config) {\n            const timelineManager = config.runtime.GetTimelineManager();\n            const tweenDataItem = new C3.TimelineDataItem;\n            if (config.json) {\n                tweenDataItem._LoadFromJson(config.json["tweenDataItemJson"]);\n                const tween = new C3.TweenState(tweenDataItem,timelineManager);\n                tween._LoadFromJson(config.json);\n                return tween\n            } else {\n                const tween = new C3.TweenState(tweenDataItem,timelineManager);\n                if (!C3.IsArray(config.propertyTracksConfig))\n                    config.propertyTracksConfig = [config.propertyTracksConfig];\n                tween.SetId(config.id);\n                tween.SetTags(config.tags);\n                tween.SetInitialValueMode(config.initialValueMode);\n                tween.SetDestroyInstanceOnComplete(config.releaseOnComplete);\n                tween.SetLoop(config.loop);\n                tween.SetPingPong(config.pingPong);\n                tween.SetTotalTime(config.time);\n                tween.SetStep(0);\n                tween.SetInterpolationMode("default");\n                tween.SetResultMode(config.propertyTracksConfig[0].resultMode);\n                const track = tween.AddTrack();\n                track.SetInstanceUID(config.instance.GetUID());\n                track.SetInterpolationMode("default");\n                track.SetResultMode(config.propertyTracksConfig[0].resultMode);\n                track.SetEnable(true);\n                track.SetObjectClassIndex(config.instance.GetObjectClass().GetIndex());\n                const sdkIntance = config.instance.GetSdkInstance();\n                const w = sdkIntance.IsOriginalSizeKnown() ? sdkIntance.GetOriginalWidth() : config.instance.GetWorldInfo().GetWidth();\n                const h = sdkIntance.IsOriginalSizeKnown() ? sdkIntance.GetOriginalHeight() : config.instance.GetWorldInfo().GetHeight();\n                track.SetOriginalWidth(w);\n                track.SetOriginalHeight(h);\n                const startKeyframeDataItem = track.AddKeyframe();\n                startKeyframeDataItem.SetTime(0);\n                startKeyframeDataItem.SetEase("noease");\n                startKeyframeDataItem.SetEnable(true);\n                startKeyframeDataItem.SetTags("");\n                const endKeyframeDataItem = track.AddKeyframe();\n                endKeyframeDataItem.SetTime(config.time);\n                endKeyframeDataItem.SetEase("noease");\n                endKeyframeDataItem.SetEnable(true);\n                endKeyframeDataItem.SetTags("");\n                for (const propertyTrackConfig of config.propertyTracksConfig) {\n                    const propertyTrack = track.AddPropertyTrack();\n                    propertyTrack.SetSourceAdapterId(propertyTrackConfig.sourceId);\n                    propertyTrack.SetSourceAdapterArgs(propertyTrackConfig.sourceArgs);\n                    propertyTrack.SetPropertyName(propertyTrackConfig.property);\n                    propertyTrack.SetPropertyType(propertyTrackConfig.type);\n                    propertyTrack.SetMin(NaN);\n                    propertyTrack.SetMax(NaN);\n                    propertyTrack.SetInterpolationMode("default");\n                    propertyTrack.SetResultMode(propertyTrackConfig.resultMode);\n                    propertyTrack.SetEnable(true);\n                    const startPropertyKeyframeDataItem = propertyTrack.AddPropertyKeyframe();\n                    startPropertyKeyframeDataItem.SetType(propertyTrackConfig.valueType);\n                    startPropertyKeyframeDataItem.SetTime(0);\n                    startPropertyKeyframeDataItem.SetEase(propertyTrackConfig.ease);\n                    startPropertyKeyframeDataItem.SetEnable(true);\n                    startPropertyKeyframeDataItem.SetValue(propertyTrackConfig.startValue);\n                    startPropertyKeyframeDataItem.SetAbsoluteValue(propertyTrackConfig.startValue);\n                    const endPropertyKeyframeDataItem = propertyTrack.AddPropertyKeyframe();\n                    endPropertyKeyframeDataItem.SetType(propertyTrackConfig.valueType);\n                    endPropertyKeyframeDataItem.SetTime(config.time);\n                    endPropertyKeyframeDataItem.SetEase(propertyTrackConfig.ease);\n                    endPropertyKeyframeDataItem.SetEnable(true);\n                    endPropertyKeyframeDataItem.SetValue(propertyTrackConfig.endValue);\n                    endPropertyKeyframeDataItem.SetAbsoluteValue(propertyTrackConfig.endValue);\n                    propertyTrack.GetSourceAdapter()\n                }\n                return tween\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/tweens\/tweenTrackState.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.TweenTrackState = class TweenTrack extends C3.TrackState {\n        constructor(timeline, trackDataItem) {\n            super(timeline, trackDataItem);\n            this._firstPropertyTrack = null;\n            this._secondPropertyTrack = null\n        }\n        static Create(timeline, trackDataItem) {\n            return C3.New(C3.TweenTrackState, timeline, trackDataItem)\n        }\n        _CachePropertyTracks() {\n            if (this._propertyTracks.length === 1)\n                this._firstPropertyTrack = this._propertyTracks[0];\n            else {\n                this._firstPropertyTrack = this._propertyTracks[0];\n                this._secondPropertyTrack = this._propertyTracks[1]\n            }\n        }\n        CreatePropertyTrackStates() {\n            for (const propertyTrackDataItem of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems())\n                this._propertyTracks.push(C3.TweenPropertyTrackState.Create(this, propertyTrackDataItem));\n            this._CachePropertyTracks()\n        }\n        AddPropertyTrack() {\n            const propertyTrackData = this._trackDataItem.GetPropertyTrackData();\n            const propertyTrackDataItem = propertyTrackData.AddEmptyPropertyTrackDataItem();\n            const propertyTrack = C3.TweenPropertyTrackState.Create(this, propertyTrackDataItem);\n            this._propertyTracks.push(propertyTrack);\n            this._CachePropertyTracks();\n            return propertyTrack\n        }\n        SetInitialState() {\n            this.MaybeGetInstance();\n            if (!this.IsInstanceValid() && this.IsInstanceTrack())\n                return;\n            const timeline = this.GetTimeline();\n            const isForwardPlayBack = timeline.IsForwardPlayBack();\n            const time = isForwardPlayBack ? 0 : this.GetLocalTotalTime();\n            for (const propertyTrack of this._propertyTracks) {\n                propertyTrack.SetInitialState(time);\n                if (this._worldInfoChange === 0 && propertyTrack.GetWorldInfoChange() === 1)\n                    this._worldInfoChange = 1;\n                if (this._renderChange === 0 && propertyTrack.GetRenderChange() === 1)\n                    this._renderChange = 1\n            }\n            this._needsBeforeAndAfter = 0;\n            const nba = this._propertyTracks.some(pt => pt.GetNeedsBeforeAndAfter());\n            if (nba)\n                this._needsBeforeAndAfter = 1;\n            this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(time);\n            this._initialStateOfNestedSet = false;\n            this._endStateOfNestedSet = false;\n            this.Interpolate(time)\n        }\n        BeforeInterpolate() {}\n        Interpolate(time, isTicking=false, setTime=false, ensureValue=false, firstTick=false, ignoreGlobals=false) {\n            if (!this._instance)\n                this.GetInstance();\n            if (!this._instance)\n                return;\n            const instanceValid = !this._instance.IsDestroyed();\n            if (!instanceValid)\n                return false;\n            if (ignoreGlobals && this.GetObjectClass().IsGlobal())\n                return false;\n            if (this._secondPropertyTrack) {\n                this._firstPropertyTrack.Interpolate(time, setTime, ensureValue);\n                this._secondPropertyTrack.Interpolate(time, setTime, ensureValue)\n            } else\n                this._firstPropertyTrack.Interpolate(time, setTime, ensureValue);\n            if (this._firstPropertyTrack.GetWorldInfoChange() !== 0) {\n                if (!this._worldInfo)\n                    this._worldInfo = this._instance.GetWorldInfo();\n                if (this._worldInfo)\n                    this._worldInfo.SetBboxChanged()\n            }\n        }\n        AfterInterpolate() {}\n        _LoadFromJson(o) {\n            super._LoadFromJson(o);\n            this._CachePropertyTracks()\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/tweens\/tweenPropertyTrackState.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.TweenPropertyTrackState = class TweenPropertyTrackState extends C3.PropertyTrackState {\n        constructor(track, propertyTrackDataItem) {\n            super(track, propertyTrackDataItem);\n            this._basic = false\n        }\n        static Create(track, propertyTrackDataItem) {\n            return C3.New(C3.TweenPropertyTrackState, track, propertyTrackDataItem)\n        }\n        Interpolate(time, setTime=false, ensureValue=false) {\n            let start;\n            let end;\n            if (this._basic) {\n                start = this._propertyKeyframeDataItems[0];\n                end = this._propertyKeyframeDataItems[1]\n            } else if (setTime) {\n                start = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(time, this._propertyTrackDataItem);\n                end = start.GetNext()\n            } else {\n                if (this._lastPropertyKeyframeDataItem) {\n                    const timeline = this.GetTimeline();\n                    const nextPropertyKeyframe = this._lastPropertyKeyframeDataItem.GetNext();\n                    const lastTime = this._lastPropertyKeyframeDataItem.GetTime();\n                    const nextTime = nextPropertyKeyframe ? nextPropertyKeyframe.GetTime() : timeline.GetTotalTime();\n                    if (time <= lastTime || time >= nextTime)\n                        this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(time, this._propertyTrackDataItem)\n                } else\n                    this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(time, this._propertyTrackDataItem);\n                start = this._lastPropertyKeyframeDataItem;\n                end = start.GetNext()\n            }\n            this._sourceAdapter.Interpolate(time, start, end, setTime, ensureValue)\n        }\n        AddPropertyKeyframe() {\n            const propertyKeyframeData = this._propertyTrackDataItem.GetPropertyKeyframeData();\n            const propertyKeyframeDataItem = propertyKeyframeData.AddEmptyPropertyKeyframeDataItem();\n            this._lastPropertyKeyframeDataItem = null;\n            this._basic = this.GetPropertyKeyframeDataItems().length <= 2;\n            return propertyKeyframeDataItem\n        }\n        DeletePropertyKeyframes(match) {\n            this._lastPropertyKeyframeDataItem = null;\n            const propertyKeyframeData = this._propertyTrackDataItem.GetPropertyKeyframeData();\n            propertyKeyframeData.DeletePropertyKeyframeDataItems(match);\n            this._basic = this.GetPropertyKeyframeDataItems().length <= 2\n        }\n        _SaveToJson() {\n            return {\n                "sourceAdapterJson": this.GetSourceAdapter()._SaveToJson(),\n                "basic": this._basic\n            }\n        }\n        _LoadFromJson(o) {\n            if (!o)\n                return;\n            this.GetSourceAdapter()._LoadFromJson(o["sourceAdapterJson"]);\n            this._basic = o["basic"]\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/transitions\/transition.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const Ease = self.Ease;\n    const NAME = 0;\n    const TRANSITION_KEYFRAMES = 1;\n    C3.Transition = class Transition extends C3.DefendedBase {\n        constructor(data) {\n            super();\n            this._name = data[NAME];\n            this._transitionKeyframes = [];\n            for (const transitionKeyframeData of data[TRANSITION_KEYFRAMES]) {\n                const transitionKeyframe = C3.TransitionKeyframe.Create(this, transitionKeyframeData);\n                this._transitionKeyframes.push(transitionKeyframe)\n            }\n            for (let i = 0; i < this._transitionKeyframes.length; i++) {\n                const current = this._transitionKeyframes[i];\n                current.SetNext(this._transitionKeyframes[i + 1])\n            }\n            this._precalculatedSamples = new Map;\n            this._transitionKeyframeCache = new Map;\n            this._PreCalcSamples();\n            Ease.AddCustomEase(this._name, (t, sv, dv, tt) => this.Interpolate(t, sv, dv, tt))\n        }\n        static Create(data) {\n            return C3.New(C3.Transition, data)\n        }\n        Release() {\n            for (const transitionKeyframe of this._transitionKeyframes)\n                transitionKeyframe.Release();\n            C3.clearArray(this._transitionKeyframes);\n            this._transitionKeyframes = null;\n            this._precalculatedSamples.clear();\n            this._precalculatedSamples = null;\n            this._transitionKeyframeCache.clear();\n            this._transitionKeyframeCache = null\n        }\n        GetTransitionKeyFrameAt(x) {\n            const transitionKeyframe = this._transitionKeyframeCache.get(x);\n            if (transitionKeyframe)\n                return transitionKeyframe;\n            for (const transitionKeyframe of this._transitionKeyframes)\n                if (transitionKeyframe.GetValueX() === x) {\n                    this._transitionKeyframeCache.set(x, transitionKeyframe);\n                    return transitionKeyframe\n                }\n        }\n        GetFirstTransitionKeyFrameHigherThan(x) {\n            for (const transitionKeyframe of this._transitionKeyframes)\n                if (transitionKeyframe.GetValueX() > x)\n                    return transitionKeyframe\n        }\n        GetFirstTransitionKeyFrameHigherOrEqualThan(x) {\n            for (const transitionKeyframe of this._transitionKeyframes)\n                if (transitionKeyframe.GetValueX() >= x)\n                    return transitionKeyframe\n        }\n        GetFirstTransitionKeyFrameLowerThan(x) {\n            for (let i = this._transitionKeyframes.length - 1; i >= 0; i--) {\n                const transitionKeyframe = this._transitionKeyframes[i];\n                if (transitionKeyframe.GetValueX() < x)\n                    return transitionKeyframe\n            }\n        }\n        GetFirstTransitionKeyFrameLowerOrEqualThan(x) {\n            for (let i = this._transitionKeyframes.length - 1; i >= 0; i--) {\n                const transitionKeyframe = this._transitionKeyframes[i];\n                if (transitionKeyframe.GetValueX() <= x)\n                    return transitionKeyframe\n            }\n        }\n        Interpolate(time, startValue, deltaValue, totalTime) {\n            const n = time \/ totalTime;\n            let start = this.GetFirstTransitionKeyFrameLowerOrEqualThan(n);\n            let end = start.GetNext();\n            if (!end) {\n                start = this.GetFirstTransitionKeyFrameLowerThan(n);\n                end = start.GetNext()\n            }\n            const delta = end.GetValueX() - start.GetValueX();\n            const nn = C3.mapToRange(n, start.GetValueX(), end.GetValueX(), 0, delta);\n            const startX = start.GetValueX();\n            const startY = start.GetValueY();\n            const anchor1X = start.GetValueX() + start.GetStartAnchorX();\n            const anchor1Y = start.GetValueY() + start.GetStartAnchorY();\n            const anchor2X = end.GetValueX() + end.GetEndAnchorX();\n            const anchor2Y = end.GetValueY() + end.GetEndAnchorY();\n            const endX = end.GetValueX();\n            const endY = end.GetValueY();\n            let ret = Ease.GetRuntimeEase("spline")(nn, startX, startY, anchor1X, anchor1Y, anchor2X, anchor2Y, endX, endY, this._precalculatedSamples.get(start));\n            ret += start.GetValueY();\n            return (1 - ret) * startValue + ret * (startValue + deltaValue)\n        }\n        _PreCalcSamples() {\n            this._precalculatedSamples.clear();\n            for (let i = 0; i < this._transitionKeyframes.length - 1; i++) {\n                const transitionKeyframe = this._transitionKeyframes[i];\n                if (!transitionKeyframe.GetStartEnable())\n                    continue;\n                const start = transitionKeyframe;\n                const end = this._transitionKeyframes[i + 1];\n                const startValue = start.GetValueX();\n                const anchor1Value = start.GetValueX() + start.GetStartAnchorX();\n                const anchor2Value = end.GetValueX() + end.GetEndAnchorX();\n                const endValue = end.GetValueX();\n                this._precalculatedSamples.set(start, Ease.GetBezierSamples(startValue, anchor1Value, anchor2Value, endValue))\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/transitions\/transitionKeyframe.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const VALUE_X = 0;\n    const VALUE_Y = 1;\n    const START_ANCHOR_X = 2;\n    const START_ANCHOR_Y = 3;\n    const END_ANCHOR_X = 4;\n    const END_ANCHOR_Y = 5;\n    const START_ENABLE = 6;\n    const END_ENABLE = 7;\n    C3.TransitionKeyframe = class TransitionKeyframe extends C3.DefendedBase {\n        constructor(transition, data) {\n            super();\n            this._transition = transition;\n            this._valueX = data[VALUE_X];\n            this._valueY = data[VALUE_Y];\n            this._startAnchorX = data[START_ANCHOR_X];\n            this._startAnchorY = data[START_ANCHOR_Y];\n            this._endAnchorX = data[END_ANCHOR_X];\n            this._endAnchorY = data[END_ANCHOR_Y];\n            this._startEnable = data[START_ENABLE];\n            this._endEnable = data[END_ENABLE];\n            this._next = null\n        }\n        Release() {\n            this._transition = null\n        }\n        static Create(transition, data) {\n            return C3.New(C3.TransitionKeyframe, transition, data)\n        }\n        SetNext(transitionKeyframe) {\n            this._next = transitionKeyframe\n        }\n        GetNext() {\n            return this._next\n        }\n        GetValueX() {\n            return this._valueX\n        }\n        GetValueY() {\n            return this._valueY\n        }\n        GetStartAnchorX() {\n            return this._startAnchorX\n        }\n        GetStartAnchorY() {\n            return this._startAnchorY\n        }\n        GetEndAnchorX() {\n            return this._endAnchorX\n        }\n        GetEndAnchorY() {\n            return this._endAnchorY\n        }\n        GetStartEnable() {\n            return this._startEnable\n        }\n        GetEndEnable() {\n            return this._endEnable\n        }\n    }\n    ;\n\n}\n\n\/\/ timelines\/transitions\/transitionManager.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.TransitionManager = class TransitionManager extends C3.DefendedBase {\n        constructor(runtime) {\n            super();\n            this._runtime = runtime;\n            this._transitions = []\n        }\n        Release() {\n            for (const transition of this._transitions)\n                transition.Release();\n            C3.clearArray(this._transitions);\n            this._transitions = null\n        }\n        Create(transitionData) {\n            this._transitions.push(C3.Transition.Create(transitionData))\n        }\n    }\n    ;\n\n}\n\n\/\/ templates\/templateManager.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.TemplateManager = class TemplateManager extends C3.DefendedBase {\n        constructor(runtime) {\n            super();\n            this._runtime = runtime;\n            this._templateDataMap = null;\n            this._instanceToTemplateNameMap = null;\n            this._instanceDestroy = e => this._OnInstanceDestroy(e.instance)\n        }\n        Release() {\n            this.RemoveRuntimeListeners();\n            if (this._templateDataMap) {\n                for (const objectClassTemplatesMap of this._templateDataMap.values())\n                    objectClassTemplatesMap.clear();\n                this._templateDataMap.clear()\n            }\n            this._templateDataMap = null;\n            this._runtime = null\n        }\n        Create(templateInstanceData) {\n            if (!this._templateDataMap)\n                this._templateDataMap = new Map;\n            if (!templateInstanceData)\n                return;\n            const templateData = templateInstanceData[0][16];\n            const templateName = templateData[0];\n            const objectClassIndex = templateInstanceData[1];\n            if (!this._templateDataMap.has(objectClassIndex))\n                this._templateDataMap.set(objectClassIndex, new Map);\n            const objectClassTemplatesMap = this._templateDataMap.get(objectClassIndex);\n            objectClassTemplatesMap.set(templateName, templateInstanceData)\n        }\n        AddRuntimeListeners() {\n            const dispatcher = this._runtime.Dispatcher();\n            if (dispatcher)\n                dispatcher.addEventListener("instancedestroy", this._instanceDestroy)\n        }\n        RemoveRuntimeListeners() {\n            const dispatcher = this._runtime.Dispatcher();\n            if (dispatcher)\n                dispatcher.removeEventListener("instancedestroy", this._instanceDestroy)\n        }\n        HasTemplates() {\n            if (!this._templateDataMap)\n                return false;\n            return this._templateDataMap.size !== 0\n        }\n        GetTemplateData(objectClass_or_index, templateName) {\n            let index = 0;\n            if (objectClass_or_index instanceof C3.ObjectClass)\n                index = objectClass_or_index.GetIndex();\n            else\n                index = objectClass_or_index;\n            if (!this._templateDataMap.has(index))\n                return;\n            const ret = this._templateDataMap.get(index).get(templateName);\n            if (ret)\n                return JSON.parse(JSON.stringify(ret));\n            return undefined\n        }\n        MapInstanceToTemplateName(inst, templateName) {\n            if (!this._instanceToTemplateNameMap)\n                this._instanceToTemplateNameMap = new WeakMap;\n            if (this._instanceToTemplateNameMap.has(inst))\n                return;\n            this._instanceToTemplateNameMap.set(inst, templateName)\n        }\n        GetInstanceTemplateName(inst) {\n            if (!this._instanceToTemplateNameMap)\n                return "";\n            const ret = this._instanceToTemplateNameMap.get(inst);\n            if (ret)\n                return ret;\n            return ""\n        }\n        _OnInstanceDestroy(inst) {\n            if (!this._instanceToTemplateNameMap)\n                return;\n            if (!this._instanceToTemplateNameMap.has(inst))\n                return;\n            this._instanceToTemplateNameMap.delete(inst)\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/stacks\/solStack.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.SolStack = class SolStack extends C3.DefendedBase {\n        constructor(objectClass) {\n            super();\n            this._objectClass = objectClass;\n            this._stack = [];\n            this._stack.push(C3.New(C3.Sol, this));\n            this._index = 0;\n            this._current = this._stack[0]\n        }\n        Release() {\n            for (const s of this._stack)\n                s.Release();\n            C3.clearArray(this._stack);\n            this._current = null;\n            this._objectClass = null\n        }\n        GetObjectClass() {\n            return this._objectClass\n        }\n        GetCurrentSol() {\n            return this._current\n        }\n        Clear() {\n            this.GetCurrentSol().Clear()\n        }\n        PushClean() {\n            const stack = this._stack;\n            const index = ++this._index;\n            if (index === stack.length) {\n                const sol = C3.New(C3.Sol, this);\n                stack.push(sol);\n                this._current = sol\n            } else {\n                const sol = stack[index];\n                sol.Reset();\n                this._current = sol\n            }\n        }\n        PushCopy() {\n            const stack = this._stack;\n            const index = ++this._index;\n            if (index === stack.length)\n                stack.push(C3.New(C3.Sol, this));\n            const sol = stack[index];\n            sol.Copy(stack[index - 1]);\n            this._current = sol\n        }\n        Pop() {\n            this._current = this._stack[--this._index]\n        }\n        RemoveInstances(s) {\n            const stack = this._stack;\n            for (let i = 0, len = stack.length; i < len; ++i)\n                stack[i].RemoveInstances(s)\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/stacks\/sol.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Sol = class Sol extends C3.DefendedBase {\n        constructor(stack) {\n            super();\n            this._stack = stack;\n            this._objectClass = this._stack.GetObjectClass();\n            this._eventStack = this._objectClass.GetRuntime().GetEventStack();\n            this._selectAll = true;\n            this._instances = [];\n            this._elseInstances = []\n        }\n        Release() {\n            this.ClearArrays();\n            this._stack = null;\n            this._objectClass = null;\n            this._eventStack = null\n        }\n        ClearArrays() {\n            C3.clearArray(this._instances);\n            C3.clearArray(this._elseInstances)\n        }\n        GetObjectClass() {\n            return this._objectClass\n        }\n        IsSelectAll() {\n            return this._selectAll\n        }\n        HasAnyInstances() {\n            if (this._selectAll)\n                return !!this._objectClass.GetInstanceCount();\n            else\n                return !!this._instances.length\n        }\n        GetInstances() {\n            if (this._selectAll)\n                return this._objectClass.GetInstances();\n            else\n                return this._instances\n        }\n        HasAnyElseInstances() {\n            return !!this._elseInstances.length\n        }\n        GetElseInstances() {\n            return this._elseInstances\n        }\n        GetExpressionInstances() {\n            const ret = this.GetInstances();\n            if (ret.length)\n                return ret;\n            else\n                return this._elseInstances\n        }\n        Reset() {\n            this._selectAll = true;\n            C3.clearArray(this._elseInstances)\n        }\n        Clear() {\n            this._selectAll = true\n        }\n        Copy(sol) {\n            if (sol.IsSelectAll())\n                this.Reset();\n            else {\n                this._selectAll = false;\n                C3.shallowAssignArray(this._instances, sol._instances);\n                C3.clearArray(this._elseInstances)\n            }\n        }\n        _PushInstance(inst) {\n            this._instances.push(inst)\n        }\n        _PushElseInstance(inst) {\n            this._elseInstances.push(inst)\n        }\n        _SetSelectAll(s) {\n            this._selectAll = !!s\n        }\n        _GetOwnInstances() {\n            return this._instances\n        }\n        _GetOwnElseInstances() {\n            return this._elseInstances\n        }\n        SetSinglePicked(inst) {\n            this._selectAll = false;\n            C3.clearArray(this._instances);\n            this._instances.push(inst)\n        }\n        SetArrayPicked(arr) {\n            this._selectAll = false;\n            C3.shallowAssignArray(this._instances, arr)\n        }\n        SetSetPicked(set) {\n            this._selectAll = false;\n            C3.clearArray(this._instances);\n            for (const item of set)\n                this._instances.push(item)\n        }\n        AddElseInstances(setOfPicked, arrayOfAllPicked) {\n            for (const inst of arrayOfAllPicked)\n                if (!setOfPicked.has(inst))\n                    this._elseInstances.push(inst)\n        }\n        TransferElseInstancesToOwn(setOfPicked) {\n            for (const inst of setOfPicked)\n                this._instances.push(inst);\n            C3.arrayRemoveAllInSet(this._elseInstances, setOfPicked)\n        }\n        PickOne(inst) {\n            if (!inst)\n                return;\n            if (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock()) {\n                if (this.IsSelectAll()) {\n                    C3.clearArray(this._instances);\n                    C3.shallowAssignArray(this._elseInstances, inst.GetObjectClass().GetInstances());\n                    this._selectAll = false\n                }\n                const i = this._elseInstances.indexOf(inst);\n                if (i !== -1) {\n                    this._instances.push(this._elseInstances[i]);\n                    this._elseInstances.splice(i, 1)\n                }\n            } else\n                this.SetSinglePicked(inst)\n        }\n        RemoveInstances(s) {\n            C3.arrayRemoveAllInSet(this._instances, s);\n            C3.arrayRemoveAllInSet(this._elseInstances, s)\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/stacks\/eventStack.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.EventStack = class EventStack extends C3.DefendedBase {\n        constructor(eventSheetManager) {\n            super();\n            this._eventSheetManager = eventSheetManager;\n            this._runtime = this._eventSheetManager.GetRuntime();\n            this._stack = [];\n            this._stack.push(C3.New(C3.EventStackFrame, this, null));\n            this._index = 0;\n            this._expFuncStack = []\n        }\n        Release() {\n            for (const e of this._stack)\n                e.Release();\n            C3.clearArray(this._stack);\n            C3.clearArray(this._expFuncStack);\n            this._eventSheetManager = null;\n            this._runtime = null\n        }\n        GetEventSheetManager() {\n            return this._eventSheetManager\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetCurrentStackFrame() {\n            return this._stack[this._index]\n        }\n        Push(currentEvent) {\n            const stack = this._stack;\n            const index = ++this._index;\n            if (index === stack.length) {\n                const ret = C3.New(C3.EventStackFrame, this, currentEvent);\n                stack.push(ret);\n                return ret\n            } else {\n                const ret = stack[index];\n                ret.Reset(currentEvent);\n                return ret\n            }\n        }\n        Pop() {\n            --this._index\n        }\n        PushExpFunc(frame) {\n            this._expFuncStack.push(frame)\n        }\n        PopExpFunc() {\n            this._expFuncStack.pop()\n        }\n        GetCurrentExpFuncStackFrame() {\n            const expFuncStack = this._expFuncStack;\n            if (expFuncStack.length === 0)\n                return null;\n            else\n                return expFuncStack.at(-1)\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/stacks\/eventStackFrame.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.EventStackFrame = class EventStackFrame extends C3.DefendedBase {\n        constructor(stack, currentEvent) {\n            super();\n            this._stack = stack;\n            this._runtime = this._stack.GetRuntime();\n            this._currentEvent = currentEvent;\n            this._cndIndex = 0;\n            this._actIndex = 0;\n            this._lastEventTrue = false;\n            this._elseBranchRan = false;\n            this._expressionObjectClass = null;\n            this._functionReturnType = 0;\n            this._functionReturnValue = 0\n        }\n        Release() {\n            this.Reset(null);\n            this._stack = null;\n            this._runtime = null\n        }\n        Reset(currentEvent) {\n            this._currentEvent = currentEvent;\n            this._cndIndex = 0;\n            this._actIndex = 0;\n            this._lastEventTrue = false;\n            this._elseBranchRan = false\n        }\n        _Restore(currentEvent, actIndex) {\n            this._currentEvent = currentEvent;\n            this._cndIndex = 0;\n            this._actIndex = actIndex\n        }\n        ResetQuick() {\n            this._cndIndex = 0;\n            this._actIndex = 0\n        }\n        GetCurrentEvent() {\n            return this._currentEvent\n        }\n        SetCurrentEvent(currentEvent) {\n            this._currentEvent = currentEvent\n        }\n        GetConditionIndex() {\n            return this._cndIndex\n        }\n        SetConditionIndex(i) {\n            this._cndIndex = i\n        }\n        GetActionIndex() {\n            return this._actIndex\n        }\n        SetActionIndex(i) {\n            this._actIndex = i\n        }\n        SetLastEventTrue(t) {\n            this._lastEventTrue = !!t\n        }\n        GetLastEventTrue() {\n            return this._lastEventTrue\n        }\n        SetElseBranchRan(r) {\n            this._elseBranchRan = !!r\n        }\n        GetElseBranchRan() {\n            return this._elseBranchRan\n        }\n        SetExpressionObjectClass(objectClass) {\n            this._expressionObjectClass = objectClass\n        }\n        GetExpressionObjectClass() {\n            return this._expressionObjectClass\n        }\n        InitCallFunctionExpression(returnType, defaultReturnValue) {\n            this._functionReturnType = returnType;\n            this._functionReturnValue = defaultReturnValue\n        }\n        GetFunctionReturnType() {\n            return this._functionReturnType\n        }\n        SetFunctionReturnValue(v) {\n            this._functionReturnValue = v\n        }\n        GetFunctionReturnValue() {\n            return this._functionReturnValue\n        }\n        IsSolModifierAfterCnds() {\n            const currentEvent = this._currentEvent;\n            if (currentEvent.IsSolWriterAfterCnds())\n                return true;\n            if (this._cndIndex < currentEvent.GetConditionCount() - 1)\n                return !!currentEvent.GetSolModifiers().length;\n            return false\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/stacks\/localVarStack.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.LocalVarStack = class LocalVarStack extends C3.DefendedBase {\n        constructor(eventSheetManager) {\n            super();\n            this._eventSheetManager = eventSheetManager;\n            this._runtime = this._eventSheetManager.GetRuntime();\n            this._stack = [];\n            this._index = -1;\n            this._current = null;\n            this._initialValues = []\n        }\n        Release() {\n            C3.clearArray(this._stack);\n            this._eventSheetManager = null;\n            this._runtime = null\n        }\n        _SetInitialValues(initialValues) {\n            this._initialValues = initialValues;\n            const arr = this._initialValues.slice(0);\n            this._stack.push(arr);\n            this._index = 0;\n            this._current = arr\n        }\n        GetEventSheetManager() {\n            return this._eventSheetManager\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetCurrent() {\n            return this._current\n        }\n        Push() {\n            const index = ++this._index;\n            const stack = this._stack;\n            if (index === stack.length)\n                stack.push(this._initialValues.slice(0));\n            else\n                C3.shallowAssignArray(stack[index], this._initialValues);\n            this._current = stack[index]\n        }\n        Pop() {\n            this._current = this._stack[--this._index]\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/stacks\/loopStack.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.LoopStack = class LoopStack extends C3.DefendedBase {\n        constructor(eventSheetManager) {\n            super();\n            this._eventSheetManager = eventSheetManager;\n            this._runtime = this._eventSheetManager.GetRuntime();\n            this._stack = [];\n            this._index = -1\n        }\n        Release() {\n            C3.clearArray(this._stack);\n            this._eventSheetManager = null;\n            this._runtime = null\n        }\n        GetEventSheetManager() {\n            return this._eventSheetManager\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        IsInLoop() {\n            return this._index >= 0\n        }\n        GetCurrent() {\n            return this._stack[this._index]\n        }\n        Push() {\n            ++this._index;\n            if (this._index === this._stack.length) {\n                const ret = C3.New(C3.Loop, this);\n                this._stack.push(ret);\n                return ret\n            } else {\n                const ret = this._stack[this._index];\n                ret.Reset();\n                return ret\n            }\n        }\n        Pop() {\n            --this._index\n        }\n        FindByName(name) {\n            const stack = this._stack;\n            for (let i = this._index; i >= 0; --i) {\n                const loop = stack[i];\n                if (loop.GetName() === name)\n                    return loop\n            }\n            return null\n        }\n        _GetStack() {\n            return this._stack.slice(0, this._index + 1)\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/stacks\/loop.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Loop = class Loop extends C3.DefendedBase {\n        constructor(loopStack) {\n            super();\n            this._loopStack = loopStack;\n            this._name = "";\n            this._index = 0;\n            this._isStopped = false;\n            this._end = NaN\n        }\n        Reset() {\n            this._name = "";\n            this._index = 0;\n            this._isStopped = false;\n            this._end = NaN\n        }\n        SetName(name) {\n            this._name = name\n        }\n        GetName() {\n            return this._name\n        }\n        SetIndex(i) {\n            this._index = i\n        }\n        GetIndex() {\n            return this._index\n        }\n        Stop() {\n            this._isStopped = true\n        }\n        IsStopped() {\n            return this._isStopped\n        }\n        SetEnd(e) {\n            this._end = e\n        }\n        GetEnd() {\n            return this._end\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/stacks\/arrayStack.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.ArrayStack = class ArrayStack extends C3.DefendedBase {\n        constructor() {\n            super();\n            this._stack = [];\n            this._index = -1\n        }\n        Release() {\n            C3.clearArray(this._stack)\n        }\n        GetCurrent() {\n            return this._stack[this._index]\n        }\n        Push() {\n            ++this._index;\n            if (this._index === this._stack.length) {\n                const ret = [];\n                this._stack.push(ret);\n                return ret\n            } else\n                return this._stack[this._index]\n        }\n        Pop() {\n            --this._index\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/eventSheetManager.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const assert = self.assert;\n    function SortSolArray(a, b) {\n        return a.GetIndex() - b.GetIndex()\n    }\n    function IsSolArrayIdentical(a, b) {\n        for (let i = 0, len = a.length; i < len; ++i)\n            if (a[i] !== b[i])\n                return false;\n        return true\n    }\n    C3.EventSheetManager = class EventSheetManager extends C3.DefendedBase {\n        constructor(runtime) {\n            super();\n            this._runtime = runtime;\n            this._allSheets = [];\n            this._sheetsByName = new Map;\n            this._allGroups = [];\n            this._groupsByName = new Map;\n            this._blocksBySid = new Map;\n            this._cndsBySid = new Map;\n            this._actsBySid = new Map;\n            this._allUniqueSolModifiers = new Map;\n            this._eventVarsBySid = new Map;\n            this._nextLocalVarIndex = 0;\n            this._allGlobalVars = [];\n            this._allLocalVars = [];\n            this._localVarInitialValues = [];\n            this._functionBlocksByName = new Map;\n            this._eventStack = C3.New(C3.EventStack, this);\n            this._localVarStack = C3.New(C3.LocalVarStack, this);\n            this._loopStack = C3.New(C3.LoopStack, this);\n            this._triggersToPostInit = [];\n            this._queuedTriggers = [];\n            this._queuedDebugTriggers = [];\n            this._runningEventsDepth = 0;\n            this._executingTriggerDepth = 0;\n            this._blockFlushingDepth = 0;\n            this._scheduledWaits = [];\n            this._asyncActionPromises = [];\n            self["c3_callFunction"] = (name, params) => this._InvokeFunctionFromJS(name, params)\n        }\n        Release() {\n            this.ClearAllScheduledWaits();\n            this._eventStack.Release();\n            this._eventStack = null;\n            this._localVarStack.Release();\n            this._localVarStack = null;\n            C3.clearArray(this._queuedTriggers);\n            C3.clearArray(this._queuedDebugTriggers);\n            this._runtime = null;\n            C3.clearArray(this._allSheets);\n            this._sheetsByName.clear()\n        }\n        Create(eventSheetData) {\n            const eventSheet = C3.New(C3.EventSheet, this, eventSheetData);\n            this._allSheets.push(eventSheet);\n            this._sheetsByName.set(eventSheet.GetName().toLowerCase(), eventSheet)\n        }\n        _AddTriggerToPostInit(trig) {\n            this._triggersToPostInit.push(trig)\n        }\n        _PostInit() {\n            for (const functionBlock of this._functionBlocksByName.values())\n                functionBlock._PostInit(false);\n            for (const sheet of this._allSheets)\n                sheet._PostInit();\n            for (const sheet of this._allSheets)\n                sheet._UpdateDeepIncludes();\n            for (const trig of this._triggersToPostInit)\n                trig._PostInit(false);\n            C3.clearArray(this._triggersToPostInit);\n            this._localVarStack._SetInitialValues(this._localVarInitialValues)\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetEventSheetByName(name) {\n            return this._sheetsByName.get(name.toLowerCase()) || null\n        }\n        _RegisterGroup(group) {\n            this._allGroups.push(group);\n            this._groupsByName.set(group.GetGroupName(), group)\n        }\n        _RegisterEventBlock(eventBlock) {\n            this._blocksBySid.set(eventBlock.GetSID(), eventBlock)\n        }\n        _RegisterCondition(condition) {\n            this._cndsBySid.set(condition.GetSID(), condition)\n        }\n        _RegisterAction(action) {\n            this._actsBySid.set(action.GetSID(), action)\n        }\n        _RegisterFunctionBlock(functionBlock) {\n            this._functionBlocksByName.set(functionBlock.GetFunctionName().toLowerCase(), functionBlock)\n        }\n        _RegisterEventVariable(ev) {\n            this._eventVarsBySid.set(ev.GetSID(), ev);\n            if (ev.IsGlobal())\n                this._allGlobalVars.push(ev);\n            else\n                this._allLocalVars.push(ev)\n        }\n        _DeduplicateSolModifierList(arr) {\n            if (arr.length >= 2)\n                arr.sort(SortSolArray);\n            let candidateList = this._allUniqueSolModifiers.get(arr.length);\n            if (!candidateList) {\n                candidateList = [];\n                this._allUniqueSolModifiers.set(arr.length, candidateList)\n            }\n            for (let i = 0, len = candidateList.length; i < len; ++i) {\n                const candidate = candidateList[i];\n                if (IsSolArrayIdentical(arr, candidate))\n                    return candidate\n            }\n            candidateList.push(arr);\n            return arr\n        }\n        _GetNextLocalVarIndex(eventVar) {\n            this._localVarInitialValues.push(eventVar.GetInitialValue());\n            return this._nextLocalVarIndex++\n        }\n        GetEventStack() {\n            return this._eventStack\n        }\n        GetCurrentEventStackFrame() {\n            return this.GetEventStack().GetCurrentStackFrame()\n        }\n        GetCurrentEvent() {\n            return this.GetCurrentEventStackFrame().GetCurrentEvent()\n        }\n        GetCurrentCondition() {\n            const frame = this.GetCurrentEventStackFrame();\n            const event = frame.GetCurrentEvent();\n            return event.GetConditionAt(frame.GetConditionIndex())\n        }\n        GetCurrentAction() {\n            const frame = this.GetCurrentEventStackFrame();\n            const event = frame.GetCurrentEvent();\n            return event.GetActionAt(frame.GetActionIndex())\n        }\n        GetLocalVarStack() {\n            return this._localVarStack\n        }\n        GetLoopStack() {\n            return this._loopStack\n        }\n        GetAllLocalVariablesInScope(fromRow) {\n            const ret = [];\n            fromRow = fromRow.GetScopeParent();\n            while (fromRow) {\n                C3.appendArray(ret, fromRow._GetAllLocalVariablesInScope());\n                fromRow = fromRow.GetScopeParent()\n            }\n            return ret\n        }\n        _GetLocalVariablesScriptInterface(fromRow) {\n            const localVarDescriptors = {};\n            for (const v of this.GetAllLocalVariablesInScope(fromRow))\n                localVarDescriptors[v.GetJsPropName()] = v._GetScriptInterfaceDescriptor();\n            return Object.create(Object.prototype, localVarDescriptors)\n        }\n        GetEventVariableBySID(sid) {\n            return this._eventVarsBySid.get(sid) || null\n        }\n        GetEventBlockBySID(sid) {\n            return this._blocksBySid.get(sid) || null\n        }\n        GetConditionBySID(sid) {\n            return this._cndsBySid.get(sid) || null\n        }\n        GetActionBySID(sid) {\n            return this._actsBySid.get(sid) || null\n        }\n        GetFunctionBlockByName(name) {\n            return this._functionBlocksByName.get(name.toLowerCase()) || null\n        }\n        GetAllGlobalVariables() {\n            return this._allGlobalVars\n        }\n        GetAllLocalVariables() {\n            return this._allLocalVars\n        }\n        ResetAllGlobalsToInitialValue() {\n            for (const ev of this._allGlobalVars)\n                ev.ResetToInitialValue()\n        }\n        GetEventGroupByName(name) {\n            return this._groupsByName.get(name.toLowerCase()) || null\n        }\n        GetEventGroupBySID(sid) {\n            const group = this._blocksBySid.get(sid);\n            if (group && group.IsGroup())\n                return group;\n            else\n                return null\n        }\n        GetAllGroups() {\n            return this._allGroups\n        }\n        ResetAllGroupsInitialActivation() {\n            for (const group of this._allGroups)\n                group.ResetInitialActivation()\n        }\n        _ResetAllHasRunFlags() {\n            for (const sheet of this._allSheets)\n                sheet._ResetHasRunFlag()\n        }\n        RunEvents(layoutManager) {\n            this._ResetAllHasRunFlags();\n            this._runningEventsDepth++;\n            for (const layout of layoutManager.runningLayouts()) {\n                const eventSheet = layout.GetEventSheet();\n                if (!eventSheet)\n                    continue;\n                this._runtime.PushCurrentLayout(layout);\n                eventSheet.Run();\n                this._runtime.PopCurrentLayout()\n            }\n            this._runningEventsDepth--\n        }\n        async DebugRunEvents(layoutManager) {\n            this._ResetAllHasRunFlags();\n            this._runningEventsDepth++;\n            for (const breakEventObject of this._DebugRunEventsGen(layoutManager))\n                await this._runtime.DebugBreak(breakEventObject);\n            this._runningEventsDepth--\n        }\n        *_DebugRunEventsGen(layoutManager) {\n            for (const layout of layoutManager.runningLayouts()) {\n                const eventSheet = layout.GetEventSheet();\n                if (!eventSheet)\n                    continue;\n                this._runtime.PushCurrentLayout(layout);\n                yield*eventSheet.DebugRun();\n                this._runtime.PopCurrentLayout()\n            }\n        }\n        _Trigger(layoutManager, method, inst, behaviorType) {\n            let ret = false;\n            if (!layoutManager.GetMainRunningLayout())\n                return this.QueueTrigger(method, inst, behaviorType);\n            this._executingTriggerDepth++;\n            for (const layout of layoutManager.runningLayouts()) {\n                const eventSheet = layout.GetEventSheet();\n                if (!eventSheet)\n                    continue;\n                this._runtime.PushCurrentLayout(layout);\n                for (const includeSheet of eventSheet.deepIncludes()) {\n                    const result = includeSheet._Trigger(method, inst, behaviorType);\n                    ret = ret || result\n                }\n                const result2 = eventSheet._Trigger(method, inst, behaviorType);\n                ret = ret || result2;\n                this._runtime.PopCurrentLayout()\n            }\n            this._executingTriggerDepth--;\n            return ret\n        }\n        *_DebugTrigger(layoutManager, method, inst, behaviorType) {\n            let ret = false;\n            if (!layoutManager.GetMainRunningLayout())\n                return this.QueueTrigger(method, inst, behaviorType);\n            this._executingTriggerDepth++;\n            for (const layout of layoutManager.runningLayouts()) {\n                const eventSheet = layout.GetEventSheet();\n                if (!eventSheet)\n                    continue;\n                this._runtime.PushCurrentLayout(layout);\n                for (const includeSheet of eventSheet.deepIncludes()) {\n                    const result = yield*includeSheet._DebugTrigger(method, inst, behaviorType);\n                    ret = ret || result\n                }\n                const result2 = yield*eventSheet._DebugTrigger(method, inst, behaviorType);\n                ret = ret || result2;\n                this._runtime.PopCurrentLayout()\n            }\n            this._executingTriggerDepth--;\n            return ret\n        }\n        QueueTrigger(method, inst, behaviorType) {\n            this._queuedTriggers.push([method, inst, behaviorType]);\n            return false\n        }\n        QueueDebugTrigger(method, inst, behaviorType) {\n            let resolve = null;\n            const ret = new Promise(r => resolve = r);\n            this._queuedDebugTriggers.push([method, inst, behaviorType, resolve]);\n            return ret\n        }\n        *_RunQueuedDebugTriggersGen() {\n            if (this._runtime.HitBreakpoint())\n                throw new Error("should not be in breakpoint");\n            const layoutManager = this._runtime.GetLayoutManager();\n            while (this._queuedDebugTriggers.length) {\n                const [method,inst,behaviorType,resolve] = this._queuedDebugTriggers.shift();\n                const ret = yield*this._DebugTrigger(layoutManager, method, inst, behaviorType);\n                resolve(ret)\n            }\n        }\n        async RunQueuedDebugTriggersAsync() {\n            for (const breakEventObject of this._RunQueuedDebugTriggersGen())\n                await this._runtime.DebugBreak(breakEventObject)\n        }\n        _FastTrigger(layoutManager, method, inst, value) {\n            let ret = false;\n            const layout = layoutManager.GetMainRunningLayout();\n            const eventSheet = layout.GetEventSheet();\n            if (!eventSheet)\n                return;\n            this._executingTriggerDepth++;\n            this._runtime.PushCurrentLayout(layout);\n            const deepIncludes = eventSheet.deepIncludes();\n            for (let i = 0, len = deepIncludes.length; i < len; ++i) {\n                const result = deepIncludes[i]._FastTrigger(method, inst, value);\n                ret = ret || result\n            }\n            const result2 = eventSheet._FastTrigger(method, inst, value);\n            ret = ret || result2;\n            this._runtime.PopCurrentLayout();\n            this._executingTriggerDepth--;\n            return ret\n        }\n        *_DebugFastTrigger(layoutManager, method, inst, value) {\n            let ret = false;\n            const layout = layoutManager.GetMainRunningLayout();\n            const eventSheet = layout.GetEventSheet();\n            if (!eventSheet)\n                return;\n            this._executingTriggerDepth++;\n            this._runtime.PushCurrentLayout(layout);\n            const deepIncludes = eventSheet.deepIncludes();\n            for (let i = 0, len = deepIncludes.length; i < len; ++i) {\n                const result = yield*deepIncludes[i]._DebugFastTrigger(method, inst, value);\n                ret = ret || result\n            }\n            const result2 = yield*eventSheet._DebugFastTrigger(method, inst, value);\n            ret = ret || result2;\n            this._runtime.PopCurrentLayout();\n            this._executingTriggerDepth--;\n            return ret\n        }\n        GetTriggerDepth() {\n            return this._executingTriggerDepth\n        }\n        IsInTrigger() {\n            return this.GetTriggerDepth() > 0\n        }\n        _IncTriggerDepth() {\n            return ++this._executingTriggerDepth\n        }\n        _DecTriggerDepth() {\n            --this._executingTriggerDepth\n        }\n        IsRunningEvents() {\n            return this._runningEventsDepth > 0\n        }\n        IsInEventEngine() {\n            return this.IsRunningEvents() || this.IsInTrigger()\n        }\n        _RunQueuedTriggers(layoutManager) {\n            for (const [method,inst,behaviorType] of this._queuedTriggers)\n                this._Trigger(layoutManager, method, inst, behaviorType);\n            C3.clearArray(this._queuedTriggers)\n        }\n        BlockFlushingInstances(e) {\n            if (e)\n                this._blockFlushingDepth++;\n            else\n                this._blockFlushingDepth--\n        }\n        IsFlushingBlocked() {\n            return this._blockFlushingDepth > 0\n        }\n        ClearSol(solModifiers) {\n            for (let i = 0, len = solModifiers.length; i < len; ++i)\n                solModifiers[i].GetSolStack().Clear()\n        }\n        PushCleanSol(solModifiers) {\n            for (let i = 0, len = solModifiers.length; i < len; ++i)\n                solModifiers[i].GetSolStack().PushClean()\n        }\n        PushCopySol(solModifiers) {\n            for (let i = 0, len = solModifiers.length; i < len; ++i)\n                solModifiers[i].GetSolStack().PushCopy()\n        }\n        PopSol(solModifiers) {\n            for (let i = 0, len = solModifiers.length; i < len; ++i)\n                solModifiers[i].GetSolStack().Pop()\n        }\n        AddScheduledWait() {\n            const w = C3.New(C3.ScheduledWait, this);\n            this._scheduledWaits.push(w);\n            return w\n        }\n        scheduledWaits() {\n            return this._scheduledWaits\n        }\n        RunScheduledWaits() {\n            if (!this._scheduledWaits.length)\n                return;\n            const frame = this.GetCurrentEventStackFrame();\n            let didAnyRun = false;\n            this._runningEventsDepth++;\n            for (let i = 0, len = this._scheduledWaits.length; i < len; ++i) {\n                const w = this._scheduledWaits[i];\n                if (w._ShouldRun())\n                    w._Run(frame);\n                if (w.ShouldRelease())\n                    didAnyRun = true\n            }\n            if (didAnyRun) {\n                this._FilterScheduledWaitsToRelease();\n                frame.Reset(null)\n            }\n            this._runningEventsDepth--\n        }\n        async DebugRunScheduledWaits() {\n            if (!this._scheduledWaits.length)\n                return;\n            const frame = this.GetCurrentEventStackFrame();\n            let didAnyRun = false;\n            this._runningEventsDepth++;\n            for (let i = 0, len = this._scheduledWaits.length; i < len; ++i) {\n                const w = this._scheduledWaits[i];\n                if (w._ShouldRun())\n                    await w._DebugRun(frame);\n                if (w.ShouldRelease())\n                    didAnyRun = true\n            }\n            if (didAnyRun) {\n                this._FilterScheduledWaitsToRelease();\n                frame.Reset(null)\n            }\n            this._runningEventsDepth--\n        }\n        _FilterScheduledWaitsToRelease() {\n            const toRelease = C3.arrayFilterOut(this._scheduledWaits, w => w.ShouldRelease());\n            for (const w of toRelease)\n                w.Release()\n        }\n        ClearAllScheduledWaits() {\n            for (const w of this._scheduledWaits)\n                w.Release();\n            C3.clearArray(this._scheduledWaits)\n        }\n        RemoveInstancesFromScheduledWaits(s) {\n            for (const w of this._scheduledWaits)\n                w.RemoveInstances(s)\n        }\n        AddAsyncActionPromise(p) {\n            this._asyncActionPromises.push(p)\n        }\n        ClearAsyncActionPromises() {\n            C3.clearArray(this._asyncActionPromises)\n        }\n        GetPromiseForAllAsyncActions() {\n            const ret = Promise.all(this._asyncActionPromises);\n            this._asyncActionPromises = [];\n            return ret\n        }\n        _SaveToJson() {\n            return {\n                "groups": this._SaveGroupsToJson(),\n                "cnds": this._SaveCndsToJson(),\n                "acts": this._SaveActsToJson(),\n                "vars": this._SaveVarsToJson(),\n                "waits": this._SaveScheduledWaitsToJson()\n            }\n        }\n        _LoadFromJson(o) {\n            this._LoadGroupsFromJson(o["groups"]);\n            this._LoadCndsFromJson(o["cnds"]);\n            this._LoadActsFromJson(o["acts"]);\n            this._LoadVarsFromJson(o["vars"]);\n            this._LoadScheduledWaitsFromJson(o["waits"])\n        }\n        _SaveGroupsToJson() {\n            const o = {};\n            for (const group of this.GetAllGroups())\n                o[group.GetSID().toString()] = group.IsGroupActive();\n            return o\n        }\n        _LoadGroupsFromJson(o) {\n            for (const [sidStr,data] of Object.entries(o)) {\n                const sid = parseInt(sidStr, 10);\n                const group = this.GetEventGroupBySID(sid);\n                if (group)\n                    group.SetGroupActive(data)\n            }\n        }\n        _SaveCndsToJson() {\n            const o = {};\n            for (const [sid,cnd] of this._cndsBySid) {\n                const data = cnd._SaveToJson();\n                if (data)\n                    o[sid.toString()] = data\n            }\n            return o\n        }\n        _LoadCndsFromJson(o) {\n            const map = new Map;\n            for (const [sidStr,data] of Object.entries(o))\n                map.set(parseInt(sidStr, 10), data);\n            for (const [sid,cnd] of this._cndsBySid)\n                cnd._LoadFromJson(map.get(sid) || null)\n        }\n        _SaveActsToJson() {\n            const o = {};\n            for (const [sid,act] of this._actsBySid) {\n                const data = act._SaveToJson();\n                if (data)\n                    o[sid.toString()] = data\n            }\n            return o\n        }\n        _LoadActsFromJson(o) {\n            const map = new Map;\n            for (const [sidStr,data] of Object.entries(o))\n                map.set(parseInt(sidStr, 10), data);\n            for (const [sid,act] of this._actsBySid)\n                act._LoadFromJson(map.get(sid) || null)\n        }\n        _SaveVarsToJson() {\n            const o = {};\n            for (const [sid,eventVar] of this._eventVarsBySid)\n                if (!eventVar.IsConstant() && (eventVar.IsGlobal() || eventVar.IsStatic()))\n                    o[sid.toString()] = eventVar.GetValue();\n            return o\n        }\n        _LoadVarsFromJson(o) {\n            for (const [sidStr,data] of Object.entries(o)) {\n                const sid = parseInt(sidStr, 10);\n                const eventVar = this.GetEventVariableBySID(sid);\n                if (eventVar)\n                    eventVar.SetValue(data)\n            }\n        }\n        _SaveScheduledWaitsToJson() {\n            return this._scheduledWaits.filter(w => !w.IsPromise()).map(w => w._SaveToJson())\n        }\n        _LoadScheduledWaitsFromJson(arr) {\n            this.ClearAllScheduledWaits();\n            for (const data of arr) {\n                const sw = C3.ScheduledWait._CreateFromJson(this, data);\n                if (sw)\n                    this._scheduledWaits.push(sw)\n            }\n        }\n        _GetPerfRecords() {\n            return [...this._runtime.GetLayoutManager().runningLayouts()].map(l => l.GetEventSheet()).filter(eventSheet => eventSheet).map(e => e._GetPerfRecord())\n        }\n        FindFirstFunctionBlockParent(parent) {\n            while (parent) {\n                const scopeParent = parent.GetScopeParent();\n                if (scopeParent instanceof C3.FunctionBlock)\n                    return scopeParent;\n                parent = scopeParent\n            }\n            return null\n        }\n        _InvokeFunctionFromJS(name, params) {\n            if (!Array.isArray(params))\n                params = [];\n            const functionBlock = this.GetFunctionBlockByName(name.toLowerCase());\n            if (!functionBlock)\n                return null;\n            if (!functionBlock.IsEnabled())\n                return functionBlock.GetDefaultReturnValue();\n            const functionParameters = functionBlock.GetFunctionParameters();\n            if (params.length < functionParameters.length) {\n                params = params.slice(0);\n                do\n                    params.push(functionParameters[params.length].GetInitialValue());\n                while (params.length < functionParameters.length)\n            }\n            const callEventBlock = functionBlock.GetEventBlock();\n            return callEventBlock.RunAsExpressionFunctionCall(callEventBlock.GetSolModifiersIncludingParents(), functionBlock.GetReturnType(), functionBlock.GetDefaultReturnValue(), ...params)\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/eventSheet.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.EventSheet = class EventSheet extends C3.DefendedBase {\n        constructor(eventSheetManager, data) {\n            super();\n            this._eventSheetManager = eventSheetManager;\n            this._runtime = eventSheetManager.GetRuntime();\n            this._name = data[0];\n            this._events = [];\n            this._triggers = new Map;\n            this._fastTriggers = new Map;\n            this._eventsByDisplayNumber = new Map;\n            this._hasRun = false;\n            this._shallowIncludes = [];\n            this._deepIncludes = [];\n            this._alreadyIncludedSheets = new Set;\n            for (const eventData of data[1])\n                this._CreateEvent(eventData, null, this._events);\n            this._perfRecord = this._runtime.IsDebug() ? {\n                type: "sheet",\n                name: this._name,\n                totalTimeCounter: 0,\n                children: []\n            } : null\n        }\n        Release() {\n            this._eventSheetManager = null;\n            this._runtime = null\n        }\n        _CreateEvent(eventData, parent, nontriggers) {\n            switch (eventData[0]) {\n            case 0:\n            case 3:\n                this._CreateEventBlock(eventData, parent, nontriggers);\n                break;\n            case 1:\n                this._CreateEventVariable(eventData, parent, nontriggers);\n                break;\n            case 2:\n                this._CreateInclude(eventData, parent, nontriggers);\n                break;\n            case 4:\n                this._CreateFunctionBlock(eventData, parent);\n                break;\n            case 5:\n                this._CreateScriptBlock(eventData, parent, nontriggers);\n                break;\n            default:\n                throw new Error("invalid event type");\n            }\n        }\n        _CreateEventBlock(data, parent, nontriggers) {\n            const eventBlock = C3.EventBlock.Create(this, parent, data);\n            if (eventBlock.IsOrBlock()) {\n                nontriggers.push(eventBlock);\n                const conditions = eventBlock.GetConditions();\n                for (let i = 0, len = conditions.length; i < len; ++i)\n                    if (conditions[i].IsTrigger())\n                        this._InitTrigger(eventBlock, i)\n            } else if (eventBlock.IsTrigger())\n                this._InitTrigger(eventBlock, 0);\n            else\n                nontriggers.push(eventBlock)\n        }\n        _CreateFunctionBlock(data, parent) {\n            const functionBlock = C3.FunctionBlock.Create(this, parent, data);\n            this._eventSheetManager._RegisterFunctionBlock(functionBlock)\n        }\n        _CreateEventVariable(data, parent, nontriggers) {\n            const v = C3.EventVariable.Create(this, parent, data);\n            nontriggers.push(v)\n        }\n        _CreateInclude(data, parent, nontriggers) {\n            const include = C3.EventInclude.Create(this, parent, data);\n            nontriggers.push(include)\n        }\n        _CreateScriptBlock(data, parent, nontriggers) {\n            const scriptBlock = C3.EventScript.Create(this, parent, data);\n            nontriggers.push(scriptBlock)\n        }\n        _InitTrigger(eventBlock, i) {\n            if (!eventBlock.IsOrBlock())\n                this._eventSheetManager._AddTriggerToPostInit(eventBlock);\n            const cnd = eventBlock.GetConditionAt(i);\n            const func = cnd._GetFunc();\n            const objectClass = cnd.GetObjectClass();\n            if (cnd.IsFastTrigger()) {\n                let methodMap = this._fastTriggers.get(objectClass);\n                if (!methodMap) {\n                    methodMap = new Map;\n                    this._fastTriggers.set(objectClass, methodMap)\n                }\n                const value = cnd.GetFastTriggerValue().toLowerCase();\n                let valueMap = methodMap.get(func);\n                if (!valueMap) {\n                    valueMap = new Map;\n                    methodMap.set(func, valueMap)\n                }\n                let triggerArr = valueMap.get(value);\n                if (!triggerArr) {\n                    triggerArr = [];\n                    valueMap.set(value, triggerArr)\n                }\n                triggerArr.push([eventBlock, i])\n            } else {\n                let ocInfo = this._triggers.get(objectClass);\n                if (!ocInfo) {\n                    ocInfo = {\n                        methodMap: new Map,\n                        behaviors: new Map\n                    };\n                    this._triggers.set(objectClass, ocInfo)\n                }\n                const behaviorType = cnd.GetBehaviorType();\n                let methodMap;\n                if (behaviorType) {\n                    methodMap = ocInfo.behaviors.get(behaviorType);\n                    if (!methodMap) {\n                        methodMap = new Map;\n                        ocInfo.behaviors.set(behaviorType, methodMap)\n                    }\n                } else\n                    methodMap = ocInfo.methodMap;\n                let triggerArr = methodMap.get(func);\n                if (!triggerArr) {\n                    triggerArr = [];\n                    methodMap.set(func, triggerArr)\n                }\n                triggerArr.push([eventBlock, i])\n            }\n        }\n        _PostInit() {\n            const events = this._events;\n            for (let i = 0, len = events.length; i < len; ++i) {\n                const hasElseBlock = i < len - 1 && events[i + 1]instanceof C3.EventBlock && events[i + 1].IsElseBlock();\n                events[i]._PostInit(hasElseBlock)\n            }\n        }\n        _AddShallowInclude(include) {\n            this._shallowIncludes.push(include)\n        }\n        _UpdateDeepIncludes() {\n            C3.clearArray(this._deepIncludes);\n            this._AddDeepIncludes(this);\n            this._alreadyIncludedSheets.clear()\n        }\n        _AddDeepIncludes(rootSheet) {\n            const deepIncludes = rootSheet._deepIncludes;\n            const alreadyIncludedSheets = rootSheet._alreadyIncludedSheets;\n            for (const include of this._shallowIncludes) {\n                const sheet = include.GetIncludeSheet();\n                if (!include.IsActive() || rootSheet === sheet || alreadyIncludedSheets.has(sheet))\n                    continue;\n                alreadyIncludedSheets.add(sheet);\n                sheet._AddDeepIncludes(rootSheet);\n                deepIncludes.push(sheet)\n            }\n        }\n        deepIncludes() {\n            return this._deepIncludes\n        }\n        GetEventSheetManager() {\n            return this._eventSheetManager\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetName() {\n            return this._name\n        }\n        _RegisterEventByDisplayNumber(eventBlock, displayNumber) {\n            this._eventsByDisplayNumber.set(displayNumber, eventBlock)\n        }\n        _GetEventByDisplayNumber(displayNumber) {\n            return this._eventsByDisplayNumber.get(displayNumber) || null\n        }\n        _ResetHasRunFlag() {\n            this._hasRun = false\n        }\n        Run() {\n            if (this._hasRun)\n                return;\n            const runtime = this._runtime;\n            const profile = runtime.IsCPUProfiling();\n            const startTime = profile ? performance.now() : 0;\n            this._hasRun = true;\n            const eventSheetManager = this.GetEventSheetManager();\n            const frame = eventSheetManager.GetCurrentEventStackFrame();\n            for (const e of this._events) {\n                e.Run(frame);\n                eventSheetManager.ClearSol(e.GetSolModifiers());\n                eventSheetManager.ClearAsyncActionPromises();\n                runtime.FlushPendingInstances()\n            }\n            frame.Reset(null);\n            if (profile)\n                this._perfRecord.totalTimeCounter += performance.now() - startTime\n        }\n        *DebugRun() {\n            if (this._hasRun)\n                return;\n            this._hasRun = true;\n            const runtime = this._runtime;\n            const eventSheetManager = this.GetEventSheetManager();\n            const frame = eventSheetManager.GetCurrentEventStackFrame();\n            for (const e of this._events) {\n                yield*e.DebugRun(frame);\n                eventSheetManager.ClearSol(e.GetSolModifiers());\n                eventSheetManager.ClearAsyncActionPromises();\n                runtime.FlushPendingInstances()\n            }\n            frame.Reset(null)\n        }\n        _Trigger(method, inst, behaviorType) {\n            if (inst) {\n                const objectClass = inst.GetObjectClass();\n                let ret = false;\n                let r = this._TriggerForClass(method, inst, objectClass, behaviorType);\n                ret = ret || r;\n                for (const family of objectClass.GetFamilies()) {\n                    r = this._TriggerForClass(method, inst, family, behaviorType);\n                    ret = ret || r\n                }\n            } else\n                return this._TriggerForClass(method, inst, null, null)\n        }\n        _TriggerForClass(method, inst, objectClass, behaviorType) {\n            const ocInfo = this._triggers.get(objectClass);\n            if (!ocInfo)\n                return false;\n            const methodMap = behaviorType ? ocInfo.behaviors.get(behaviorType) : ocInfo.methodMap;\n            if (!methodMap)\n                return false;\n            const triggerList = methodMap.get(method);\n            if (!triggerList)\n                return false;\n            let ret = false;\n            for (const [trigger,index] of triggerList) {\n                const r = this._ExecuteTrigger(inst, trigger, index);\n                ret = ret || r\n            }\n            return ret\n        }\n        *_DebugTrigger(method, inst, behaviorType) {\n            if (inst) {\n                const objectClass = inst.GetObjectClass();\n                let ret = false;\n                let r = yield*this._DebugTriggerForClass(method, inst, objectClass, behaviorType);\n                ret = ret || r;\n                for (const family of objectClass.GetFamilies()) {\n                    r = yield*this._DebugTriggerForClass(method, inst, family, behaviorType);\n                    ret = ret || r\n                }\n            } else\n                return yield*this._DebugTriggerForClass(method, inst, null, null)\n        }\n        *_DebugTriggerForClass(method, inst, objectClass, behaviorType) {\n            const ocInfo = this._triggers.get(objectClass);\n            if (!ocInfo)\n                return false;\n            const methodMap = behaviorType ? ocInfo.behaviors.get(behaviorType) : ocInfo.methodMap;\n            if (!methodMap)\n                return false;\n            const triggerList = methodMap.get(method);\n            if (!triggerList)\n                return false;\n            let ret = false;\n            for (const [trigger,index] of triggerList) {\n                let r;\n                if (trigger.DebugCanRunFast())\n                    r = this._ExecuteTrigger(inst, trigger, index);\n                else\n                    r = yield*this._DebugExecuteTrigger(inst, trigger, index);\n                ret = ret || r\n            }\n            return ret\n        }\n        _FastTrigger(method, inst, value) {\n            const objectClass = inst.GetObjectClass();\n            const methodMap = this._fastTriggers.get(objectClass);\n            if (!methodMap)\n                return false;\n            const valueMap = methodMap.get(method);\n            if (!valueMap)\n                return false;\n            const triggerList = valueMap.get(value);\n            if (!triggerList)\n                return false;\n            let ret = false;\n            for (let i = 0, len = triggerList.length; i < len; ++i) {\n                const t = triggerList[i];\n                const r = this._ExecuteTrigger(null, t[0], t[1]);\n                ret = ret || r\n            }\n            return ret\n        }\n        *_DebugFastTrigger(method, inst, value) {\n            const objectClass = inst.GetObjectClass();\n            const methodMap = this._fastTriggers.get(objectClass);\n            if (!methodMap)\n                return false;\n            const valueMap = methodMap.get(method);\n            if (!valueMap)\n                return false;\n            const triggerList = valueMap.get(value);\n            if (!triggerList)\n                return false;\n            let ret = false;\n            for (let i = 0, len = triggerList.length; i < len; ++i) {\n                const t = triggerList[i];\n                const trigger = t[0];\n                const index = t[1];\n                let r;\n                if (trigger.DebugCanRunFast())\n                    r = this._ExecuteTrigger(null, trigger, index);\n                else\n                    r = yield*this._DebugExecuteTrigger(null, trigger, index);\n                ret = ret || r\n            }\n            return ret\n        }\n        _ExecuteTrigger(inst, trigger, index) {\n            const runtime = this._runtime;\n            const eventSheetManager = this._eventSheetManager;\n            const currentEvent = eventSheetManager.GetCurrentEvent();\n            const eventStack = eventSheetManager.GetEventStack();\n            const triggerDepth = eventSheetManager.GetTriggerDepth();\n            let ret = false;\n            if (currentEvent)\n                eventSheetManager.PushCleanSol(currentEvent.GetSolModifiersIncludingParents());\n            eventSheetManager.PushCleanSol(trigger.GetSolModifiersIncludingParents());\n            const isRecursive = triggerDepth > 1;\n            if (isRecursive)\n                eventSheetManager.GetLocalVarStack().Push();\n            const frame = eventStack.Push(trigger);\n            if (inst) {\n                const objectClass = trigger.GetConditions()[index].GetObjectClass();\n                const sol = objectClass.GetCurrentSol();\n                sol.SetSinglePicked(inst);\n                if (inst.IsInContainer())\n                    inst.SetSiblingsSinglePicked()\n            }\n            let okToRun = true;\n            if (trigger.GetParent()) {\n                const parents = trigger.GetTriggerParents();\n                for (let i = 0, len = parents.length; i < len; ++i)\n                    if (!parents[i].RunPreTrigger(frame)) {\n                        okToRun = false;\n                        break\n                    }\n            }\n            if (okToRun) {\n                if (trigger.IsOrBlock())\n                    trigger.RunOrBlockTrigger(frame, index);\n                else\n                    trigger.Run(frame);\n                ret = frame.GetLastEventTrue()\n            }\n            eventStack.Pop();\n            if (isRecursive)\n                eventSheetManager.GetLocalVarStack().Pop();\n            eventSheetManager.PopSol(trigger.GetSolModifiersIncludingParents());\n            if (currentEvent)\n                eventSheetManager.PopSol(currentEvent.GetSolModifiersIncludingParents());\n            if (!currentEvent && triggerDepth === 1) {\n                eventSheetManager.ClearAsyncActionPromises();\n                if (!eventSheetManager.IsFlushingBlocked())\n                    runtime.FlushPendingInstances()\n            }\n            return ret\n        }\n        *_DebugExecuteTrigger(inst, trigger, index) {\n            const runtime = this._runtime;\n            const eventSheetManager = this._eventSheetManager;\n            const currentEvent = eventSheetManager.GetCurrentEvent();\n            const eventStack = eventSheetManager.GetEventStack();\n            const triggerDepth = eventSheetManager.GetTriggerDepth();\n            let ret = false;\n            if (currentEvent)\n                eventSheetManager.PushCleanSol(currentEvent.GetSolModifiersIncludingParents());\n            eventSheetManager.PushCleanSol(trigger.GetSolModifiersIncludingParents());\n            const isRecursive = triggerDepth > 1;\n            if (isRecursive)\n                eventSheetManager.GetLocalVarStack().Push();\n            const frame = eventStack.Push(trigger);\n            if (inst) {\n                const objectClass = trigger.GetConditions()[index].GetObjectClass();\n                const sol = objectClass.GetCurrentSol();\n                sol.SetSinglePicked(inst);\n                if (inst.IsInContainer())\n                    inst.SetSiblingsSinglePicked()\n            }\n            let okToRun = true;\n            if (trigger.GetParent()) {\n                const parents = trigger.GetTriggerParents();\n                for (let i = 0, len = parents.length; i < len; ++i)\n                    if (!(yield*parents[i].DebugRunPreTrigger(frame))) {\n                        okToRun = false;\n                        break\n                    }\n            }\n            if (okToRun) {\n                if (trigger.IsOrBlock())\n                    yield*trigger.DebugRunOrBlockTrigger(frame, index);\n                else\n                    yield*trigger.DebugRun(frame);\n                ret = frame.GetLastEventTrue()\n            }\n            eventStack.Pop();\n            if (isRecursive)\n                eventSheetManager.GetLocalVarStack().Pop();\n            eventSheetManager.PopSol(trigger.GetSolModifiersIncludingParents());\n            if (currentEvent)\n                eventSheetManager.PopSol(currentEvent.GetSolModifiersIncludingParents());\n            if (!currentEvent && triggerDepth === 1) {\n                eventSheetManager.ClearAsyncActionPromises();\n                if (!eventSheetManager.IsFlushingBlocked())\n                    runtime.FlushPendingInstances()\n            }\n            return ret\n        }\n        _GetPerfRecord() {\n            return this._perfRecord\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/eventBlock.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const EMPTY_ARRAY = [];\n    function NoActions(frame, index) {\n        return true\n    }\n    function *DebugNoActions(frame, index) {\n        return true\n    }\n    C3.EventBlock = class EventBlock extends C3.DefendedBase {\n        constructor(eventSheet, parent, data) {\n            super();\n            this._eventSheet = eventSheet;\n            this._runtime = eventSheet.GetRuntime();\n            this._parent = parent;\n            this._scopeParent = null;\n            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();\n            this._solModifiers = [];\n            this._solModifiersIncludingParents = [];\n            this._hasGotSolModifiersIncludingParents = false;\n            this._isSolWriterAfterCnds = false;\n            this._isTopLevelGroup = false;\n            this._hasElseBlock = false;\n            this._isOrBlock = !!data[2];\n            this._isElseBlock = false;\n            this._triggerParents = null;\n            this._conditions = [];\n            this._actions = [];\n            this._subEvents = [];\n            this._RunActions = NoActions;\n            this._DebugRunActions = DebugNoActions;\n            this._isGroup = false;\n            this._isInitiallyActive = false;\n            this._groupName = "";\n            this._isGroupActive = false;\n            this._containedIncludes = null;\n            this._perfRecord = null;\n            this._sid = data[4];\n            this._displayNumber = data[5];\n            this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);\n            this._debugData = this._runtime.IsDebug() ? {\n                isBreakpoint: data[3][0],\n                isBreakable: data[3][1],\n                canRunAllConditionsFast: false,\n                canRunAllActionsFast: false,\n                canRunAllSubEventsFast: false,\n                canRunSelfFast: false\n            } : null;\n            this.GetEventSheetManager()._RegisterEventBlock(this);\n            if (data[0] === 3)\n                this._InitGroup(data[1]);\n            let index = 0;\n            for (const cndData of data[6]) {\n                const condition = C3.Condition.Create(this, cndData, index++);\n                this._conditions.push(condition);\n                this._AddSolModifier(condition.GetObjectClass())\n            }\n            index = 0;\n            for (const actData of data[7]) {\n                const action = C3.Action.Create(this, actData, index++);\n                this._actions.push(action)\n            }\n            if (data.length === 9) {\n                const subEventsData = data[8];\n                for (const eventData of subEventsData)\n                    this._eventSheet._CreateEvent(eventData, this, this._subEvents)\n            }\n            if (this._conditions.length)\n                this._isElseBlock = this._conditions[0].GetObjectClass() === null && this._conditions[0]._GetFunc() === C3.Plugins.System.Cnds.Else;\n            if (this._conditions.length === 0)\n                this._conditions = EMPTY_ARRAY;\n            if (this._actions.length === 0)\n                this._actions = EMPTY_ARRAY;\n            if (this._subEvents.length === 0)\n                this._subEvents = EMPTY_ARRAY\n        }\n        static Create(eventSheet, parent, data) {\n            return C3.New(C3.EventBlock, eventSheet, parent, data)\n        }\n        _InitGroup(groupData) {\n            this._isGroup = true;\n            this._isInitiallyActive = !!groupData[0];\n            this._isGroupActive = this._isInitiallyActive;\n            this._groupName = groupData[1].toLowerCase();\n            this._containedIncludes = [];\n            this.GetEventSheetManager()._RegisterGroup(this);\n            if (this._runtime.IsDebug())\n                this._perfRecord = {\n                    type: "group",\n                    name: groupData[1],\n                    totalTimeCounter: 0,\n                    children: []\n                }\n        }\n        _AddContainedInclude(include) {\n            this._containedIncludes.push(include)\n        }\n        _AddContainerSolModifierToList(objectClass, arr) {\n            for (const containerType of objectClass.GetContainer().objectTypes())\n                if (!arr.includes(containerType))\n                    arr.push(containerType)\n        }\n        _AddSolModifierToList(objectClass, arr) {\n            if (!objectClass)\n                return;\n            if (!arr.includes(objectClass))\n                arr.push(objectClass);\n            if (objectClass.IsFamily())\n                for (const familyMember of objectClass.GetFamilyMembers()) {\n                    if (familyMember.IsInContainer())\n                        this._AddContainerSolModifierToList(familyMember, arr)\n                }\n            else if (objectClass.IsInContainer())\n                this._AddContainerSolModifierToList(objectClass, arr)\n        }\n        _AddSolModifier(objectClass) {\n            this._AddSolModifierToList(objectClass, this._solModifiers)\n        }\n        _AddParentSolModifier(objectClass) {\n            this._AddSolModifierToList(objectClass, this._solModifiersIncludingParents)\n        }\n        SetAllSolModifiers() {\n            this._solModifiers = this._runtime.GetAllObjectClasses()\n        }\n        _PostInit(hasElse) {\n            this._hasElseBlock = !!hasElse;\n            this._IdentifyTopLevelGroup();\n            this._IdentifyTriggerParents();\n            for (const c of this._conditions)\n                c._PostInit();\n            if (this._actions.length > 0) {\n                let hasAnyActionWithReturnType = false;\n                for (const a of this._actions) {\n                    a._PostInit();\n                    if (a.HasReturnType())\n                        hasAnyActionWithReturnType = true\n                }\n                if (hasAnyActionWithReturnType) {\n                    this._RunActions = this._RunActions_ReturnValue;\n                    this._DebugRunActions = this._DebugRunActions_ReturnValue\n                } else {\n                    this._RunActions = this._RunActions_Fast;\n                    this._DebugRunActions = this._DebugRunActions_Fast\n                }\n            }\n            const subEvents = this._subEvents;\n            for (let i = 0, len = subEvents.length; i < len; ++i) {\n                const hasElseBlock = i < len - 1 && subEvents[i + 1]instanceof C3.EventBlock && subEvents[i + 1].IsElseBlock();\n                subEvents[i]._PostInit(hasElseBlock)\n            }\n            if (this._debugData)\n                this._UpdateCanRunFast();\n            if (this._perfRecord)\n                this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord)\n        }\n        _GetPerfRecord() {\n            return this._perfRecord\n        }\n        _GetPerfRecordParent() {\n            let p = this.GetParent();\n            while (p) {\n                if (p.IsGroup())\n                    return p;\n                p = p.GetParent()\n            }\n            return this._eventSheet\n        }\n        _UpdateCanRunFast() {\n            const dd = this._debugData;\n            dd.canRunAllConditionsFast = this._conditions.every(c => c.DebugCanRunFast());\n            dd.canRunAllActionsFast = this._actions.every(a => a.DebugCanRunFast());\n            dd.canRunAllSubEventsFast = this._subEvents.every(s => s.DebugCanRunFast());\n            dd.canRunSelfFast = dd.canRunAllConditionsFast && dd.canRunAllActionsFast && dd.canRunAllSubEventsFast\n        }\n        _UpdateCanRunFastRecursive() {\n            let e = this;\n            do {\n                e._UpdateCanRunFast();\n                e = e.GetParent()\n            } while (e)\n        }\n        _IdentifyTopLevelGroup() {\n            if (!this.IsGroup())\n                return;\n            let p = this.GetParent();\n            this._isTopLevelGroup = true;\n            while (p) {\n                if (!p.IsGroup()) {\n                    this._isTopLevelGroup = false;\n                    break\n                }\n                p = p.GetParent()\n            }\n        }\n        _IdentifySolModifiersIncludingParents() {\n            const allObjectClasses = this._runtime.GetAllObjectClasses();\n            if (this._solModifiers === allObjectClasses)\n                this._solModifiersIncludingParents = allObjectClasses;\n            else {\n                this._solModifiersIncludingParents = C3.cloneArray(this._solModifiers);\n                let p = this.GetParent();\n                while (p) {\n                    for (const o of p._solModifiers)\n                        this._AddParentSolModifier(o);\n                    p = p.GetParent()\n                }\n                const eventSheetManager = this.GetEventSheetManager();\n                this._solModifiers = eventSheetManager._DeduplicateSolModifierList(this._solModifiers);\n                this._solModifiersIncludingParents = eventSheetManager._DeduplicateSolModifierList(this._solModifiersIncludingParents)\n            }\n        }\n        _IdentifyTriggerParents() {\n            if (!this.HasAnyTriggeredCondition())\n                return;\n            this._triggerParents = [];\n            let p = this.GetParent();\n            while (p) {\n                this._triggerParents.push(p);\n                p = p.GetParent()\n            }\n            this._triggerParents.reverse()\n        }\n        SetSolWriterAfterCnds() {\n            this._isSolWriterAfterCnds = true;\n            if (this._parent)\n                this._parent.SetSolWriterAfterCnds()\n        }\n        IsSolWriterAfterCnds() {\n            return this._isSolWriterAfterCnds\n        }\n        GetSolModifiers() {\n            return this._solModifiers\n        }\n        GetSolModifiersIncludingParents() {\n            if (!this._hasGotSolModifiersIncludingParents) {\n                this._hasGotSolModifiersIncludingParents = true;\n                this._IdentifySolModifiersIncludingParents()\n            }\n            return this._solModifiersIncludingParents\n        }\n        HasSolModifier(objectClass) {\n            return this._solModifiers.includes(objectClass)\n        }\n        GetTriggerParents() {\n            return this._triggerParents\n        }\n        GetEventSheet() {\n            return this._eventSheet\n        }\n        GetEventSheetManager() {\n            return this._eventSheet.GetEventSheetManager()\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetParent() {\n            return this._parent\n        }\n        _SetScopeParent(p) {\n            this._scopeParent = p\n        }\n        GetScopeParent() {\n            return this._scopeParent || this._parent\n        }\n        GetDisplayNumber() {\n            return this._displayNumber\n        }\n        IsDebugBreakable() {\n            return this._debugData && this._debugData.isBreakable\n        }\n        IsDebugBreakpoint() {\n            return this.IsDebugBreakable() && this._debugData.isBreakpoint\n        }\n        _SetDebugBreakpoint(b) {\n            this._debugData.isBreakpoint = !!b;\n            this._UpdateCanRunFastRecursive()\n        }\n        IsGroup() {\n            return this._isGroup\n        }\n        IsTopLevelGroup() {\n            return this._isTopLevelGroup\n        }\n        IsElseBlock() {\n            return this._isElseBlock\n        }\n        HasElseBlock() {\n            return this._hasElseBlock\n        }\n        GetGroupName() {\n            return this._groupName\n        }\n        IsGroupActive() {\n            return this._isGroupActive\n        }\n        ResetInitialActivation() {\n            this.SetGroupActive(this._isInitiallyActive)\n        }\n        SetGroupActive(a) {\n            a = !!a;\n            if (!this._isGroup)\n                throw new Error("not a group");\n            if (this._isGroupActive === a)\n                return;\n            this._isGroupActive = a;\n            for (const include of this._containedIncludes)\n                include.UpdateActive();\n            if (this._containedIncludes.length) {\n                const currentLayout = this._runtime.GetCurrentLayout();\n                const mainEventSheet = currentLayout.GetEventSheet();\n                if (mainEventSheet)\n                    mainEventSheet._UpdateDeepIncludes()\n            }\n        }\n        GetSID() {\n            return this._sid\n        }\n        IsOrBlock() {\n            return this._isOrBlock\n        }\n        IsTrigger() {\n            return this._conditions.length && this._conditions[0].IsTrigger()\n        }\n        IsForFunctionBlock() {\n            return this._scopeParent && this._scopeParent instanceof C3.FunctionBlock\n        }\n        HasAnyTriggeredCondition() {\n            return this.IsForFunctionBlock() || this._conditions.some(c => c.IsTrigger())\n        }\n        GetConditions() {\n            return this._conditions\n        }\n        GetConditionCount() {\n            return this._conditions.length\n        }\n        GetConditionAt(i) {\n            i = Math.floor(i);\n            if (i < 0 || i >= this._conditions.length)\n                throw new RangeError("invalid condition index");\n            return this._conditions[i]\n        }\n        GetConditionByDebugIndex(i) {\n            return this.GetConditionAt(i)\n        }\n        IsFirstConditionOfType(cnd) {\n            let i = cnd.GetIndex();\n            if (i === 0)\n                return true;\n            --i;\n            for (; i >= 0; --i)\n                if (this._conditions[i].GetObjectClass() === cnd.GetObjectClass())\n                    return false;\n            return true\n        }\n        GetActions() {\n            return this._actions\n        }\n        GetActionCount() {\n            return this._actions.length\n        }\n        GetActionAt(i) {\n            i = Math.floor(i);\n            if (i < 0 || i >= this._actions.length)\n                throw new RangeError("invalid action index");\n            return this._actions[i]\n        }\n        GetActionByDebugIndex(i) {\n            i = Math.floor(i);\n            const ret = this._actions.find(a => a.GetDebugIndex() === i);\n            if (!ret)\n                throw new RangeError("invalid action debug index");\n            return ret\n        }\n        _HasActionIndex(i) {\n            i = Math.floor(i);\n            return i >= 0 && i < this._actions.length\n        }\n        GetSubEvents() {\n            return this._subEvents\n        }\n        _GetAllLocalVariablesInScope() {\n            return this._subEvents.filter(e => e instanceof C3.EventVariable)\n        }\n        RunPreTrigger(frame) {\n            frame.SetCurrentEvent(this);\n            let isAnyTrue = false;\n            const conditions = this._conditions;\n            for (let i = 0, len = conditions.length; i < len; ++i) {\n                const c = conditions[i];\n                frame.SetConditionIndex(i);\n                if (c.IsLooping())\n                    throw new Error("trigger cannot be used as sub-event to a loop");\n                if (c.Run())\n                    isAnyTrue = true;\n                else if (!this._isOrBlock)\n                    return false\n            }\n            return this._isOrBlock ? isAnyTrue : true\n        }\n        RunOrBlockTrigger(frame, index) {\n            frame.SetCurrentEvent(this);\n            if (this._conditions[index].Run()) {\n                if (this._RunActions(frame, 0))\n                    this._RunSubEvents(frame);\n                frame.SetLastEventTrue(true)\n            }\n        }\n        *DebugRunPreTrigger(frame) {\n            frame.SetCurrentEvent(this);\n            let isAnyTrue = false;\n            const conditions = this._conditions;\n            for (let i = 0, len = conditions.length; i < len; ++i) {\n                const c = conditions[i];\n                frame.SetConditionIndex(i);\n                if (c.IsLooping())\n                    throw new Error("trigger cannot be used as sub-event to a loop");\n                let ret;\n                if (c.DebugCanRunFast())\n                    ret = c.Run();\n                else\n                    ret = yield*c.DebugRun();\n                if (ret)\n                    isAnyTrue = true;\n                else if (!this._isOrBlock)\n                    return false\n            }\n            return this._isOrBlock ? isAnyTrue : true\n        }\n        *DebugRunOrBlockTrigger(frame, index) {\n            frame.SetCurrentEvent(this);\n            const c = this._conditions[index];\n            let ret;\n            if (c.DebugCanRunFast())\n                ret = c.Run();\n            else\n                ret = yield*c.DebugRun();\n            if (ret) {\n                let actRet;\n                if (this.DebugCanRunActionsFast())\n                    actRet = this._RunActions(frame, 0);\n                else\n                    actRet = yield*this._DebugRunActions(frame, 0);\n                if (actRet)\n                    if (this.DebugCanRunSubEventsFast())\n                        this._RunSubEvents();\n                    else\n                        yield*this._DebugRunSubEvents();\n                frame.SetLastEventTrue(true)\n            }\n        }\n        Run(frame) {\n            frame.SetCurrentEvent(this);\n            if (!this._isElseBlock)\n                frame.SetElseBranchRan(false);\n            if (this._isOrBlock)\n                this._RunOrBlock(frame);\n            else\n                this._RunAndBlock(frame)\n        }\n        *DebugRun(frame) {\n            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            frame.SetCurrentEvent(this);\n            if (!this._isElseBlock)\n                frame.SetElseBranchRan(false);\n            if (this._isOrBlock)\n                yield*this._DebugRunOrBlock(frame);\n            else\n                yield*this._DebugRunAndBlock(frame)\n        }\n        _RunOrBlock(frame) {\n            const conditions = this._conditions;\n            let isAnyTrue = conditions.length === 0;\n            for (let i = 0, len = conditions.length; i < len; ++i) {\n                const c = conditions[i];\n                if (c.IsTrigger())\n                    continue;\n                frame.SetConditionIndex(i);\n                const result = c.Run();\n                isAnyTrue = isAnyTrue || result\n            }\n            frame.SetLastEventTrue(isAnyTrue);\n            if (isAnyTrue) {\n                if (this._RunActions(frame, 0))\n                    this._RunSubEvents(frame);\n                if (this._hasElseBlock)\n                    frame.SetElseBranchRan(true)\n            }\n        }\n        *_DebugRunOrBlock(frame) {\n            const conditions = this._conditions;\n            let isAnyTrue = conditions.length === 0;\n            for (let i = 0, len = conditions.length; i < len; ++i) {\n                const c = conditions[i];\n                if (c.IsTrigger())\n                    continue;\n                frame.SetConditionIndex(i);\n                let ret;\n                if (c.DebugCanRunFast())\n                    ret = c.Run();\n                else\n                    ret = yield*c.DebugRun();\n                isAnyTrue = isAnyTrue || ret\n            }\n            frame.SetLastEventTrue(isAnyTrue);\n            if (isAnyTrue) {\n                let actRet;\n                if (this.DebugCanRunActionsFast())\n                    actRet = this._RunActions(frame, 0);\n                else\n                    actRet = yield*this._DebugRunActions(frame, 0);\n                if (actRet)\n                    if (this.DebugCanRunSubEventsFast())\n                        this._RunSubEvents();\n                    else\n                        yield*this._DebugRunSubEvents();\n                if (this._hasElseBlock)\n                    frame.SetElseBranchRan(true)\n            }\n        }\n        _RunAndBlock(frame) {\n            const conditions = this._conditions;\n            for (let i = 0, len = conditions.length; i < len; ++i) {\n                const c = conditions[i];\n                frame.SetConditionIndex(i);\n                const result = c.Run();\n                if (!result) {\n                    frame.SetLastEventTrue(false);\n                    return\n                }\n            }\n            frame.SetLastEventTrue(true);\n            if (this._RunActions(frame, 0))\n                this._RunSubEvents(frame);\n            if (frame.GetLastEventTrue() && this._hasElseBlock)\n                frame.SetElseBranchRan(true)\n        }\n        *_DebugRunAndBlock(frame) {\n            const conditions = this._conditions;\n            for (let i = 0, len = conditions.length; i < len; ++i) {\n                const c = conditions[i];\n                frame.SetConditionIndex(i);\n                let ret;\n                if (c.DebugCanRunFast())\n                    ret = c.Run();\n                else\n                    ret = yield*c.DebugRun();\n                if (!ret) {\n                    frame.SetLastEventTrue(false);\n                    return\n                }\n            }\n            frame.SetLastEventTrue(true);\n            let actRet;\n            if (this.DebugCanRunActionsFast())\n                actRet = this._RunActions(frame, 0);\n            else\n                actRet = yield*this._DebugRunActions(frame, 0);\n            if (actRet)\n                if (this.DebugCanRunSubEventsFast())\n                    this._RunSubEvents();\n                else\n                    yield*this._DebugRunSubEvents();\n            if (frame.GetLastEventTrue() && this._hasElseBlock)\n                frame.SetElseBranchRan(true)\n        }\n        _RunActions_Fast(frame, startIndex) {\n            const actions = this._actions;\n            for (let i = startIndex, len = actions.length; i < len; ++i) {\n                const a = actions[i];\n                frame.SetActionIndex(i);\n                a.Run()\n            }\n            return true\n        }\n        *_DebugRunActions_Fast(frame, startIndex) {\n            const actions = this._actions;\n            for (let i = startIndex, len = actions.length; i < len; ++i) {\n                const a = actions[i];\n                frame.SetActionIndex(i);\n                if (a.DebugCanRunFast())\n                    a.Run();\n                else\n                    yield*a.DebugRun()\n            }\n            return true\n        }\n        _RunActions_ReturnValue(frame, startIndex) {\n            const eventSheetManager = this.GetEventSheetManager();\n            const actions = this._actions;\n            for (let i = startIndex, len = actions.length; i < len; ++i) {\n                const a = actions[i];\n                frame.SetActionIndex(i);\n                const ret = a.Run();\n                if (a.CanBailOut() && ret === true)\n                    return false;\n                else if (a.IsAsync() && ret instanceof Promise)\n                    eventSheetManager.AddAsyncActionPromise(ret)\n            }\n            return true\n        }\n        *_DebugRunActions_ReturnValue(frame, startIndex) {\n            const eventSheetManager = this.GetEventSheetManager();\n            const actions = this._actions;\n            for (let i = startIndex, len = actions.length; i < len; ++i) {\n                const a = actions[i];\n                frame.SetActionIndex(i);\n                let ret;\n                if (a.DebugCanRunFast())\n                    ret = a.Run();\n                else\n                    ret = yield*a.DebugRun();\n                if (a.CanBailOut() && ret === true)\n                    return false;\n                else if (a.IsAsync() && ret instanceof Promise)\n                    eventSheetManager.AddAsyncActionPromise(ret)\n            }\n            return true\n        }\n        _ResumeActionsAndSubEvents(frame) {\n            if (this._RunActions(frame, frame.GetActionIndex()))\n                this._RunSubEvents()\n        }\n        *_DebugResumeActionsAndSubEvents(frame) {\n            if (yield*this._DebugRunActions(frame, frame.GetActionIndex()))\n                yield*this._DebugRunSubEvents()\n        }\n        _RunSubEvents() {\n            if (!this._subEvents.length)\n                return;\n            const profile = this.IsGroup() && this._runtime.IsCPUProfiling();\n            const startTime = profile ? performance.now() : 0;\n            const eventStack = this._eventStack;\n            const frame = eventStack.Push(this);\n            if (this._isSolWriterAfterCnds)\n                this._RunSubEvents_SolWriterAfterCnds(frame);\n            else\n                this._RunSubEvents_Fast(frame);\n            eventStack.Pop();\n            if (profile)\n                this._perfRecord.totalTimeCounter += performance.now() - startTime\n        }\n        _RunSubEvents_SolWriterAfterCnds(frame) {\n            const isGroup = this._isGroup;\n            const isTopLevelGroup = this._isTopLevelGroup;\n            const eventSheetManager = this.GetEventSheetManager();\n            const subEvents = this._subEvents;\n            for (let i = 0, len = subEvents.length, last = len - 1; i < len; ++i) {\n                const e = subEvents[i];\n                const solModifiers = e.GetSolModifiers();\n                const copySol = !isTopLevelGroup || !isGroup && i < last;\n                if (copySol)\n                    eventSheetManager.PushCopySol(solModifiers);\n                e.Run(frame);\n                if (copySol)\n                    eventSheetManager.PopSol(solModifiers);\n                else\n                    eventSheetManager.ClearSol(solModifiers)\n            }\n        }\n        _RunSubEvents_Fast(frame) {\n            const subEvents = this._subEvents;\n            for (let i = 0, len = subEvents.length; i < len; ++i)\n                subEvents[i].Run(frame)\n        }\n        *_DebugRunSubEvents() {\n            if (!this._subEvents.length)\n                return;\n            const eventStack = this._eventStack;\n            const frame = eventStack.Push(this);\n            if (this._isSolWriterAfterCnds)\n                yield*this._DebugRunSubEvents_SolWriterAfterCnds(frame);\n            else\n                yield*this._DebugRunSubEvents_Fast(frame);\n            eventStack.Pop()\n        }\n        *_DebugRunSubEvents_SolWriterAfterCnds(frame) {\n            const isGroup = this._isGroup;\n            const isTopLevelGroup = this._isTopLevelGroup;\n            const eventSheetManager = this.GetEventSheetManager();\n            const subEvents = this._subEvents;\n            for (let i = 0, len = subEvents.length, last = len - 1; i < len; ++i) {\n                const e = subEvents[i];\n                const solModifiers = e.GetSolModifiers();\n                const copySol = !isTopLevelGroup || !isGroup && i < last;\n                if (copySol)\n                    eventSheetManager.PushCopySol(solModifiers);\n                yield*e.DebugRun(frame);\n                if (copySol)\n                    eventSheetManager.PopSol(solModifiers);\n                else\n                    eventSheetManager.ClearSol(solModifiers)\n            }\n        }\n        *_DebugRunSubEvents_Fast(frame) {\n            const subEvents = this._subEvents;\n            for (let i = 0, len = subEvents.length; i < len; ++i)\n                yield*subEvents[i].DebugRun(frame)\n        }\n        Retrigger(oldFrame, newFrame) {\n            newFrame.ResetQuick();\n            const conditions = this._conditions;\n            if (!this.IsOrBlock())\n                for (let i = oldFrame.GetConditionIndex() + 1, len = conditions.length; i < len; ++i) {\n                    const c = conditions[i];\n                    newFrame.SetConditionIndex(i);\n                    const result = c.Run();\n                    if (!result)\n                        return false\n                }\n            if (this._RunActions(newFrame, 0))\n                this._RunSubEvents(newFrame);\n            return true\n        }\n        *DebugRetrigger(oldFrame, newFrame) {\n            newFrame.ResetQuick();\n            const conditions = this._conditions;\n            if (!this.IsOrBlock())\n                for (let i = oldFrame.GetConditionIndex() + 1, len = conditions.length; i < len; ++i) {\n                    const c = conditions[i];\n                    newFrame.SetConditionIndex(i);\n                    let ret;\n                    if (c.DebugCanRunFast())\n                        ret = c.Run();\n                    else\n                        ret = yield*c.DebugRun();\n                    if (!ret)\n                        return false\n                }\n            let actRet;\n            if (this.DebugCanRunActionsFast())\n                actRet = this._RunActions(newFrame, 0);\n            else\n                actRet = yield*this._DebugRunActions(newFrame, 0);\n            if (actRet)\n                if (this.DebugCanRunSubEventsFast())\n                    this._RunSubEvents();\n                else\n                    yield*this._DebugRunSubEvents();\n            return true\n        }\n        DebugCanRunFast() {\n            return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast\n        }\n        DebugCanRunActionsFast() {\n            return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast\n        }\n        DebugCanRunSubEventsFast() {\n            return !this._runtime.DebugBreakNext() && this._debugData.canRunAllSubEventsFast\n        }\n        _CheckParentsOKToRun(frame) {\n            if (this.GetParent()) {\n                const parents = this.GetTriggerParents();\n                for (let i = 0, len = parents.length; i < len; ++i)\n                    if (!parents[i].RunPreTrigger(frame))\n                        return false\n            }\n            return true\n        }\n        *_DebugCheckParentsOKToRun(frame) {\n            if (this.GetParent()) {\n                const parents = this.GetTriggerParents();\n                for (let i = 0, len = parents.length; i < len; ++i)\n                    if (!(yield*parents[i].DebugRunPreTrigger(frame)))\n                        return false\n            }\n            return true\n        }\n        _EvaluateFunctionCallParameters(eventSheetManager, parameters, isRecursive) {\n            if (parameters.length > 0)\n                if (isRecursive) {\n                    const paramResults = parameters.map(p => p.Get(0));\n                    eventSheetManager.GetLocalVarStack().Push();\n                    this._scopeParent.SetFunctionParameters(paramResults)\n                } else\n                    this._scopeParent.EvaluateFunctionParameters(parameters);\n            else if (isRecursive)\n                eventSheetManager.GetLocalVarStack().Push()\n        }\n        RunAsFunctionCall(combinedSolModifiers, parameters) {\n            let ret;\n            let asyncId;\n            const hasAnySolModifiers = combinedSolModifiers.length > 0;\n            const runtime = this._runtime;\n            const eventStack = this._eventStack;\n            const eventSheetManager = runtime.GetEventSheetManager();\n            const triggerDepth = eventSheetManager._IncTriggerDepth();\n            const isRecursive = triggerDepth > 1;\n            this._EvaluateFunctionCallParameters(eventSheetManager, parameters, isRecursive);\n            if (hasAnySolModifiers)\n                eventSheetManager.PushCleanSol(combinedSolModifiers);\n            const frame = eventStack.Push(this);\n            if (this._CheckParentsOKToRun(frame)) {\n                frame.SetCurrentEvent(this);\n                const isAsync = this._scopeParent.IsAsync();\n                if (isAsync)\n                    [asyncId,ret] = this._scopeParent.StartAsyncFunctionCall();\n                this._RunAndBlock(frame);\n                if (isAsync)\n                    this._scopeParent.MaybeFinishAsyncFunctionCall(asyncId)\n            }\n            eventStack.Pop();\n            if (isRecursive)\n                eventSheetManager.GetLocalVarStack().Pop();\n            if (hasAnySolModifiers)\n                eventSheetManager.PopSol(combinedSolModifiers);\n            eventSheetManager._DecTriggerDepth();\n            return ret\n        }\n        *DebugRunAsFunctionCall(combinedSolModifiers, parameters) {\n            let ret;\n            let asyncId;\n            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            const hasAnySolModifiers = combinedSolModifiers.length > 0;\n            const runtime = this._runtime;\n            const eventStack = this._eventStack;\n            const eventSheetManager = runtime.GetEventSheetManager();\n            const triggerDepth = eventSheetManager._IncTriggerDepth();\n            const isRecursive = triggerDepth > 1;\n            this._EvaluateFunctionCallParameters(eventSheetManager, parameters, isRecursive);\n            if (hasAnySolModifiers)\n                eventSheetManager.PushCleanSol(combinedSolModifiers);\n            const frame = eventStack.Push(this);\n            if (yield*this._DebugCheckParentsOKToRun(frame)) {\n                frame.SetCurrentEvent(this);\n                const isAsync = this._scopeParent.IsAsync();\n                if (isAsync)\n                    [asyncId,ret] = this._scopeParent.StartAsyncFunctionCall();\n                yield*this._DebugRunAndBlock(frame);\n                if (isAsync)\n                    this._scopeParent.MaybeFinishAsyncFunctionCall(asyncId)\n            }\n            eventStack.Pop();\n            if (isRecursive)\n                eventSheetManager.GetLocalVarStack().Pop();\n            if (hasAnySolModifiers)\n                eventSheetManager.PopSol(combinedSolModifiers);\n            eventSheetManager._DecTriggerDepth();\n            return ret\n        }\n        RunAsMappedFunctionCall(paramResults) {\n            const solModifiers = this.GetSolModifiersIncludingParents();\n            const hasAnySolModifiers = solModifiers.length > 0;\n            const runtime = this._runtime;\n            const eventStack = this._eventStack;\n            const eventSheetManager = runtime.GetEventSheetManager();\n            const triggerDepth = eventSheetManager._IncTriggerDepth();\n            const isRecursive = triggerDepth > 1;\n            if (isRecursive)\n                eventSheetManager.GetLocalVarStack().Push();\n            this._scopeParent.SetFunctionParameters(paramResults);\n            if (hasAnySolModifiers)\n                eventSheetManager.PushCleanSol(solModifiers);\n            const frame = eventStack.Push(this);\n            if (this._CheckParentsOKToRun(frame)) {\n                frame.SetCurrentEvent(this);\n                this._RunAndBlock(frame)\n            }\n            eventStack.Pop();\n            if (isRecursive)\n                eventSheetManager.GetLocalVarStack().Pop();\n            if (hasAnySolModifiers)\n                eventSheetManager.PopSol(solModifiers);\n            eventSheetManager._DecTriggerDepth()\n        }\n        *DebugRunAsMappedFunctionCall(paramResults) {\n            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            const solModifiers = this.GetSolModifiersIncludingParents();\n            const hasAnySolModifiers = solModifiers.length > 0;\n            const runtime = this._runtime;\n            const eventStack = this._eventStack;\n            const eventSheetManager = runtime.GetEventSheetManager();\n            const triggerDepth = eventSheetManager._IncTriggerDepth();\n            const isRecursive = triggerDepth > 1;\n            if (isRecursive)\n                eventSheetManager.GetLocalVarStack().Push();\n            this._scopeParent.SetFunctionParameters(paramResults);\n            if (hasAnySolModifiers)\n                eventSheetManager.PushCleanSol(solModifiers);\n            const frame = eventStack.Push(this);\n            if (yield*this._DebugCheckParentsOKToRun(frame)) {\n                frame.SetCurrentEvent(this);\n                yield*this._DebugRunAndBlock(frame)\n            }\n            eventStack.Pop();\n            if (isRecursive)\n                eventSheetManager.GetLocalVarStack().Pop();\n            if (hasAnySolModifiers)\n                eventSheetManager.PopSol(solModifiers);\n            eventSheetManager._DecTriggerDepth()\n        }\n        RunAsExpressionFunctionCall(combinedSolModifiers, returnType, defaultReturnValue, ...paramResults) {\n            let ret;\n            let asyncId;\n            const hasAnySolModifiers = combinedSolModifiers.length > 0;\n            const runtime = this._runtime;\n            const eventStack = this._eventStack;\n            const eventSheetManager = runtime.GetEventSheetManager();\n            const triggerDepth = eventSheetManager._IncTriggerDepth();\n            const isRecursive = triggerDepth > 1;\n            if (isRecursive)\n                eventSheetManager.GetLocalVarStack().Push();\n            if (paramResults.length > 0)\n                this._scopeParent.SetFunctionParameters(paramResults);\n            if (hasAnySolModifiers)\n                eventSheetManager.PushCleanSol(combinedSolModifiers);\n            const frame = eventStack.Push(this);\n            frame.InitCallFunctionExpression(returnType, defaultReturnValue);\n            eventStack.PushExpFunc(frame);\n            runtime.SetDebuggingEnabled(false);\n            if (this._CheckParentsOKToRun(frame)) {\n                frame.SetCurrentEvent(this);\n                const isAsync = this._scopeParent.IsAsync();\n                if (isAsync)\n                    [asyncId,ret] = this._scopeParent.StartAsyncFunctionCall();\n                this._RunAndBlock(frame);\n                if (isAsync)\n                    this._scopeParent.MaybeFinishAsyncFunctionCall(asyncId)\n            }\n            runtime.SetDebuggingEnabled(true);\n            eventStack.Pop();\n            eventStack.PopExpFunc();\n            if (isRecursive)\n                eventSheetManager.GetLocalVarStack().Pop();\n            if (hasAnySolModifiers)\n                eventSheetManager.PopSol(combinedSolModifiers);\n            eventSheetManager._DecTriggerDepth();\n            return ret || frame.GetFunctionReturnValue()\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/eventScript.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const EMPTY_SOL_MODIFIERS = [];\n    let hadUserScriptException = false;\n    C3.EventScript = class EventScript extends C3.DefendedBase {\n        constructor(eventSheet, parent, data) {\n            super();\n            const runtime = eventSheet.GetRuntime();\n            const eventSheetManager = eventSheet.GetEventSheetManager();\n            this._eventSheet = eventSheet;\n            this._eventSheetManager = eventSheetManager;\n            this._runtime = eventSheet.GetRuntime();\n            this._parent = parent;\n            const userMethod = runtime.GetObjectReference(data[1]);\n            this._func = userMethod;\n            this._displayNumber = data[2];\n            this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);\n            this._debugData = runtime.IsDebug() ? {\n                isBreakpoint: data[3][0],\n                isBreakable: data[3][1]\n            } : null\n        }\n        static Create(eventSheet, parent, data) {\n            return C3.New(C3.EventScript, eventSheet, parent, data)\n        }\n        _PostInit() {\n            const userMethod = this._func;\n            const localVars = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);\n            this._func = userMethod.bind(null, this._runtime.GetIRuntime(), localVars)\n        }\n        GetParent() {\n            return this._parent\n        }\n        GetScopeParent() {\n            return this._parent\n        }\n        GetEventSheet() {\n            return this._eventSheet\n        }\n        GetDisplayNumber() {\n            return this._displayNumber\n        }\n        IsDebugBreakable() {\n            return this._debugData && this._debugData.isBreakable\n        }\n        IsDebugBreakpoint() {\n            return this.IsDebugBreakable() && this._debugData.isBreakpoint\n        }\n        _SetDebugBreakpoint(b) {\n            this._debugData.isBreakpoint = !!b\n        }\n        IsElseBlock() {\n            return false\n        }\n        GetSolModifiers() {\n            return EMPTY_SOL_MODIFIERS\n        }\n        GetSolModifiersIncludingParents() {\n            if (this._parent)\n                return this._parent.GetSolModifiersIncludingParents();\n            else\n                return EMPTY_SOL_MODIFIERS\n        }\n        Run(frame) {\n            frame.SetCurrentEvent(this);\n            this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript())\n        }\n        async _RunUserScript() {\n            try {\n                await this._func()\n            } catch (err) {\n                console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, "font-size: 1.2em; font-weight: bold;", err);\n                if (self.C3Debugger)\n                    self.C3Debugger._SetLastErrorScript(this);\n                if (!hadUserScriptException) {\n                    console.info(`%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()`, "font-weight: bold; text-decoration: underline", "", "font-weight: bold");\n                    hadUserScriptException = true\n                }\n            }\n        }\n        *DebugRun(frame) {\n            frame.SetCurrentEvent(this);\n            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            this.Run(frame)\n        }\n        DebugCanRunFast() {\n            return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext()\n        }\n        static HadUserScriptException() {\n            return hadUserScriptException\n        }\n        static SetHadUserScriptException() {\n            hadUserScriptException = true\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/functionBlock.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const assert = self.assert;\n    C3.FunctionBlock = class FunctionBlock extends C3.DefendedBase {\n        constructor(eventSheet, parent, data) {\n            super();\n            this._eventSheet = eventSheet;\n            this._runtime = eventSheet.GetRuntime();\n            this._parent = parent;\n            const funcData = data[1];\n            this._functionName = funcData[0];\n            this._returnType = funcData[1];\n            this._functionParameters = funcData[2].map(paramData => C3.EventVariable.Create(eventSheet, this, paramData));\n            this._isEnabled = funcData[3];\n            this._innerLocalVariables = [];\n            this._isAsync = funcData[4];\n            this._nextAsyncId = 0;\n            this._currentAsyncId = -1;\n            this._asyncMap = new Map;\n            this._eventBlock = C3.EventBlock.Create(eventSheet, parent, data);\n            this._eventBlock._SetScopeParent(this)\n        }\n        static Create(eventSheet, parent, data) {\n            return C3.New(C3.FunctionBlock, eventSheet, parent, data)\n        }\n        _PostInit() {\n            for (const fp of this._functionParameters)\n                fp._PostInit();\n            this._eventBlock._PostInit(false)\n        }\n        _GetAllLocalVariablesInScope() {\n            return this._functionParameters\n        }\n        GetFunctionParameters() {\n            return this._functionParameters\n        }\n        GetFunctionParameterCount() {\n            return this._functionParameters.length\n        }\n        _RegisterLocalVariable(localVariable) {\n            this._innerLocalVariables.push(localVariable)\n        }\n        _GetAllInnerLocalVariables() {\n            return this._innerLocalVariables\n        }\n        EvaluateFunctionParameters(parameters) {\n            const functionParameters = this._functionParameters;\n            for (let i = 0, len = functionParameters.length; i < len; ++i)\n                functionParameters[i].SetValue(parameters[i].Get(0))\n        }\n        SetFunctionParameters(paramResults) {\n            const functionParameters = this._functionParameters;\n            for (let i = 0, len = functionParameters.length; i < len; ++i)\n                functionParameters[i].SetValue(paramResults[i])\n        }\n        CaptureFunctionParameters() {\n            return this._functionParameters.map(p => p.GetValue())\n        }\n        GetParent() {\n            return this._parent\n        }\n        GetScopeParent() {\n            return this._parent\n        }\n        GetFunctionName() {\n            return this._functionName\n        }\n        GetReturnType() {\n            return this._returnType\n        }\n        IsEnabled() {\n            return this._isEnabled\n        }\n        GetDefaultReturnValue() {\n            switch (this._returnType) {\n            case 0:\n                return null;\n            case 2:\n                return "";\n            default:\n                return 0\n            }\n        }\n        GetEventBlock() {\n            return this._eventBlock\n        }\n        IsAsync() {\n            return this._isAsync\n        }\n        StartAsyncFunctionCall() {\n            const asyncId = this._nextAsyncId++;\n            this._currentAsyncId = asyncId;\n            let resolve;\n            const promise = new Promise(r => resolve = r);\n            this._asyncMap.set(asyncId, {\n                resolve,\n                pauseCount: 0\n            });\n            return [asyncId, promise]\n        }\n        MaybeFinishAsyncFunctionCall(asyncId) {\n            const info = this._asyncMap.get(asyncId);\n            if (info.pauseCount === 0) {\n                info.resolve();\n                this._asyncMap.delete(asyncId)\n            }\n            this._currentAsyncId = -1\n        }\n        PauseCurrentAsyncFunction() {\n            const info = this._asyncMap.get(this._currentAsyncId);\n            info.pauseCount++;\n            return this._currentAsyncId\n        }\n        ResumeAsyncFunction(asyncId) {\n            this._currentAsyncId = asyncId;\n            const info = this._asyncMap.get(asyncId);\n            info.pauseCount--\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/eventVariable.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const EMPTY_SOL_MODIFIERS = [];\n    C3.EventVariable = class EventVariable extends C3.DefendedBase {\n        constructor(eventSheet, parent, data) {\n            super();\n            const eventSheetManager = eventSheet.GetEventSheetManager();\n            this._eventSheet = eventSheet;\n            this._eventSheetManager = eventSheetManager;\n            this._runtime = eventSheet.GetRuntime();\n            this._parent = parent;\n            this._localVarStack = eventSheetManager.GetLocalVarStack();\n            this._name = data[1];\n            this._type = data[2];\n            this._initialValue = data[3];\n            this._isStatic = !!data[4];\n            this._isConstant = !!data[5];\n            this._isFunctionParameter = parent instanceof C3.FunctionBlock;\n            this._sid = data[6];\n            this._jsPropName = this._runtime.GetJsPropName(data[8]);\n            this._scriptSetter = v => this.SetValue(v);\n            this._scriptGetter = () => this.GetValue();\n            this._hasSingleValue = !this._parent || this._isStatic || this._isConstant;\n            this._value = this._initialValue;\n            this._localIndex = -1;\n            if (this.IsBoolean())\n                this._value = this._value ? 1 : 0;\n            if (this.IsLocal() && !this.IsStatic() && !this.IsConstant())\n                this._localIndex = eventSheetManager._GetNextLocalVarIndex(this);\n            eventSheetManager._RegisterEventVariable(this)\n        }\n        static Create(eventSheet, parent, data) {\n            return C3.New(C3.EventVariable, eventSheet, parent, data)\n        }\n        _PostInit() {\n            if (this.IsLocal() && !this.IsStatic() && !this.IsConstant() && !this.IsFunctionParameter()) {\n                const functionBlock = this._eventSheetManager.FindFirstFunctionBlockParent(this);\n                if (functionBlock)\n                    functionBlock._RegisterLocalVariable(this)\n            }\n        }\n        GetName() {\n            return this._name\n        }\n        GetJsPropName() {\n            return this._jsPropName\n        }\n        GetParent() {\n            return this._parent\n        }\n        GetScopeParent() {\n            return this.GetParent()\n        }\n        IsGlobal() {\n            return !this.GetParent()\n        }\n        IsLocal() {\n            return !this.IsGlobal()\n        }\n        IsFunctionParameter() {\n            return this._isFunctionParameter\n        }\n        IsStatic() {\n            return this._isStatic\n        }\n        IsConstant() {\n            return this._isConstant\n        }\n        IsNumber() {\n            return this._type === 0\n        }\n        IsString() {\n            return this._type === 1\n        }\n        IsBoolean() {\n            return this._type === 2\n        }\n        IsElseBlock() {\n            return false\n        }\n        GetSID() {\n            return this._sid\n        }\n        GetInitialValue() {\n            return this._initialValue\n        }\n        GetSolModifiers() {\n            return EMPTY_SOL_MODIFIERS\n        }\n        Run(frame) {\n            if (this.IsLocal() && !this.IsStatic() && !this.IsConstant())\n                this.SetValue(this.GetInitialValue())\n        }\n        DebugCanRunFast() {\n            return true\n        }\n        *DebugRun(frame) {\n            this.Run(frame)\n        }\n        SetValue(v) {\n            if (this.IsNumber()) {\n                if (typeof v !== "number")\n                    v = parseFloat(v)\n            } else if (this.IsString()) {\n                if (typeof v !== "string")\n                    v = v.toString()\n            } else if (this.IsBoolean())\n                v = v ? 1 : 0;\n            if (this._hasSingleValue)\n                this._value = v;\n            else\n                this._localVarStack.GetCurrent()[this._localIndex] = v\n        }\n        GetValue() {\n            return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex]\n        }\n        GetTypedValue() {\n            let ret = this.GetValue();\n            if (this.IsBoolean())\n                ret = !!ret;\n            return ret\n        }\n        ResetToInitialValue() {\n            this._value = this._initialValue\n        }\n        _GetScriptInterfaceDescriptor() {\n            return {\n                configurable: false,\n                enumerable: true,\n                get: this._scriptGetter,\n                set: this._scriptSetter\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/eventInclude.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const assert = self.assert;\n    const EMPTY_SOL_MODIFIERS = [];\n    C3.EventInclude = class EventInclude extends C3.DefendedBase {\n        constructor(eventSheet, parent, data) {\n            super();\n            const eventSheetManager = eventSheet.GetEventSheetManager();\n            this._eventSheet = eventSheet;\n            this._eventSheetManager = eventSheetManager;\n            this._runtime = eventSheet.GetRuntime();\n            this._parent = parent;\n            this._includeSheet = null;\n            this._includeSheetName = data[1];\n            this._isActive = true\n        }\n        static Create(eventSheet, parent, data) {\n            return C3.New(C3.EventInclude, eventSheet, parent, data)\n        }\n        _PostInit() {\n            this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName);\n            this._eventSheet._AddShallowInclude(this);\n            let p = this.GetParent();\n            while (p) {\n                if (p instanceof C3.EventBlock && p.IsGroup())\n                    p._AddContainedInclude(this);\n                p = p.GetParent()\n            }\n            this.UpdateActive();\n            if (this._runtime.IsDebug())\n                this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord())\n        }\n        GetParent() {\n            return this._parent\n        }\n        GetSolModifiers() {\n            return EMPTY_SOL_MODIFIERS\n        }\n        GetIncludeSheet() {\n            return this._includeSheet\n        }\n        Run(frame) {\n            const pushSol = !!this.GetParent();\n            const allObjectClasses = this._runtime.GetAllObjectClasses();\n            if (pushSol)\n                this._eventSheetManager.PushCleanSol(allObjectClasses);\n            this._includeSheet.Run();\n            if (pushSol)\n                this._eventSheetManager.PopSol(allObjectClasses)\n        }\n        *DebugRun(frame) {\n            const pushSol = !!this.GetParent();\n            const allObjectClasses = this._runtime.GetAllObjectClasses();\n            if (pushSol)\n                this._eventSheetManager.PushCleanSol(allObjectClasses);\n            yield*this._includeSheet.DebugRun();\n            if (pushSol)\n                this._eventSheetManager.PopSol(allObjectClasses)\n        }\n        DebugCanRunFast() {\n            return false\n        }\n        IsActive() {\n            return this._isActive\n        }\n        UpdateActive() {\n            let p = this.GetParent();\n            while (p) {\n                if (p instanceof C3.EventBlock && p.IsGroup() && !p.IsGroupActive()) {\n                    this._isActive = false;\n                    return\n                }\n                p = p.GetParent()\n            }\n            this._isActive = true\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/expNode.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const assert = self.assert;\n    C3.ExpNode = class ExpNode extends C3.DefendedBase {\n        constructor(owner) {\n            super();\n            this._owner = owner;\n            this._runtime = owner.GetRuntime()\n        }\n        _PostInit() {}\n        static CreateNode(owner, data) {\n            const type = data[0];\n            const Classes = [BehaviorExpressionNode, ObjectExpressionNode, InstVarExpressionNode, EventVarExpNode, SystemExpressionExpNode, CallFunctionExpressionExpNode];\n            return C3.New(Classes[type], owner, data)\n        }\n    }\n    ;\n    class SystemExpressionExpNode extends C3.ExpNode {\n        constructor(owner, data) {\n            super(owner);\n            this._systemPlugin = this._runtime.GetSystemPlugin();\n            this._func = this._runtime.GetObjectReference(data[1]);\n            if (this._func === C3.Plugins.System.Exps.random || this._func === C3.Plugins.System.Exps.choose)\n                this._owner.SetVariesPerInstance()\n        }\n        GetBoundMethod() {\n            return this._systemPlugin._GetBoundACEMethod(this._func, this._systemPlugin)\n        }\n    }\n    class CallFunctionExpressionExpNode extends C3.ExpNode {\n        constructor(owner, data) {\n            super(owner);\n            this._functionBlock = null;\n            this._functionName = data[1];\n            this._owner.SetVariesPerInstance()\n        }\n        _PostInit() {\n            const eventSheetManager = this._runtime.GetEventSheetManager();\n            this._functionBlock = eventSheetManager.GetFunctionBlockByName(this._functionName);\n            this._functionName = null;\n            const myEventBlock = this._owner.GetEventBlock();\n            const callEventBlock = this._functionBlock.GetEventBlock();\n            this._combinedSolModifiers = [...(new Set([...myEventBlock.GetSolModifiersIncludingParents(), ...callEventBlock.GetSolModifiersIncludingParents()]))];\n            this._combinedSolModifiers = eventSheetManager._DeduplicateSolModifierList(this._combinedSolModifiers)\n        }\n        GetBoundMethod() {\n            const functionBlock = this._functionBlock;\n            if (functionBlock.IsEnabled()) {\n                const callEventBlock = functionBlock.GetEventBlock();\n                return C3.EventBlock.prototype.RunAsExpressionFunctionCall.bind(callEventBlock, this._combinedSolModifiers, functionBlock.GetReturnType(), functionBlock.GetDefaultReturnValue())\n            } else {\n                const defaultReturnValue = functionBlock.GetDefaultReturnValue();\n                return () => defaultReturnValue\n            }\n        }\n    }\n    function WrapIndex(index, len) {\n        if (index >= len)\n            return index % len;\n        else if (index < 0) {\n            if (index <= -len)\n                index %= len;\n            if (index < 0)\n                index += len;\n            return index\n        } else\n            return index\n    }\n    class ObjectExpressionNode extends C3.ExpNode {\n        constructor(owner, data) {\n            super(owner);\n            this._objectClass = this._runtime.GetObjectClassByIndex(data[1]);\n            this._func = this._runtime.GetObjectReference(data[2]);\n            this._returnsString = !!data[3];\n            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();\n            this._owner._MaybeVaryFor(this._objectClass)\n        }\n        GetBoundMethod() {\n            return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance())\n        }\n        ExpObject(...args) {\n            const objectClass = this._objectClass;\n            const instances = objectClass.GetCurrentSol().GetExpressionInstances();\n            const len = instances.length;\n            if (len === 0)\n                return this._returnsString ? "" : 0;\n            const index = WrapIndex(this._owner.GetSolIndex(), len);\n            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(objectClass);\n            return this._func.apply(instances[index].GetSdkInstance(), args)\n        }\n        ExpObject_InstExpr(instIndex, ...args) {\n            const objectClass = this._objectClass;\n            const instances = objectClass.GetInstances();\n            const len = instances.length;\n            if (len === 0)\n                return this._returnsString ? "" : 0;\n            const index = WrapIndex(instIndex, len);\n            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(objectClass);\n            return this._func.apply(instances[index].GetSdkInstance(), args)\n        }\n    }\n    class InstVarExpressionNode extends C3.ExpNode {\n        constructor(owner, data) {\n            super(owner);\n            this._objectClass = this._runtime.GetObjectClassByIndex(data[1]);\n            this._varIndex = data[3];\n            this._returnsString = !!data[2];\n            this._owner._MaybeVaryFor(this._objectClass)\n        }\n        ExpInstVar() {\n            const instances = this._objectClass.GetCurrentSol().GetExpressionInstances();\n            const len = instances.length;\n            if (len === 0)\n                return this._returnsString ? "" : 0;\n            const index = WrapIndex(this._owner.GetSolIndex(), len);\n            return instances[index]._GetInstanceVariableValueUnchecked(this._varIndex)\n        }\n        ExpInstVar_Family() {\n            const objectClass = this._objectClass;\n            const instances = objectClass.GetCurrentSol().GetExpressionInstances();\n            const len = instances.length;\n            if (len === 0)\n                return this._returnsString ? "" : 0;\n            const index = WrapIndex(this._owner.GetSolIndex(), len);\n            const inst = instances[index];\n            const offset = inst.GetObjectClass().GetFamilyInstanceVariableOffset(objectClass.GetFamilyIndex());\n            return inst._GetInstanceVariableValueUnchecked(this._varIndex + offset)\n        }\n        ExpInstVar_InstExpr(instIndex) {\n            const objectClass = this._objectClass;\n            const instances = objectClass.GetInstances();\n            const len = instances.length;\n            if (len === 0)\n                return this._returnsString ? "" : 0;\n            const index = WrapIndex(instIndex, len);\n            const inst = instances[index];\n            let offset = 0;\n            if (objectClass.IsFamily())\n                offset = inst.GetObjectClass().GetFamilyInstanceVariableOffset(objectClass.GetFamilyIndex());\n            return inst._GetInstanceVariableValueUnchecked(this._varIndex + offset)\n        }\n    }\n    class BehaviorExpressionNode extends C3.ExpNode {\n        constructor(owner, data) {\n            super(owner);\n            this._objectClass = this._runtime.GetObjectClassByIndex(data[1]);\n            this._behaviorType = this._objectClass.GetBehaviorTypeByName(data[2]);\n            this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(data[2]);\n            this._func = this._runtime.GetObjectReference(data[3]);\n            this._returnsString = !!data[4];\n            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();\n            this._owner._MaybeVaryFor(this._objectClass)\n        }\n        ExpBehavior(...args) {\n            const objectClass = this._objectClass;\n            const instances = objectClass.GetCurrentSol().GetExpressionInstances();\n            const len = instances.length;\n            if (len === 0)\n                return this._returnsString ? "" : 0;\n            const index = WrapIndex(this._owner.GetSolIndex(), len);\n            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(objectClass);\n            const inst = instances[index];\n            let offset = 0;\n            if (objectClass.IsFamily())\n                offset = inst.GetObjectClass().GetFamilyBehaviorOffset(objectClass.GetFamilyIndex());\n            return this._func.apply(inst.GetBehaviorInstances()[this._behaviorIndex + offset].GetSdkInstance(), args)\n        }\n        ExpBehavior_InstExpr(instIndex, ...args) {\n            const objectClass = this._objectClass;\n            const instances = objectClass.GetInstances();\n            const len = instances.length;\n            if (len === 0)\n                return this._returnsString ? "" : 0;\n            const index = WrapIndex(instIndex, len);\n            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(objectClass);\n            const inst = instances[index];\n            let offset = 0;\n            if (objectClass.IsFamily())\n                offset = inst.GetObjectClass().GetFamilyBehaviorOffset(objectClass.GetFamilyIndex());\n            return this._func.apply(inst.GetBehaviorInstances()[this._behaviorIndex + offset].GetSdkInstance(), args)\n        }\n    }\n    class EventVarExpNode extends C3.ExpNode {\n        constructor(owner, data) {\n            super(owner);\n            this._eventVar = null;\n            this._eventVarSid = data[1]\n        }\n        _PostInit() {\n            this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)\n        }\n        GetVar() {\n            return this._eventVar\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/parameter.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const assert = self.assert;\n    C3.Parameter = class Parameter extends C3.DefendedBase {\n        constructor(owner, type, index) {\n            super();\n            this._owner = owner;\n            this._index = index;\n            this._type = type;\n            this.Get = null;\n            this._variesPerInstance = false;\n            this._isConstant = false\n        }\n        static Create(owner, data, index) {\n            const type = data[0];\n            const Classes = [ExpressionParameter, StringExpressionParameter, FileParameter, ComboParameter, ObjectParameter, LayerExpressionParameter, LayoutParameter, ExpressionParameter, ComboParameter, ComboParameter, InstVarParameter, EventVarParameter, FileParameter, VariadicParameter, StringExpressionParameter, TimelineParameter, BooleanParameter, FunctionParameter, EaseParameter, TilemapBrushParameter, TemplateExpressionParameter];\n            return C3.New(Classes[type], owner, type, index, data)\n        }\n        _PostInit() {}\n        SetVariesPerInstance() {\n            this._variesPerInstance = true\n        }\n        _MaybeVaryFor(objectClass) {\n            if (this._variesPerInstance)\n                return;\n            if (!objectClass)\n                return;\n            if (!objectClass.GetPlugin().IsSingleGlobal())\n                this._variesPerInstance = true\n        }\n        VariesPerInstance() {\n            return this._variesPerInstance\n        }\n        GetIndex() {\n            return this._index\n        }\n        GetRuntime() {\n            return this._owner.GetRuntime()\n        }\n        GetEventBlock() {\n            return this._owner.GetEventBlock()\n        }\n        IsConstant() {\n            return this._isConstant\n        }\n    }\n    ;\n    function GetExpressionFunc(number) {\n        const ret = self.C3_ExpressionFuncs[number];\n        if (!ret)\n            throw new Error("invalid expression number");\n        return ret\n    }\n    class ExpressionParameter extends C3.Parameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index);\n            this._solIndex = 0;\n            const expData = data[1];\n            this._expressionNumber = expData[0];\n            this._numberedNodes = [];\n            this._expressionFunc = null;\n            for (let i = 1, len = expData.length; i < len; ++i)\n                this._numberedNodes.push(C3.ExpNode.CreateNode(this, expData[i]));\n            if (this._numberedNodes.length)\n                this.Get = this.GetExpression;\n            else {\n                this.Get = GetExpressionFunc(this._expressionNumber);\n                this._isConstant = true\n            }\n        }\n        _GetNode(i) {\n            if (i < 0 || i >= this._numberedNodes.length)\n                throw new RangeError("invalid numbered node");\n            return this._numberedNodes[i]\n        }\n        _PostInit() {\n            for (const node of this._numberedNodes)\n                node._PostInit();\n            const func = GetExpressionFunc(this._expressionNumber);\n            if (this._numberedNodes.length)\n                this._expressionFunc = func(this);\n            else\n                this._expressionFunc = func\n        }\n        GetSolIndex() {\n            return this._solIndex\n        }\n        GetExpression(solIndex) {\n            this._solIndex = solIndex;\n            return this._expressionFunc()\n        }\n    }\n    class StringExpressionParameter extends ExpressionParameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index, data);\n            this.Get = this.GetStringExpression;\n            if (type === 14) {\n                this.GetEventBlock().SetAllSolModifiers();\n                if (this._owner instanceof C3.Action)\n                    this.GetEventBlock().SetSolWriterAfterCnds()\n            }\n        }\n        GetStringExpression(solIndex) {\n            this._solIndex = solIndex;\n            const ret = this._expressionFunc();\n            if (typeof ret === "string")\n                return ret;\n            else\n                return ""\n        }\n        _GetFastTriggerValue() {\n            return GetExpressionFunc(this._expressionNumber)()\n        }\n    }\n    class LayerExpressionParameter extends ExpressionParameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index, data);\n            this.Get = this.GetLayer;\n            this._isConstant = false\n        }\n        GetLayer(solIndex) {\n            this._solIndex = solIndex;\n            const ret = this._expressionFunc();\n            const layout = this.GetRuntime().GetCurrentLayout();\n            return layout.GetLayer(ret)\n        }\n    }\n    class ComboParameter extends C3.Parameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index);\n            this._combo = data[1];\n            this.Get = this.GetCombo;\n            this._isConstant = true\n        }\n        GetCombo() {\n            return this._combo\n        }\n    }\n    class BooleanParameter extends C3.Parameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index);\n            this._bool = data[1];\n            this.Get = this.GetBoolean;\n            this._isConstant = true\n        }\n        GetBoolean() {\n            return this._bool\n        }\n    }\n    class ObjectParameter extends C3.Parameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index);\n            this._objectClass = this.GetRuntime().GetObjectClassByIndex(data[1]);\n            this.Get = this.GetObjectClass;\n            const eventBlock = this.GetEventBlock();\n            eventBlock._AddSolModifier(this._objectClass);\n            if (this._owner instanceof C3.Action)\n                eventBlock.SetSolWriterAfterCnds();\n            else if (eventBlock.GetParent())\n                eventBlock.GetParent().SetSolWriterAfterCnds();\n            this._isConstant = true\n        }\n        GetObjectClass() {\n            return this._objectClass\n        }\n    }\n    class LayoutParameter extends C3.Parameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index);\n            this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(data[1]);\n            this.Get = this.GetLayout;\n            this._isConstant = true\n        }\n        GetLayout() {\n            return this._layout\n        }\n    }\n    class TimelineParameter extends C3.Parameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index);\n            this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(data[1]);\n            this.Get = this.GetTimeline;\n            this._isConstant = true\n        }\n        GetTimeline() {\n            return this._timeline\n        }\n    }\n    class FileParameter extends C3.Parameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index);\n            this._fileInfo = data[1];\n            this.Get = this.GetFile;\n            this._isConstant = true\n        }\n        GetFile() {\n            return this._fileInfo\n        }\n    }\n    class InstVarParameter extends C3.Parameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index);\n            this._instVarIndex = data[1];\n            const ownerObjectClass = this._owner.GetObjectClass();\n            if (ownerObjectClass && ownerObjectClass.IsFamily()) {\n                this.Get = this.GetFamilyInstanceVariable;\n                this.SetVariesPerInstance()\n            } else {\n                this.Get = this.GetInstanceVariable;\n                this._isConstant = true\n            }\n        }\n        GetInstanceVariable() {\n            return this._instVarIndex\n        }\n        GetFamilyInstanceVariable(solIndex) {\n            solIndex = solIndex || 0;\n            const familyType = this._owner.GetObjectClass();\n            const sol = familyType.GetCurrentSol();\n            const instances = sol.GetInstances();\n            let realType = null;\n            if (instances.length)\n                realType = instances[solIndex % instances.length].GetObjectClass();\n            else if (sol.HasAnyElseInstances()) {\n                const elseInstances = sol.GetElseInstances();\n                realType = elseInstances[solIndex % elseInstances.length].GetObjectClass()\n            } else if (familyType.GetInstanceCount() > 0) {\n                const familyInstances = familyType.GetInstances();\n                realType = familyInstances[solIndex % familyInstances.length].GetObjectClass()\n            } else\n                return 0;\n            return this._instVarIndex + realType.GetFamilyInstanceVariableOffset(familyType.GetFamilyIndex())\n        }\n    }\n    class EventVarParameter extends C3.Parameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index);\n            this._eventVarSid = data[1];\n            this._eventVar = null;\n            this.Get = this.GetEventVariable;\n            this._isConstant = true\n        }\n        _PostInit() {\n            this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)\n        }\n        GetEventVariable() {\n            return this._eventVar\n        }\n    }\n    class FunctionParameter extends C3.Parameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index);\n            this._functionBlockName = data[1];\n            this._functionBlock = null;\n            this.Get = this.GetFunction;\n            this._isConstant = true\n        }\n        _PostInit() {\n            this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName);\n            this._functionBlockName = null\n        }\n        GetFunction() {\n            return this._functionBlock\n        }\n    }\n    class VariadicParameter extends C3.Parameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index);\n            this._subParams = [];\n            this._variadicRet = [];\n            this._isConstant = true;\n            for (let i = 1, len = data.length; i < len; ++i) {\n                const subParam = C3.Parameter.Create(this._owner, data[i], 0);\n                this._subParams.push(subParam);\n                this._variadicRet.push(0);\n                if (!subParam.IsConstant())\n                    this._isConstant = false\n            }\n            this.Get = this.GetVariadic\n        }\n        _PostInit() {\n            for (const subParam of this._subParams)\n                subParam._PostInit()\n        }\n        GetVariadic() {\n            const subParams = this._subParams;\n            const variadicRet = this._variadicRet;\n            for (let i = 0, len = subParams.length; i < len; ++i)\n                variadicRet[i] = subParams[i].Get(0);\n            return variadicRet\n        }\n    }\n    class EaseParameter extends C3.Parameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index);\n            this._easeIndex = data[1];\n            this.Get = this.GetEase;\n            this._isConstant = true\n        }\n        GetEase() {\n            return this._easeIndex\n        }\n    }\n    class TilemapBrushParameter extends C3.Parameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index);\n            this._brushIndex = data[1];\n            this.Get = this.GetTilemapBrush;\n            this._isConstant = true\n        }\n        GetTilemapBrush() {\n            return this._brushIndex\n        }\n    }\n    class TemplateExpressionParameter extends ExpressionParameter {\n        constructor(owner, type, index, data) {\n            super(owner, type, index, data);\n            this.Get = this.GetTemplateName;\n            this._isConstant = false\n        }\n        GetTemplateName() {\n            return this._expressionFunc()\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/condition.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const assert = self.assert;\n    function EvalParams(parameters, results) {\n        for (let i = 0, len = parameters.length; i < len; ++i)\n            results[i] = parameters[i].Get(0)\n    }\n    const EMPTY_PARAMS_ARRAY = [];\n    const noop = function() {};\n    C3.Condition = class Condition extends C3.DefendedBase {\n        constructor(eventBlock, data, index) {\n            super();\n            this._eventBlock = eventBlock;\n            this._runtime = eventBlock.GetRuntime();\n            this._index = index;\n            this._func = this._runtime.GetObjectReference(data[1]);\n            this._isTrigger = data[3] > 0;\n            this._isFastTrigger = data[3] === 2;\n            this._isLooping = !!data[4];\n            this._isInverted = !!data[5];\n            this._isStatic = !!data[6];\n            this._sid = data[7];\n            this._isInOrBlock = this._eventBlock.IsOrBlock();\n            this._objectClass = null;\n            this._behaviorType = null;\n            this._behaviorIndex = -1;\n            this._systemPlugin = null;\n            this.Run = noop;\n            this.DebugRun = noop;\n            this._parameters = [];\n            this._results = [];\n            this._anyParamVariesPerInstance = false;\n            this._savedData = null;\n            this._unsavedData = null;\n            this._debugData = this._runtime.IsDebug() ? {\n                isBreakpoint: data[8][0],\n                canDebug: data[8][1]\n            } : null;\n            if (data[0] === -1)\n                this._systemPlugin = this._runtime.GetSystemPlugin();\n            else {\n                this._objectClass = this._runtime.GetObjectClassByIndex(data[0]);\n                if (data[2]) {\n                    this._behaviorType = this._objectClass.GetBehaviorTypeByName(data[2]);\n                    this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(data[2])\n                }\n                if (this._eventBlock.GetParent())\n                    this._eventBlock.GetParent().SetSolWriterAfterCnds()\n            }\n            if (data.length === 10) {\n                let paramData = data[9];\n                for (let data of paramData) {\n                    this._parameters.push(C3.Parameter.Create(this, data, this._parameters.length));\n                    this._results.push(0)\n                }\n            }\n            if (this._parameters.length === 0) {\n                this._parameters = EMPTY_PARAMS_ARRAY;\n                this._results = EMPTY_PARAMS_ARRAY\n            }\n            this._eventBlock.GetEventSheetManager()._RegisterCondition(this)\n        }\n        static Create(eventBlock, data, index) {\n            return C3.New(C3.Condition, eventBlock, data, index)\n        }\n        _PostInit() {\n            for (const param of this._parameters) {\n                param._PostInit();\n                if (param.VariesPerInstance())\n                    this._anyParamVariesPerInstance = true\n            }\n            if (this._isFastTrigger) {\n                this.Run = this._RunFastTrigger;\n                this.DebugRun = this._DebugRunFastTrigger\n            } else if (this._systemPlugin) {\n                this._SetSystemRunMethod();\n                this.DebugRun = this._DebugRunSystem\n            } else if (this._objectClass.GetPlugin().IsSingleGlobal()) {\n                this._SetSingleGlobalRunMethod();\n                this.DebugRun = this._DebugRunSingleGlobal\n            } else if (this._isStatic) {\n                this.Run = this._RunStatic;\n                this.DebugRun = this._DebugRunStatic\n            } else {\n                this.Run = this._RunObject;\n                this.DebugRun = this._DebugRunObject\n            }\n        }\n        _SetSystemRunMethod() {\n            const plugin = this._systemPlugin;\n            const bindThis = this._systemPlugin;\n            this._SetRunMethodForBoundFunc(plugin, bindThis, this._RunSystem)\n        }\n        _SetSingleGlobalRunMethod() {\n            const plugin = this._objectClass.GetPlugin();\n            const bindThis = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();\n            this._SetRunMethodForBoundFunc(plugin, bindThis, this._RunSingleGlobal)\n        }\n        _SetRunMethodForBoundFunc(plugin, bindThis, fallbackMethod) {\n            const func = this._func;\n            const isInverted = this._isInverted;\n            const parameters = this._parameters;\n            if (parameters.length === 0) {\n                const boundFunc = plugin._GetBoundACEMethod(func, bindThis);\n                if (isInverted)\n                    this.Run = function RunSingleCnd_0param() {\n                        return C3.xor(boundFunc(), isInverted)\n                    }\n                    ;\n                else\n                    this.Run = boundFunc\n            } else if (parameters.length === 1) {\n                const param0 = parameters[0];\n                if (!isInverted && param0.IsConstant())\n                    this.Run = plugin._GetBoundACEMethod_1param(func, bindThis, param0.Get(0));\n                else {\n                    const boundFunc = plugin._GetBoundACEMethod(func, bindThis);\n                    this.Run = function RunSingleCnd_1param() {\n                        return C3.xor(boundFunc(param0.Get(0)), isInverted)\n                    }\n                }\n            } else if (parameters.length === 2) {\n                const param0 = parameters[0];\n                const param1 = parameters[1];\n                if (!isInverted && param0.IsConstant() && param1.IsConstant())\n                    this.Run = plugin._GetBoundACEMethod_2params(func, bindThis, param0.Get(0), param1.Get(0));\n                else {\n                    const boundFunc = plugin._GetBoundACEMethod(func, bindThis);\n                    this.Run = function RunSingleCnd_2params() {\n                        return C3.xor(boundFunc(param0.Get(0), param1.Get(0)), isInverted)\n                    }\n                }\n            } else if (parameters.length === 3) {\n                const param0 = parameters[0];\n                const param1 = parameters[1];\n                const param2 = parameters[2];\n                if (!isInverted && param0.IsConstant() && param1.IsConstant() && param2.IsConstant())\n                    this.Run = plugin._GetBoundACEMethod_3params(func, bindThis, param0.Get(0), param1.Get(0), param2.Get(0));\n                else {\n                    const boundFunc = plugin._GetBoundACEMethod(func, bindThis);\n                    this.Run = function RunSingleCnd_3params() {\n                        return C3.xor(boundFunc(param0.Get(0), param1.Get(0), param2.Get(0)), isInverted)\n                    }\n                }\n            } else\n                this.Run = fallbackMethod\n        }\n        GetSID() {\n            return this._sid\n        }\n        _GetFunc() {\n            return this._func\n        }\n        GetObjectClass() {\n            return this._objectClass\n        }\n        GetBehaviorType() {\n            return this._behaviorType\n        }\n        GetEventBlock() {\n            return this._eventBlock\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetIndex() {\n            return this._index\n        }\n        GetDebugIndex() {\n            return this.GetIndex()\n        }\n        IsTrigger() {\n            return this._isTrigger\n        }\n        IsFastTrigger() {\n            return this._isFastTrigger\n        }\n        IsInverted() {\n            return this._isInverted\n        }\n        IsLooping() {\n            return this._isLooping\n        }\n        IsBreakpoint() {\n            return this._debugData.isBreakpoint\n        }\n        _SetBreakpoint(b) {\n            this._debugData.isBreakpoint = !!b;\n            this._eventBlock._UpdateCanRunFastRecursive()\n        }\n        _DebugReturnsGenerator() {\n            return this._debugData.canDebug\n        }\n        DebugCanRunFast() {\n            return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()\n        }\n        GetSavedDataMap() {\n            if (!this._savedData)\n                this._savedData = new Map;\n            return this._savedData\n        }\n        GetUnsavedDataMap() {\n            if (!this._unsavedData)\n                this._unsavedData = new Map;\n            return this._unsavedData\n        }\n        _RunSystem() {\n            const results = this._results;\n            EvalParams(this._parameters, results);\n            return C3.xor(this._func.apply(this._systemPlugin, results), this._isInverted)\n        }\n        *_DebugRunSystem() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            if (this._DebugReturnsGenerator()) {\n                const results = this._results;\n                EvalParams(this._parameters, results);\n                let ret = this._func.apply(this._systemPlugin, results);\n                if (C3.IsIterator(ret))\n                    ret = yield*ret;\n                return C3.xor(ret, this._isInverted)\n            } else\n                return this.Run()\n        }\n        _RunSingleGlobal() {\n            const results = this._results;\n            EvalParams(this._parameters, results);\n            const inst = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();\n            return C3.xor(this._func.apply(inst, results), this._isInverted)\n        }\n        *_DebugRunSingleGlobal() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            if (this._DebugReturnsGenerator()) {\n                const results = this._results;\n                EvalParams(this._parameters, results);\n                const inst = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();\n                let ret = this._func.apply(inst, results);\n                if (C3.IsIterator(ret))\n                    ret = yield*ret;\n                return C3.xor(ret, this._isInverted)\n            } else\n                return this.Run()\n        }\n        _RunFastTrigger() {\n            return true\n        }\n        *_DebugRunFastTrigger() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            return true\n        }\n        _RunStatic() {\n            const results = this._results;\n            EvalParams(this._parameters, results);\n            const ret = this._func.apply(this._behaviorType || this._objectClass, results);\n            this._objectClass.ApplySolToContainer();\n            return ret\n        }\n        *_DebugRunStatic() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            if (this._DebugReturnsGenerator()) {\n                const results = this._results;\n                EvalParams(this._parameters, results);\n                let ret = this._func.apply(this._behaviorType || this._objectClass, results);\n                if (C3.IsIterator(ret))\n                    ret = yield*ret;\n                this._objectClass.ApplySolToContainer();\n                return ret\n            } else\n                return this.Run()\n        }\n        _RunObject() {\n            const parameters = this._parameters;\n            const results = this._results;\n            const sol = this._objectClass.GetCurrentSol();\n            for (let i = 0, len = parameters.length; i < len; ++i) {\n                const p = parameters[i];\n                if (!p.VariesPerInstance())\n                    results[i] = p.Get(0)\n            }\n            if (sol.IsSelectAll())\n                return this._RunObject_FirstFilter(sol);\n            else\n                return this._RunObject_NextFilter(sol)\n        }\n        *_DebugRunObject() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            return this._RunObject()\n        }\n        _EvaluateVaryingParameters(solIndex) {\n            const parameters = this._parameters;\n            const results = this._results;\n            for (let i = 0, len = parameters.length; i < len; ++i) {\n                const p = parameters[i];\n                if (p.VariesPerInstance())\n                    results[i] = p.Get(solIndex)\n            }\n        }\n        _RunObject_FirstFilter(sol) {\n            const objectClass = this._objectClass;\n            const isFamily = objectClass.IsFamily();\n            const familyIndex = objectClass.GetFamilyIndex();\n            const behaviorIndex = this._behaviorIndex;\n            const isBehavior = behaviorIndex >= 0;\n            const allInstances = objectClass.GetInstances();\n            const paramsVary = this._anyParamVariesPerInstance;\n            const results = this._results;\n            const func = this._func;\n            const isInverted = this._isInverted;\n            const isInOrBlock = this._isInOrBlock && !this._isTrigger;\n            sol.ClearArrays();\n            for (let i = 0, len = allInstances.length; i < len; ++i) {\n                const inst = allInstances[i];\n                if (paramsVary)\n                    this._EvaluateVaryingParameters(i);\n                let ret;\n                if (isBehavior) {\n                    const offset = isFamily ? inst.GetObjectClass().GetFamilyBehaviorOffset(familyIndex) : 0;\n                    ret = func.apply(inst.GetBehaviorInstances()[behaviorIndex + offset].GetSdkInstance(), results)\n                } else\n                    ret = func.apply(inst.GetSdkInstance(), results);\n                if (C3.xor(ret, isInverted))\n                    sol._PushInstance(inst);\n                else if (isInOrBlock)\n                    sol._PushElseInstance(inst)\n            }\n            objectClass.FinishCondition(true);\n            sol._SetSelectAll(false);\n            objectClass.ApplySolToContainer();\n            return sol.HasAnyInstances()\n        }\n        _RunObject_NextFilter(sol) {\n            const objectClass = this._objectClass;\n            const isFamily = objectClass.IsFamily();\n            const familyIndex = objectClass.GetFamilyIndex();\n            const isInContainer = objectClass.IsInContainer();\n            const behaviorIndex = this._behaviorIndex;\n            const isBehavior = behaviorIndex >= 0;\n            const paramsVary = this._anyParamVariesPerInstance;\n            const results = this._results;\n            const func = this._func;\n            const isInverted = this._isInverted;\n            const isInOrBlock = this._isInOrBlock && !this._isTrigger;\n            const solInstances = sol._GetOwnInstances();\n            const solElseInstances = sol._GetOwnElseInstances();\n            const isUsingElseInstances = isInOrBlock && !this._eventBlock.IsFirstConditionOfType(this);\n            const arr = isUsingElseInstances ? solElseInstances : solInstances;\n            let k = 0;\n            let isAnyTrue = false;\n            for (let i = 0, len = arr.length; i < len; ++i) {\n                const inst = arr[i];\n                if (paramsVary)\n                    this._EvaluateVaryingParameters(i);\n                let ret;\n                if (isBehavior) {\n                    const offset = isFamily ? inst.GetObjectClass().GetFamilyBehaviorOffset(familyIndex) : 0;\n                    ret = func.apply(inst.GetBehaviorInstances()[behaviorIndex + offset].GetSdkInstance(), results)\n                } else\n                    ret = func.apply(inst.GetSdkInstance(), results);\n                if (C3.xor(ret, isInverted)) {\n                    isAnyTrue = true;\n                    if (isUsingElseInstances) {\n                        solInstances.push(inst);\n                        if (isInContainer)\n                            inst._PushSiblingsToSolInstances()\n                    } else {\n                        arr[k] = inst;\n                        if (isInContainer)\n                            inst._SetSiblingsToSolInstancesIndex(k);\n                        ++k\n                    }\n                } else if (isUsingElseInstances) {\n                    arr[k] = inst;\n                    if (isInContainer)\n                        inst._SetSiblingsToSolElseInstancesIndex(k);\n                    ++k\n                } else if (isInOrBlock) {\n                    solElseInstances.push(inst);\n                    if (isInContainer)\n                        inst._PushSiblingsToSolElseInstances()\n                }\n            }\n            C3.truncateArray(arr, k);\n            if (isInContainer)\n                objectClass._TruncateContainerSols(isUsingElseInstances, k);\n            const pickInFinish = isAnyTrue;\n            if (isUsingElseInstances && !isAnyTrue)\n                isAnyTrue = this._OrBlockCheckInstances(solInstances);\n            objectClass.FinishCondition(pickInFinish || isInOrBlock);\n            return isInOrBlock ? isAnyTrue : sol.HasAnyInstances()\n        }\n        _OrBlockCheckInstances(solInstances) {\n            const objectClass = this._objectClass;\n            const isFamily = objectClass.IsFamily();\n            const familyIndex = objectClass.GetFamilyIndex();\n            const paramsVary = this._anyParamVariesPerInstance;\n            const behaviorIndex = this._behaviorIndex;\n            const isBehavior = behaviorIndex >= 0;\n            const results = this._results;\n            const func = this._func;\n            const isInverted = this._isInverted;\n            for (let i = 0, len = solInstances.length; i < len; ++i) {\n                const inst = solInstances[i];\n                if (paramsVary)\n                    this._EvaluateVaryingParameters(i);\n                let ret;\n                if (isBehavior) {\n                    const offset = isFamily ? inst.GetObjectClass().GetFamilyBehaviorOffset(familyIndex) : 0;\n                    ret = func.apply(inst.GetBehaviorInstances()[behaviorIndex + offset].GetSdkInstance(), results)\n                } else\n                    ret = func.apply(inst.GetSdkInstance(), results);\n                if (C3.xor(ret, isInverted))\n                    return true\n            }\n            return false\n        }\n        ReevaluateParameter(paramIndex, solIndex) {\n            return this._parameters[paramIndex].Get(solIndex)\n        }\n        GetFastTriggerValue() {\n            const parameters = this._parameters;\n            if (!parameters.length)\n                throw new Error("no parameters");\n            return parameters[0]._GetFastTriggerValue()\n        }\n        _SaveToJson() {\n            if (!this._savedData || !this._savedData.size)\n                return null;\n            const ex = {};\n            for (const [k,v] of this._savedData.entries()) {\n                let saveVal = v;\n                if (k === "collmemory")\n                    saveVal = [...v.entries()].map(arr => [arr[0].GetUID(), arr[1].GetUID(), arr[2]]);\n                ex[k] = saveVal\n            }\n            return {\n                "ex": ex\n            }\n        }\n        _LoadFromJson(o) {\n            if (this._savedData) {\n                this._savedData.clear();\n                this._savedData = null\n            }\n            if (!o)\n                return;\n            const runtime = this._runtime;\n            const ex = o["ex"];\n            if (ex) {\n                const map = this.GetSavedDataMap();\n                map.clear();\n                for (const [k,v] of Object.entries(ex)) {\n                    let loadVal = v;\n                    if (k === "collmemory")\n                        loadVal = C3.New(C3.PairMap, v.map(arr => [runtime.GetInstanceByUID(arr[0]), runtime.GetInstanceByUID(arr[1]), arr[2]]).filter(arr => arr[0] && arr[1]));\n                    map.set(k, loadVal)\n                }\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/action.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const assert = self.assert;\n    function EvalParams(parameters, results) {\n        for (let i = 0, len = parameters.length; i < len; ++i)\n            results[i] = parameters[i].Get(0)\n    }\n    const EMPTY_PARAMS_ARRAY = [];\n    const noop = function() {};\n    const noopGenerator = function*() {};\n    C3.Action = class Action extends C3.DefendedBase {\n        constructor(eventBlock, data, index) {\n            super();\n            this._eventBlock = eventBlock;\n            const runtime = eventBlock.GetRuntime();\n            this._runtime = runtime;\n            this._index = index;\n            this._sid = data.length >= 4 ? data[3] : -1;\n            this._actionType = data.length >= 5 ? data[4] & 255 : 0;\n            this._flags = data.length >= 5 ? data[4] >> 8 : 0;\n            this._func = null;\n            this._objectClass = null;\n            this._behaviorType = null;\n            this._behaviorIndex = -1;\n            this._systemPlugin = null;\n            this._callFunctionName = "";\n            this._callEventBlock = null;\n            this._combinedSolModifiers = null;\n            this.Run = noop;\n            this.DebugRun = noop;\n            this._parameters = [];\n            this._results = [];\n            this._anyParamVariesPerInstance = false;\n            this._savedData = null;\n            this._unsavedData = null;\n            const isScript = data[0] === -3;\n            const debugInfo = isScript ? data[2] : data[5];\n            this._debugData = runtime.IsDebug() || isScript ? {\n                isBreakpoint: debugInfo[0],\n                canDebug: debugInfo[1],\n                index: debugInfo[2]\n            } : null;\n            if (data[0] === -1) {\n                this._systemPlugin = runtime.GetSystemPlugin();\n                this._func = runtime.GetObjectReference(data[1])\n            } else if (data[0] === -2)\n                this._callFunctionName = data[1];\n            else if (isScript) {\n                const userMethod = runtime.GetObjectReference(data[1]);\n                this._func = userMethod;\n                this.Run = this.RunUserScript;\n                this.DebugRun = this.DebugRunUserScript;\n                this._actionType = 1\n            } else {\n                this._func = runtime.GetObjectReference(data[1]);\n                this._objectClass = runtime.GetObjectClassByIndex(data[0]);\n                if (data[2]) {\n                    this._behaviorType = this._objectClass.GetBehaviorTypeByName(data[2]);\n                    this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(data[2])\n                }\n            }\n            if (data.length === 7) {\n                const paramData = data[6];\n                for (const data of paramData) {\n                    this._parameters.push(C3.Parameter.Create(this, data, this._parameters.length));\n                    this._results.push(0)\n                }\n            }\n            if (this._parameters.length === 0) {\n                this._parameters = EMPTY_PARAMS_ARRAY;\n                this._results = EMPTY_PARAMS_ARRAY\n            }\n            if (this.CanPickAnyObjectClass()) {\n                this._eventBlock.SetAllSolModifiers();\n                this._eventBlock.SetSolWriterAfterCnds()\n            }\n            this._eventBlock.GetEventSheetManager()._RegisterAction(this)\n        }\n        static Create(eventBlock, data, index) {\n            return C3.New(C3.Action, eventBlock, data, index)\n        }\n        _PostInit() {\n            for (const param of this._parameters) {\n                param._PostInit();\n                if (param.VariesPerInstance())\n                    this._anyParamVariesPerInstance = true\n            }\n            if (this._systemPlugin) {\n                this._SetSystemRunMethod();\n                this.DebugRun = this._DebugRunSystem\n            } else if (this._callFunctionName) {\n                this._SetCallFunctionRunMethod();\n                this._callFunctionName = ""\n            } else if (this.Run === this.RunUserScript) {\n                const userMethod = this._func;\n                const localVars = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);\n                this._func = userMethod.bind(null, this._runtime.GetIRuntime(), localVars)\n            } else if (this._behaviorType)\n                if (this.IsAsync()) {\n                    this.Run = this._RunBehavior_Async;\n                    this.DebugRun = this._DebugRunBehavior_Async\n                } else {\n                    this.Run = this._RunBehavior;\n                    this.DebugRun = this._DebugRunBehavior\n                }\n            else if (this._objectClass.GetPlugin().IsSingleGlobal()) {\n                this._SetSingleGlobalRunMethod();\n                this.DebugRun = this._DebugRunSingleGlobal\n            } else if (this.IsAsync()) {\n                this.Run = this._RunObject_Async;\n                this.DebugRun = this._DebugRunObject_Async\n            } else if (this.CallBeforeAfterHooks()) {\n                this.Run = this._RunObject_BeforeAfterHooks;\n                this.DebugRun = this._DebugRunObject_BeforeAfterHooks\n            } else if (!this._parameters.length) {\n                this.Run = this._RunObject_ParamsConst;\n                this.DebugRun = this._DebugRunObject_ParamsConst\n            } else if (this._parameters.every(p => p.VariesPerInstance())) {\n                this.Run = this._RunObject_AllParamsVary;\n                this.DebugRun = this._DebugRunObject_AllParamsVary\n            } else if (this._anyParamVariesPerInstance) {\n                this.Run = this._RunObject_SomeParamsVary;\n                this.DebugRun = this._DebugRunObject_SomeParamsVary\n            } else if (this._parameters.every(p => p.IsConstant())) {\n                EvalParams(this._parameters, this._results);\n                this.Run = this._RunObject_ParamsConst;\n                this.DebugRun = this._DebugRunObject_ParamsConst\n            } else {\n                this.Run = this._RunObject_ParamsDontVary;\n                this.DebugRun = this._DebugRunObject_ParamsDontVary\n            }\n        }\n        _SetSystemRunMethod() {\n            const plugin = this._systemPlugin;\n            const bindThis = this._systemPlugin;\n            this._SetRunMethodForBoundFunc(plugin, bindThis, this._RunSystem)\n        }\n        _SetSingleGlobalRunMethod() {\n            const plugin = this._objectClass.GetPlugin();\n            const bindThis = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();\n            this._SetRunMethodForBoundFunc(plugin, bindThis, this._RunSingleGlobal)\n        }\n        _SetCallFunctionRunMethod() {\n            const eventSheetManager = this._eventBlock.GetEventSheetManager();\n            const functionBlock = eventSheetManager.GetFunctionBlockByName(this._callFunctionName);\n            if (functionBlock.IsEnabled()) {\n                this._callEventBlock = functionBlock.GetEventBlock();\n                this._combinedSolModifiers = [...(new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()]))];\n                this._combinedSolModifiers = eventSheetManager._DeduplicateSolModifierList(this._combinedSolModifiers);\n                this.Run = C3.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, this._combinedSolModifiers, this._parameters);\n                this.DebugRun = this._DebugRunCallFunction\n            } else {\n                this.Run = noop;\n                this.DebugRun = noopGenerator\n            }\n        }\n        _SetRunMethodForBoundFunc(plugin, bindThis, fallbackMethod) {\n            const func = this._func;\n            const parameters = this._parameters;\n            if (parameters.length === 0)\n                this.Run = plugin._GetBoundACEMethod(func, bindThis);\n            else if (parameters.length === 1) {\n                const param0 = parameters[0];\n                if (param0.IsConstant())\n                    this.Run = plugin._GetBoundACEMethod_1param(func, bindThis, param0.Get(0));\n                else {\n                    const boundFunc = plugin._GetBoundACEMethod(func, bindThis);\n                    this.Run = function RunSingleAct_1param() {\n                        return boundFunc(param0.Get(0))\n                    }\n                }\n            } else if (parameters.length === 2) {\n                const param0 = parameters[0];\n                const param1 = parameters[1];\n                if (param0.IsConstant() && param1.IsConstant())\n                    this.Run = plugin._GetBoundACEMethod_2params(func, bindThis, param0.Get(0), param1.Get(0));\n                else {\n                    const boundFunc = plugin._GetBoundACEMethod(func, bindThis);\n                    this.Run = function RunSingleAct_2params() {\n                        return boundFunc(param0.Get(0), param1.Get(0))\n                    }\n                }\n            } else if (parameters.length === 3) {\n                const param0 = parameters[0];\n                const param1 = parameters[1];\n                const param2 = parameters[2];\n                if (param0.IsConstant() && param1.IsConstant() && param2.IsConstant())\n                    this.Run = plugin._GetBoundACEMethod_3params(func, bindThis, param0.Get(0), param1.Get(0), param2.Get(0));\n                else {\n                    const boundFunc = plugin._GetBoundACEMethod(func, bindThis);\n                    this.Run = function RunSingleAct_3params() {\n                        return boundFunc(param0.Get(0), param1.Get(0), param2.Get(0))\n                    }\n                }\n            } else\n                this.Run = fallbackMethod\n        }\n        GetSID() {\n            return this._sid\n        }\n        IsAsync() {\n            return this._actionType === 1\n        }\n        CanBailOut() {\n            return this._actionType === 2\n        }\n        CallBeforeAfterHooks() {\n            return this._actionType === 3\n        }\n        CanPickAnyObjectClass() {\n            return this._flags === 1\n        }\n        HasReturnType() {\n            return this.IsAsync() || this.CanBailOut()\n        }\n        GetObjectClass() {\n            return this._objectClass\n        }\n        GetEventBlock() {\n            return this._eventBlock\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetIndex() {\n            return this._index\n        }\n        GetDebugIndex() {\n            return this._debugData.index\n        }\n        GetCombinedSolModifiers() {\n            return this._combinedSolModifiers\n        }\n        IsBreakpoint() {\n            return this._debugData.isBreakpoint\n        }\n        _SetBreakpoint(b) {\n            this._debugData.isBreakpoint = !!b;\n            this._eventBlock._UpdateCanRunFastRecursive()\n        }\n        _DebugReturnsGenerator() {\n            return this._debugData.canDebug\n        }\n        DebugCanRunFast() {\n            return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()\n        }\n        GetSavedDataMap() {\n            if (!this._savedData)\n                this._savedData = new Map;\n            return this._savedData\n        }\n        GetUnsavedDataMap() {\n            if (!this._unsavedData)\n                this._unsavedData = new Map;\n            return this._unsavedData\n        }\n        _RunSystem() {\n            const results = this._results;\n            EvalParams(this._parameters, results);\n            return this._func.apply(this._systemPlugin, results)\n        }\n        *_DebugRunSystem() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            if (this._DebugReturnsGenerator()) {\n                const results = this._results;\n                EvalParams(this._parameters, results);\n                const ret = yield*this._func.apply(this._systemPlugin, results);\n                return ret\n            } else\n                return this.Run()\n        }\n        *_DebugRunCallFunction() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            const ret = yield*this._callEventBlock.DebugRunAsFunctionCall(this._combinedSolModifiers, this._parameters);\n            return ret\n        }\n        _RunSingleGlobal() {\n            const results = this._results;\n            EvalParams(this._parameters, results);\n            return this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), results)\n        }\n        *_DebugRunSingleGlobal() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            if (this._DebugReturnsGenerator()) {\n                const results = this._results;\n                EvalParams(this._parameters, results);\n                const ret = yield*this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), results);\n                return ret\n            } else\n                return this.Run()\n        }\n        _RunObject_ParamsConst() {\n            const results = this._results;\n            const instances = this._objectClass.GetCurrentSol().GetInstances();\n            for (let i = 0, len = instances.length; i < len; ++i)\n                this._func.apply(instances[i].GetSdkInstance(), results)\n        }\n        *_DebugRunObject_ParamsConst() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            if (this._DebugReturnsGenerator()) {\n                const results = this._results;\n                const instances = this._objectClass.GetCurrentSol().GetInstances();\n                for (let i = 0, len = instances.length; i < len; ++i)\n                    yield*this._func.apply(instances[i].GetSdkInstance(), results)\n            } else\n                this._RunObject_ParamsConst()\n        }\n        _RunObject_ParamsDontVary() {\n            const results = this._results;\n            EvalParams(this._parameters, results);\n            const instances = this._objectClass.GetCurrentSol().GetInstances();\n            for (let i = 0, len = instances.length; i < len; ++i)\n                this._func.apply(instances[i].GetSdkInstance(), results)\n        }\n        *_DebugRunObject_ParamsDontVary() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            if (this._DebugReturnsGenerator()) {\n                const results = this._results;\n                EvalParams(this._parameters, results);\n                const instances = this._objectClass.GetCurrentSol().GetInstances();\n                for (let i = 0, len = instances.length; i < len; ++i)\n                    yield*this._func.apply(instances[i].GetSdkInstance(), results)\n            } else\n                this._RunObject_ParamsDontVary()\n        }\n        _RunObject_AllParamsVary() {\n            const parameters = this._parameters;\n            const results = this._results;\n            const func = this._func;\n            const instances = this._objectClass.GetCurrentSol().GetInstances();\n            for (let i = 0, len = instances.length; i < len; ++i) {\n                const inst = instances[i];\n                for (let j = 0, lenj = parameters.length; j < lenj; ++j)\n                    results[j] = parameters[j].Get(i);\n                func.apply(inst.GetSdkInstance(), results)\n            }\n        }\n        *_DebugRunObject_AllParamsVary() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            if (this._DebugReturnsGenerator()) {\n                const parameters = this._parameters;\n                const results = this._results;\n                const func = this._func;\n                const instances = this._objectClass.GetCurrentSol().GetInstances();\n                for (let i = 0, len = instances.length; i < len; ++i) {\n                    const inst = instances[i];\n                    for (let j = 0, lenj = parameters.length; j < lenj; ++j)\n                        results[j] = parameters[j].Get(i);\n                    yield*func.apply(inst.GetSdkInstance(), results)\n                }\n            } else\n                this._RunObject_AllParamsVary()\n        }\n        _RunObject_SomeParamsVary() {\n            const parameters = this._parameters;\n            const results = this._results;\n            const func = this._func;\n            const instances = this._objectClass.GetCurrentSol().GetInstances();\n            for (let i = 0, len = parameters.length; i < len; ++i) {\n                const p = parameters[i];\n                if (!p.VariesPerInstance())\n                    results[i] = p.Get(0)\n            }\n            for (let i = 0, len = instances.length; i < len; ++i) {\n                const inst = instances[i];\n                for (let j = 0, lenj = parameters.length; j < lenj; ++j) {\n                    const p = parameters[j];\n                    if (p.VariesPerInstance())\n                        results[j] = p.Get(i)\n                }\n                func.apply(inst.GetSdkInstance(), results)\n            }\n        }\n        *_DebugRunObject_SomeParamsVary() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            if (this._DebugReturnsGenerator()) {\n                const parameters = this._parameters;\n                const results = this._results;\n                const func = this._func;\n                const instances = this._objectClass.GetCurrentSol().GetInstances();\n                for (let i = 0, len = parameters.length; i < len; ++i) {\n                    const p = parameters[i];\n                    if (!p.VariesPerInstance())\n                        results[i] = p.Get(0)\n                }\n                for (let i = 0, len = instances.length; i < len; ++i) {\n                    const inst = instances[i];\n                    for (let j = 0, lenj = parameters.length; j < lenj; ++j) {\n                        const p = parameters[j];\n                        if (p.VariesPerInstance())\n                            results[j] = p.Get(i)\n                    }\n                    yield*func.apply(inst.GetSdkInstance(), results)\n                }\n            } else\n                this._RunObject_SomeParamsVary()\n        }\n        _RunObject_BeforeAfterHooks() {\n            const parameters = this._parameters;\n            const results = this._results;\n            const func = this._func;\n            const objectClass = this._objectClass;\n            const sdkType = objectClass.GetSdkType();\n            const instances = objectClass.GetCurrentSol().GetInstances();\n            sdkType.BeforeRunAction(func);\n            for (let i = 0, len = instances.length; i < len; ++i) {\n                const inst = instances[i];\n                for (let j = 0, lenj = parameters.length; j < lenj; ++j)\n                    results[j] = parameters[j].Get(i);\n                func.apply(inst.GetSdkInstance(), results)\n            }\n            sdkType.AfterRunAction(func)\n        }\n        *_DebugRunObject_BeforeAfterHooks() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            if (this._DebugReturnsGenerator()) {\n                const parameters = this._parameters;\n                const results = this._results;\n                const func = this._func;\n                const objectClass = this._objectClass;\n                const sdkType = objectClass.GetSdkType();\n                const instances = objectClass.GetCurrentSol().GetInstances();\n                sdkType.BeforeRunAction(func);\n                for (let i = 0, len = instances.length; i < len; ++i) {\n                    const inst = instances[i];\n                    for (let j = 0, lenj = parameters.length; j < lenj; ++j)\n                        results[j] = parameters[j].Get(i);\n                    yield*func.apply(inst.GetSdkInstance(), results)\n                }\n                sdkType.AfterRunAction(func)\n            } else\n                this._RunObject_BeforeAfterHooks()\n        }\n        _RunBehavior() {\n            const objectClass = this._objectClass;\n            const isFamily = objectClass.IsFamily();\n            const familyIndex = objectClass.GetFamilyIndex();\n            const parameters = this._parameters;\n            const paramsVary = this._anyParamVariesPerInstance;\n            const results = this._results;\n            const func = this._func;\n            const behaviorIndex = this._behaviorIndex;\n            const instances = objectClass.GetCurrentSol().GetInstances();\n            for (let i = 0, len = parameters.length; i < len; ++i) {\n                const p = parameters[i];\n                if (!p.VariesPerInstance())\n                    results[i] = p.Get(0)\n            }\n            for (let i = 0, len = instances.length; i < len; ++i) {\n                const inst = instances[i];\n                if (paramsVary)\n                    for (let j = 0, lenj = parameters.length; j < lenj; ++j) {\n                        const p = parameters[j];\n                        if (p.VariesPerInstance())\n                            results[j] = p.Get(i)\n                    }\n                const offset = isFamily ? inst.GetObjectClass().GetFamilyBehaviorOffset(familyIndex) : 0;\n                func.apply(inst.GetBehaviorInstances()[behaviorIndex + offset].GetSdkInstance(), results)\n            }\n        }\n        *_DebugRunBehavior() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            if (this._DebugReturnsGenerator()) {\n                const objectClass = this._objectClass;\n                const isFamily = objectClass.IsFamily();\n                const familyIndex = objectClass.GetFamilyIndex();\n                const parameters = this._parameters;\n                const paramsVary = this._anyParamVariesPerInstance;\n                const results = this._results;\n                const func = this._func;\n                const behaviorIndex = this._behaviorIndex;\n                const instances = objectClass.GetCurrentSol().GetInstances();\n                for (let i = 0, len = parameters.length; i < len; ++i) {\n                    const p = parameters[i];\n                    if (!p.VariesPerInstance())\n                        results[i] = p.Get(0)\n                }\n                for (let i = 0, len = instances.length; i < len; ++i) {\n                    const inst = instances[i];\n                    if (paramsVary)\n                        for (let j = 0, lenj = parameters.length; j < lenj; ++j) {\n                            const p = parameters[j];\n                            if (p.VariesPerInstance())\n                                results[j] = p.Get(i)\n                        }\n                    const offset = isFamily ? inst.GetObjectClass().GetFamilyBehaviorOffset(familyIndex) : 0;\n                    yield*func.apply(inst.GetBehaviorInstances()[behaviorIndex + offset].GetSdkInstance(), results)\n                }\n            } else\n                this._RunBehavior()\n        }\n        _RunObject_Async() {\n            const parameters = this._parameters;\n            const results = this._results;\n            const func = this._func;\n            const instances = this._objectClass.GetCurrentSol().GetInstances();\n            const promises = [];\n            for (let i = 0, len = instances.length; i < len; ++i) {\n                const inst = instances[i];\n                for (let j = 0, lenj = parameters.length; j < lenj; ++j)\n                    results[j] = parameters[j].Get(i);\n                promises.push(func.apply(inst.GetSdkInstance(), results))\n            }\n            return Promise.all(promises)\n        }\n        *_DebugRunObject_Async() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            if (this._DebugReturnsGenerator()) {\n                const parameters = this._parameters;\n                const results = this._results;\n                const func = this._func;\n                const instances = this._objectClass.GetCurrentSol().GetInstances();\n                const promises = [];\n                for (let i = 0, len = instances.length; i < len; ++i) {\n                    const inst = instances[i];\n                    for (let j = 0, lenj = parameters.length; j < lenj; ++j)\n                        results[j] = parameters[j].Get(i);\n                    promises.push(yield*func.apply(inst.GetSdkInstance(), results))\n                }\n                return Promise.all(promises)\n            } else\n                return this._RunObject_Async()\n        }\n        _RunBehavior_Async() {\n            const objectClass = this._objectClass;\n            const isFamily = objectClass.IsFamily();\n            const familyIndex = objectClass.GetFamilyIndex();\n            const parameters = this._parameters;\n            const results = this._results;\n            const func = this._func;\n            const behaviorIndex = this._behaviorIndex;\n            const instances = objectClass.GetCurrentSol().GetInstances();\n            const promises = [];\n            for (let i = 0, len = instances.length; i < len; ++i) {\n                const inst = instances[i];\n                for (let j = 0, lenj = parameters.length; j < lenj; ++j)\n                    results[j] = parameters[j].Get(i);\n                const offset = isFamily ? inst.GetObjectClass().GetFamilyBehaviorOffset(familyIndex) : 0;\n                promises.push(func.apply(inst.GetBehaviorInstances()[behaviorIndex + offset].GetSdkInstance(), results))\n            }\n            return Promise.all(promises)\n        }\n        *_DebugRunBehavior_Async() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            if (this._DebugReturnsGenerator()) {\n                const objectClass = this._objectClass;\n                const isFamily = objectClass.IsFamily();\n                const familyIndex = objectClass.GetFamilyIndex();\n                const parameters = this._parameters;\n                const results = this._results;\n                const func = this._func;\n                const behaviorIndex = this._behaviorIndex;\n                const instances = objectClass.GetCurrentSol().GetInstances();\n                const promises = [];\n                for (let i = 0, len = instances.length; i < len; ++i) {\n                    const inst = instances[i];\n                    for (let j = 0, lenj = parameters.length; j < lenj; ++j)\n                        results[j] = parameters[j].Get(i);\n                    const offset = isFamily ? inst.GetObjectClass().GetFamilyBehaviorOffset(familyIndex) : 0;\n                    promises.push(yield*func.apply(inst.GetBehaviorInstances()[behaviorIndex + offset].GetSdkInstance(), results))\n                }\n                return Promise.all(promises)\n            } else\n                return this._RunBehavior_Async()\n        }\n        async RunUserScript() {\n            try {\n                await this._func()\n            } catch (err) {\n                console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex() + 1}:`, "font-size: 1.2em; font-weight: bold;", err);\n                if (self.C3Debugger)\n                    self.C3Debugger._SetLastErrorScript(this);\n                if (!C3.EventScript.HadUserScriptException()) {\n                    console.info(`%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()`, "font-weight: bold; text-decoration: underline", "", "font-weight: bold");\n                    C3.EventScript.SetHadUserScriptException()\n                }\n            }\n        }\n        *DebugRunUserScript() {\n            if (this.IsBreakpoint() || this._runtime.DebugBreakNext())\n                yield this;\n            return this.RunUserScript()\n        }\n        _SaveToJson() {\n            if (!this._savedData || !this._savedData.size)\n                return null;\n            return {\n                "ex": C3.ToSuperJSON(this._savedData)\n            }\n        }\n        _LoadFromJson(o) {\n            if (this._savedData) {\n                this._savedData.clear();\n                this._savedData = null\n            }\n            if (!o)\n                return;\n            const ex = o["ex"];\n            if (ex)\n                this._savedData = C3.FromSuperJSON(ex)\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/commonACEs.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const tempColor = new C3.Color;\n    function CompareX(cmp, x) {\n        return C3.compare(this.GetWorldInfo().GetX(), cmp, x)\n    }\n    function CompareY(cmp, y) {\n        return C3.compare(this.GetWorldInfo().GetY(), cmp, y)\n    }\n    function IsOnScreen() {\n        const wi = this.GetWorldInfo();\n        const layer = wi.GetLayer();\n        if (layer.Has3DCamera())\n            return wi.IsInViewport3D(layer._GetViewFrustum());\n        else\n            return wi.IsInViewport(layer.GetViewport(), wi.GetLayout().HasVanishingPointOutsideViewport(), wi.GetLayout().IsOrthographicProjection())\n    }\n    function IsOutsideLayout() {\n        const wi = this.GetWorldInfo();\n        const layout = wi.GetLayout();\n        const bbox = wi.GetBoundingBox();\n        return bbox.getRight() < 0 || bbox.getBottom() < 0 || bbox.getLeft() > layout.GetWidth() || bbox.getTop() > layout.GetHeight()\n    }\n    function PickDistance(which, x, y) {\n        const sol = this.GetCurrentSol();\n        const instances = sol.GetInstances();\n        if (!instances.length)\n            return false;\n        let inst = instances[0];\n        let wi = inst.GetWorldInfo();\n        let pickme = inst;\n        let dist2 = C3.distanceSquared(wi.GetX(), wi.GetY(), x, y);\n        for (let i = 1, len = instances.length; i < len; ++i) {\n            inst = instances[i];\n            wi = inst.GetWorldInfo();\n            const d2 = C3.distanceSquared(wi.GetX(), wi.GetY(), x, y);\n            if (which === 0 && d2 < dist2 || which === 1 && d2 > dist2) {\n                dist2 = d2;\n                pickme = inst\n            }\n        }\n        sol.PickOne(pickme);\n        return true\n    }\n    function SetX(x) {\n        const wi = this.GetWorldInfo();\n        if (wi.GetX() === x)\n            return;\n        wi.SetX(x);\n        wi.SetBboxChanged()\n    }\n    function SetY(y) {\n        const wi = this.GetWorldInfo();\n        if (wi.GetY() === y)\n            return;\n        wi.SetY(y);\n        wi.SetBboxChanged()\n    }\n    function SetPos(x, y) {\n        const wi = this.GetWorldInfo();\n        if (wi.EqualsXY(x, y))\n            return;\n        wi.SetXY(x, y);\n        wi.SetBboxChanged()\n    }\n    function SetPosToObject(objectClass, imgPt) {\n        if (!objectClass)\n            return;\n        const inst = objectClass.GetPairedInstance(this._inst);\n        if (!inst)\n            return;\n        const [x,y] = inst.GetImagePoint(imgPt);\n        const wi = this.GetWorldInfo();\n        if (wi.GetX() === x && wi.GetY() === y)\n            return;\n        wi.SetXY(x, y);\n        wi.SetBboxChanged()\n    }\n    function MoveForward(dist) {\n        if (dist === 0)\n            return;\n        const wi = this.GetWorldInfo();\n        wi.OffsetXY(wi.GetCosAngle() * dist, wi.GetSinAngle() * dist);\n        wi.SetBboxChanged()\n    }\n    function MoveAtAngle(a, dist) {\n        if (dist === 0)\n            return;\n        const wi = this.GetWorldInfo();\n        a = C3.toRadians(a);\n        wi.OffsetXY(Math.cos(a) * dist, Math.sin(a) * dist);\n        wi.SetBboxChanged()\n    }\n    function GetX() {\n        return this.GetWorldInfo().GetX()\n    }\n    function GetY() {\n        return this.GetWorldInfo().GetY()\n    }\n    function GetDt() {\n        return this._runtime.GetDt(this._inst)\n    }\n    function CompareWidth(cmp, w) {\n        return C3.compare(this.GetWorldInfo().GetWidth(), cmp, w)\n    }\n    function CompareHeight(cmp, h) {\n        return C3.compare(this.GetWorldInfo().GetHeight(), cmp, h)\n    }\n    function SetWidth(w) {\n        const wi = this.GetWorldInfo();\n        if (wi.GetWidth() === w)\n            return;\n        wi.SetWidth(w);\n        wi.SetBboxChanged()\n    }\n    function SetHeight(h) {\n        const wi = this.GetWorldInfo();\n        if (wi.GetHeight() === h)\n            return;\n        wi.SetHeight(h);\n        wi.SetBboxChanged()\n    }\n    function SetSize(w, h) {\n        const wi = this.GetWorldInfo();\n        if (wi.GetWidth() === w && wi.GetHeight() === h)\n            return;\n        wi.SetSize(w, h);\n        wi.SetBboxChanged()\n    }\n    function GetWidth() {\n        return this.GetWorldInfo().GetWidth()\n    }\n    function GetHeight() {\n        return this.GetWorldInfo().GetHeight()\n    }\n    function GetBboxLeft() {\n        return this.GetWorldInfo().GetBoundingBox().getLeft()\n    }\n    function GetBboxTop() {\n        return this.GetWorldInfo().GetBoundingBox().getTop()\n    }\n    function GetBboxRight() {\n        return this.GetWorldInfo().GetBoundingBox().getRight()\n    }\n    function GetBboxBottom() {\n        return this.GetWorldInfo().GetBoundingBox().getBottom()\n    }\n    function IsAngleWithin(within, a) {\n        return C3.angleDiff(this.GetWorldInfo().GetAngle(), C3.toRadians(a)) <= C3.toRadians(within)\n    }\n    function IsAngleClockwiseFrom(a) {\n        return C3.angleClockwise(this.GetWorldInfo().GetAngle(), C3.toRadians(a))\n    }\n    function IsBetweenAngles(a, b) {\n        const lower = C3.toRadians(a);\n        const upper = C3.toRadians(b);\n        const angle = this.GetWorldInfo().GetAngle();\n        const obtuse = !C3.angleClockwise(upper, lower);\n        if (obtuse)\n            return !(!C3.angleClockwise(angle, lower) && C3.angleClockwise(angle, upper));\n        else\n            return C3.angleClockwise(angle, lower) && !C3.angleClockwise(angle, upper)\n    }\n    function SetAngle(a) {\n        const wi = this.GetWorldInfo();\n        const newAngle = C3.clampAngle(C3.toRadians(a));\n        if (isNaN(newAngle) || wi.GetAngle() === newAngle)\n            return;\n        wi.SetAngle(newAngle);\n        wi.SetBboxChanged()\n    }\n    function RotateClockwise(a) {\n        if (isNaN(a) || a === 0)\n            return;\n        const wi = this.GetWorldInfo();\n        wi.SetAngle(wi.GetAngle() + C3.toRadians(a));\n        wi.SetBboxChanged()\n    }\n    function RotateCounterclockwise(a) {\n        if (isNaN(a) || a === 0)\n            return;\n        const wi = this.GetWorldInfo();\n        wi.SetAngle(wi.GetAngle() - C3.toRadians(a));\n        wi.SetBboxChanged()\n    }\n    function RotateTowardAngle(amt, target) {\n        const wi = this.GetWorldInfo();\n        const a = wi.GetAngle();\n        const newAngle = C3.angleRotate(a, C3.toRadians(target), C3.toRadians(amt));\n        if (isNaN(newAngle) || a === newAngle)\n            return;\n        wi.SetAngle(newAngle);\n        wi.SetBboxChanged()\n    }\n    function RotateTowardPosition(amt, x, y) {\n        const wi = this.GetWorldInfo();\n        const a = wi.GetAngle();\n        const dx = x - wi.GetX();\n        const dy = y - wi.GetY();\n        const target = Math.atan2(dy, dx);\n        const newAngle = C3.angleRotate(a, target, C3.toRadians(amt));\n        if (isNaN(newAngle) || a === newAngle)\n            return;\n        wi.SetAngle(newAngle);\n        wi.SetBboxChanged()\n    }\n    function SetTowardPosition(x, y) {\n        const wi = this.GetWorldInfo();\n        const a = wi.GetAngle();\n        const dx = x - wi.GetX();\n        const dy = y - wi.GetY();\n        const newAngle = Math.atan2(dy, dx);\n        if (isNaN(newAngle) || a === newAngle)\n            return;\n        wi.SetAngle(newAngle);\n        wi.SetBboxChanged()\n    }\n    function GetAngle() {\n        return C3.toDegrees(this.GetWorldInfo().GetAngle())\n    }\n    function CompareOpacity(cmp, x) {\n        return C3.compare(C3.round6dp(this.GetWorldInfo().GetOpacity() * 100), cmp, x)\n    }\n    function IsVisible() {\n        return this.GetWorldInfo().IsVisible()\n    }\n    function SetVisible(v) {\n        const wi = this.GetWorldInfo();\n        if (v === 2)\n            v = !wi.IsVisible();\n        else\n            v = v !== 0;\n        if (wi.IsVisible() === v)\n            return;\n        wi.SetVisible(v);\n        this._runtime.UpdateRender()\n    }\n    function SetOpacity(o) {\n        const newOpacity = C3.clamp(o \/ 100, 0, 1);\n        const wi = this.GetWorldInfo();\n        if (wi.GetOpacity() === newOpacity)\n            return;\n        wi.SetOpacity(newOpacity);\n        this._runtime.UpdateRender()\n    }\n    function SetDefaultColor(rgb) {\n        tempColor.setFromRgbValue(rgb);\n        const wi = this.GetWorldInfo();\n        if (wi.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor))\n            return;\n        wi.SetUnpremultipliedColor(tempColor);\n        this._runtime.UpdateRender()\n    }\n    function GetColor() {\n        const c = this.GetWorldInfo().GetUnpremultipliedColor();\n        return C3.PackRGBAEx(c.getR(), c.getG(), c.getB(), c.getA())\n    }\n    function GetOpacity() {\n        return C3.round6dp(this.GetWorldInfo().GetOpacity() * 100)\n    }\n    function IsOnLayer(layer) {\n        if (!layer)\n            return false;\n        return this.GetWorldInfo().GetLayer() === layer\n    }\n    function PickTopBottom(which) {\n        const sol = this.GetCurrentSol();\n        const instances = sol.GetInstances();\n        if (!instances.length)\n            return false;\n        let inst = instances[0];\n        let pickme = inst;\n        for (let i = 1, len = instances.length; i < len; ++i) {\n            const inst = instances[i];\n            const instWi = inst.GetWorldInfo();\n            const pickmeWi = pickme.GetWorldInfo();\n            const instLayerIndex = instWi.GetLayer().GetIndex();\n            const pickmeLayerIndex = pickmeWi.GetLayer().GetIndex();\n            if (which === 0) {\n                if (instLayerIndex > pickmeLayerIndex || instLayerIndex === pickmeLayerIndex && instWi.GetZIndex() > pickmeWi.GetZIndex())\n                    pickme = inst\n            } else if (instLayerIndex < pickmeLayerIndex || instLayerIndex === pickmeLayerIndex && instWi.GetZIndex() < pickmeWi.GetZIndex())\n                pickme = inst\n        }\n        sol.PickOne(pickme);\n        return true\n    }\n    function CompareZElevation(which, cmp, value) {\n        const wi = this.GetWorldInfo();\n        const z = which === 0 ? wi.GetZElevation() : wi.GetTotalZElevation();\n        return C3.compare(z, cmp, value)\n    }\n    function MoveToTop() {\n        this.GetWorldInfo().ZOrderMoveToTop()\n    }\n    function MoveToBottom() {\n        this.GetWorldInfo().ZOrderMoveToBottom()\n    }\n    function MoveToLayer(layerMove) {\n        if (!layerMove)\n            return;\n        this.GetWorldInfo().ZOrderMoveToLayer(layerMove)\n    }\n    function ZMoveToObject(where, objectClass) {\n        const isAfter = where === 0;\n        if (!objectClass)\n            return;\n        const otherInst = objectClass.GetFirstPicked(this.GetInstance());\n        if (!otherInst)\n            return;\n        this.GetWorldInfo().ZOrderMoveAdjacentToInstance(otherInst, isAfter)\n    }\n    function SetZElevation(z) {\n        const wi = this.GetWorldInfo();\n        if (wi.GetZElevation() === z)\n            return;\n        wi.SetZElevation(z);\n        this._runtime.UpdateRender()\n    }\n    function LayerNumber() {\n        return this.GetWorldInfo().GetLayer().GetIndex()\n    }\n    function LayerName() {\n        return this.GetWorldInfo().GetLayer().GetName()\n    }\n    function ZIndex() {\n        return this.GetWorldInfo().GetZIndex()\n    }\n    function ZElevation() {\n        return this.GetWorldInfo().GetZElevation()\n    }\n    function TotalZElevation() {\n        return this.GetWorldInfo().GetTotalZElevation()\n    }\n    function IsEffectEnabled(effectName) {\n        const effectType = this.GetObjectClass().GetEffectList().GetEffectTypeByName(effectName);\n        if (!effectType)\n            return;\n        const effectTypeIndex = effectType.GetIndex();\n        const instFxList = this.GetWorldInfo().GetInstanceEffectList();\n        return instFxList.IsEffectIndexActive(effectTypeIndex)\n    }\n    function SetEffectEnabled(enabled, effectName) {\n        const effectType = this.GetObjectClass().GetEffectList().GetEffectTypeByName(effectName);\n        if (!effectType)\n            return;\n        const effectTypeIndex = effectType.GetIndex();\n        const e = enabled === 1;\n        const instFxList = this.GetWorldInfo().GetInstanceEffectList();\n        if (instFxList.IsEffectIndexActive(effectTypeIndex) === e)\n            return;\n        instFxList.SetEffectIndexActive(effectTypeIndex, e);\n        instFxList.UpdateActiveEffects();\n        this._runtime.UpdateRender()\n    }\n    function SetEffectParam(effectName, paramIndex, value) {\n        const effectType = this.GetObjectClass().GetEffectList().GetEffectTypeByName(effectName);\n        if (!effectType)\n            return;\n        paramIndex = Math.floor(paramIndex);\n        const paramType = effectType.GetShaderProgram().GetParameterType(paramIndex);\n        if (!paramType)\n            return;\n        if (paramType === "color") {\n            tempColor.setFromRgbValue(value);\n            value = tempColor\n        } else if (paramType === "percent")\n            value \/= 100;\n        const effectTypeIndex = effectType.GetIndex();\n        const instFxList = this.GetWorldInfo().GetInstanceEffectList();\n        const didChange = instFxList.SetEffectParameter(effectTypeIndex, paramIndex, value);\n        if (didChange && instFxList.IsEffectIndexActive(effectTypeIndex))\n            this._runtime.UpdateRender()\n    }\n    const tempRect = C3.New(C3.Rect);\n    const tempCandidates1 = [];\n    const tempCandidates2 = [];\n    let needsCollisionFinish = false;\n    let rPickType = null;\n    let rPickFromElseInstances = false;\n    const rToPick = new Set;\n    function CollMemory_Add(collMemory, a, b, tickCount) {\n        const a_uid = a.GetUID();\n        const b_uid = b.GetUID();\n        if (a_uid < b_uid)\n            collMemory.Set(a, b, tickCount);\n        else\n            collMemory.Set(b, a, tickCount)\n    }\n    function CollMemory_Remove(collMemory, a, b) {\n        const a_uid = a.GetUID();\n        const b_uid = b.GetUID();\n        if (a_uid < b_uid)\n            collMemory.Delete(a, b);\n        else\n            collMemory.Delete(b, a)\n    }\n    function CollMemory_RemoveInstance(collMemory, inst) {\n        collMemory.DeleteEither(inst)\n    }\n    function CollMemory_Get(collMemory, a, b) {\n        const a_uid = a.GetUID();\n        const b_uid = b.GetUID();\n        if (a_uid < b_uid)\n            return collMemory.Get(a, b);\n        else\n            return collMemory.Get(b, a)\n    }\n    function DoOverlapCondition(sdkInst, rtype, offX, offY) {\n        if (!rtype)\n            return false;\n        const inst = sdkInst.GetInstance();\n        const hasOffset = offX !== 0 || offY !== 0;\n        const wi = inst.GetWorldInfo();\n        const runtime = inst.GetRuntime();\n        const collisionEngine = runtime.GetCollisionEngine();\n        const cnd = runtime.GetCurrentCondition();\n        const isOrBlock = cnd.GetEventBlock().IsOrBlock();\n        const ltype = cnd.GetObjectClass();\n        const isInverted = cnd.IsInverted();\n        const rsol = rtype.GetCurrentSol();\n        const isDifferentTypes = ltype !== rtype;\n        rPickType = rtype;\n        needsCollisionFinish = isDifferentTypes && !isInverted;\n        rPickFromElseInstances = false;\n        let rinstances;\n        let oldX = 0;\n        let oldY = 0;\n        let ret = false;\n        if (rsol.IsSelectAll()) {\n            tempRect.copy(wi.GetBoundingBox());\n            tempRect.offset(offX, offY);\n            collisionEngine.GetCollisionCandidates(wi.GetLayer(), rtype, tempRect, tempCandidates2);\n            rinstances = tempCandidates2\n        } else if (isOrBlock)\n            if (runtime.IsCurrentConditionFirst() && !rsol._GetOwnElseInstances().length && rsol._GetOwnInstances().length)\n                rinstances = rsol._GetOwnInstances();\n            else {\n                rinstances = rsol._GetOwnElseInstances();\n                rPickFromElseInstances = true\n            }\n        else\n            rinstances = rsol._GetOwnInstances();\n        if (hasOffset) {\n            oldX = wi.GetX();\n            oldY = wi.GetY();\n            wi.OffsetXY(offX, offY);\n            wi.SetBboxChanged()\n        }\n        for (const rinst of rinstances)\n            if (collisionEngine.TestOverlap(inst, rinst)) {\n                ret = true;\n                if (isInverted)\n                    break;\n                if (isDifferentTypes)\n                    rToPick.add(rinst)\n            }\n        if (hasOffset) {\n            wi.SetXY(oldX, oldY);\n            wi.SetBboxChanged()\n        }\n        C3.clearArray(tempCandidates2);\n        return ret\n    }\n    function FinishCollisionConditionPicking(type) {\n        const isOrBlock = type.GetRuntime().GetCurrentEvent().IsOrBlock();\n        const sol = rPickType.GetCurrentSol();\n        const solInstances = sol._GetOwnInstances();\n        const solElseInstances = sol._GetOwnElseInstances();\n        if (sol.IsSelectAll()) {\n            sol.SetSetPicked(rToPick);\n            if (isOrBlock) {\n                C3.clearArray(solElseInstances);\n                sol.AddElseInstances(rToPick, rPickType.GetInstances())\n            }\n        } else if (isOrBlock)\n            if (rPickFromElseInstances)\n                sol.TransferElseInstancesToOwn(rToPick);\n            else {\n                sol.AddElseInstances(rToPick, solInstances);\n                sol.SetSetPicked(rToPick)\n            }\n        else\n            sol.SetSetPicked(rToPick);\n        rPickType.ApplySolToContainer()\n    }\n    function FinishCollisionCondition(type, doPick) {\n        if (!needsCollisionFinish)\n            return;\n        if (doPick)\n            FinishCollisionConditionPicking(type);\n        rToPick.clear();\n        rPickType = null;\n        needsCollisionFinish = false\n    }\n    function OnCollision(rtype) {\n        if (this._runtime.IsDebugging())\n            return DebugOnCollision.call(this, rtype);\n        if (!rtype)\n            return false;\n        const runtime = this._runtime;\n        const collisionEngine = runtime.GetCollisionEngine();\n        const eventSheetManager = runtime.GetEventSheetManager();\n        const eventStack = eventSheetManager.GetEventStack();\n        const cnd = eventSheetManager.GetCurrentCondition();\n        const ltype = cnd.GetObjectClass();\n        const savedData = cnd.GetSavedDataMap();\n        const unsavedData = cnd.GetUnsavedDataMap();\n        const oldFrame = eventStack.GetCurrentStackFrame();\n        const tickCount = runtime.GetTickCount();\n        const lastTickCount = tickCount - 1;\n        const currentEvent = oldFrame.GetCurrentEvent();\n        const newFrame = eventStack.Push(currentEvent);\n        let collMemory = savedData.get("collmemory");\n        if (!collMemory) {\n            collMemory = C3.New(C3.PairMap);\n            savedData.set("collmemory", collMemory)\n        }\n        if (!unsavedData.get("collisionCreatedDestroyCallback")) {\n            unsavedData.set("collisionCreatedDestroyCallback", true);\n            runtime.Dispatcher().addEventListener("instancedestroy", e => CollMemory_RemoveInstance(collMemory, e.instance))\n        }\n        const lsol = ltype.GetCurrentSol();\n        const rsol = rtype.GetCurrentSol();\n        const linstances = lsol.GetInstances();\n        let rinstances = null;\n        for (let l = 0; l < linstances.length; ++l) {\n            const linst = linstances[l];\n            if (rsol.IsSelectAll()) {\n                collisionEngine.GetCollisionCandidates(linst.GetWorldInfo().GetLayer(), rtype, linst.GetWorldInfo().GetBoundingBox(), tempCandidates1);\n                rinstances = tempCandidates1;\n                collisionEngine.AddRegisteredCollisionCandidates(linst, rtype, rinstances)\n            } else\n                rinstances = rsol.GetInstances();\n            for (let r = 0; r < rinstances.length; ++r) {\n                const rinst = rinstances[r];\n                if (collisionEngine.TestOverlap(linst, rinst) || collisionEngine.CheckRegisteredCollision(linst, rinst)) {\n                    const entry = CollMemory_Get(collMemory, linst, rinst);\n                    let entryExists = false;\n                    let lastCollTickCount = -2;\n                    if (typeof entry === "number") {\n                        entryExists = true;\n                        lastCollTickCount = entry\n                    }\n                    const shouldRun = !entryExists || lastCollTickCount < lastTickCount;\n                    CollMemory_Add(collMemory, linst, rinst, tickCount);\n                    if (shouldRun) {\n                        const solModifiers = currentEvent.GetSolModifiers();\n                        eventSheetManager.PushCopySol(solModifiers);\n                        const curlsol = ltype.GetCurrentSol();\n                        const currsol = rtype.GetCurrentSol();\n                        curlsol._SetSelectAll(false);\n                        currsol._SetSelectAll(false);\n                        if (ltype === rtype) {\n                            const solInstances = curlsol._GetOwnInstances();\n                            C3.clearArray(solInstances);\n                            solInstances.push(linst);\n                            solInstances.push(rinst);\n                            ltype.ApplySolToContainer()\n                        } else {\n                            const lsolInstances = curlsol._GetOwnInstances();\n                            const rsolInstances = currsol._GetOwnInstances();\n                            C3.clearArray(lsolInstances);\n                            C3.clearArray(rsolInstances);\n                            lsolInstances.push(linst);\n                            rsolInstances.push(rinst);\n                            ltype.ApplySolToContainer();\n                            rtype.ApplySolToContainer()\n                        }\n                        currentEvent.Retrigger(oldFrame, newFrame);\n                        eventSheetManager.PopSol(solModifiers)\n                    }\n                } else\n                    CollMemory_Remove(collMemory, linst, rinst)\n            }\n            C3.clearArray(tempCandidates1)\n        }\n        eventStack.Pop();\n        return false\n    }\n    function *DebugOnCollision(rtype) {\n        if (!rtype)\n            return false;\n        const runtime = this._runtime;\n        const collisionEngine = runtime.GetCollisionEngine();\n        const eventSheetManager = runtime.GetEventSheetManager();\n        const eventStack = eventSheetManager.GetEventStack();\n        const cnd = eventSheetManager.GetCurrentCondition();\n        const ltype = cnd.GetObjectClass();\n        const savedData = cnd.GetSavedDataMap();\n        const unsavedData = cnd.GetUnsavedDataMap();\n        const oldFrame = eventStack.GetCurrentStackFrame();\n        const tickCount = runtime.GetTickCount();\n        const lastTickCount = tickCount - 1;\n        const currentEvent = oldFrame.GetCurrentEvent();\n        const newFrame = eventStack.Push(currentEvent);\n        let collMemory = savedData.get("collmemory");\n        if (!collMemory) {\n            collMemory = C3.New(C3.PairMap);\n            savedData.set("collmemory", collMemory)\n        }\n        if (!unsavedData.get("collisionCreatedDestroyCallback")) {\n            unsavedData.set("collisionCreatedDestroyCallback", true);\n            runtime.Dispatcher().addEventListener("instancedestroy", e => CollMemory_RemoveInstance(collMemory, e.instance))\n        }\n        const lsol = ltype.GetCurrentSol();\n        const rsol = rtype.GetCurrentSol();\n        const linstances = lsol.GetInstances();\n        let rinstances = null;\n        for (let l = 0; l < linstances.length; ++l) {\n            const linst = linstances[l];\n            if (rsol.IsSelectAll()) {\n                collisionEngine.GetCollisionCandidates(linst.GetWorldInfo().GetLayer(), rtype, linst.GetWorldInfo().GetBoundingBox(), tempCandidates1);\n                rinstances = tempCandidates1;\n                collisionEngine.AddRegisteredCollisionCandidates(linst, rtype, rinstances)\n            } else\n                rinstances = rsol.GetInstances();\n            for (let r = 0; r < rinstances.length; ++r) {\n                const rinst = rinstances[r];\n                if (collisionEngine.TestOverlap(linst, rinst) || collisionEngine.CheckRegisteredCollision(linst, rinst)) {\n                    const entry = CollMemory_Get(collMemory, linst, rinst);\n                    let entryExists = false;\n                    let lastCollTickCount = -2;\n                    if (typeof entry === "number") {\n                        entryExists = true;\n                        lastCollTickCount = entry\n                    }\n                    const shouldRun = !entryExists || lastCollTickCount < lastTickCount;\n                    CollMemory_Add(collMemory, linst, rinst, tickCount);\n                    if (shouldRun) {\n                        const solModifiers = currentEvent.GetSolModifiers();\n                        eventSheetManager.PushCopySol(solModifiers);\n                        const curlsol = ltype.GetCurrentSol();\n                        const currsol = rtype.GetCurrentSol();\n                        curlsol._SetSelectAll(false);\n                        currsol._SetSelectAll(false);\n                        if (ltype === rtype) {\n                            const solInstances = curlsol._GetOwnInstances();\n                            C3.clearArray(solInstances);\n                            solInstances.push(linst);\n                            solInstances.push(rinst);\n                            ltype.ApplySolToContainer()\n                        } else {\n                            const lsolInstances = curlsol._GetOwnInstances();\n                            const rsolInstances = currsol._GetOwnInstances();\n                            C3.clearArray(lsolInstances);\n                            C3.clearArray(rsolInstances);\n                            lsolInstances.push(linst);\n                            rsolInstances.push(rinst);\n                            ltype.ApplySolToContainer();\n                            rtype.ApplySolToContainer()\n                        }\n                        yield*currentEvent.DebugRetrigger(oldFrame, newFrame);\n                        eventSheetManager.PopSol(solModifiers)\n                    }\n                } else\n                    CollMemory_Remove(collMemory, linst, rinst)\n            }\n            C3.clearArray(tempCandidates1)\n        }\n        eventStack.Pop();\n        return false\n    }\n    function IsOverlapping(rtype) {\n        return DoOverlapCondition(this, rtype, 0, 0)\n    }\n    function IsOverlappingOffset(rtype, offX, offY) {\n        return DoOverlapCondition(this, rtype, offX, offY)\n    }\n    function HasParent() {\n        return this.GetWorldInfo().HasParent()\n    }\n    function HasChildren() {\n        return this.GetWorldInfo().HasChildren()\n    }\n    function PickParent(parentObjectClass, which) {\n        const mySol = this.GetCurrentSol();\n        const myInstances = mySol.GetInstances();\n        if (myInstances.length === 0)\n            return false;\n        const parentSol = parentObjectClass.GetCurrentSol();\n        const parentInstances = parentSol.GetInstances();\n        if (parentInstances.length === 0)\n            return false;\n        const parentInstancesSet = new Set(parentInstances);\n        const pickParents = new Set;\n        for (let i = 0, len = myInstances.length; i < len; ++i) {\n            const myInst = myInstances[i];\n            if (which === 1)\n                for (const parentInst of myInst.parents()) {\n                    if (parentInst.BelongsToObjectClass(parentObjectClass) && parentInstancesSet.has(parentInst))\n                        pickParents.add(parentInst)\n                }\n            else {\n                let parentInst;\n                if (which === 0) {\n                    parentInst = myInst.GetParent();\n                    if (parentInst === null)\n                        continue\n                } else\n                    parentInst = myInst.GetTopParent();\n                if (parentInst.BelongsToObjectClass(parentObjectClass) && parentInstancesSet.has(parentInst))\n                    pickParents.add(parentInst)\n            }\n        }\n        if (pickParents.size === 0)\n            return false;\n        parentSol.SetSetPicked(pickParents);\n        parentObjectClass.ApplySolToContainer();\n        return true\n    }\n    function PickChildren(childObjectClass, which) {\n        const mySol = this.GetCurrentSol();\n        const myInstances = mySol.GetInstances();\n        if (myInstances.length === 0)\n            return false;\n        const childSol = childObjectClass.GetCurrentSol();\n        let childInstances = childSol.GetInstances();\n        if (childSol.IsSelectAll()) {\n            const childInstsPendingCreate = [...this._runtime.instancesPendingCreateForObjectClass(childObjectClass)];\n            if (childInstsPendingCreate.length > 0)\n                childInstances = childInstances.concat(childInstsPendingCreate)\n        }\n        if (childInstances.length === 0)\n            return false;\n        const childInstancesSet = new Set(childInstances);\n        const pickChildren = new Set;\n        for (let i = 0, len = myInstances.length; i < len; ++i) {\n            const myInst = myInstances[i];\n            if (which === 2 && !myInst.HasChildren() && myInst.BelongsToObjectClass(childObjectClass) && childInstancesSet.has(myInst))\n                pickChildren.add(myInst);\n            for (const childInst of which === 0 ? myInst.children() : myInst.allChildren()) {\n                if (which === 2 && childInst.HasChildren())\n                    continue;\n                if (childInst.BelongsToObjectClass(childObjectClass) && childInstancesSet.has(childInst))\n                    pickChildren.add(childInst)\n            }\n        }\n        if (pickChildren.size === 0)\n            return false;\n        childSol.SetSetPicked(pickChildren);\n        childObjectClass.ApplySolToContainer();\n        return true\n    }\n    function PickNthChild(childObjectClass, index) {\n        const mySol = this.GetCurrentSol();\n        const myInstances = mySol.GetInstances();\n        if (myInstances.length === 0)\n            return false;\n        const childSol = childObjectClass.GetCurrentSol();\n        let childInstances = childSol.GetInstances();\n        if (childSol.IsSelectAll()) {\n            const childInstsPendingCreate = [...this._runtime.instancesPendingCreateForObjectClass(childObjectClass)];\n            if (childInstsPendingCreate.length > 0)\n                childInstances = childInstances.concat(childInstsPendingCreate)\n        }\n        if (childInstances.length === 0)\n            return false;\n        const childInstancesSet = new Set(childInstances);\n        const pickChildren = [];\n        for (let i = 0, len = myInstances.length; i < len; ++i) {\n            const myInst = myInstances[i];\n            const childInst = myInst.GetChildAt(index);\n            if (childInst !== null && childInst.BelongsToObjectClass(childObjectClass) && childInstancesSet.has(childInst))\n                pickChildren.push(childInst)\n        }\n        if (pickChildren.length === 0)\n            return false;\n        childSol.SetArrayPicked(pickChildren);\n        childObjectClass.ApplySolToContainer();\n        return true\n    }\n    function CompareChildCount(which, cmp, count) {\n        switch (which) {\n        case 0:\n        default:\n            {\n                return C3.compare(this._inst.GetChildCount(), cmp, count)\n            }\n        case 1:\n            {\n                return C3.compare(this._inst.GetAllChildCount(), cmp, count)\n            }\n        }\n    }\n    function AddChild(childObjectClass, transformX, transformY, transformWidth, transformHeight, transformAngle, transformZElevation, destroyWithParent) {\n        const inst = this._inst;\n        const actObjectClass = this._runtime.GetCurrentAction().GetObjectClass();\n        for (const child of childObjectClass.allCorrespondingInstances(inst, actObjectClass)) {\n            if (!child.GetPlugin().SupportsSceneGraph())\n                return;\n            inst.AddChild(child, {\n                transformX,\n                transformY,\n                transformWidth,\n                transformHeight,\n                transformAngle,\n                transformZElevation,\n                destroyWithParent\n            })\n        }\n    }\n    function RemoveChild(childObjectClass) {\n        const inst = this._inst;\n        const actObjectClass = this._runtime.GetCurrentAction().GetObjectClass();\n        for (const child of childObjectClass.allCorrespondingInstances(inst, actObjectClass))\n            inst.RemoveChild(child)\n    }\n    function RemoveFromParent() {\n        if (!this._inst.HasParent())\n            return;\n        const parent = this._inst.GetParent();\n        parent.RemoveChild(this._inst)\n    }\n    function ChildCount() {\n        return this._inst.GetChildCount()\n    }\n    function AllChildCount() {\n        return this._inst.GetAllChildCount()\n    }\n    function SetMeshSize(cols, rows) {\n        cols = Math.floor(cols);\n        rows = Math.floor(rows);\n        const wi = this.GetWorldInfo();\n        if (cols < 2 || rows < 2 || !isFinite(cols) || !isFinite(rows)) {\n            wi.ReleaseMesh();\n            wi.SetBboxChanged()\n        } else\n            wi.CreateMesh(cols, rows)\n    }\n    function SetMeshPoint(col, row, mode, posx, posy, zElevation, texu, texv) {\n        const wi = this.GetWorldInfo();\n        const didBboxChange = wi.SetMeshPoint(col, row, {\n            mode: mode === 0 ? "absolute" : "relative",\n            x: posx,\n            y: posy,\n            zElevation,\n            u: texu,\n            v: texv\n        });\n        if (didBboxChange)\n            wi.SetBboxChanged()\n    }\n    function MeshColumns() {\n        const wi = this.GetWorldInfo();\n        return wi.HasMesh() ? wi.GetSourceMesh().GetHSize() : 0\n    }\n    function MeshRows() {\n        const wi = this.GetWorldInfo();\n        return wi.HasMesh() ? wi.GetSourceMesh().GetVSize() : 0\n    }\n    function SetElementVisible(v) {\n        const wi = this.GetWorldInfo();\n        if (v === 2)\n            v = !wi.IsVisible();\n        else\n            v = v !== 0;\n        if (wi.IsVisible() === v)\n            return;\n        wi.SetVisible(v)\n    }\n    function SetElementCSSStyle(prop, val) {\n        this.SetElementCSSStyle(prop, val)\n    }\n    function SetElementAttribute(attribName, value) {\n        this.SetElementAttribute(attribName, "" + value)\n    }\n    function RemoveElementAttribute(attribName) {\n        this.RemoveElementAttribute(attribName)\n    }\n    function SetElementFocus() {\n        this.FocusElement()\n    }\n    function SetElementBlur() {\n        this.BlurElement()\n    }\n    function IsElementFocused() {\n        return this.IsElementFocused()\n    }\n    function SetElementEnabled(e) {\n        this._SetEnabled(e !== 0)\n    }\n    function IsElementEnabled() {\n        return this._IsEnabled()\n    }\n    function CompareInstanceVar(iv, cmp, val) {\n        return C3.compare(this.GetInstance().GetInstanceVariableValue(iv), cmp, val)\n    }\n    function IsBoolInstanceVarSet(iv) {\n        return !!this.GetInstance().GetInstanceVariableValue(iv)\n    }\n    function TemplateName() {\n        const templateManager = this._runtime.GetTemplateManager();\n        if (!templateManager)\n            return "";\n        return templateManager.GetInstanceTemplateName(this.GetInstance())\n    }\n    function PickInstVarHiLow(which, iv) {\n        const sol = this.GetCurrentSol();\n        const instances = sol.GetInstances();\n        if (!instances.length)\n            return false;\n        let inst = instances[0];\n        let pickme = inst;\n        let val = inst.GetInstanceVariableValue(iv);\n        for (let i = 1, len = instances.length; i < len; ++i) {\n            inst = instances[i];\n            const v = inst.GetInstanceVariableValue(iv);\n            if (which === 0 && v < val || which === 1 && v > val) {\n                val = v;\n                pickme = inst\n            }\n        }\n        sol.PickOne(pickme);\n        return true\n    }\n    function PickByUID(uid) {\n        if (this._runtime.GetCurrentCondition().IsInverted())\n            return PickByUID_Inverted(this, uid);\n        else\n            return PickByUID_Normal(this, uid)\n    }\n    function PickByUID_Normal(objectClass, uid) {\n        const inst = objectClass.GetRuntime().GetInstanceByUID(uid);\n        if (!inst)\n            return false;\n        const sol = objectClass.GetCurrentSol();\n        if (!sol.IsSelectAll() && !sol._GetOwnInstances().includes(inst))\n            return false;\n        if (objectClass.IsFamily()) {\n            if (inst.GetObjectClass().BelongsToFamily(objectClass)) {\n                sol.PickOne(inst);\n                objectClass.ApplySolToContainer();\n                return true\n            }\n        } else if (inst.GetObjectClass() === objectClass) {\n            sol.PickOne(inst);\n            objectClass.ApplySolToContainer();\n            return true\n        }\n        return false\n    }\n    function PickByUID_Inverted(objectClass, uid) {\n        const sol = objectClass.GetCurrentSol();\n        if (sol.IsSelectAll()) {\n            sol._SetSelectAll(false);\n            sol.ClearArrays();\n            const instances = objectClass.GetInstances();\n            for (let i = 0, len = instances.length; i < len; ++i) {\n                const inst = instances[i];\n                if (inst.GetUID() === uid)\n                    sol._PushElseInstance(inst);\n                else\n                    sol._PushInstance(inst)\n            }\n            objectClass.ApplySolToContainer();\n            return !!sol._GetOwnInstances().length\n        } else {\n            const instances = sol._GetOwnInstances();\n            let j = 0;\n            for (let i = 0, len = instances.length; i < len; ++i) {\n                const inst = instances[i];\n                instances[j] = inst;\n                if (inst.GetUID() === uid)\n                    sol._PushElseInstance(inst);\n                else\n                    ++j\n            }\n            C3.truncateArray(instances, j);\n            objectClass.ApplySolToContainer();\n            return !!instances.length\n        }\n    }\n    function Destroy() {\n        this._runtime.DestroyInstance(this._inst)\n    }\n    function OnCreated() {\n        return true\n    }\n    function OnDestroyed() {\n        return true\n    }\n    function SetInstanceVar(iv, value) {\n        this.GetInstance().SetInstanceVariableValue(iv, value)\n    }\n    function AddInstanceVar(iv, value) {\n        const instance = this.GetInstance();\n        const lastValue = instance.GetInstanceVariableValue(iv);\n        if (typeof lastValue === "number" && typeof value !== "number")\n            value = parseFloat(value);\n        else if (typeof lastValue === "string" && typeof value !== "string")\n            value = value.toString();\n        instance.SetInstanceVariableValue(iv, lastValue + value)\n    }\n    function SubInstanceVar(iv, value) {\n        const instance = this.GetInstance();\n        const lastValue = instance.GetInstanceVariableValue(iv);\n        if (typeof lastValue !== "number")\n            return;\n        if (typeof value !== "number")\n            value = parseFloat(value);\n        instance.SetInstanceVariableValue(iv, lastValue - value)\n    }\n    function SetBoolInstanceVar(iv, value) {\n        this.GetInstance().SetInstanceVariableValue(iv, value ? 1 : 0)\n    }\n    function ToggleBoolInstanceVar(iv) {\n        const instance = this.GetInstance();\n        instance.SetInstanceVariableValue(iv, instance.GetInstanceVariableValue(iv) === 0 ? 1 : 0)\n    }\n    function LoadFromJsonString(str) {\n        let o;\n        try {\n            o = JSON.parse(str)\n        } catch (err) {\n            console.error("Failed to load from JSON string: ", err);\n            return\n        }\n        const inst = this.GetInstance();\n        const mode = "state";\n        inst._OnBeforeLoad(mode);\n        inst.LoadFromJson(o, mode);\n        const event = C3.New(C3.Event, "afterloadinstance");\n        event["instance"] = inst;\n        this._runtime.Dispatcher().dispatchEvent(event)\n    }\n    function AsJSON() {\n        return JSON.stringify(this.GetInstance().SaveToJson("state"))\n    }\n    function ObjectTypeName() {\n        return this.GetInstance().GetObjectClass().GetName()\n    }\n    function Count() {\n        const expObjectClass = this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass();\n        let count = expObjectClass.GetInstanceCount();\n        for (const inst of this._runtime.instancesPendingCreateForObjectClass(expObjectClass))\n            ++count;\n        return count\n    }\n    function PickedCount() {\n        return this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length\n    }\n    function GetIID() {\n        return this._inst.GetIID()\n    }\n    function GetUID() {\n        return this._inst.GetUID()\n    }\n    C3.AddCommonACEs = function AddCommonACEs(pluginData, pluginCtor) {\n        const isSingleGlobal = pluginData[1];\n        const hasPositionACEs = pluginData[3];\n        const hasSizeACEs = pluginData[4];\n        const hasAngleACEs = pluginData[5];\n        const hasAppearanceACEs = pluginData[6];\n        const hasZOrderACEs = pluginData[7];\n        const hasEffectsACEs = pluginData[8];\n        const hasElementACEs = pluginData[10];\n        const hasElementFocusACEs = pluginData[11];\n        const hasElementEnabledACEs = pluginData[12];\n        const hasSceneGraphACEs = pluginData[13];\n        const hasMeshACEs = pluginData[14];\n        const hasCollisionACEs = pluginData[15];\n        const hasTemplateACEs = pluginData[16];\n        const Cnds = pluginCtor.Cnds;\n        const Acts = pluginCtor.Acts;\n        const Exps = pluginCtor.Exps;\n        if (hasPositionACEs) {\n            Cnds.CompareX = CompareX;\n            Cnds.CompareY = CompareY;\n            Cnds.IsOnScreen = IsOnScreen;\n            Cnds.IsOutsideLayout = IsOutsideLayout;\n            Cnds.PickDistance = PickDistance;\n            Acts.SetX = SetX;\n            Acts.SetY = SetY;\n            Acts.SetPos = SetPos;\n            Acts.SetPosToObject = SetPosToObject;\n            Acts.MoveForward = MoveForward;\n            Acts.MoveAtAngle = MoveAtAngle;\n            Exps.X = GetX;\n            Exps.Y = GetY;\n            Exps.dt = GetDt\n        }\n        if (hasSizeACEs) {\n            Cnds.CompareWidth = CompareWidth;\n            Cnds.CompareHeight = CompareHeight;\n            Acts.SetWidth = SetWidth;\n            Acts.SetHeight = SetHeight;\n            Acts.SetSize = SetSize;\n            Exps.Width = GetWidth;\n            Exps.Height = GetHeight;\n            Exps.BBoxLeft = GetBboxLeft;\n            Exps.BBoxTop = GetBboxTop;\n            Exps.BBoxRight = GetBboxRight;\n            Exps.BBoxBottom = GetBboxBottom\n        }\n        if (hasAngleACEs) {\n            Cnds.AngleWithin = IsAngleWithin;\n            Cnds.IsClockwiseFrom = IsAngleClockwiseFrom;\n            Cnds.IsBetweenAngles = IsBetweenAngles;\n            Acts.SetAngle = SetAngle;\n            Acts.RotateClockwise = RotateClockwise;\n            Acts.RotateCounterclockwise = RotateCounterclockwise;\n            Acts.RotateTowardAngle = RotateTowardAngle;\n            Acts.RotateTowardPosition = RotateTowardPosition;\n            Acts.SetTowardPosition = SetTowardPosition;\n            Exps.Angle = GetAngle\n        }\n        if (hasAppearanceACEs) {\n            Cnds.IsVisible = IsVisible;\n            Cnds.CompareOpacity = CompareOpacity;\n            Acts.SetVisible = SetVisible;\n            Acts.SetOpacity = SetOpacity;\n            Acts.SetDefaultColor = SetDefaultColor;\n            Exps.Opacity = GetOpacity;\n            Exps.ColorValue = GetColor\n        }\n        if (hasZOrderACEs) {\n            Cnds.IsOnLayer = IsOnLayer;\n            Cnds.PickTopBottom = PickTopBottom;\n            Cnds.CompareZElevation = CompareZElevation;\n            Acts.MoveToTop = MoveToTop;\n            Acts.MoveToBottom = MoveToBottom;\n            Acts.MoveToLayer = MoveToLayer;\n            Acts.ZMoveToObject = ZMoveToObject;\n            Acts.SetZElevation = SetZElevation;\n            Exps.LayerNumber = LayerNumber;\n            Exps.LayerName = LayerName;\n            Exps.ZIndex = ZIndex;\n            Exps.ZElevation = ZElevation;\n            Exps.TotalZElevation = TotalZElevation\n        }\n        if (hasEffectsACEs) {\n            Cnds.IsEffectEnabled = IsEffectEnabled;\n            Acts.SetEffectEnabled = SetEffectEnabled;\n            Acts.SetEffectParam = SetEffectParam\n        }\n        if (hasSceneGraphACEs) {\n            Cnds.HasParent = HasParent;\n            Cnds.HasChildren = HasChildren;\n            Cnds.PickParent = PickParent;\n            Cnds.PickChildren = PickChildren;\n            Cnds.PickNthChild = PickNthChild;\n            Cnds.CompareChildCount = CompareChildCount;\n            Acts.AddChild = AddChild;\n            Acts.RemoveChild = RemoveChild;\n            Acts.RemoveFromParent = RemoveFromParent;\n            Exps.ChildCount = ChildCount;\n            Exps.AllChildCount = AllChildCount\n        }\n        if (hasMeshACEs) {\n            Acts.SetMeshSize = SetMeshSize;\n            Acts.SetMeshPoint = SetMeshPoint;\n            Exps.MeshColumns = MeshColumns;\n            Exps.MeshRows = MeshRows\n        }\n        if (hasElementACEs) {\n            Cnds.IsVisible = IsVisible;\n            Acts.SetVisible = SetElementVisible;\n            Acts.SetCSSStyle = SetElementCSSStyle;\n            Acts.SetElemAttribute = SetElementAttribute;\n            Acts.RemoveElemAttribute = RemoveElementAttribute\n        }\n        if (hasElementFocusACEs) {\n            Cnds.IsFocused = IsElementFocused;\n            Acts.SetFocus = SetElementFocus;\n            Acts.SetBlur = SetElementBlur\n        }\n        if (hasElementEnabledACEs) {\n            Cnds.IsEnabled = IsElementEnabled;\n            Acts.SetEnabled = SetElementEnabled\n        }\n        if (hasCollisionACEs) {\n            Cnds.OnCollision = OnCollision;\n            Cnds.IsOverlapping = IsOverlapping;\n            Cnds.IsOverlappingOffset = IsOverlappingOffset;\n            pluginCtor.FinishCollisionCondition = FinishCollisionCondition\n        }\n        if (!isSingleGlobal) {\n            Cnds.CompareInstanceVar = CompareInstanceVar;\n            Cnds.IsBoolInstanceVarSet = IsBoolInstanceVarSet;\n            Cnds.PickInstVarHiLow = PickInstVarHiLow;\n            Cnds.PickByUID = PickByUID;\n            Acts.SetInstanceVar = SetInstanceVar;\n            Acts.AddInstanceVar = AddInstanceVar;\n            Acts.SubInstanceVar = SubInstanceVar;\n            Acts.SetBoolInstanceVar = SetBoolInstanceVar;\n            Acts.ToggleBoolInstanceVar = ToggleBoolInstanceVar;\n            Cnds.OnCreated = OnCreated;\n            Cnds.OnDestroyed = OnDestroyed;\n            Acts.Destroy = Destroy;\n            if (!Acts.LoadFromJsonString)\n                Acts.LoadFromJsonString = LoadFromJsonString;\n            if (!Exps.AsJSON)\n                Exps.AsJSON = AsJSON;\n            Exps.Count = Count;\n            Exps.PickedCount = PickedCount;\n            Exps.IID = GetIID;\n            Exps.UID = GetUID;\n            Exps.ObjectTypeName = ObjectTypeName\n        }\n        if (hasTemplateACEs)\n            Exps.TemplateName = TemplateName\n    }\n    ;\n\n}\n\n\/\/ events\/scheduledWait.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.ScheduledWait = class ScheduledWait extends C3.DefendedBase {\n        constructor(eventSheetManager) {\n            super();\n            this._eventSheetManager = eventSheetManager;\n            this._type = "";\n            this._time = -1;\n            this._signalTag = "";\n            this._isSignalled = false;\n            this._event = null;\n            this._actIndex = 0;\n            this._solModifiers = [];\n            this._sols = new Map;\n            this._callingFunctionBlock = null;\n            this._asyncId = -1;\n            this._functionParameters = null;\n            this._functionInnerLocalVars = null;\n            this._shouldRelease = false\n        }\n        Release() {\n            this._type = "";\n            this._time = -1;\n            this._signalTag = "";\n            this._event = null;\n            this._callingFunctionBlock = null;\n            this._functionParameters = null;\n            this._functionInnerLocalVars = null;\n            this._asyncId = -1;\n            C3.clearArray(this._solModifiers);\n            for (const s of this._sols.values())\n                s.Release();\n            this._sols.clear()\n        }\n        _Init() {\n            const eventSheetManager = this._eventSheetManager;\n            const allObjectClasses = eventSheetManager.GetRuntime().GetAllObjectClasses();\n            const frame = eventSheetManager.GetCurrentEventStackFrame();\n            this._event = frame.GetCurrentEvent();\n            this._actIndex = frame.GetActionIndex() + 1;\n            const functionBlock = eventSheetManager.FindFirstFunctionBlockParent(this._event);\n            if (functionBlock) {\n                this._callingFunctionBlock = functionBlock;\n                this._functionParameters = functionBlock.CaptureFunctionParameters();\n                this._functionInnerLocalVars = functionBlock._GetAllInnerLocalVariables().map(v => v.GetValue());\n                if (functionBlock.IsAsync())\n                    this._asyncId = functionBlock.PauseCurrentAsyncFunction()\n            }\n            for (const objectClass of allObjectClasses) {\n                const sol = objectClass.GetCurrentSol();\n                if (sol.IsSelectAll() && !this._event.HasSolModifier(objectClass))\n                    continue;\n                this._solModifiers.push(objectClass);\n                this._sols.set(objectClass, C3.New(C3.SolState, sol))\n            }\n        }\n        InitTimer(seconds) {\n            this._type = "timer";\n            this._Init();\n            this._time = this._eventSheetManager.GetRuntime().GetGameTime() + seconds\n        }\n        InitSignal(tag) {\n            this._type = "signal";\n            this._Init();\n            this._signalTag = tag.toLowerCase()\n        }\n        InitPromise(p) {\n            this._type = "promise";\n            this._Init();\n            p.then( () => this.SetSignalled()).catch(err => {\n                console.warn("[C3 runtime] Promise rejected in \'Wait for previous actions to complete\': ", err);\n                this.SetSignalled()\n            }\n            )\n        }\n        IsTimer() {\n            return this._type === "timer"\n        }\n        IsSignal() {\n            return this._type === "signal"\n        }\n        IsPromise() {\n            return this._type === "promise"\n        }\n        GetSignalTag() {\n            return this._signalTag\n        }\n        IsSignalled() {\n            return this._isSignalled\n        }\n        SetSignalled() {\n            this._isSignalled = true\n        }\n        _ShouldRun() {\n            if (this.IsTimer())\n                return this._time <= this._eventSheetManager.GetRuntime().GetGameTime();\n            else\n                return this.IsSignalled()\n        }\n        _RestoreState(frame) {\n            frame._Restore(this._event, this._actIndex);\n            for (const [objectClass,solState] of this._sols.entries()) {\n                const sol = objectClass.GetCurrentSol();\n                solState._Restore(sol)\n            }\n            const callingFunctionBlock = this._callingFunctionBlock;\n            if (callingFunctionBlock) {\n                callingFunctionBlock.SetFunctionParameters(this._functionParameters);\n                callingFunctionBlock._GetAllInnerLocalVariables().map( (v, index) => v.SetValue(this._functionInnerLocalVars[index]));\n                if (callingFunctionBlock.IsAsync())\n                    callingFunctionBlock.ResumeAsyncFunction(this._asyncId)\n            }\n        }\n        _Run(frame) {\n            this._RestoreState(frame);\n            this._event._ResumeActionsAndSubEvents(frame);\n            if (this._callingFunctionBlock && this._callingFunctionBlock.IsAsync())\n                this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);\n            this._eventSheetManager.ClearSol(this._solModifiers);\n            this._shouldRelease = true\n        }\n        async _DebugRun(frame) {\n            this._RestoreState(frame);\n            for (const breakEventObject of this._event._DebugResumeActionsAndSubEvents(frame))\n                await this._eventSheetManager.GetRuntime().DebugBreak(breakEventObject);\n            if (this._callingFunctionBlock && this._callingFunctionBlock.IsAsync())\n                this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);\n            this._eventSheetManager.ClearSol(this._solModifiers);\n            this._shouldRelease = true\n        }\n        ShouldRelease() {\n            return this._shouldRelease\n        }\n        RemoveInstances(s) {\n            for (const solState of this._sols.values())\n                solState.RemoveInstances(s)\n        }\n        _SaveToJson() {\n            const sols = {};\n            const o = {\n                "t": this._time,\n                "st": this._signalTag,\n                "s": this._isSignalled,\n                "ev": this._event.GetSID(),\n                "sm": this._solModifiers.map(oc => oc.GetSID()),\n                "sols": sols\n            };\n            if (this._event._HasActionIndex(this._actIndex))\n                o["act"] = this._event.GetActionAt(this._actIndex).GetSID();\n            for (const [objectClass,solState] of this._sols)\n                sols[objectClass.GetSID().toString()] = solState._SaveToJson();\n            return o\n        }\n        static _CreateFromJson(eventSheetManager, o) {\n            const runtime = eventSheetManager.GetRuntime();\n            const event = eventSheetManager.GetEventBlockBySID(o["ev"]);\n            if (!event)\n                return null;\n            let actIndex = 0;\n            if (o.hasOwnProperty("act")) {\n                const act = eventSheetManager.GetActionBySID(o["act"]);\n                if (!act)\n                    return null;\n                actIndex = act.GetIndex()\n            }\n            const sw = C3.New(C3.ScheduledWait, eventSheetManager);\n            sw._time = o["t"];\n            sw._type = sw._time === -1 ? "signal" : "timer";\n            sw._signalTag = o["st"];\n            sw._isSignalled = o["s"];\n            sw._event = event;\n            sw._actIndex = actIndex;\n            for (const sid of o["sm"]) {\n                const objectClass = runtime.GetObjectClassBySID(sid);\n                if (objectClass)\n                    sw._solModifiers.push(objectClass)\n            }\n            for (const [sidStr,solData] of Object.entries(o["sols"])) {\n                const sid = parseInt(sidStr, 10);\n                const objectClass = runtime.GetObjectClassBySID(sid);\n                if (!objectClass)\n                    continue;\n                const solState = C3.New(C3.SolState, null);\n                solState._LoadFromJson(eventSheetManager, solData);\n                sw._sols.set(objectClass, solState)\n            }\n            return sw\n        }\n    }\n    ;\n\n}\n\n\/\/ events\/solState.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.SolState = class SolState extends C3.DefendedBase {\n        constructor(sol) {\n            super();\n            this._objectClass = null;\n            this._isSelectAll = true;\n            this._instances = [];\n            if (sol) {\n                this._objectClass = sol.GetObjectClass();\n                this._isSelectAll = sol.IsSelectAll();\n                C3.shallowAssignArray(this._instances, sol._GetOwnInstances())\n            }\n        }\n        Release() {\n            this._objectClass = null;\n            C3.clearArray(this._instances)\n        }\n        _Restore(sol) {\n            sol._SetSelectAll(this._isSelectAll);\n            C3.shallowAssignArray(sol._GetOwnInstances(), this._instances)\n        }\n        RemoveInstances(s) {\n            C3.arrayRemoveAllInSet(this._instances, s)\n        }\n        _SaveToJson() {\n            return {\n                "sa": this._isSelectAll,\n                "insts": this._instances.map(inst => inst.GetUID())\n            }\n        }\n        _LoadFromJson(eventSheetManager, o) {\n            const runtime = eventSheetManager.GetRuntime();\n            this._isSelectAll = !!o["sa"];\n            C3.clearArray(this._instances);\n            for (const uid of o["insts"]) {\n                const inst = runtime.GetInstanceByUID(uid);\n                if (inst)\n                    this._instances.push(inst)\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ sdk\/sdkPluginBase.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    function GetNextParamMap(paramMap, param) {\n        let nextParamMap = paramMap.get(param);\n        if (!nextParamMap) {\n            nextParamMap = new Map;\n            paramMap.set(param, nextParamMap)\n        }\n        return nextParamMap\n    }\n    C3.SDKPluginBase = class SDKPluginBase extends C3.DefendedBase {\n        constructor(opts) {\n            super();\n            this._runtime = opts.runtime;\n            this._isSingleGlobal = !!opts.isSingleGlobal;\n            this._isWorldType = !!opts.isWorld;\n            this._isRotatable = !!opts.isRotatable;\n            this._mustPredraw = !!opts.mustPredraw;\n            this._hasEffects = !!opts.hasEffects;\n            this._supportsSceneGraph = !!opts.supportsSceneGraph;\n            this._supportsMesh = !!opts.supportsMesh;\n            this._singleGlobalObjectClass = null;\n            this._boundACEMethodCache = new Map;\n            this._boundACEMethodCache_1param = new Map;\n            this._boundACEMethodCache_2params = new Map;\n            this._boundACEMethodCache_3params = new Map\n        }\n        Release() {\n            this._runtime = null\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        OnCreate() {}\n        IsSingleGlobal() {\n            return this._isSingleGlobal\n        }\n        IsWorldType() {\n            return this._isWorldType\n        }\n        IsRotatable() {\n            return this._isRotatable\n        }\n        MustPreDraw() {\n            return this._mustPredraw\n        }\n        HasEffects() {\n            return this._hasEffects\n        }\n        SupportsSceneGraph() {\n            return this._supportsSceneGraph\n        }\n        SupportsMesh() {\n            return this._supportsMesh\n        }\n        _GetBoundACEMethod(func, bindThis) {\n            if (!bindThis)\n                throw new Error("missing \'this\' binding");\n            let ret = this._boundACEMethodCache.get(func);\n            if (ret)\n                return ret;\n            ret = func.bind(bindThis);\n            this._boundACEMethodCache.set(func, ret);\n            return ret\n        }\n        _GetBoundACEMethod_1param(func, bindThis, param0) {\n            if (!bindThis)\n                throw new Error("missing \'this\' binding");\n            const param0map = GetNextParamMap(this._boundACEMethodCache_1param, func);\n            let ret = param0map.get(param0);\n            if (ret)\n                return ret;\n            ret = func.bind(bindThis, param0);\n            param0map.set(param0, ret);\n            return ret\n        }\n        _GetBoundACEMethod_2params(func, bindThis, param0, param1) {\n            if (!bindThis)\n                throw new Error("missing \'this\' binding");\n            const param0map = GetNextParamMap(this._boundACEMethodCache_2params, func);\n            const param1map = GetNextParamMap(param0map, param0);\n            let ret = param1map.get(param1);\n            if (ret)\n                return ret;\n            ret = func.bind(bindThis, param0, param1);\n            param1map.set(param1, ret);\n            return ret\n        }\n        _GetBoundACEMethod_3params(func, bindThis, param0, param1, param2) {\n            if (!bindThis)\n                throw new Error("missing \'this\' binding");\n            const param0map = GetNextParamMap(this._boundACEMethodCache_3params, func);\n            const param1map = GetNextParamMap(param0map, param0);\n            const param2map = GetNextParamMap(param1map, param1);\n            let ret = param2map.get(param2);\n            if (ret)\n                return ret;\n            ret = func.bind(bindThis, param0, param1, param2);\n            param2map.set(param2, ret);\n            return ret\n        }\n        _SetSingleGlobalObjectClass(objectClass) {\n            if (!this.IsSingleGlobal())\n                throw new Error("must be single-global plugin");\n            this._singleGlobalObjectClass = objectClass\n        }\n        GetSingleGlobalObjectClass() {\n            if (!this.IsSingleGlobal())\n                throw new Error("must be single-global plugin");\n            return this._singleGlobalObjectClass\n        }\n        GetSingleGlobalInstance() {\n            if (!this.IsSingleGlobal())\n                throw new Error("must be single-global plugin");\n            return this._singleGlobalObjectClass.GetSingleGlobalInstance()\n        }\n    }\n    ;\n\n}\n\n\/\/ sdk\/sdkDOMPluginBase.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.SDKDOMPluginBase = class SDKDOMPluginBase extends C3.SDKPluginBase {\n        constructor(opts, DOM_COMPONENT_ID) {\n            super(opts);\n            this._domComponentId = DOM_COMPONENT_ID;\n            this._nextElementId = 0;\n            this._instMap = new Map;\n            this.AddElementMessageHandler("elem-focused", sdkInst => sdkInst._OnElemFocused());\n            this.AddElementMessageHandler("elem-blurred", sdkInst => {\n                if (sdkInst)\n                    sdkInst._OnElemBlurred()\n            }\n            )\n        }\n        Release() {\n            super.Release()\n        }\n        _AddElement(sdkInst) {\n            const elementId = this._nextElementId++;\n            this._instMap.set(elementId, sdkInst);\n            return elementId\n        }\n        _RemoveElement(elementId) {\n            this._instMap.delete(elementId)\n        }\n        AddElementMessageHandler(handler, func) {\n            this._runtime.AddDOMComponentMessageHandler(this._domComponentId, handler, e => {\n                const sdkInst = this._instMap.get(e["elementId"]);\n                func(sdkInst, e)\n            }\n            )\n        }\n    }\n    ;\n\n}\n\n\/\/ sdk\/sdkTypeBase.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.SDKTypeBase = class SDKTypeBase extends C3.DefendedBase {\n        constructor(objectClass) {\n            super();\n            this._objectClass = objectClass;\n            this._runtime = objectClass.GetRuntime();\n            this._plugin = objectClass.GetPlugin()\n        }\n        Release() {\n            this._objectClass = null;\n            this._runtime = null;\n            this._plugin = null\n        }\n        GetObjectClass() {\n            return this._objectClass\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetPlugin() {\n            return this._plugin\n        }\n        GetImageInfo() {\n            return this._objectClass.GetImageInfo()\n        }\n        FinishCondition(f) {}\n        BeforeRunAction(method) {}\n        AfterRunAction(method) {}\n        LoadTextures(renderer) {}\n        ReleaseTextures() {}\n        OnDynamicTextureLoadComplete() {}\n        PreloadTexturesWithInstances(renderer) {}\n        LoadTilemapData() {}\n        GetScriptInterfaceClass() {\n            return null\n        }\n    }\n    ;\n\n}\n\n\/\/ sdk\/sdkInstanceBase.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.SDKInstanceBase = class SDKInstanceBase extends C3.DefendedBase {\n        constructor(inst, domComponentId) {\n            super();\n            this._inst = inst;\n            this._domComponentId = domComponentId;\n            this._runtime = inst.GetRuntime();\n            this._objectClass = this._inst.GetObjectClass();\n            this._sdkType = this._objectClass.GetSdkType();\n            this._tickFunc = null;\n            this._tick2Func = null;\n            this._isTicking = false;\n            this._isTicking2 = false;\n            this._disposables = null;\n            this._wasReleased = false\n        }\n        Release() {\n            this._wasReleased = true;\n            this._StopTicking();\n            this._StopTicking2();\n            this._tickFunc = null;\n            this._tick2Func = null;\n            if (this._disposables) {\n                this._disposables.Release();\n                this._disposables = null\n            }\n            this._inst = null;\n            this._runtime = null;\n            this._objectClass = null;\n            this._sdkType = null\n        }\n        WasReleased() {\n            return this._wasReleased\n        }\n        GetInstance() {\n            return this._inst\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetObjectClass() {\n            return this._objectClass\n        }\n        GetPlugin() {\n            return this._sdkType.GetPlugin()\n        }\n        GetSdkType() {\n            return this._sdkType\n        }\n        GetScriptInterface() {\n            return this._inst.GetInterfaceClass()\n        }\n        Trigger(method) {\n            return this._runtime.Trigger(method, this._inst, null)\n        }\n        DebugTrigger(method) {\n            return this._runtime.DebugTrigger(method, this._inst, null)\n        }\n        TriggerAsync(method) {\n            return this._runtime.TriggerAsync(method, this._inst, null)\n        }\n        FastTrigger(method, value) {\n            return this._runtime.FastTrigger(method, this._inst, value)\n        }\n        DebugFastTrigger(method, value) {\n            return this._runtime.DebugFastTrigger(method, this._inst, value)\n        }\n        ScheduleTriggers(f) {\n            return this._runtime.ScheduleTriggers(f)\n        }\n        AddDOMMessageHandler(handler, func) {\n            this._runtime.AddDOMComponentMessageHandler(this._domComponentId, handler, func)\n        }\n        AddDOMMessageHandlers(list) {\n            for (const [handler,func] of list)\n                this.AddDOMMessageHandler(handler, func)\n        }\n        PostToDOM(handler, data) {\n            this._runtime.PostComponentMessageToDOM(this._domComponentId, handler, data)\n        }\n        PostToDOMAsync(handler, data) {\n            return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, handler, data)\n        }\n        _PostToDOMMaybeSync(handler, data) {\n            if (this._runtime.IsInWorker())\n                this.PostToDOM(handler, data);\n            else\n                return window["c3_runtimeInterface"]["_OnMessageFromRuntime"]({\n                    "type": "event",\n                    "component": this._domComponentId,\n                    "handler": handler,\n                    "data": data,\n                    "responseId": null\n                })\n        }\n        Tick() {}\n        Tick2() {}\n        _StartTicking() {\n            if (this._isTicking)\n                return;\n            if (!this._tickFunc)\n                this._tickFunc = () => this.Tick();\n            this._runtime.Dispatcher().addEventListener("tick", this._tickFunc);\n            this._isTicking = true\n        }\n        _StopTicking() {\n            if (!this._isTicking)\n                return;\n            this._runtime.Dispatcher().removeEventListener("tick", this._tickFunc);\n            this._isTicking = false\n        }\n        IsTicking() {\n            return this._isTicking\n        }\n        _StartTicking2() {\n            if (this._isTicking2)\n                return;\n            if (!this._tick2Func)\n                this._tick2Func = () => this.Tick2();\n            this._runtime.Dispatcher().addEventListener("tick2", this._tick2Func);\n            this._isTicking2 = true\n        }\n        _StopTicking2() {\n            if (!this._isTicking2)\n                return;\n            this._runtime.Dispatcher().removeEventListener("tick2", this._tick2Func);\n            this._isTicking2 = false\n        }\n        IsTicking2() {\n            return this._isTicking2\n        }\n        GetDebuggerProperties() {\n            return []\n        }\n        SaveToJson() {\n            return null\n        }\n        LoadFromJson(o) {}\n        GetPropertyValueByIndex(index) {}\n        SetPropertyValueByIndex(index, value) {}\n        OffsetPropertyValueByIndex(index, offset) {\n            if (offset === 0)\n                return;\n            const value = this.GetPropertyValueByIndex(index);\n            if (typeof value !== "number")\n                throw new Error("expected number");\n            this.SetPropertyValueByIndex(index, value + offset)\n        }\n        SetPropertyColorOffsetValueByIndex(offset, r, g, b) {}\n        CallAction(actMethod, ...args) {\n            actMethod.call(this, ...args)\n        }\n        CallExpression(expMethod, ...args) {\n            return expMethod.call(this, ...args)\n        }\n        GetScriptInterfaceClass() {\n            return null\n        }\n        DispatchScriptEvent(name, cancelable, additionalProperties) {\n            const scriptInterface = this.GetScriptInterface();\n            const e = C3.New(C3.Event, name, cancelable);\n            e.instance = scriptInterface;\n            if (additionalProperties)\n                Object.assign(e, additionalProperties);\n            scriptInterface.dispatchEvent(e)\n        }\n    }\n    ;\n\n}\n\n\/\/ sdk\/sdkWorldInstanceBase.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.SDKWorldInstanceBase = class SDKWorldInstanceBase extends C3.SDKInstanceBase {\n        constructor(inst, domComponentId) {\n            super(inst, domComponentId);\n            this._worldInfo = inst.GetWorldInfo();\n            this._webglcontextlost_handler = null;\n            this._webglcontextrestored_handler = null\n        }\n        Release() {\n            if (this._webglcontextlost_handler) {\n                const dispatcher = this._runtime.Dispatcher();\n                dispatcher.removeEventListener("webglcontextlost", this._webglcontextlost_handler);\n                dispatcher.removeEventListener("webglcontextrestored", this._webglcontextrestored_handler);\n                this._webglcontextlost_handler = null;\n                this._webglcontextrestored_handler = null\n            }\n            this._worldInfo = null;\n            super.Release()\n        }\n        HandleWebGLContextLoss() {\n            if (this._webglcontextlost_handler)\n                return;\n            this._webglcontextlost_handler = () => this.OnWebGLContextLost();\n            this._webglcontextrestored_handler = () => this.OnWebGLContextRestored();\n            const dispatcher = this._runtime.Dispatcher();\n            dispatcher.addEventListener("webglcontextlost", this._webglcontextlost_handler);\n            dispatcher.addEventListener("webglcontextrestored", this._webglcontextrestored_handler)\n        }\n        OnWebGLContextLost() {}\n        OnWebGLContextRestored() {}\n        GetWorldInfo() {\n            return this._worldInfo\n        }\n        IsOriginalSizeKnown() {\n            return false\n        }\n        GetOriginalWidth() {\n            if (!this.IsOriginalSizeKnown())\n                throw new Error("original size not known");\n            const imageInfo = this.GetCurrentImageInfo();\n            if (imageInfo)\n                return imageInfo.GetWidth();\n            else\n                ;\n        }\n        GetOriginalHeight() {\n            if (!this.IsOriginalSizeKnown())\n                throw new Error("original size not known");\n            const imageInfo = this.GetCurrentImageInfo();\n            if (imageInfo)\n                return imageInfo.GetHeight();\n            else\n                ;\n        }\n        GetCurrentImageInfo() {\n            return null\n        }\n        GetCurrentSurfaceSize() {\n            const imageInfo = this.GetCurrentImageInfo();\n            if (imageInfo) {\n                const texture = imageInfo.GetTexture();\n                if (texture)\n                    return [texture.GetWidth(), texture.GetHeight()]\n            }\n            return [100, 100]\n        }\n        GetCurrentTexRect() {\n            const imageInfo = this.GetCurrentImageInfo();\n            return imageInfo ? imageInfo.GetTexRect() : null\n        }\n        GetCurrentTexQuad() {\n            const imageInfo = this.GetCurrentImageInfo();\n            return imageInfo ? imageInfo.GetTexQuad() : null\n        }\n        IsCurrentTexRotated() {\n            const imageInfo = this.GetCurrentImageInfo();\n            return imageInfo ? imageInfo.IsRotated() : false\n        }\n        GetImagePoint(nameOrIndex) {\n            const wi = this._inst.GetWorldInfo();\n            return [wi.GetX(), wi.GetY()]\n        }\n        LoadTilemapData(data, mapWidth, mapHeight) {}\n        TestPointOverlapTile(x, y) {}\n        RendersToOwnZPlane() {\n            return true\n        }\n    }\n    ;\n\n}\n\n\/\/ sdk\/sdkDOMInstanceBase.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const tempRect = C3.New(C3.Rect);\n    C3.SDKDOMInstanceBase = class SDKDOMInstanceBase extends C3.SDKWorldInstanceBase {\n        constructor(inst, domComponentId) {\n            super(inst, domComponentId);\n            this._elementId = this.GetPlugin()._AddElement(this);\n            this._isElementShowing = true;\n            this._elemHasFocus = false;\n            this._autoFontSize = false;\n            this._autoFontSizeOffset = -.2;\n            this._lastRect = C3.New(C3.Rect, 0, 0, -1, -1);\n            const canvasManager = this._runtime.GetCanvasManager();\n            this._lastWindowWidth = canvasManager.GetLastWidth();\n            this._lastWindowHeight = canvasManager.GetLastHeight();\n            this._isPendingUpdateState = false;\n            this._StartTicking()\n        }\n        Release() {\n            this.GetPlugin()._RemoveElement(this._elementId);\n            this.PostToDOMElement("destroy");\n            this._elementId = -1;\n            super.Release()\n        }\n        _GetElementInDOMMode() {\n            if (this._runtime.IsInWorker())\n                throw new Error("not valid in worker mode");\n            return this._PostToDOMElementMaybeSync("get-element")\n        }\n        PostToDOMElement(handler, data) {\n            if (!data)\n                data = {};\n            data["elementId"] = this._elementId;\n            this.PostToDOM(handler, data)\n        }\n        _PostToDOMElementMaybeSync(handler, data) {\n            if (!data)\n                data = {};\n            data["elementId"] = this._elementId;\n            return this._PostToDOMMaybeSync(handler, data)\n        }\n        PostToDOMElementAsync(handler, data) {\n            if (!data)\n                data = {};\n            data["elementId"] = this._elementId;\n            return this.PostToDOMAsync(handler, data)\n        }\n        CreateElement(data) {\n            if (!data)\n                data = {};\n            const isVisible = this.GetWorldInfo().IsVisible();\n            data["elementId"] = this._elementId;\n            data["isVisible"] = isVisible;\n            Object.assign(data, this.GetElementState());\n            this._isElementShowing = !!data["isVisible"];\n            this._PostToDOMMaybeSync("create", data);\n            this._UpdatePosition(true)\n        }\n        SetElementVisible(v) {\n            v = !!v;\n            if (this._isElementShowing === v)\n                return;\n            this._isElementShowing = v;\n            this.PostToDOMElement("set-visible", {\n                "isVisible": v\n            })\n        }\n        Tick() {\n            this._UpdatePosition(false)\n        }\n        _ShouldPreserveElement() {\n            const fullscreenMode = this._runtime.GetCanvasManager().GetFullscreenMode();\n            return C3.Platform.OS === "Android" && (fullscreenMode === "scale-inner" || fullscreenMode === "scale-outer" || fullscreenMode === "crop")\n        }\n        _UpdatePosition(first) {\n            const wi = this.GetWorldInfo();\n            const layer = wi.GetLayer();\n            const bbox = wi.GetBoundingBox();\n            let[cleft,ctop] = layer.LayerToCanvasCss(bbox.getLeft(), bbox.getTop());\n            let[cright,cbottom] = layer.LayerToCanvasCss(bbox.getRight(), bbox.getBottom());\n            const canvasManager = this._runtime.GetCanvasManager();\n            const rightEdge = canvasManager.GetCssWidth();\n            const bottomEdge = canvasManager.GetCssHeight();\n            if (!wi.IsVisible() || !layer.IsVisible()) {\n                this.SetElementVisible(false);\n                return\n            }\n            if (!this._ShouldPreserveElement()) {\n                if (cright <= 0 || cbottom <= 0 || cleft >= rightEdge || ctop >= bottomEdge) {\n                    this.SetElementVisible(false);\n                    return\n                }\n                if (cleft < 1)\n                    cleft = 1;\n                if (ctop < 1)\n                    ctop = 1;\n                if (cright >= rightEdge)\n                    cright = rightEdge - 1;\n                if (cbottom >= bottomEdge)\n                    cbottom = bottomEdge - 1\n            }\n            tempRect.set(cleft, ctop, cright, cbottom);\n            const curWinWidth = canvasManager.GetLastWidth();\n            const curWinHeight = canvasManager.GetLastHeight();\n            if (!first && tempRect.equals(this._lastRect) && this._lastWindowWidth === curWinWidth && this._lastWindowHeight === curWinHeight) {\n                this.SetElementVisible(true);\n                return\n            }\n            this._lastRect.copy(tempRect);\n            this._lastWindowWidth = curWinWidth;\n            this._lastWindowHeight = curWinHeight;\n            this.SetElementVisible(true);\n            let fontSize = null;\n            if (this._autoFontSize)\n                fontSize = layer.GetDisplayScale() + this._autoFontSizeOffset;\n            this.PostToDOMElement("update-position", {\n                "left": Math.round(this._lastRect.getLeft()) + canvasManager.GetCanvasClientX(),\n                "top": Math.round(this._lastRect.getTop()) + canvasManager.GetCanvasClientY(),\n                "width": Math.round(this._lastRect.width()),\n                "height": Math.round(this._lastRect.height()),\n                "fontSize": fontSize\n            })\n        }\n        FocusElement() {\n            this._PostToDOMElementMaybeSync("focus", {\n                "focus": true\n            })\n        }\n        BlurElement() {\n            this._PostToDOMElementMaybeSync("focus", {\n                "focus": false\n            })\n        }\n        _OnElemFocused() {\n            this._elemHasFocus = true\n        }\n        _OnElemBlurred() {\n            this._elemHasFocus = false\n        }\n        IsElementFocused() {\n            return this._elemHasFocus\n        }\n        SetElementCSSStyle(prop, val) {\n            this.PostToDOMElement("set-css-style", {\n                "prop": C3.CSSToCamelCase(prop),\n                "val": val\n            })\n        }\n        SetElementAttribute(attribName, value) {\n            this.PostToDOMElement("set-attribute", {\n                "name": attribName,\n                "val": value\n            })\n        }\n        RemoveElementAttribute(attribName) {\n            this.PostToDOMElement("remove-attribute", {\n                "name": attribName\n            })\n        }\n        UpdateElementState() {\n            if (this._isPendingUpdateState)\n                return;\n            this._isPendingUpdateState = true;\n            Promise.resolve().then( () => {\n                this._isPendingUpdateState = false;\n                this.PostToDOMElement("update-state", this.GetElementState())\n            }\n            )\n        }\n        GetElementState() {}\n        GetElementId() {\n            return this._elementId\n        }\n    }\n    ;\n\n}\n\n\/\/ sdk\/sdkBehaviorBase.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const IBehavior = self.IBehavior;\n    C3.SDKBehaviorBase = class SDKBehaviorBase extends C3.DefendedBase {\n        constructor(opts) {\n            super();\n            this._runtime = opts.runtime;\n            this._myObjectClasses = C3.New(C3.ArraySet);\n            this._myInstances = C3.New(C3.ArraySet);\n            this._iBehavior = null;\n            this._scriptInterfaceClass = opts.scriptInterfaceClass || null\n        }\n        Release() {\n            this._myInstances.Release();\n            this._myObjectClasses.Release();\n            this._runtime = null\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        OnCreate() {}\n        _AddObjectClass(objectClass) {\n            this._myObjectClasses.Add(objectClass)\n        }\n        GetObjectClasses() {\n            return this._myObjectClasses.GetArray()\n        }\n        _AddInstance(inst) {\n            this._myInstances.Add(inst)\n        }\n        _RemoveInstance(inst) {\n            this._myInstances.Delete(inst)\n        }\n        GetInstances() {\n            return this._myInstances.GetArray()\n        }\n        GetIBehavior() {\n            if (this._iBehavior === null) {\n                const CustomScriptClass = this._scriptInterfaceClass;\n                if (CustomScriptClass) {\n                    this._iBehavior = new CustomScriptClass(this);\n                    if (!(this._iBehavior instanceof IBehavior))\n                        throw new TypeError("script interface class must derive from IBehavior");\n                } else\n                    this._iBehavior = new IBehavior(this)\n            }\n            return this._iBehavior\n        }\n    }\n    ;\n\n}\n\n\/\/ sdk\/sdkBehaviorTypeBase.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.SDKBehaviorTypeBase = class SDKBehaviorTypeBase extends C3.DefendedBase {\n        constructor(behaviorType) {\n            super();\n            this._runtime = behaviorType.GetRuntime();\n            this._behaviorType = behaviorType;\n            this._objectClass = behaviorType.GetObjectClass();\n            this._behavior = behaviorType.GetBehavior();\n            this._behavior._AddObjectClass(this._objectClass)\n        }\n        Release() {\n            this._runtime = null;\n            this._behaviorType = null;\n            this._objectClass = null;\n            this._behavior = null\n        }\n        GetBehaviorType() {\n            return this._behaviorType\n        }\n        GetObjectClass() {\n            return this._objectClass\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetBehavior() {\n            return this._behavior\n        }\n    }\n    ;\n\n}\n\n\/\/ sdk\/sdkBehaviorInstanceBase.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.SDKBehaviorInstanceBase = class SDKBehaviorInstanceBase extends C3.DefendedBase {\n        constructor(behInst, domComponentId) {\n            super();\n            this._behInst = behInst;\n            this._domComponentId = domComponentId;\n            this._inst = behInst.GetObjectInstance();\n            this._runtime = behInst.GetRuntime();\n            this._behaviorType = behInst.GetBehaviorType();\n            this._sdkType = this._behaviorType.GetSdkType();\n            this._isTicking = false;\n            this._isTicking2 = false;\n            this._isPostTicking = false;\n            this._disposables = null\n        }\n        Release() {\n            this._StopTicking();\n            this._StopTicking2();\n            this._StopPostTicking();\n            if (this._disposables) {\n                this._disposables.Release();\n                this._disposables = null\n            }\n            this._behInst = null;\n            this._inst = null;\n            this._runtime = null;\n            this._behaviorType = null;\n            this._sdkType = null\n        }\n        GetBehavior() {\n            return this._behaviorType.GetBehavior()\n        }\n        GetBehaviorInstance() {\n            return this._behInst\n        }\n        GetObjectInstance() {\n            return this._inst\n        }\n        GetObjectClass() {\n            return this._inst.GetObjectClass()\n        }\n        GetWorldInfo() {\n            return this._inst.GetWorldInfo()\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetBehaviorType() {\n            return this._behaviorType\n        }\n        GetSdkType() {\n            return this._sdkType\n        }\n        GetScriptInterface() {\n            return this._behInst.GetScriptInterface()\n        }\n        Trigger(method) {\n            return this._runtime.Trigger(method, this._inst, this._behaviorType)\n        }\n        DebugTrigger(method) {\n            return this._runtime.DebugTrigger(method, this._inst, this._behaviorType)\n        }\n        TriggerAsync(method) {\n            return this._runtime.TriggerAsync(method, this._inst, this._behaviorType)\n        }\n        PostCreate() {}\n        Tick() {}\n        Tick2() {}\n        PostTick() {}\n        _StartTicking() {\n            if (this._isTicking)\n                return;\n            this._runtime._AddBehInstToTick(this);\n            this._isTicking = true\n        }\n        _StopTicking() {\n            if (!this._isTicking)\n                return;\n            this._runtime._RemoveBehInstToTick(this);\n            this._isTicking = false\n        }\n        IsTicking() {\n            return this._isTicking\n        }\n        _StartTicking2() {\n            if (this._isTicking2)\n                return;\n            this._runtime._AddBehInstToTick2(this);\n            this._isTicking2 = true\n        }\n        _StopTicking2() {\n            if (!this._isTicking2)\n                return;\n            this._runtime._RemoveBehInstToTick2(this);\n            this._isTicking2 = false\n        }\n        IsTicking2() {\n            return this._isTicking2\n        }\n        _StartPostTicking() {\n            if (this._isPostTicking)\n                return;\n            this._runtime._AddBehInstToPostTick(this);\n            this._isPostTicking = true\n        }\n        _StopPostTicking() {\n            if (!this._isPostTicking)\n                return;\n            this._runtime._RemoveBehInstToPostTick(this);\n            this._isPostTicking = false\n        }\n        IsPostTicking() {\n            return this._isPostTicking\n        }\n        GetDebuggerProperties() {\n            return []\n        }\n        AddDOMMessageHandler(handler, func) {\n            this._runtime.AddDOMComponentMessageHandler(this._domComponentId, handler, func)\n        }\n        OnSpriteFrameChanged(prevFrame, nextFrame) {}\n        SaveToJson() {\n            return null\n        }\n        LoadFromJson(o) {}\n        GetPropertyValueByIndex(index) {}\n        SetPropertyValueByIndex(index, value) {}\n        OffsetPropertyValueByIndex(index, offset) {\n            if (offset === 0)\n                return;\n            const value = this.GetPropertyValueByIndex(index);\n            if (typeof value !== "number")\n                throw new Error("expected number");\n            this.SetPropertyValueByIndex(index, value + offset)\n        }\n        SetPropertyColorOffsetValueByIndex(index, offsetR, offsetG, offsetB) {}\n        CallAction(actMethod, ...args) {\n            actMethod.call(this, ...args)\n        }\n        CallExpression(expMethod, ...args) {\n            return expMethod.call(this, ...args)\n        }\n        GetScriptInterfaceClass() {\n            return null\n        }\n        DispatchScriptEvent(name, cancelable, additionalProperties) {\n            const scriptInterface = this.GetScriptInterface();\n            const e = C3.New(C3.Event, name, cancelable);\n            e.behaviorInstance = scriptInterface;\n            e.instance = scriptInterface.instance;\n            if (additionalProperties)\n                Object.assign(e, additionalProperties);\n            scriptInterface.dispatchEvent(e)\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/pluginManager.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Plugins = {};\n    C3.Behaviors = {};\n    C3.PluginManager = class PluginManager extends C3.DefendedBase {\n        constructor(runtime) {\n            super();\n            this._runtime = runtime;\n            this._allPlugins = [];\n            this._pluginsByCtor = new Map;\n            this._systemPlugin = null;\n            this._allBehaviors = [];\n            this._behaviorsByCtor = new Map;\n            this._solidBehavior = null;\n            this._jumpthruBehavior = null\n        }\n        CreatePlugin(pluginData) {\n            const Ctor = this._runtime.GetObjectReference(pluginData[0]);\n            if (!Ctor)\n                throw new Error("missing plugin");\n            C3.AddCommonACEs(pluginData, Ctor);\n            const plugin = C3.New(Ctor, {\n                runtime: this._runtime,\n                isSingleGlobal: pluginData[1],\n                isWorld: pluginData[2],\n                isRotatable: pluginData[5],\n                hasEffects: pluginData[8],\n                mustPredraw: pluginData[9],\n                supportsSceneGraph: pluginData[13],\n                supportsMesh: pluginData[14]\n            });\n            plugin.OnCreate();\n            this._allPlugins.push(plugin);\n            this._pluginsByCtor.set(Ctor, plugin)\n        }\n        CreateSystemPlugin() {\n            this._systemPlugin = C3.New(C3.Plugins.System, {\n                runtime: this._runtime,\n                isSingleGlobal: true\n            });\n            this._systemPlugin.OnCreate()\n        }\n        CreateBehavior(behaviorData) {\n            const Ctor = this._runtime.GetObjectReference(behaviorData[1]);\n            if (!Ctor)\n                throw new Error("missing behavior");\n            const behavior = C3.New(Ctor, {\n                runtime: this._runtime\n            });\n            behavior.OnCreate();\n            this._allBehaviors.push(behavior);\n            this._behaviorsByCtor.set(Ctor, behavior);\n            if (!this._solidBehavior && C3.Behaviors.solid && behavior instanceof C3.Behaviors.solid)\n                this._solidBehavior = behavior;\n            else if (!this._jumpthruBehavior && C3.Behaviors.jumpthru && behavior instanceof C3.Behaviors.jumpthru)\n                this._jumpthruBehavior = behavior\n        }\n        GetPluginByConstructorFunction(ctor) {\n            return this._pluginsByCtor.get(ctor) || null\n        }\n        HasBehaviorByConstructorFunction(ctor) {\n            return this._behaviorsByCtor.has(ctor)\n        }\n        GetBehaviorByConstructorFunction(ctor) {\n            return this._behaviorsByCtor.get(ctor) || null\n        }\n        GetSystemPlugin() {\n            return this._systemPlugin\n        }\n        GetSolidBehavior() {\n            return this._solidBehavior\n        }\n        GetJumpthruBehavior() {\n            return this._jumpthruBehavior\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/imageInfo.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const allImageInfos = new Set;\n    C3.ImageInfo = class ImageInfo extends C3.DefendedBase {\n        constructor() {\n            super();\n            this._url = "";\n            this._size = 0;\n            this._offsetX = 0;\n            this._offsetY = 0;\n            this._width = 0;\n            this._height = 0;\n            this._isRotated = false;\n            this._hasMetaData = false;\n            this._imageAsset = null;\n            this._textureState = "";\n            this._rcTex = C3.New(C3.Rect);\n            this._quadTex = C3.New(C3.Quad);\n            this._blobUrl = "";\n            this._iImageInfo = new self.IImageInfo(this);\n            allImageInfos.add(this)\n        }\n        Release() {\n            this.ReleaseTexture();\n            this._imageAsset = null;\n            allImageInfos.delete(this);\n            this.ReleaseBlobURL()\n        }\n        static OnWebGLContextLost() {\n            for (const imageInfo of allImageInfos) {\n                imageInfo._textureState = "";\n                imageInfo._rcTex.set(0, 0, 0, 0);\n                imageInfo._quadTex.setFromRect(imageInfo._rcTex)\n            }\n        }\n        LoadData(imageData) {\n            this._url = imageData[0];\n            this._size = imageData[1];\n            this._offsetX = imageData[2];\n            this._offsetY = imageData[3];\n            this._width = imageData[4];\n            this._height = imageData[5];\n            this._isRotated = imageData[6];\n            this._hasMetaData = true\n        }\n        LoadDynamicAsset(runtime, url) {\n            if (this._imageAsset)\n                throw new Error("already loaded asset");\n            this._url = url;\n            const opts = {};\n            if (C3.IsAbsoluteURL(url))\n                opts.loadPolicy = "remote";\n            this.LoadAsset(runtime, opts);\n            return this._imageAsset.Load()\n        }\n        ReplaceWith(otherImageInfo) {\n            if (otherImageInfo === this)\n                throw new Error("cannot replace with self");\n            this.ReleaseTexture();\n            this._url = otherImageInfo._url;\n            this._size = otherImageInfo._size;\n            this._offsetX = otherImageInfo._offsetX;\n            this._offsetY = otherImageInfo._offsetY;\n            this._width = otherImageInfo._width;\n            this._height = otherImageInfo._height;\n            this._isRotated = otherImageInfo._isRotated;\n            this._hasMetaData = otherImageInfo._hasMetaData;\n            this._imageAsset = otherImageInfo._imageAsset;\n            this._textureState = otherImageInfo._textureState;\n            this._rcTex = otherImageInfo._rcTex;\n            this._quadTex = otherImageInfo._quadTex;\n            this.ReleaseBlobURL()\n        }\n        GetURL() {\n            return this._url\n        }\n        GetSize() {\n            return this._size\n        }\n        GetOffsetX() {\n            return this._offsetX\n        }\n        GetOffsetY() {\n            return this._offsetY\n        }\n        IsRotated() {\n            return this._isRotated\n        }\n        GetWidth() {\n            return this._width\n        }\n        GetHeight() {\n            return this._height\n        }\n        GetSheetWidth() {\n            return this._imageAsset.GetWidth()\n        }\n        GetSheetHeight() {\n            return this._imageAsset.GetHeight()\n        }\n        LoadAsset(runtime, opts) {\n            if (this._imageAsset)\n                throw new Error("already got asset");\n            opts = Object.assign({}, opts, {\n                url: this.GetURL(),\n                size: this.GetSize()\n            });\n            this._imageAsset = runtime.LoadImage(opts)\n        }\n        IsLoaded() {\n            return this._imageAsset && this._imageAsset.IsLoaded()\n        }\n        async LoadStaticTexture(renderer, opts) {\n            if (!this._imageAsset)\n                throw new Error("no asset");\n            if (this._textureState)\n                throw new Error("already loaded texture");\n            this._textureState = "loading";\n            const texture = await this._imageAsset.LoadStaticTexture(renderer, opts);\n            if (!texture) {\n                this._textureState = "";\n                return null\n            }\n            this._textureState = "loaded";\n            if (!this._hasMetaData) {\n                this._width = texture.GetWidth();\n                this._height = texture.GetHeight();\n                this._hasMetaData = true\n            }\n            const wr = this._isRotated ? this._height : this._width;\n            const hr = this._isRotated ? this._width : this._height;\n            this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + wr, this._offsetY + hr);\n            this._rcTex.divide(texture.GetWidth(), texture.GetHeight());\n            this._quadTex.setFromRect(this._rcTex);\n            if (this._isRotated)\n                this._quadTex.rotatePointsAnticlockwise();\n            return texture\n        }\n        ReleaseTexture() {\n            if (!this._textureState)\n                return;\n            if (this._imageAsset)\n                this._imageAsset.ReleaseTexture();\n            this._textureState = "";\n            this._rcTex.set(0, 0, 0, 0);\n            this._quadTex.setFromRect(this._rcTex)\n        }\n        GetTexture() {\n            return this._imageAsset ? this._imageAsset.GetTexture() : null\n        }\n        GetTexRect() {\n            return this._rcTex\n        }\n        GetTexQuad() {\n            return this._quadTex\n        }\n        GetIImageInfo() {\n            return this._iImageInfo\n        }\n        async ExtractImageToCanvas() {\n            const srcDrawable = await this._imageAsset.LoadToDrawable();\n            const canvas = C3.CreateCanvas(this._width, this._height);\n            const ctx = canvas.getContext("2d");\n            if (this._isRotated) {\n                ctx.rotate(Math.PI \/ -2);\n                ctx.translate(-this._height, 0);\n                ctx.drawImage(srcDrawable, this._offsetX, this._offsetY, this._height, this._width, 0, 0, this._height, this._width)\n            } else\n                ctx.drawImage(srcDrawable, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height);\n            return canvas\n        }\n        async ExtractImageToBlobURL() {\n            if (this._blobUrl)\n                return this._blobUrl;\n            const canvas = await this.ExtractImageToCanvas();\n            const blob = await C3.CanvasToBlob(canvas);\n            this._blobUrl = URL.createObjectURL(blob);\n            return this._blobUrl\n        }\n        ReleaseBlobURL() {\n            if (this._blobUrl) {\n                URL.revokeObjectURL(this._blobUrl);\n                this._blobUrl = ""\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/animationInfo.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.AnimationInfo = class AnimationInfo extends C3.DefendedBase {\n        constructor(animData) {\n            super();\n            this._name = animData[0];\n            this._speed = animData[1];\n            this._isLooping = !!animData[2];\n            this._repeatCount = animData[3];\n            this._repeatTo = animData[4];\n            this._isPingPong = !!animData[5];\n            this._sid = animData[6];\n            this._frames = animData[7].map(frameData => C3.New(C3.AnimationFrameInfo, frameData));\n            this._iAnimation = new self.IAnimation(this)\n        }\n        Release() {\n            for (const f of this._frames)\n                f.Release();\n            C3.clearArray(this._frames)\n        }\n        LoadAllAssets(runtime) {\n            for (const f of this._frames)\n                f.GetImageInfo().LoadAsset(runtime)\n        }\n        LoadAllTextures(renderer, opts) {\n            return Promise.all(this._frames.map(f => f.GetImageInfo().LoadStaticTexture(renderer, opts)))\n        }\n        ReleaseAllTextures() {\n            for (const f of this._frames)\n                f.GetImageInfo().ReleaseTexture()\n        }\n        GetName() {\n            return this._name\n        }\n        GetSID() {\n            return this._sid\n        }\n        GetFrameCount() {\n            return this._frames.length\n        }\n        GetFrames() {\n            return this._frames\n        }\n        GetFrameAt(i) {\n            i = Math.floor(i);\n            if (i < 0 || i >= this._frames.length)\n                throw new RangeError("invalid frame");\n            return this._frames[i]\n        }\n        GetSpeed() {\n            return this._speed\n        }\n        IsLooping() {\n            return this._isLooping\n        }\n        GetRepeatCount() {\n            return this._repeatCount\n        }\n        GetRepeatTo() {\n            return this._repeatTo\n        }\n        IsPingPong() {\n            return this._isPingPong\n        }\n        GetIAnimation() {\n            return this._iAnimation\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/animationFrameInfo.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.AnimationFrameInfo = class AnimationFrameInfo extends C3.DefendedBase {\n        constructor(frameData) {\n            super();\n            this._imageInfo = C3.New(C3.ImageInfo);\n            this._imageInfo.LoadData(frameData);\n            this._duration = frameData[7];\n            this._origin = C3.New(C3.Vector2, frameData[8], frameData[9]);\n            this._imagePoints = frameData[10].map(data => C3.New(C3.ImagePoint, this, data));\n            this._imagePointsByName = new Map;\n            for (const ip of this._imagePoints)\n                this._imagePointsByName.set(ip.GetName().toLowerCase(), ip);\n            this._collisionPoly = null;\n            const polyPoints = frameData[11];\n            if (polyPoints.length >= 6)\n                this._collisionPoly = C3.New(C3.CollisionPoly, polyPoints);\n            this._iAnimationFrame = new self.IAnimationFrame(this)\n        }\n        Release() {\n            if (this._collisionPoly) {\n                this._collisionPoly.Release();\n                this._collisionPoly = null\n            }\n            this._imageInfo.Release();\n            this._imageInfo = null\n        }\n        GetImageInfo() {\n            return this._imageInfo\n        }\n        GetDuration() {\n            return this._duration\n        }\n        GetOriginX() {\n            return this._origin.getX()\n        }\n        GetOriginY() {\n            return this._origin.getY()\n        }\n        GetCollisionPoly() {\n            return this._collisionPoly\n        }\n        GetImagePointByName(name) {\n            return this._imagePointsByName.get(name.toLowerCase()) || null\n        }\n        GetImagePointByIndex(index) {\n            index = Math.floor(index);\n            if (index < 0 || index >= this._imagePoints.length)\n                return null;\n            return this._imagePoints[index]\n        }\n        GetImagePointCount() {\n            return this._imagePoints.length\n        }\n        GetIAnimationFrame() {\n            return this._iAnimationFrame\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/imagePoint.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.ImagePoint = class ImagePoint extends C3.DefendedBase {\n        constructor(afi, data) {\n            super();\n            this._afi = afi;\n            this._name = data[0];\n            this._pos = C3.New(C3.Vector2, data[1], data[2])\n        }\n        Release() {}\n        GetName() {\n            return this._name\n        }\n        GetX() {\n            return this._pos.getX()\n        }\n        GetY() {\n            return this._pos.getY()\n        }\n        GetVec2() {\n            return this._pos\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/objectClass.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3Debugger = self.C3Debugger;\n    const IObjectClass = self.IObjectClass;\n    const assert = self.assert;\n    C3.ObjectClass = class ObjectClass extends C3.DefendedBase {\n        constructor(runtime, index, data) {\n            super();\n            const PluginCtor = runtime.GetObjectReference(data[1]);\n            this._runtime = runtime;\n            this._plugin = runtime.GetPluginManager().GetPluginByConstructorFunction(PluginCtor);\n            this._sdkType = null;\n            this._instSdkCtor = PluginCtor.Instance;\n            this._index = index;\n            this._sid = data[11];\n            this._name = data[0];\n            this._jsPropName = this._runtime.GetJsPropName(data[14]);\n            this._isGlobal = !!data[9];\n            this._isFamily = !!data[2];\n            this._isOnLoaderLayout = !!data[10];\n            this._instVars = data[3].map(arr => ({\n                sid: arr[0],\n                type: arr[1],\n                name: arr[2],\n                jsPropName: runtime.GetJsPropName(arr[3])\n            }));\n            this._behaviorsCount = data[4];\n            this._effectsCount = data[5];\n            this._isWorldType = this._plugin.IsWorldType();\n            this._effectList = null;\n            this._collisionGrid = C3.New(C3.SparseGrid, runtime.GetOriginalViewportWidth(), runtime.GetOriginalViewportHeight());\n            this._anyCollisionCellChanged = true;\n            this._anyInstanceParallaxed = false;\n            this._familyMembers = null;\n            this._familyMembersSet = null;\n            this._familyIndex = -1;\n            this._families = null;\n            this._familiesSet = null;\n            this._familyInstVarMap = null;\n            this._familyBehaviorMap = null;\n            this._familyEffectMap = null;\n            this._isInContainer = false;\n            this._container = null;\n            this._behaviorTypes = data[8].map(behaviorTypeData => C3.BehaviorType.Create(this, behaviorTypeData));\n            this._behaviorTypesIncludingInherited = [];\n            this._behaviorsByName = new Map;\n            this._behaviorNameToIndex = new Map;\n            this._usedBehaviorCtors = new Set;\n            this._solStack = C3.New(C3.SolStack, this);\n            this._defaultInstanceData = null;\n            this._defaultLayerIndex = 0;\n            this._isContained = false;\n            this._container = null;\n            this._imageInfo = null;\n            this._animations = null;\n            this._animationsByName = null;\n            this._animationsBySid = null;\n            this._textureRefCount = 0;\n            this._savedData = new Map;\n            this._unsavedData = new Map;\n            this._instances = [];\n            this._iidsStale = true;\n            if (this._plugin.HasEffects())\n                this._effectList = C3.New(C3.EffectList, this, data[12]);\n            if (data[6]) {\n                this._imageInfo = C3.New(C3.ImageInfo);\n                this._imageInfo.LoadData(data[6])\n            }\n            if (data[7]) {\n                this._animations = data[7].map(animData => C3.New(C3.AnimationInfo, animData));\n                this._animationsByName = new Map;\n                this._animationsBySid = new Map;\n                for (const anim of this._animations) {\n                    this._animationsByName.set(anim.GetName().toLowerCase(), anim);\n                    this._animationsBySid.set(anim.GetSID(), anim)\n                }\n            }\n            if (this._isFamily) {\n                this._familyMembers = [];\n                this._familyMembersSet = new Set;\n                this._familyIndex = this._runtime._GetNextFamilyIndex()\n            } else {\n                this._families = [];\n                this._familiesSet = new Set;\n                this._familyInstVarMap = [];\n                this._familyBehaviorMap = [];\n                this._familyEffectMap = []\n            }\n            this._sdkType = C3.New(PluginCtor.Type, this, data[15]);\n            this._iObjectClass = null;\n            this._instanceUserScriptClass = null;\n            this._userScriptDispatcher = C3.New(C3.Event.Dispatcher);\n            const CustomScriptClass = this._sdkType.GetScriptInterfaceClass();\n            if (CustomScriptClass) {\n                this._iObjectClass = new CustomScriptClass(this);\n                if (!(this._iObjectClass instanceof IObjectClass))\n                    throw new TypeError("script interface class must derive from IObjectClass");\n            } else\n                this._iObjectClass = new IObjectClass(this);\n            if (data[13]) {\n                const tilemapData = data[13];\n                if (tilemapData) {\n                    const tilePolyData = tilemapData[0];\n                    const maxTileIndex = tilemapData[1];\n                    const brushData = tilemapData[2];\n                    this._sdkType.LoadTilemapData(tilePolyData, maxTileIndex, brushData)\n                }\n            }\n            if (!this._runtime.UsesLoaderLayout() || this._isFamily || this._isOnLoaderLayout || !this._isWorldType)\n                this.OnCreate();\n            if (this._plugin.IsSingleGlobal()) {\n                this._plugin._SetSingleGlobalObjectClass(this);\n                this._CreateSingleGlobalInstance(data)\n            }\n        }\n        static Create(runtime, index, objectClassData) {\n            return C3.New(C3.ObjectClass, runtime, index, objectClassData)\n        }\n        Release() {\n            if (this._imageInfo) {\n                this._imageInfo.Release();\n                this._imageInfo = null\n            }\n            if (this._animations) {\n                for (const a of this._animations)\n                    a.Release();\n                C3.clearArray(this._animations);\n                this._animationsByName.clear();\n                this._animationsBySid.clear()\n            }\n            this._solStack.Release();\n            this._solStack = null;\n            this._savedData.clear();\n            this._unsavedData.clear();\n            this._container = null;\n            this._runtime = null\n        }\n        _LoadFamily(familyData) {\n            for (let i = 1, len = familyData.length; i < len; ++i) {\n                const memberType = this._runtime.GetObjectClassByIndex(familyData[i]);\n                this._familyMembers.push(memberType);\n                this._familyMembersSet.add(memberType);\n                memberType._families.push(this);\n                memberType._familiesSet.add(this)\n            }\n        }\n        _SetContainer(container) {\n            this._isInContainer = true;\n            this._container = container\n        }\n        IsInContainer() {\n            return this._isInContainer\n        }\n        GetContainer() {\n            return this._container\n        }\n        _OnAfterCreate() {\n            let index = 0;\n            if (!this._isFamily)\n                for (const family of this._families)\n                    for (const familyBehType of family.GetBehaviorTypes()) {\n                        const lowerName = familyBehType.GetName().toLowerCase();\n                        this._behaviorsByName.set(lowerName, familyBehType);\n                        this._behaviorNameToIndex.set(lowerName, index);\n                        this._behaviorTypesIncludingInherited.push(familyBehType);\n                        ++index\n                    }\n            for (const behaviorType of this.GetBehaviorTypes()) {\n                const lowerName = behaviorType.GetName().toLowerCase();\n                this._behaviorsByName.set(lowerName, behaviorType);\n                this._behaviorNameToIndex.set(lowerName, index);\n                this._behaviorTypesIncludingInherited.push(behaviorType);\n                ++index\n            }\n            for (const behaviorType of this._behaviorTypesIncludingInherited)\n                this._usedBehaviorCtors.add(behaviorType.GetBehavior().constructor);\n            if (!this._isFamily && this._families.length) {\n                const familyCount = this._runtime.GetFamilyCount();\n                C3.extendArray(this._familyInstVarMap, familyCount, 0);\n                C3.extendArray(this._familyBehaviorMap, familyCount, 0);\n                C3.extendArray(this._familyEffectMap, familyCount, 0);\n                const allFx = [];\n                let ivSum = 0;\n                let behSum = 0;\n                let fxSum = 0;\n                for (const family of this._families) {\n                    const familyIndex = family.GetFamilyIndex();\n                    this._familyInstVarMap[familyIndex] = ivSum;\n                    ivSum += family.GetInstanceVariablesCount();\n                    this._familyBehaviorMap[familyIndex] = behSum;\n                    behSum += family.GetBehaviorTypesCount();\n                    this._familyEffectMap[familyIndex] = fxSum;\n                    fxSum += family.GetEffectTypesCount();\n                    const familyEffectList = family.GetEffectList();\n                    if (familyEffectList && this._effectList)\n                        for (const effectType of familyEffectList.GetAllEffectTypes())\n                            allFx.push(effectType.Clone(this._effectList))\n                }\n                if (this._effectList)\n                    this._effectList.PrependEffectTypes(allFx)\n            }\n        }\n        _CreateSingleGlobalInstance(data) {\n            const uid = this._runtime._GetNewUID();\n            const inst = C3.New(C3.Instance, {\n                runtime: this._runtime,\n                objectType: this,\n                uid: uid\n            });\n            inst._CreateSdkInstance(data[16], []);\n            this._runtime._MapInstanceByUID(uid, inst);\n            this._instances.push(inst)\n        }\n        GetSdkType() {\n            return this._sdkType\n        }\n        IsOnLoaderLayout() {\n            return this._isOnLoaderLayout\n        }\n        OnCreate() {\n            if (!this._isFamily)\n                this._sdkType.OnCreate()\n        }\n        HasLoadedTextures() {\n            return this._textureRefCount > 0\n        }\n        LoadTextures(renderer) {\n            if (this._isFamily)\n                return Promise.resolve();\n            this._textureRefCount++;\n            if (this._textureRefCount === 1)\n                return this._sdkType.LoadTextures(renderer) || Promise.resolve();\n            else\n                return Promise.resolve()\n        }\n        ReleaseTextures() {\n            if (this._isFamily)\n                return;\n            this._textureRefCount--;\n            if (this._textureRefCount < 0)\n                throw new Error("released textures too many times");\n            if (this._textureRefCount === 0)\n                this._sdkType.ReleaseTextures()\n        }\n        OnDynamicTextureLoadComplete() {\n            if (this._isFamily)\n                throw new Error("not applicable to family");\n            this._sdkType.OnDynamicTextureLoadComplete()\n        }\n        PreloadTexturesWithInstances(renderer) {\n            if (this._isFamily)\n                return Promise.resolve();\n            return this._sdkType.PreloadTexturesWithInstances(renderer)\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetPlugin() {\n            return this._plugin\n        }\n        GetInstanceSdkCtor() {\n            return this._instSdkCtor\n        }\n        GetName() {\n            return this._name\n        }\n        GetJsPropName() {\n            return this._jsPropName\n        }\n        GetIndex() {\n            return this._index\n        }\n        GetSID() {\n            return this._sid\n        }\n        IsFamily() {\n            return this._isFamily\n        }\n        IsGlobal() {\n            return this._isGlobal\n        }\n        IsWorldType() {\n            return this._isWorldType\n        }\n        GetFamilyIndex() {\n            return this._familyIndex\n        }\n        GetBehaviorTypes() {\n            return this._behaviorTypes\n        }\n        GetBehaviorTypesCount() {\n            return this._behaviorsCount\n        }\n        UsesBehaviorByCtor(Ctor) {\n            return Ctor && this._usedBehaviorCtors.has(Ctor)\n        }\n        GetInstanceVariablesCount() {\n            return this._instVars.length\n        }\n        GetInstanceVariableSIDs() {\n            return this._instVars.map(iv => iv.sid)\n        }\n        GetInstanceVariableIndexBySID(sid) {\n            return this._instVars.findIndex(iv => iv.sid === sid)\n        }\n        GetInstanceVariableIndexByName(name) {\n            return this._instVars.findIndex(iv => iv.name === name)\n        }\n        _GetAllInstanceVariableNames() {\n            return this._instVars.map(iv => iv.name)\n        }\n        _GetAllInstanceVariableJsPropNames() {\n            return this._instVars.map(iv => iv.jsPropName)\n        }\n        GetInstanceVariableType(i) {\n            i = Math.floor(i);\n            if (i < 0 || i >= this._instVars.length)\n                throw new RangeError("invalid instance variable index");\n            return this._instVars[i].type\n        }\n        GetInstanceVariableName(i) {\n            i = Math.floor(i);\n            if (i < 0 || i >= this._instVars.length)\n                throw new RangeError("invalid instance variable index");\n            return this._instVars[i].name\n        }\n        GetEffectTypesCount() {\n            return this._effectsCount\n        }\n        GetBehaviorTypesIncludingInherited() {\n            return this._behaviorTypesIncludingInherited\n        }\n        GetBehaviorTypeByName(name) {\n            return this._behaviorsByName.get(name.toLowerCase()) || null\n        }\n        GetBehaviorIndexByName(name) {\n            const ret = this._behaviorNameToIndex.get(name.toLowerCase());\n            if (typeof ret === "undefined")\n                return -1;\n            else\n                return ret\n        }\n        GetEffectList() {\n            return this._effectList\n        }\n        HasEffects() {\n            return this._plugin.HasEffects()\n        }\n        UsesEffects() {\n            return this._effectList && this._effectList.HasAnyEffectType()\n        }\n        GetSolStack() {\n            return this._solStack\n        }\n        GetCurrentSol() {\n            return this._solStack.GetCurrentSol()\n        }\n        GetImageInfo() {\n            return this._imageInfo\n        }\n        SetDefaultInstanceData(d) {\n            this._defaultInstanceData = d\n        }\n        GetDefaultInstanceData() {\n            return this._defaultInstanceData\n        }\n        _SetDefaultLayerIndex(i) {\n            this._defaultLayerIndex = i\n        }\n        GetDefaultLayerIndex() {\n            return this._defaultLayerIndex\n        }\n        GetAnimations() {\n            return this._animations\n        }\n        GetAnimationCount() {\n            return this._animations.length\n        }\n        GetFamilies() {\n            return this._families\n        }\n        BelongsToFamily(family) {\n            return this._familiesSet.has(family)\n        }\n        GetFamilyMembers() {\n            return this._familyMembers\n        }\n        FamilyHasMember(objectType) {\n            return this._familyMembersSet.has(objectType)\n        }\n        GetFamilyBehaviorOffset(familyIndex) {\n            return this._familyBehaviorMap[familyIndex]\n        }\n        GetFamilyInstanceVariableOffset(familyIndex) {\n            return this._familyInstVarMap[familyIndex]\n        }\n        GetAnimationByName(name) {\n            if (!this._animations)\n                throw new Error("no animations");\n            return this._animationsByName.get(name.toLowerCase()) || null\n        }\n        GetAnimationBySID(sid) {\n            if (!this._animations)\n                throw new Error("no animations");\n            return this._animationsBySid.get(sid) || null\n        }\n        GetFirstAnimationFrame() {\n            if (!this._animations)\n                throw new Error("no animations");\n            return this._animations[0].GetFrameAt(0)\n        }\n        GetDefaultInstanceSize() {\n            if (this._animations) {\n                const firstFrameInfo = this.GetFirstAnimationFrame().GetImageInfo();\n                return [firstFrameInfo.GetWidth(), firstFrameInfo.GetHeight()]\n            } else if (this._imageInfo)\n                return [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()];\n            else\n                return [100, 100]\n        }\n        GetSingleGlobalInstance() {\n            if (!this._plugin.IsSingleGlobal())\n                throw new Error("not a single-global plugin");\n            return this._instances[0]\n        }\n        GetInstances() {\n            return this._instances\n        }\n        *instances() {\n            yield*this._instances\n        }\n        *instancesIncludingPendingCreate() {\n            yield*this._instances;\n            yield*this._runtime.instancesPendingCreateForObjectClass(this)\n        }\n        GetInstanceCount() {\n            return this._instances.length\n        }\n        _AddInstance(inst) {\n            this._instances.push(inst)\n        }\n        _SetIIDsStale() {\n            this._iidsStale = true\n        }\n        _UpdateIIDs() {\n            if (!this._iidsStale || this._isFamily)\n                return;\n            const instances = this._instances;\n            let i = 0;\n            for (let len = instances.length; i < len; ++i)\n                instances[i]._SetIID(i);\n            const instancesPendingCreate = this._runtime._GetInstancesPendingCreate();\n            for (const inst of instancesPendingCreate)\n                if (inst.GetObjectClass() === this)\n                    inst._SetIID(i++);\n            this._iidsStale = false\n        }\n        GetInstanceByIID(i) {\n            const instances = this._instances;\n            if (i < instances.length)\n                return instances[i];\n            i -= instances.length;\n            const instancesPendingCreate = this._runtime._GetInstancesPendingCreate();\n            for (const inst of instancesPendingCreate)\n                if (inst.GetObjectClass() === this) {\n                    if (i === 0)\n                        return inst;\n                    --i\n                }\n            return null\n        }\n        GetFirstPicked(fromInst) {\n            if (fromInst && fromInst.IsInContainer() && fromInst.GetObjectClass() !== this)\n                for (const s of fromInst.siblings())\n                    if (s.GetObjectClass() === this)\n                        return s;\n            const instances = this.GetCurrentSol().GetInstances();\n            if (instances.length)\n                return instances[0];\n            else\n                return null\n        }\n        GetPairedInstance(inst) {\n            const instances = this.GetCurrentSol().GetInstances();\n            if (instances.length > 0)\n                return instances[inst.GetIID() % instances.length];\n            else\n                return null\n        }\n        *allCorrespondingInstances(inst, objectClass) {\n            const myInstances = this.GetCurrentSol().GetInstances();\n            const myInstanceCount = myInstances.length;\n            const otherSol = objectClass.GetCurrentSol();\n            const otherInstances = objectClass.GetCurrentSol().GetInstances();\n            const otherInstanceCount = otherInstances.length;\n            let index = inst.GetIID();\n            if (objectClass.IsFamily() || !otherSol.IsSelectAll())\n                index = otherInstances.indexOf(inst);\n            const divisor = Math.ceil(myInstanceCount \/ otherInstanceCount);\n            const remainder = myInstanceCount % otherInstanceCount;\n            let startIndex = 0;\n            let correspondCount = 0;\n            if (remainder === 0 || index < remainder) {\n                startIndex = index * divisor;\n                correspondCount = divisor\n            } else {\n                startIndex = remainder * divisor + (index - remainder) * (divisor - 1);\n                correspondCount = divisor - 1\n            }\n            for (let i = startIndex, end = startIndex + correspondCount; i < end; ++i)\n                yield myInstances[i]\n        }\n        FinishCondition(f) {\n            this._sdkType.FinishCondition(f)\n        }\n        ApplySolToContainer() {\n            if (!this._isInContainer || this._isFamily)\n                return;\n            this._UpdateIIDs();\n            const sol1 = this.GetCurrentSol();\n            const sol1instances = sol1._GetOwnInstances();\n            const selectAll = sol1.IsSelectAll();\n            const es = this._runtime.GetCurrentEventStackFrame();\n            const isOrBlock = es && es.GetCurrentEvent() && es.GetCurrentEvent().IsOrBlock();\n            for (const containerType of this._container.objectTypes()) {\n                if (containerType === this)\n                    continue;\n                containerType._UpdateIIDs();\n                const sol2 = containerType.GetCurrentSol();\n                sol2._SetSelectAll(selectAll);\n                if (!selectAll) {\n                    const sol2instances = sol2._GetOwnInstances();\n                    C3.clearArray(sol2instances);\n                    for (const inst of sol1instances)\n                        sol2instances.push(containerType.GetInstanceByIID(inst.GetIID()));\n                    if (isOrBlock) {\n                        const sol1elseInstances = sol1._GetOwnElseInstances();\n                        const sol2elseInstances = sol2._GetOwnElseInstances();\n                        C3.clearArray(sol2elseInstances);\n                        for (const inst of sol1elseInstances)\n                            sol2elseInstances.push(containerType.GetInstanceByIID(inst.GetIID()))\n                    }\n                }\n            }\n        }\n        _TruncateContainerSols(useElseInstances, i) {\n            for (const containerType of this.GetContainer().objectTypes()) {\n                const sol = containerType.GetCurrentSol();\n                if (useElseInstances)\n                    C3.truncateArray(sol._GetOwnElseInstances(), i);\n                else\n                    C3.truncateArray(sol._GetOwnInstances(), i)\n            }\n        }\n        _GetCollisionCellGrid() {\n            return this._collisionGrid\n        }\n        _SetAnyCollisionCellChanged(c) {\n            this._anyCollisionCellChanged = !!c\n        }\n        _SetAnyInstanceParallaxed(p) {\n            this._anyInstanceParallaxed = !!p\n        }\n        IsAnyInstanceParallaxed() {\n            return this._anyInstanceParallaxed\n        }\n        _UpdateAllCollisionCells() {\n            if (!this._anyCollisionCellChanged || !this._isWorldType)\n                return;\n            for (const inst of this._instances)\n                inst.GetWorldInfo()._UpdateCollisionCell();\n            for (const inst of this._runtime._GetInstancesPendingCreate())\n                if (inst.GetObjectClass() === this)\n                    inst.GetWorldInfo()._UpdateCollisionCell();\n            this._anyCollisionCellChanged = false\n        }\n        GetSavedDataMap() {\n            if (!this._savedData)\n                this._savedData = new Map;\n            return this._savedData\n        }\n        GetUnsavedDataMap() {\n            if (!this._unsavedData)\n                this._unsavedData = new Map;\n            return this._unsavedData\n        }\n        HasSolidBehavior() {\n            return this.UsesBehaviorByCtor(C3.Behaviors.solid)\n        }\n        HasJumpthruBehavior() {\n            return this.UsesBehaviorByCtor(C3.Behaviors.jumpthru)\n        }\n        HasNoSaveBehavior() {\n            return this.UsesBehaviorByCtor(C3.Behaviors.NoSave)\n        }\n        HasPersistBehavior() {\n            return this.UsesBehaviorByCtor(C3.Behaviors.Persist)\n        }\n        _SaveToJson() {\n            const o = {\n                "instances": this._instances.map(inst => inst.SaveToJson())\n            };\n            if (this._savedData && this._savedData.size)\n                o["ex"] = C3.ToSuperJSON(this._savedData);\n            return o\n        }\n        _LoadFromJson(o) {\n            if (this._savedData) {\n                this._savedData.clear();\n                this._savedData = null\n            }\n            const ex = o["ex"];\n            if (ex)\n                this._savedData = C3.FromSuperJSON(ex);\n            const existingInstances = this._instances;\n            const loadInstances = o["instances"];\n            for (let i = 0, len = Math.min(existingInstances.length, loadInstances.length); i < len; ++i)\n                existingInstances[i].LoadFromJson(loadInstances[i]);\n            for (let i = loadInstances.length, len = existingInstances.length; i < len; ++i)\n                this._runtime.DestroyInstance(existingInstances[i]);\n            for (let i = existingInstances.length, len = loadInstances.length; i < len; ++i) {\n                const data = loadInstances[i];\n                let layer = null;\n                if (this.IsWorldType()) {\n                    layer = this._runtime.GetMainRunningLayout().GetLayerBySID(data["w"]["l"]);\n                    if (!layer)\n                        continue\n                }\n                const inst = this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, layer, false, 0, 0, true);\n                inst.LoadFromJson(data)\n            }\n            this._SetIIDsStale()\n        }\n        GetIObjectClass() {\n            return this._iObjectClass\n        }\n        UserScriptDispatcher() {\n            return this._userScriptDispatcher\n        }\n        _GetUserScriptInstanceClass() {\n            return this._instanceUserScriptClass\n        }\n        _SetUserScriptInstanceClass(Class) {\n            this._instanceUserScriptClass = Class\n        }\n        DispatchUserScriptEvent(e) {\n            const runtime = this._runtime;\n            const shouldTime = runtime.IsDebug() && !runtime.GetEventSheetManager().IsInEventEngine();\n            if (shouldTime)\n                C3Debugger.StartMeasuringScriptTime();\n            this._userScriptDispatcher.dispatchEvent(e);\n            if (shouldTime)\n                C3Debugger.AddScriptTime()\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/container.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.Container = class Container extends C3.DefendedBase {\n        constructor(runtime, objectTypes) {\n            super();\n            this._runtime = runtime;\n            this._objectTypes = objectTypes;\n            for (const objectType of this._objectTypes)\n                objectType._SetContainer(this)\n        }\n        Release() {\n            this._runtime = null\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetObjectTypes() {\n            return this._objectTypes\n        }\n        objectTypes() {\n            return this._objectTypes\n        }\n        HasAnyWorldType() {\n            return this._objectTypes.some(o => o.IsWorldType())\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/instance.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3Debugger = self.C3Debugger;\n    const IInstance = self.IInstance;\n    const EMPTY_ARRAY = [];\n    let nextPuid = 0;\n    const savedDataMaps = new WeakMap;\n    const unsavedDataMaps = new WeakMap;\n    const FLAG_DESTROYED = 1 << 0;\n    const FLAG_TILEMAP = 1 << 1;\n    const FLAG_MUST_PREDRAW = 1 << 2;\n    const FLAG_SOLID_ENABLED = 1 << 3;\n    const FLAG_JUMPTHRU_ENABLED = 1 << 4;\n    const FLAG_MUST_MITIGATE_Z_FIGHTING = 1 << 5;\n    const FLAG_IS_DRAWING_WITH_EFFECTS = 1 << 6;\n    C3.Instance = class Instance extends C3.DefendedBase {\n        constructor(opts) {\n            super();\n            this._runtime = opts.runtime;\n            this._objectType = opts.objectType;\n            this._worldInfo = null;\n            this._sdkInst = null;\n            this._iScriptInterface = null;\n            this._iid = 0;\n            this._uid = opts.uid;\n            this._puid = nextPuid++;\n            this._flags = 0;\n            this._instVarValues = EMPTY_ARRAY;\n            this._behaviorInstances = EMPTY_ARRAY;\n            const behaviorTypes = this._objectType.GetBehaviorTypesIncludingInherited();\n            if (behaviorTypes.length > 0)\n                this._behaviorInstances = behaviorTypes.map( (behaviorType, index) => C3.New(C3.BehaviorInstance, {\n                    runtime: this._runtime,\n                    behaviorType: behaviorType,\n                    instance: this,\n                    index\n                }));\n            this._siblings = this._objectType.IsInContainer() ? [] : null;\n            this._timeScale = -1;\n            this._dispatcher = null;\n            const plugin = this.GetPlugin();\n            if (plugin.MustPreDraw())\n                this._flags |= FLAG_MUST_PREDRAW;\n            if (plugin.IsWorldType()) {\n                this._worldInfo = C3.New(C3.WorldInfo, this, opts.layer);\n                if (opts.worldData)\n                    this._worldInfo.Init(opts.worldData);\n                else {\n                    this._worldInfo.InitNoData();\n                    const [width,height] = this._objectType.GetDefaultInstanceSize();\n                    this._worldInfo.SetSize(width, height);\n                    if (this.GetObjectClass().UsesEffects())\n                        this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters()\n                }\n            }\n            if (opts.instVarData)\n                this._LoadInstanceVariableData(opts.instVarData);\n            else\n                this._LoadDefaultInstanceVariables()\n        }\n        Release() {\n            if (this._iScriptInterface) {\n                this._iScriptInterface._Release();\n                this._iScriptInterface = null\n            }\n            if (this._behaviorInstances.length > 0) {\n                for (const behInst of this._behaviorInstances)\n                    behInst.Release();\n                C3.clearArray(this._behaviorInstances)\n            }\n            this._sdkInst.Release();\n            this._sdkInst = null;\n            const savedData = savedDataMaps.get(this);\n            if (savedData) {\n                savedData.clear();\n                savedDataMaps.delete(this)\n            }\n            const unsavedData = unsavedDataMaps.get(this);\n            if (unsavedData) {\n                unsavedData.clear();\n                unsavedDataMaps.delete(this)\n            }\n            if (this._siblings)\n                C3.clearArray(this._siblings);\n            if (this._dispatcher) {\n                this._dispatcher.Release();\n                this._dispatcher = null\n            }\n            this._runtime = null;\n            this._objectType = null;\n            if (this._instVarValues.length > 0)\n                C3.clearArray(this._instVarValues);\n            if (this._worldInfo) {\n                this._worldInfo.Release();\n                this._worldInfo = null\n            }\n        }\n        _LoadInstanceVariableData(instVarData) {\n            if (instVarData.length > 0) {\n                this._instVarValues = [];\n                C3.shallowAssignArray(this._instVarValues, instVarData)\n            }\n        }\n        _LoadDefaultInstanceVariables() {\n            const len = this._objectType.GetInstanceVariablesCount();\n            if (len === 0)\n                return;\n            this._instVarValues = [];\n            const typeToInitValue = [0, 0, ""];\n            for (let i = 0; i < len; ++i)\n                this._instVarValues.push(typeToInitValue[this._objectType.GetInstanceVariableType(i)])\n        }\n        _CreateSdkInstance(properties, behInstProperties) {\n            if (this._sdkInst)\n                throw new Error("already got sdk instance");\n            for (let i = 0, len = this._behaviorInstances.length; i < len; ++i) {\n                const behInst = this._behaviorInstances[i];\n                behInst._CreateSdkInstance(behInstProperties ? behInstProperties[i] : null)\n            }\n            this._sdkInst = C3.New(this._objectType.GetInstanceSdkCtor(), this, properties);\n            if (!(this._sdkInst instanceof C3.SDKInstanceBase))\n                throw new Error("sdk type must derive from SDKInstanceBase");\n            for (let i = 0, len = this._behaviorInstances.length; i < len; ++i)\n                this._behaviorInstances[i].PostCreate();\n            if (this._objectType._GetUserScriptInstanceClass())\n                this._InitUserScriptInterface()\n        }\n        GetSdkInstance() {\n            return this._sdkInst\n        }\n        GetWorldInfo() {\n            return this._worldInfo\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetTimeScale() {\n            return this._timeScale\n        }\n        GetActiveTimeScale() {\n            const ts = this._timeScale;\n            if (ts === -1)\n                return this.GetRuntime().GetTimeScale();\n            else\n                return ts\n        }\n        SetTimeScale(ts) {\n            ts = +ts;\n            if (ts < 0 || !isFinite(ts))\n                ts = 0;\n            this._timeScale = ts;\n            if (this.GetObjectClass().UsesEffects())\n                this._runtime._SetTrackingInstanceTime(this, true)\n        }\n        RestoreTimeScale() {\n            this._timeScale = -1;\n            if (this.GetObjectClass().UsesEffects())\n                this._runtime._SetTrackingInstanceTime(this, false)\n        }\n        GetInstanceGameTime() {\n            return this._runtime._GetInstanceGameTime(this)\n        }\n        Dispatcher() {\n            if (!this._dispatcher)\n                this._dispatcher = C3.New(C3.Event.Dispatcher);\n            return this._dispatcher\n        }\n        Draw(renderer) {\n            this._sdkInst.Draw(renderer)\n        }\n        OnCreate(properties) {\n            this._sdkInst.OnCreate(properties)\n        }\n        _SetHasTilemap() {\n            this._flags |= FLAG_TILEMAP\n        }\n        HasTilemap() {\n            return (this._flags & FLAG_TILEMAP) !== 0\n        }\n        _MarkDestroyed() {\n            this._flags |= FLAG_DESTROYED\n        }\n        IsDestroyed() {\n            return (this._flags & FLAG_DESTROYED) !== 0\n        }\n        MustPreDraw() {\n            return (this._flags & FLAG_MUST_PREDRAW) !== 0\n        }\n        SetMustMitigateZFighting() {\n            this._flags |= FLAG_MUST_MITIGATE_Z_FIGHTING\n        }\n        MustMitigateZFighting() {\n            return (this._flags & FLAG_MUST_MITIGATE_Z_FIGHTING) !== 0\n        }\n        _IsSolidEnabled() {\n            return (this._flags & FLAG_SOLID_ENABLED) !== 0\n        }\n        _SetSolidEnabled(e) {\n            if (e)\n                this._flags |= FLAG_SOLID_ENABLED;\n            else\n                this._flags &= ~FLAG_SOLID_ENABLED\n        }\n        _IsJumpthruEnabled() {\n            return (this._flags & FLAG_JUMPTHRU_ENABLED) !== 0\n        }\n        _SetJumpthruEnabled(e) {\n            if (e)\n                this._flags |= FLAG_JUMPTHRU_ENABLED;\n            else\n                this._flags &= ~FLAG_JUMPTHRU_ENABLED\n        }\n        _IsDrawingWithEffects() {\n            return (this._flags & FLAG_IS_DRAWING_WITH_EFFECTS) !== 0\n        }\n        _SetIsDrawingWithEffects(e) {\n            if (e)\n                this._flags |= FLAG_IS_DRAWING_WITH_EFFECTS;\n            else\n                this._flags &= ~FLAG_IS_DRAWING_WITH_EFFECTS\n        }\n        SetFlag(bit, enable) {\n            bit <<= 16;\n            if (enable)\n                this._flags |= bit;\n            else\n                this._flags &= ~bit\n        }\n        GetFlag(bit) {\n            return (this._flags & bit << 16) !== 0\n        }\n        GetCurrentImageInfo() {\n            return this._sdkInst.GetCurrentImageInfo()\n        }\n        GetCurrentSurfaceSize() {\n            return this._sdkInst.GetCurrentSurfaceSize()\n        }\n        GetCurrentTexRect() {\n            return this._sdkInst.GetCurrentTexRect()\n        }\n        GetCurrentTexQuad() {\n            return this._sdkInst.GetCurrentTexQuad()\n        }\n        IsCurrentTexRotated() {\n            return this._sdkInst.IsCurrentTexRotated()\n        }\n        GetImagePoint(nameOrIndex) {\n            return this._sdkInst.GetImagePoint(nameOrIndex)\n        }\n        GetObjectClass() {\n            return this._objectType\n        }\n        RendersToOwnZPlane() {\n            return this._sdkInst.RendersToOwnZPlane()\n        }\n        BelongsToObjectClass(objectClass) {\n            if (objectClass.IsFamily())\n                return objectClass.FamilyHasMember(this.GetObjectClass());\n            else\n                return this.GetObjectClass() === objectClass\n        }\n        CollectInstancesToPick(pickMap, createdObjectClass, includeHierarchy) {\n            const addInst = (inst, objectClass_) => {\n                const objectClass = objectClass_ || inst.GetObjectClass();\n                const instSet = pickMap.get(objectClass);\n                if (instSet)\n                    instSet.add(inst);\n                else\n                    pickMap.set(objectClass, new Set([inst]))\n            }\n            ;\n            addInst(this, createdObjectClass);\n            if (this.IsInContainer())\n                for (const s of this.siblings())\n                    addInst(s);\n            if (includeHierarchy)\n                for (const c of this.allChildren())\n                    addInst(c)\n        }\n        VerifySupportsSceneGraph() {\n            if (!this.GetPlugin().SupportsSceneGraph())\n                throw new Error("object does not support scene graph");\n        }\n        HasParent() {\n            return this.GetParent() !== null\n        }\n        GetParent() {\n            const wi = this.GetWorldInfo();\n            if (!wi)\n                return null;\n            const parentWi = wi.GetParent();\n            return parentWi ? parentWi.GetInstance() : null\n        }\n        GetTopParent() {\n            const wi = this.GetWorldInfo();\n            if (!wi)\n                return null;\n            const parentWi = wi.GetTopParent();\n            return parentWi ? parentWi.GetInstance() : null\n        }\n        *parents() {\n            const wi = this.GetWorldInfo();\n            if (!wi)\n                return;\n            for (const parentWi of wi.parents())\n                yield parentWi.GetInstance()\n        }\n        HasChild(child) {\n            if (!child)\n                return false;\n            for (const c of this.children())\n                if (c === child)\n                    return true;\n            return false\n        }\n        HasChildren() {\n            const wi = this.GetWorldInfo();\n            return wi ? wi.HasChildren() : false\n        }\n        GetChildren() {\n            const wi = this.GetWorldInfo();\n            if (!wi)\n                return [];\n            return wi.GetChildren().map(wi => wi.GetInstance())\n        }\n        *children() {\n            const wi = this.GetWorldInfo();\n            if (!wi)\n                return;\n            for (const childWi of wi.children())\n                yield childWi.GetInstance()\n        }\n        *allChildren() {\n            const wi = this.GetWorldInfo();\n            if (!wi)\n                return;\n            for (const childWi of wi.allChildren())\n                yield childWi.GetInstance()\n        }\n        GetChildCount() {\n            const wi = this.GetWorldInfo();\n            return wi ? wi.GetChildCount() : 0\n        }\n        GetAllChildCount() {\n            const wi = this.GetWorldInfo();\n            return wi ? wi.GetAllChildCount() : 0\n        }\n        GetChildAt(index) {\n            const wi = this.GetWorldInfo();\n            if (!wi)\n                return null;\n            const childWi = wi.GetChildAt(index);\n            return childWi ? childWi.GetInstance() : null\n        }\n        AddChild(childInst, opts) {\n            this.VerifySupportsSceneGraph();\n            childInst.VerifySupportsSceneGraph();\n            this.GetWorldInfo().AddChild(childInst.GetWorldInfo(), opts || {})\n        }\n        RemoveChild(childInst) {\n            const wi = this.GetWorldInfo();\n            if (!wi)\n                return;\n            wi.RemoveChild(childInst.GetWorldInfo())\n        }\n        GetDestroyWithParent() {\n            const wi = this.GetWorldInfo();\n            return wi ? wi.GetDestroyWithParent() : false\n        }\n        SetupInitialSceneGraphConnections() {\n            const wi = this.GetWorldInfo();\n            if (!wi)\n                return;\n            const childrenData = wi.GetSceneGraphChildrenExportData();\n            if (!childrenData)\n                return;\n            for (const childData of childrenData) {\n                const child = this._runtime.GetInstanceByUID(childData[2]);\n                if (child) {\n                    const flags = childData[3];\n                    this.AddChild(child, {\n                        transformX: !!(flags >> 0 & 1),\n                        transformY: !!(flags >> 1 & 1),\n                        transformWidth: !!(flags >> 2 & 1),\n                        transformHeight: !!(flags >> 3 & 1),\n                        transformAngle: !!(flags >> 4 & 1),\n                        destroyWithParent: !!(flags >> 5 & 1),\n                        transformZElevation: !!(flags >> 6 & 1)\n                    })\n                }\n            }\n        }\n        IsInContainer() {\n            return this._siblings !== null\n        }\n        _AddSibling(inst) {\n            this._siblings.push(inst)\n        }\n        GetSiblings() {\n            return this._siblings\n        }\n        HasSibling(objectClass) {\n            return !!this.GetSibling(objectClass)\n        }\n        GetSibling(objectClass) {\n            const siblings = this.siblings();\n            if (siblings === null || siblings.length === 0)\n                return false;\n            for (const s of siblings)\n                if (s.GetObjectClass() === objectClass)\n                    return s;\n            return null\n        }\n        siblings() {\n            return this._siblings\n        }\n        SetSiblingsSinglePicked() {\n            for (const s of this.siblings())\n                s.GetObjectClass().GetCurrentSol().SetSinglePicked(s)\n        }\n        _PushSiblingsToSolInstances() {\n            for (const s of this.siblings())\n                s.GetObjectClass().GetCurrentSol()._PushInstance(s)\n        }\n        _SetSiblingsToSolInstancesIndex(i) {\n            for (const s of this.siblings())\n                s.GetObjectClass().GetCurrentSol()._GetOwnInstances()[i] = s\n        }\n        _PushSiblingsToSolElseInstances() {\n            for (const s of this.siblings())\n                s.GetObjectClass().GetCurrentSol()._PushElseInstance(s)\n        }\n        _SetSiblingsToSolElseInstancesIndex(i) {\n            for (const s of this.siblings())\n                s.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[i] = s\n        }\n        GetPlugin() {\n            return this._objectType.GetPlugin()\n        }\n        _SetIID(i) {\n            this._iid = i\n        }\n        GetIID() {\n            this._objectType._UpdateIIDs();\n            return this._iid\n        }\n        GetUID() {\n            return this._uid\n        }\n        GetPUID() {\n            return this._puid\n        }\n        GetBehaviorInstances() {\n            return this._behaviorInstances\n        }\n        GetBehaviorInstanceFromCtor(ctor) {\n            if (!ctor)\n                return null;\n            for (const behInst of this._behaviorInstances)\n                if (behInst.GetBehavior()instanceof ctor)\n                    return behInst;\n            return null\n        }\n        GetBehaviorSdkInstanceFromCtor(ctor) {\n            if (!ctor)\n                return null;\n            const behInst = this.GetBehaviorInstanceFromCtor(ctor);\n            if (behInst)\n                return behInst.GetSdkInstance();\n            else\n                return null\n        }\n        GetBehaviorIndexBySID(sid) {\n            const behaviorInstances = this._behaviorInstances;\n            for (let i = 0, len = behaviorInstances.length; i < len; ++i)\n                if (behaviorInstances[i].GetBehaviorType().GetSID() === sid)\n                    return i;\n            return -1\n        }\n        GetAllInstanceVariableValues() {\n            return this._instVarValues\n        }\n        _GetAllInstanceVariableNames() {\n            return this._objectType._GetAllInstanceVariableNames()\n        }\n        GetInstanceVariableCount() {\n            return this._instVarValues.length\n        }\n        GetInstanceVariableValue(index) {\n            index = index | 0;\n            const instVarValues = this._instVarValues;\n            if (index < 0 || index >= instVarValues.length)\n                throw new RangeError("invalid instance variable");\n            return instVarValues[index]\n        }\n        _GetInstanceVariableValueUnchecked(index) {\n            return this._instVarValues[index]\n        }\n        _GetInstanceVariableTypedValue(index) {\n            const ret = this._instVarValues[index];\n            if (this._objectType.GetInstanceVariableType(index) === 0)\n                return !!ret;\n            else\n                return ret\n        }\n        SetInstanceVariableValue(index, value) {\n            index = index | 0;\n            const instVarValues = this._instVarValues;\n            if (index < 0 || index >= instVarValues.length)\n                throw new RangeError("invalid instance variable");\n            const type = this._objectType.GetInstanceVariableType(index);\n            switch (type) {\n            case 0:\n                instVarValues[index] = value ? 1 : 0;\n                break;\n            case 1:\n                instVarValues[index] = typeof value === "number" ? value : parseFloat(value);\n                break;\n            case 2:\n                instVarValues[index] = typeof value === "string" ? value : value.toString();\n                break;\n            default:\n                throw new Error("unknown instance variable type");\n            }\n        }\n        SetInstanceVariableOffset(index, offset) {\n            if (offset === 0)\n                return;\n            index = index | 0;\n            const instVarValues = this._instVarValues;\n            if (index < 0 || index >= instVarValues.length)\n                throw new RangeError("invalid instance variable");\n            const lastValue = instVarValues[index];\n            if (typeof lastValue === "number")\n                if (typeof offset === "number")\n                    instVarValues[index] += offset;\n                else\n                    instVarValues[index] += parseFloat(offset);\n            else if (typeof lastValue === "boolean")\n                throw new Error("can not set offset of boolean variable");\n            else if (typeof lastValue === "string")\n                throw new Error("can not set offset of string variable");\n            else\n                throw new Error("unknown instance variable type");\n        }\n        GetSavedDataMap() {\n            let ret = savedDataMaps.get(this);\n            if (ret)\n                return ret;\n            ret = new Map;\n            savedDataMaps.set(this, ret);\n            return ret\n        }\n        GetUnsavedDataMap() {\n            let ret = unsavedDataMaps.get(this);\n            if (ret)\n                return ret;\n            ret = new Map;\n            unsavedDataMaps.set(this, ret);\n            return ret\n        }\n        _HasAnyCreateDestroyHandler(name) {\n            const objectType = this.GetObjectClass();\n            if (objectType.UserScriptDispatcher().HasAnyHandlerFor(name))\n                return true;\n            for (const family of objectType.GetFamilies())\n                if (family.UserScriptDispatcher().HasAnyHandlerFor(name))\n                    return true;\n            if (this._runtime.UserScriptDispatcher().HasAnyHandlerFor(name))\n                return true;\n            return false\n        }\n        _TriggerOnCreatedOnSelfAndRelated() {\n            const instancesToTriggerOnCreated = new Set;\n            instancesToTriggerOnCreated.add(this);\n            const wi = this.GetWorldInfo();\n            if (wi && wi.HasChildren())\n                for (const c of this.allChildren()) {\n                    instancesToTriggerOnCreated.add(c);\n                    if (!c.IsInContainer())\n                        continue;\n                    for (const s of c.siblings())\n                        instancesToTriggerOnCreated.add(s)\n                }\n            if (this.IsInContainer())\n                for (const s of this.siblings())\n                    instancesToTriggerOnCreated.add(s);\n            for (const instance of instancesToTriggerOnCreated.values())\n                instance._TriggerOnCreated()\n        }\n        _TriggerOnCreated() {\n            if (this._HasAnyCreateDestroyHandler("instancecreate")) {\n                const objectType = this.GetObjectClass();\n                const instCreateEvent = new C3.Event("instancecreate");\n                instCreateEvent.instance = this.GetInterfaceClass();\n                objectType.DispatchUserScriptEvent(instCreateEvent);\n                for (const family of objectType.GetFamilies())\n                    family.DispatchUserScriptEvent(instCreateEvent);\n                this._runtime.DispatchUserScriptEvent(instCreateEvent)\n            }\n            this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnCreated, this, null)\n        }\n        _TriggerOnDestroyed() {\n            this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnDestroyed, this, null)\n        }\n        _FireDestroyedScriptEvents(isEndingLayout) {\n            if (this._iScriptInterface) {\n                const e = new C3.Event("destroy");\n                e.isEndingLayout = isEndingLayout;\n                this.DispatchUserScriptEvent(e)\n            }\n            if (!this._HasAnyCreateDestroyHandler("instancedestroy"))\n                return;\n            const objectType = this.GetObjectClass();\n            const instDestroyEvent = new C3.Event("instancedestroy");\n            instDestroyEvent.instance = this.GetInterfaceClass();\n            instDestroyEvent.isEndingLayout = isEndingLayout;\n            objectType.DispatchUserScriptEvent(instDestroyEvent);\n            for (const family of objectType.GetFamilies())\n                family.DispatchUserScriptEvent(instDestroyEvent);\n            this._runtime.DispatchUserScriptEvent(instDestroyEvent)\n        }\n        _GetDebuggerProperties() {\n            return this._sdkInst.GetDebuggerProperties()\n        }\n        SaveToJson(mode="full") {\n            const o = {};\n            if (mode === "full")\n                o["uid"] = this.GetUID();\n            else\n                o["c3"] = true;\n            if (mode !== "visual-state") {\n                const savedData = savedDataMaps.get(this);\n                if (savedData && savedData.size)\n                    o["ex"] = C3.ToSuperJSON(savedData);\n                if (this.GetTimeScale() !== -1)\n                    o["mts"] = this.GetTimeScale();\n                if (this._objectType.GetInstanceVariablesCount() > 0) {\n                    const ivs = {};\n                    const ivSids = this._objectType.GetInstanceVariableSIDs();\n                    for (let i = 0, len = this._instVarValues.length; i < len; ++i)\n                        ivs[ivSids[i].toString()] = this._instVarValues[i];\n                    o["ivs"] = ivs\n                }\n                if (this._behaviorInstances.length) {\n                    const behs = {};\n                    for (const behInst of this._behaviorInstances) {\n                        const data = behInst.SaveToJson();\n                        if (data)\n                            behs[behInst.GetBehaviorType().GetSID().toString()] = data\n                    }\n                    o["behs"] = behs\n                }\n            }\n            if (this._worldInfo)\n                o["w"] = this._worldInfo._SaveToJson(mode);\n            const ownData = this._sdkInst.SaveToJson();\n            if (ownData)\n                o["data"] = ownData;\n            return o\n        }\n        _OnBeforeLoad(mode="full") {\n            if (this._worldInfo)\n                this._worldInfo._OnBeforeLoad(mode)\n        }\n        LoadFromJson(o, mode="full") {\n            if (mode === "full")\n                this._uid = o["uid"];\n            else if (!o["c3"])\n                return;\n            if (mode !== "visual-state") {\n                let savedData = savedDataMaps.get(this);\n                if (savedData) {\n                    savedData.clear();\n                    savedDataMaps.delete(this)\n                }\n                const ex = o["ex"];\n                if (ex) {\n                    savedData = C3.FromSuperJSON(ex);\n                    savedDataMaps.set(this, savedData)\n                }\n                this._timeScale = o.hasOwnProperty("mts") ? o["mts"] : -1;\n                const ivs = o["ivs"];\n                if (ivs)\n                    for (const [sidStr,value] of Object.entries(ivs)) {\n                        const sid = parseInt(sidStr, 10);\n                        const index = this._objectType.GetInstanceVariableIndexBySID(sid);\n                        if (index < 0 || index >= this._instVarValues.length)\n                            continue;\n                        let v = value;\n                        if (v === null)\n                            v = NaN;\n                        this._instVarValues[index] = v\n                    }\n            }\n            if (this.GetPlugin().IsWorldType()) {\n                const worldData = o["w"];\n                const layerSid = worldData["l"];\n                if (this._worldInfo.GetLayer().GetSID() !== layerSid) {\n                    const oldLayer = this._worldInfo.GetLayer();\n                    const newLayer = oldLayer.GetLayout().GetLayerBySID(layerSid);\n                    if (newLayer) {\n                        this._worldInfo._SetLayer(newLayer);\n                        oldLayer._RemoveInstance(this, true);\n                        newLayer._AddInstance(this, true);\n                        newLayer.SetZIndicesChanged();\n                        this._worldInfo.SetBboxChanged()\n                    } else if (mode === "full")\n                        this._runtime.DestroyInstance(this)\n                }\n                this._worldInfo._LoadFromJson(worldData, mode)\n            }\n            if (mode !== "visual-state") {\n                const behs = o["behs"];\n                if (behs)\n                    for (const [sidStr,data] of Object.entries(behs)) {\n                        const sid = parseInt(sidStr, 10);\n                        const index = this.GetBehaviorIndexBySID(sid);\n                        if (index < 0 || index >= this._behaviorInstances.length)\n                            continue;\n                        this._behaviorInstances[index].LoadFromJson(data)\n                    }\n            }\n            const ownData = o["data"];\n            if (ownData)\n                this._sdkInst.LoadFromJson(ownData)\n        }\n        GetInterfaceClass() {\n            return this._iScriptInterface || this._InitUserScriptInterface()\n        }\n        _InitUserScriptInterface() {\n            const DefaultScriptClass = this._worldInfo ? self.IWorldInstance : IInstance;\n            const SdkScriptClass = this._sdkInst.GetScriptInterfaceClass();\n            const UserScriptClass = this._objectType._GetUserScriptInstanceClass();\n            const ScriptInterfaceClass = UserScriptClass || SdkScriptClass || DefaultScriptClass;\n            IInstance._Init(this);\n            this._iScriptInterface = new ScriptInterfaceClass;\n            IInstance._Init(null);\n            if (SdkScriptClass && !(this._iScriptInterface instanceof DefaultScriptClass))\n                throw new TypeError(`script interface class \'${SdkScriptClass.name}\' does not extend the right base class \'${DefaultScriptClass.name}\'`);\n            if (UserScriptClass) {\n                const ExpectedBaseClass = SdkScriptClass || DefaultScriptClass;\n                if (!(this._iScriptInterface instanceof ExpectedBaseClass))\n                    throw new TypeError(`setInstanceClass(): class \'${UserScriptClass.name}\' does not extend the right base class \'${ExpectedBaseClass.name}\'`);\n            }\n            return this._iScriptInterface\n        }\n        _GetInstVarsScriptDescriptor(instDescriptors) {\n            if (this._instVarValues.length === 0)\n                return;\n            const varDescriptors = {};\n            const instVarJsPropNames = this._objectType._GetAllInstanceVariableJsPropNames();\n            for (let i = 0, len = instVarJsPropNames.length; i < len; ++i)\n                varDescriptors[instVarJsPropNames[i]] = {\n                    configurable: false,\n                    enumerable: true,\n                    get: C3.Instance.prototype._GetInstanceVariableTypedValue.bind(this, i),\n                    set: C3.Instance.prototype.SetInstanceVariableValue.bind(this, i)\n                };\n            const instVarsObj = Object.create(Object.prototype, varDescriptors);\n            instDescriptors.instVars = {\n                value: instVarsObj,\n                writable: false\n            }\n        }\n        _GetBehaviorsScriptDescriptor(instDescriptors) {\n            const behaviorInstances = this._behaviorInstances;\n            if (behaviorInstances.length === 0)\n                return;\n            const behDescriptors = {};\n            for (const behInst of behaviorInstances)\n                behDescriptors[behInst.GetBehaviorType().GetJsPropName()] = {\n                    value: behInst.GetScriptInterface(),\n                    writable: false\n                };\n            const behaviorsObj = Object.create(Object.prototype, behDescriptors);\n            instDescriptors.behaviors = {\n                value: behaviorsObj,\n                writable: false\n            }\n        }\n        DispatchUserScriptEvent(e) {\n            e.instance = this.GetInterfaceClass();\n            const runtime = this._runtime;\n            const shouldTime = runtime.IsDebug() && !runtime.GetEventSheetManager().IsInEventEngine();\n            if (shouldTime)\n                C3Debugger.StartMeasuringScriptTime();\n            this.GetInterfaceClass().dispatchEvent(e);\n            if (shouldTime)\n                C3Debugger.AddScriptTime()\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/sceneGraphInfo.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.SceneGraphInfo = class SceneGraphInfo extends C3.DefendedBase {\n        constructor(owner) {\n            super();\n            this._owner = owner;\n            this._parent = null;\n            this._children = [];\n            this._startWidth = owner.GetWidth();\n            this._startHeight = owner.GetHeight();\n            this._startScaleX = 1;\n            this._startScaleY = 1;\n            this._parentStartAngle = 0\n        }\n        Release() {\n            this._parent = null;\n            C3.clearArray(this._children)\n        }\n        SetParent(parent) {\n            this._parent = parent;\n            this._parentStartAngle = parent ? parent.GetAngle() : 0\n        }\n        GetParent() {\n            return this._parent\n        }\n        HasChildren() {\n            return this._children.length > 0\n        }\n        GetChildren() {\n            return this._children\n        }\n        GetStartScaleX() {\n            return this._startScaleX\n        }\n        SetStartScaleX(sx) {\n            this._startScaleX = sx\n        }\n        GetStartScaleY() {\n            return this._startScaleY\n        }\n        SetStartScaleY(sy) {\n            this._startScaleY = sy\n        }\n        _GetStartWidth() {\n            if (this._startWidth === 0)\n                return Number.EPSILON;\n            return this._startWidth\n        }\n        _GetStartHeight() {\n            if (this._startHeight === 0)\n                return Number.EPSILON;\n            return this._startHeight\n        }\n        GetParentScaleX() {\n            if (this._owner.GetTransformWithParentWidth()) {\n                const p = this._parent;\n                let cw = p.GetWidth();\n                let sw = p._GetSceneGraphInfo()._GetStartWidth();\n                if (cw === 0)\n                    cw = Number.EPSILON;\n                if (sw === Number.EPSILON && cw === Number.EPSILON)\n                    return 1;\n                if (sw === Number.EPSILON && cw !== Number.EPSILON) {\n                    const sdkIntance = p.GetInstance().GetSdkInstance();\n                    if (sdkIntance.IsOriginalSizeKnown())\n                        return 1 + cw \/ sdkIntance.GetOriginalWidth()\n                }\n                return cw \/ sw\n            }\n            return 1\n        }\n        GetParentScaleY() {\n            if (this._owner.GetTransformWithParentHeight()) {\n                const p = this._parent;\n                let ch = p.GetHeight();\n                let sh = p._GetSceneGraphInfo()._GetStartHeight();\n                if (ch === 0)\n                    ch = Number.EPSILON;\n                if (sh === Number.EPSILON && ch === Number.EPSILON)\n                    return 1;\n                if (sh === Number.EPSILON && ch !== Number.EPSILON) {\n                    const sdkIntance = p.GetInstance().GetSdkInstance();\n                    if (sdkIntance.IsOriginalSizeKnown())\n                        return 1 + ch \/ sdkIntance.GetOriginalHeight()\n                }\n                return ch \/ sh\n            }\n            return 1\n        }\n        GetParentStartAngle() {\n            return this._parentStartAngle\n        }\n        _SaveToJson(mode) {\n            return {\n                "sw": this._startWidth,\n                "sh": this._startHeight,\n                "sx": this._startScaleX,\n                "sy": this._startScaleY,\n                "psa": this._parentStartAngle,\n                "p": this._GetParentJson(mode),\n                "c": this._GetChildrenJson(mode)\n            }\n        }\n        _GetFlagsString(wi) {\n            let flagsStr = "";\n            if (wi.GetTransformWithParentX())\n                flagsStr += "x";\n            if (wi.GetTransformWithParentY())\n                flagsStr += "y";\n            if (wi.GetTransformWithParentWidth())\n                flagsStr += "w";\n            if (wi.GetTransformWithParentHeight())\n                flagsStr += "h";\n            if (wi.GetTransformWithParentAngle())\n                flagsStr += "a";\n            if (wi.GetTransformWithParentZElevation())\n                flagsStr += "z";\n            if (wi.GetDestroyWithParent())\n                flagsStr += "d";\n            return flagsStr\n        }\n        _GetParentJson(mode) {\n            if (!this._parent)\n                return null;\n            if (!this._parent.GetInstance() || this._parent.GetInstance().IsDestroyed())\n                return null;\n            return this._GetInstanceJson(this._parent, this._owner, mode)\n        }\n        _GetChildrenJson(mode) {\n            return this._children.map(c => {\n                return this._GetInstanceJson(c, c, mode)\n            }\n            )\n        }\n        _GetInstanceJson(wi, flagsSource, mode) {\n            const inst = wi.GetInstance();\n            const ret = {};\n            ret["uid"] = inst.GetUID();\n            ret["f"] = this._GetFlagsString(flagsSource);\n            ret["offsets"] = flagsSource._SaveSceneGraphPropertiesToJson();\n            if (mode === "state") {\n                ret["oci"] = inst.GetObjectClass().GetIndex();\n                ret["inst"] = inst.SaveToJson()\n            }\n            return ret\n        }\n        _LoadFromJson(o) {\n            this._startWidth = o["sw"];\n            this._startHeight = o["sh"];\n            this._startScaleX = o["sx"];\n            this._startScaleY = o["sy"];\n            this._parentStartAngle = o["psa"]\n        }\n        _OnAfterLoad(o, opts) {\n            const owner = this._owner;\n            const runtime = owner.GetRuntime();\n            if (o["p"] && !this._parent) {\n                const parentUid = o["p"]["uid"];\n                const parentInst = runtime.GetInstanceByUID(parentUid);\n                if (opts && !opts.ignoreMissingInstances)\n                    ;if (parentInst) {\n                    const parentWi = parentInst.GetWorldInfo();\n                    if (parentInst.HasChild(this._owner.GetInstance()))\n                        this._parent = parentWi;\n                    else {\n                        parentInst.AddChild(this._owner.GetInstance(), this._GetFlagsObj(o["p"]["f"]));\n                        this._owner._LoadSceneGraphPropertiesFromJson(o["p"]["offsets"])\n                    }\n                } else if (C3.IsFiniteNumber(o["p"]["oci"])) {\n                    const objectClass = runtime.GetObjectClassByIndex(o["p"]["oci"]);\n                    const system = runtime.GetSystemPlugin();\n                    const parentInstance = runtime.CreateInstance(objectClass, owner.GetLayer(), 0, 0, true);\n                    if (opts && !opts.ignoreMissingInstances)\n                        ;if (parentInstance) {\n                        parentInstance.LoadFromJson(o["p"]["inst"]);\n                        const parentWi = parentInstance.GetWorldInfo();\n                        parentWi.GetLayer().SortAndAddInstancesByZIndex(parentInstance);\n                        parentInstance.AddChild(owner.GetInstance(), this._GetFlagsObj(o["p"]["f"]))\n                    }\n                }\n            }\n            for (const childData of o["c"]) {\n                const childUid = childData["uid"];\n                const childInst = runtime.GetInstanceByUID(childUid);\n                if (opts && !opts.ignoreMissingInstances)\n                    ;if (childInst) {\n                    const childWi = childInst.GetWorldInfo();\n                    owner.AddChild(childWi, this._GetFlagsObj(childData["f"]));\n                    childWi._LoadSceneGraphPropertiesFromJson(childData["offsets"])\n                } else if (C3.IsFiniteNumber(childData["oci"])) {\n                    const objectClass = runtime.GetObjectClassByIndex(childData["oci"]);\n                    const system = runtime.GetSystemPlugin();\n                    const childInstance = runtime.CreateInstance(objectClass, owner.GetLayer(), 0, 0, true);\n                    if (opts && !opts.ignoreMissingInstances)\n                        ;if (childInstance) {\n                        childInstance.LoadFromJson(childData["inst"]);\n                        const childWi = childInstance.GetWorldInfo();\n                        childWi.GetLayer().SortAndAddInstancesByZIndex(childInstance);\n                        owner.AddChild(childWi, this._GetFlagsObj(childData["f"]))\n                    }\n                }\n            }\n        }\n        _GetFlagsObj(flagsString) {\n            const opts = {};\n            opts.transformX = flagsString.includes("x");\n            opts.transformY = flagsString.includes("y");\n            opts.transformWidth = flagsString.includes("w");\n            opts.transformHeight = flagsString.includes("h");\n            opts.transformAngle = flagsString.includes("a");\n            opts.transformZElevation = flagsString.includes("z");\n            opts.destroyWithParent = flagsString.includes("d");\n            return opts\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/worldInfo.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const glMatrix = self.glMatrix;\n    const vec3 = glMatrix.vec3;\n    const vec4 = glMatrix.vec4;\n    const tempRect = C3.New(C3.Rect);\n    const tempQuad = C3.New(C3.Quad);\n    const bboxChangeEvent = C3.New(C3.Event, "bboxchange", false);\n    const tempColor = C3.New(C3.Color, 0, 0, 0, 0);\n    const tempCollisionPoly = C3.New(C3.CollisionPoly);\n    const DEFAULT_COLOR = C3.New(C3.Color, 1, 1, 1, 1);\n    const DEFAULT_RENDER_CELLS = C3.New(C3.Rect, 0, 0, -1, -1);\n    const DEFAULT_COLLISION_CELLS = C3.New(C3.Rect, 0, 0, -1, -1);\n    const VALID_SET_MESH_POINT_MODES = new Set(["absolute", "relative"]);\n    const EMPTY_ARRAY = [];\n    let enableUpdateRendererStateGroup = true;\n    const FLAG_IS_VISIBLE = 1 << 0;\n    const FLAG_BBOX_CHANGED = 1 << 1;\n    const FLAG_ENABLE_BBOX_CHANGED_EVENT = 1 << 2;\n    const FLAG_COLLISION_ENABLED = 1 << 3;\n    const FLAG_COLLISION_CELL_CHANGED = 1 << 4;\n    const FLAG_SOLID_FILTER_INCLUSIVE = 1 << 5;\n    const FLAG_HAS_ANY_ACTIVE_EFFECT = 1 << 6;\n    const FLAG_IS_ROTATABLE = 1 << 7;\n    const FLAG_DESTROYED = 1 << 8;\n    const FLAG_DESTROY_WITH_PARENT = 1 << 9;\n    const FLAG_TRANSFORM_WITH_PARENT_X = 1 << 10;\n    const FLAG_TRANSFORM_WITH_PARENT_Y = 1 << 11;\n    const FLAG_TRANSFORM_WITH_PARENT_W = 1 << 12;\n    const FLAG_TRANSFORM_WITH_PARENT_H = 1 << 13;\n    const FLAG_TRANSFORM_WITH_PARENT_A = 1 << 14;\n    const FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION = 1 << 15;\n    const MASK_ALL_SCENE_GRAPH_FLAGS = FLAG_DESTROY_WITH_PARENT | FLAG_TRANSFORM_WITH_PARENT_X | FLAG_TRANSFORM_WITH_PARENT_Y | FLAG_TRANSFORM_WITH_PARENT_W | FLAG_TRANSFORM_WITH_PARENT_H | FLAG_TRANSFORM_WITH_PARENT_A | FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION;\n    const FLAG_MESH_CHANGED = 1 << 16;\n    const FLAG_PHYSICS_BODY_CHANGED = 1 << 17;\n    const FLAG_SIN_COS_ANGLE_CHANGED = 1 << 18;\n    const FLAG_USE_POINTS_SHADER_PROGRAM = 1 << 19;\n    const FLAG_DRAW_BACK_FACE_ONLY = 1 << 20;\n    const FLAG_DRAW_NON_BACK_FACES_ONLY = 1 << 21;\n    const FLAG_BLEND_MODE_BIT_OFFSET = 26;\n    const FLAG_BLEND_MODE_MASK = 31 << FLAG_BLEND_MODE_BIT_OFFSET;\n    const sceneGraphExportDataMap = new WeakMap;\n    const sceneGraphZIndexMap = new WeakMap;\n    C3.WorldInfo = class WorldInfo extends C3.DefendedBase {\n        constructor(inst, layer) {\n            super();\n            this._inst = inst;\n            this._objectClass = inst.GetObjectClass();\n            this._runtime = inst.GetRuntime();\n            this._layer = layer;\n            this._zIndex = -1;\n            this._flags = FLAG_IS_VISIBLE | FLAG_BBOX_CHANGED | FLAG_COLLISION_ENABLED | FLAG_COLLISION_CELL_CHANGED | FLAG_MESH_CHANGED | FLAG_PHYSICS_BODY_CHANGED;\n            if (this._objectClass.GetPlugin().IsRotatable())\n                this._flags |= FLAG_IS_ROTATABLE;\n            this._x = NaN;\n            this._y = NaN;\n            this._zElevation = NaN;\n            this._w = NaN;\n            this._h = NaN;\n            this._depth = NaN;\n            this._a = NaN;\n            this._sinA = NaN;\n            this._cosA = NaN;\n            this._ox = NaN;\n            this._oy = NaN;\n            this._boundingBox = C3.New(C3.Rect);\n            this._boundingQuad = C3.New(C3.Quad);\n            this._collisionCells = DEFAULT_COLLISION_CELLS;\n            this._renderCells = DEFAULT_RENDER_CELLS;\n            this._sourceCollisionPoly = null;\n            this._transformedPolyInfo = null;\n            this._solidFilterTags = null;\n            this._color = DEFAULT_COLOR;\n            this._colorPremultiplied = DEFAULT_COLOR;\n            this._stateGroup = null;\n            this._instanceEffectList = null;\n            if (this._inst.GetObjectClass().UsesEffects())\n                this._instanceEffectList = C3.New(C3.InstanceEffectList, this._inst, this);\n            this._sceneGraphInfo = null;\n            this._meshInfo = null\n        }\n        _MarkDestroyed() {\n            this._flags |= FLAG_DESTROYED\n        }\n        Release() {\n            if (this._stateGroup) {\n                this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup);\n                this._stateGroup = null\n            }\n            this._sourceCollisionPoly = null;\n            if (this._transformedPolyInfo) {\n                this._transformedPolyInfo.poly.Release();\n                this._transformedPolyInfo = null\n            }\n            if (this._solidFilterTags) {\n                this._solidFilterTags.clear();\n                this._solidFilterTags = null\n            }\n            this.ReleaseMesh();\n            if (this.HasParent())\n                this.GetParent().RemoveChild(this);\n            if (this.HasChildren()) {\n                const childrenToRelease = [...this.GetChildren()];\n                for (const child of childrenToRelease)\n                    this.RemoveChild(child)\n            }\n            this._ReleaseSceneGraphInfo();\n            this._inst = null;\n            this._objectClass = null;\n            this._runtime = null;\n            this._layer = null\n        }\n        Init(data) {\n            enableUpdateRendererStateGroup = false;\n            this.SetXY(data[0], data[1]);\n            this.SetZElevation(data[2]);\n            this.SetSize(data[3], data[4]);\n            this._depth = 0;\n            if (this.IsRotatable())\n                this.SetAngle(data[6]);\n            else\n                this._a = 0;\n            tempColor.setFromJSON(data[7]);\n            this._SetColor(tempColor);\n            this.SetOriginX(data[8]);\n            this.SetOriginY(data[9]);\n            this.SetBlendMode(data[10]);\n            if (this._instanceEffectList)\n                this._instanceEffectList._LoadEffectParameters(data[12]);\n            if (data[14])\n                sceneGraphExportDataMap.set(this, {\n                    childrenData: data[14][1],\n                    zIndexData: data[14][2]\n                });\n            if (data[15]) {\n                const meshData = data[15];\n                this.CreateMesh(meshData[0], meshData[1]);\n                const sourceMesh = this.GetSourceMesh();\n                const meshRows = meshData[2];\n                for (let y = 0, lenY = meshRows.length; y < lenY; ++y) {\n                    const rowData = meshRows[y];\n                    for (let x = 0, lenX = rowData.length; x < lenX; ++x) {\n                        const d = rowData[x];\n                        const pt = sourceMesh.GetMeshPointAt(x, y);\n                        pt.SetX(d[0]);\n                        pt.SetY(d[1]);\n                        pt.SetZElevation(d[2]);\n                        pt.SetU(d[3]);\n                        pt.SetV(d[4])\n                    }\n                }\n            }\n            if (data[16]) {\n                const sourceTemplateName = data[16][1];\n                const isReplica = !!sourceTemplateName;\n                const templateManager = this._runtime.GetTemplateManager();\n                if (isReplica && templateManager)\n                    templateManager.MapInstanceToTemplateName(this.GetInstance(), sourceTemplateName)\n            }\n            enableUpdateRendererStateGroup = true;\n            this._UpdateRendererStateGroup()\n        }\n        InitNoData() {\n            this._x = 0;\n            this._y = 0;\n            this._zElevation = 0;\n            this._w = 0;\n            this._h = 0;\n            this._depth = 0;\n            this._a = 0;\n            this._sinA = 0;\n            this._cosA = 1;\n            this._ox = 0;\n            this._oy = 0;\n            this._UpdateRendererStateGroup()\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetObjectClass() {\n            return this._objectClass\n        }\n        GetInstance() {\n            return this._inst\n        }\n        _GetParentOffsetAngle() {\n            if (this.GetTransformWithParentAngle())\n                return this.GetParent().GetAngle() - this._sceneGraphInfo.GetParentStartAngle();\n            return 0\n        }\n        SetX(x) {\n            x = +x;\n            if (this.GetTransformWithParentX()) {\n                const sgi = this._sceneGraphInfo;\n                const dx = x - this.GetX();\n                const da = -this._GetParentOffsetAngle();\n                if (da === 0)\n                    this._x += dx \/ sgi.GetParentScaleX();\n                else {\n                    this._x += Math.cos(da) * dx \/ sgi.GetParentScaleX();\n                    if (this.GetTransformWithParentY())\n                        this._y += Math.sin(da) * dx \/ sgi.GetParentScaleY()\n                }\n            } else\n                this._x = x\n        }\n        OffsetX(x, transformWithSceneGraph=false) {\n            x = +x;\n            if (transformWithSceneGraph)\n                this._x += x;\n            else if (this.GetTransformWithParentX())\n                this.SetX(this.GetX() + x);\n            else\n                this._x += x\n        }\n        GetX() {\n            if (this.GetTransformWithParentX()) {\n                let x = this._x;\n                const sgi = this._sceneGraphInfo;\n                const parent = this.GetParent();\n                const da = this._GetParentOffsetAngle();\n                if (da === 0)\n                    x *= sgi.GetParentScaleX();\n                else {\n                    x = x * sgi.GetParentScaleX() * Math.cos(da);\n                    if (this.GetTransformWithParentY())\n                        x -= this._y * sgi.GetParentScaleY() * Math.sin(da)\n                }\n                return parent.GetX() + x\n            } else\n                return this._x\n        }\n        SetY(y) {\n            y = +y;\n            if (this.GetTransformWithParentY()) {\n                const sgi = this._sceneGraphInfo;\n                const dy = y - this.GetY();\n                const da = -this._GetParentOffsetAngle();\n                if (da === 0)\n                    this._y += dy \/ sgi.GetParentScaleY();\n                else {\n                    if (this.GetTransformWithParentX())\n                        this._x -= Math.sin(da) * dy \/ sgi.GetParentScaleX();\n                    this._y += Math.cos(da) * dy \/ sgi.GetParentScaleY()\n                }\n            } else\n                this._y = y\n        }\n        OffsetY(y, transformWithSceneGraph=false) {\n            y = +y;\n            if (transformWithSceneGraph)\n                this._y += y;\n            else if (this.GetTransformWithParentY())\n                this.SetY(this.GetY() + y);\n            else\n                this._y += y\n        }\n        GetY() {\n            if (this.GetTransformWithParentY()) {\n                let y = this._y;\n                const sgi = this._sceneGraphInfo;\n                const parent = this.GetParent();\n                const da = this._GetParentOffsetAngle();\n                if (da === 0)\n                    y *= sgi.GetParentScaleY();\n                else {\n                    y = y * sgi.GetParentScaleY() * Math.cos(da);\n                    if (this.GetTransformWithParentX())\n                        y += this._x * sgi.GetParentScaleX() * Math.sin(da)\n                }\n                return parent.GetY() + y\n            } else\n                return this._y\n        }\n        SetXY(x, y) {\n            x = +x;\n            y = +y;\n            if (this.GetTransformWithParentXOrY()) {\n                const isTransformX = this.GetTransformWithParentX();\n                const isTransformY = this.GetTransformWithParentY();\n                const sgi = this._sceneGraphInfo;\n                const dx = x - this.GetX();\n                const dy = y - this.GetY();\n                const da = -this._GetParentOffsetAngle();\n                if (da === 0) {\n                    if (isTransformX)\n                        this._x += dx \/ sgi.GetParentScaleX();\n                    else\n                        this._x = x;\n                    if (isTransformY)\n                        this._y += dy \/ sgi.GetParentScaleY();\n                    else\n                        this._y = y\n                } else {\n                    const sinDa = Math.sin(da);\n                    const cosDa = Math.cos(da);\n                    if (isTransformX)\n                        if (isTransformY)\n                            this._x += (cosDa * dx - sinDa * dy) \/ sgi.GetParentScaleX();\n                        else\n                            this._x += cosDa * dx \/ sgi.GetParentScaleX();\n                    else\n                        this._x = x;\n                    if (isTransformY)\n                        if (isTransformX)\n                            this._y += (sinDa * dx + cosDa * dy) \/ sgi.GetParentScaleY();\n                        else\n                            this._y += cosDa * dy \/ sgi.GetParentScaleY();\n                    else\n                        this._y = y\n                }\n            } else {\n                this._x = x;\n                this._y = y\n            }\n        }\n        OffsetXY(x, y) {\n            x = +x;\n            y = +y;\n            if (this.GetTransformWithParentXOrY())\n                this.SetXY(this.GetX() + x, this.GetY() + y);\n            else {\n                this._x += x;\n                this._y += y\n            }\n        }\n        EqualsXY(x, y) {\n            return this.GetX() === x && this.GetY() === y\n        }\n        SetZElevation(z) {\n            z = +z;\n            if (this.GetTransformWithParentZElevation())\n                z -= this.GetParent().GetZElevation();\n            if (this._zElevation === z)\n                return;\n            this._zElevation = z;\n            this._UpdateZElevation();\n            const layer = this.GetLayer();\n            if (this._zElevation !== 0)\n                layer._SetAnyInstanceZElevated();\n            layer.SetZIndicesChanged()\n        }\n        _UpdateZElevation() {\n            this._UpdateRendererStateGroup();\n            if (this.HasChildren()) {\n                const children = this.GetChildren();\n                for (let i = 0, len = children.length; i < len; i++) {\n                    const child = children[i];\n                    if (child.GetTransformWithParentZElevation())\n                        child._UpdateZElevation()\n                }\n            }\n        }\n        OffsetZElevation(z) {\n            this.SetZElevation(this.GetZElevation() + z)\n        }\n        GetZElevation() {\n            if (this.GetTransformWithParentZElevation())\n                return this.GetParent().GetZElevation() + this._zElevation;\n            else\n                return this._zElevation\n        }\n        GetTotalZElevation() {\n            return this.GetLayer().GetZElevation() + this.GetZElevation()\n        }\n        SetWidth(w) {\n            w = +w;\n            if (this.GetTransformWithParentWidth()) {\n                const ownWidth = this.GetWidth();\n                if (ownWidth === 0)\n                    this._w = Number.EPSILON;\n                else\n                    this._w *= w \/ ownWidth\n            } else\n                this._w = w\n        }\n        OffsetWidth(w) {\n            w = +w;\n            if (this.GetTransformWithParentWidth())\n                this.SetWidth(this.GetWidth() + w);\n            else\n                this._w += w\n        }\n        GetWidth() {\n            if (this.GetTransformWithParentWidth()) {\n                const parent = this.GetParent();\n                const pw = parent.GetWidth();\n                const psw = parent._GetSceneGraphInfo()._GetStartWidth();\n                if (psw === Number.EPSILON)\n                    return (this._GetSceneGraphInfo()._GetStartWidth() + pw) * this._w;\n                return pw * this._w\n            } else\n                return this._w\n        }\n        SetHeight(h) {\n            h = +h;\n            if (this.GetTransformWithParentHeight()) {\n                const ownHeight = this.GetHeight();\n                if (ownHeight === 0)\n                    this._h = Number.EPSILON;\n                else\n                    this._h *= h \/ ownHeight\n            } else\n                this._h = h\n        }\n        OffsetHeight(h) {\n            h = +h;\n            if (this.GetTransformWithParentHeight())\n                this.SetHeight(this.GetHeight() + h);\n            else\n                this._h += h\n        }\n        GetHeight() {\n            if (this.GetTransformWithParentHeight()) {\n                const parent = this.GetParent();\n                const ph = parent.GetHeight();\n                const psh = parent._GetSceneGraphInfo()._GetStartHeight();\n                if (psh === Number.EPSILON)\n                    return (this._GetSceneGraphInfo()._GetStartHeight() + ph) * this._h;\n                return ph * this._h\n            } else\n                return this._h\n        }\n        SetSize(w, h) {\n            w = +w;\n            h = +h;\n            if (this.GetTransformWithParentWidth()) {\n                const ownWidth = this.GetWidth();\n                if (ownWidth === 0)\n                    this._w = Number.EPSILON;\n                else\n                    this._w *= w \/ ownWidth\n            } else\n                this._w = w;\n            if (this.GetTransformWithParentHeight()) {\n                const ownHeight = this.GetHeight();\n                if (ownHeight === 0)\n                    this._h = Number.EPSILON;\n                else\n                    this._h *= h \/ ownHeight\n            } else\n                this._h = h\n        }\n        GetDepth() {\n            return this._depth\n        }\n        SetDepth(d) {\n            if (d < 0)\n                throw new RangeError("invalid depth");\n            this._depth = d\n        }\n        GetSceneGraphScale() {\n            if (this.HasParent()) {\n                const sgi = this._sceneGraphInfo;\n                return Math.min(sgi.GetParentScaleX(), sgi.GetParentScaleY())\n            } else\n                return 1\n        }\n        IsRotatable() {\n            return (this._flags & FLAG_IS_ROTATABLE) !== 0\n        }\n        SetAngle(a) {\n            a = +a;\n            if (!this.IsRotatable())\n                return;\n            if (this.GetTransformWithParentAngle())\n                a -= this.GetParent().GetAngle();\n            a = C3.clampAngle(a);\n            if (this._a === a)\n                return;\n            this._a = a;\n            this._MarkSinCosAngleChanged()\n        }\n        OffsetAngle(a) {\n            a = +a;\n            if (a === 0 || !this.IsRotatable())\n                return;\n            this._a = C3.clampAngle(this._a + a);\n            this._MarkSinCosAngleChanged()\n        }\n        _MarkSinCosAngleChanged() {\n            this._flags |= FLAG_SIN_COS_ANGLE_CHANGED;\n            if (this.HasChildren()) {\n                const children = this.GetChildren();\n                for (let i = 0, len = children.length; i < len; i++)\n                    children[i]._MarkSinCosAngleChanged()\n            }\n        }\n        GetAngle() {\n            if (this.GetTransformWithParentAngle())\n                return C3.clampAngle(this.GetParent().GetAngle() + this._a);\n            else\n                return this._a\n        }\n        _MaybeUpdateSinCosAngle() {\n            const flags = this._flags;\n            if ((flags & FLAG_SIN_COS_ANGLE_CHANGED) === 0)\n                return;\n            const a = this.GetAngle();\n            this._sinA = Math.sin(a);\n            this._cosA = Math.cos(a);\n            this._flags = flags & ~FLAG_SIN_COS_ANGLE_CHANGED\n        }\n        GetSinAngle() {\n            this._MaybeUpdateSinCosAngle();\n            return this._sinA\n        }\n        GetCosAngle() {\n            this._MaybeUpdateSinCosAngle();\n            return this._cosA\n        }\n        SetOriginX(x) {\n            this._ox = +x\n        }\n        OffsetOriginX(x) {\n            this._ox += +x\n        }\n        GetOriginX() {\n            return this._ox\n        }\n        SetOriginY(y) {\n            this._oy = +y\n        }\n        OffsetOriginY(y) {\n            this._oy += +y\n        }\n        GetOriginY() {\n            return this._oy\n        }\n        _SetColor(c) {\n            if (this._color.equals(c))\n                return;\n            if (this._color === DEFAULT_COLOR) {\n                this._color = C3.New(C3.Color, c);\n                this._colorPremultiplied = C3.New(C3.Color, c);\n                this._colorPremultiplied.premultiply()\n            } else if (c.equalsRgba(1, 1, 1, 1)) {\n                this._color = DEFAULT_COLOR;\n                this._colorPremultiplied = DEFAULT_COLOR\n            } else {\n                this._color.set(c);\n                this._colorPremultiplied.set(c);\n                this._colorPremultiplied.premultiply()\n            }\n            this._UpdateRendererStateGroup()\n        }\n        SetOpacity(o) {\n            o = C3.clamp(+o, 0, 1);\n            if (this._color.a === o)\n                return;\n            tempColor.copyRgb(this._color);\n            tempColor.a = o;\n            this._SetColor(tempColor)\n        }\n        OffsetOpacity(o) {\n            this.SetOpacity(this.GetOpacity() + o)\n        }\n        GetOpacity() {\n            return this._color.a\n        }\n        SetUnpremultipliedColor(c) {\n            if (this._color.equalsIgnoringAlpha(c))\n                return;\n            tempColor.copyRgb(c);\n            tempColor.a = this._color.a;\n            this._SetColor(tempColor)\n        }\n        SetUnpremultipliedColorRGB(r, g, b) {\n            tempColor.setRgb(r, g, b);\n            this.SetUnpremultipliedColor(tempColor)\n        }\n        OffsetUnpremultipliedColorRGB(r, g, b) {\n            if (r === 0 && g === 0 && b === 0)\n                return;\n            tempColor.copyRgb(this._color);\n            tempColor.r += r;\n            tempColor.g += g;\n            tempColor.b += b;\n            this.SetUnpremultipliedColor(tempColor)\n        }\n        GetUnpremultipliedColor() {\n            return this._color\n        }\n        GetPremultipliedColor() {\n            return this._colorPremultiplied\n        }\n        GetDestroyWithParent() {\n            return (this._flags & FLAG_DESTROY_WITH_PARENT) !== 0\n        }\n        SetDestroyWithParent(d) {\n            this._SetFlag(FLAG_DESTROY_WITH_PARENT, d)\n        }\n        GetTransformWithParentX() {\n            return (this._flags & FLAG_TRANSFORM_WITH_PARENT_X) !== 0\n        }\n        SetTransformWithParentX(tpx) {\n            this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_X, tpx)\n        }\n        GetTransformWithParentY() {\n            return (this._flags & FLAG_TRANSFORM_WITH_PARENT_Y) !== 0\n        }\n        GetTransformWithParentXOrY() {\n            return (this._flags & (FLAG_TRANSFORM_WITH_PARENT_X | FLAG_TRANSFORM_WITH_PARENT_Y)) !== 0\n        }\n        SetTransformWithParentY(tpx) {\n            this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_Y, tpx)\n        }\n        GetTransformWithParentWidth() {\n            return (this._flags & FLAG_TRANSFORM_WITH_PARENT_W) !== 0\n        }\n        SetTransformWithParentWidth(tpw) {\n            this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_W, tpw)\n        }\n        GetTransformWithParentHeight() {\n            return (this._flags & FLAG_TRANSFORM_WITH_PARENT_H) !== 0\n        }\n        SetTransformWithParentHeight(tph) {\n            this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_H, tph)\n        }\n        GetTransformWithParentAngle() {\n            return (this._flags & FLAG_TRANSFORM_WITH_PARENT_A) !== 0\n        }\n        SetTransformWithParentAngle(tpa) {\n            this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_A, tpa)\n        }\n        GetTransformWithParentZElevation() {\n            return (this._flags & FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION) !== 0\n        }\n        SetTransformWithParentZElevation(tpz) {\n            this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION, tpz)\n        }\n        _ClearAllSceneGraphFlags() {\n            this._flags &= ~MASK_ALL_SCENE_GRAPH_FLAGS\n        }\n        AddChild(child, opts) {\n            if (child === this)\n                return;\n            if (child.HasParent())\n                return;\n            if (this._HasChildRecursive(child))\n                return;\n            if (this._HasAnyParent(child))\n                return;\n            const absX = child.GetX();\n            const absY = child.GetY();\n            const absW = child.GetWidth();\n            const absH = child.GetHeight();\n            const absA = child.GetAngle();\n            const absZElevation = child.GetZElevation();\n            child._SetParent(this);\n            child.SetTransformWithParentX(opts.transformX);\n            child.SetTransformWithParentY(opts.transformY);\n            child.SetTransformWithParentWidth(opts.transformWidth);\n            child.SetTransformWithParentHeight(opts.transformHeight);\n            child.SetTransformWithParentAngle(opts.transformAngle);\n            child.SetTransformWithParentZElevation(opts.transformZElevation);\n            child.SetDestroyWithParent(opts.destroyWithParent);\n            if (opts.transformX) {\n                child._x = absX - this.GetX();\n                if (opts.transformWidth)\n                    child._x \/= this.GetWidth() \/ this._sceneGraphInfo._GetStartWidth()\n            }\n            if (opts.transformY) {\n                child._y = absY - this.GetY();\n                if (opts.transformHeight)\n                    child._y \/= this.GetHeight() \/ this._sceneGraphInfo._GetStartHeight()\n            }\n            if (opts.transformWidth) {\n                const pw = this.GetWidth();\n                if (pw === 0 || pw === Number.EPSILON) {\n                    child._w = 1;\n                    child._sceneGraphInfo.SetStartScaleX(1)\n                } else {\n                    child._w = absW \/ this.GetWidth();\n                    child._sceneGraphInfo.SetStartScaleX(child._w)\n                }\n            }\n            if (opts.transformHeight) {\n                const ph = this.GetHeight();\n                if (ph === 0 || ph === Number.EPSILON) {\n                    child._h = 1;\n                    child._sceneGraphInfo.SetStartScaleY(1)\n                } else {\n                    child._h = absH \/ this.GetHeight();\n                    child._sceneGraphInfo.SetStartScaleY(child._h)\n                }\n            }\n            if (opts.transformAngle)\n                child._a = absA - this.GetAngle();\n            if (opts.transformZElevation)\n                child._zElevation = absZElevation - this.GetZElevation();\n            this._AddChildToSceneGraphInfo(child);\n            this.SetBboxChanged()\n        }\n        RemoveChild(child) {\n            if (child.GetParent() !== this)\n                return;\n            const absX = child.GetX();\n            const absY = child.GetY();\n            const absW = child.GetWidth();\n            const absH = child.GetHeight();\n            const absA = child.GetAngle();\n            const absZElevation = child.GetZElevation();\n            child._SetParent(null);\n            child._ClearAllSceneGraphFlags();\n            child.SetXY(absX, absY);\n            child.SetSize(absW, absH);\n            child.SetAngle(absA);\n            child.SetZElevation(absZElevation);\n            this._RemoveChildFromSceneGraphInfo(child);\n            this.SetBboxChanged()\n        }\n        _ResetAllSceneGraphState() {\n            for (const c of this.children())\n                this.RemoveChild(c);\n            const parent = this.GetParent();\n            if (parent)\n                parent.RemoveChild(this);\n            this._ClearAllSceneGraphFlags()\n        }\n        HasParent() {\n            return this.GetParent() !== null\n        }\n        GetParent() {\n            const sgi = this._sceneGraphInfo;\n            return sgi !== null ? sgi.GetParent() : null\n        }\n        GetTopParent() {\n            let p = this;\n            while (p.HasParent())\n                p = p.GetParent();\n            return p\n        }\n        *parents() {\n            let parent = this.GetParent();\n            while (parent) {\n                yield parent;\n                parent = parent.GetParent()\n            }\n        }\n        HasChild(child) {\n            return this.GetChildren().includes(child)\n        }\n        HasChildren() {\n            const sgi = this._sceneGraphInfo;\n            return sgi !== null ? sgi.HasChildren() : false\n        }\n        GetChildren() {\n            const sgi = this._sceneGraphInfo;\n            return sgi !== null ? sgi.GetChildren() : EMPTY_ARRAY\n        }\n        children() {\n            return this.GetChildren()\n        }\n        *allChildren() {\n            for (const child of this.children()) {\n                yield child;\n                yield*child.allChildren()\n            }\n        }\n        GetChildCount() {\n            return this.GetChildren().length\n        }\n        GetAllChildCount() {\n            return [...this.allChildren()].length\n        }\n        GetChildAt(index) {\n            const children = this.GetChildren();\n            index = Math.floor(+index);\n            if (index < 0 || index >= children.length)\n                return null;\n            return children[index]\n        }\n        _CreateSceneGraphInfo(parent) {\n            if (!this._sceneGraphInfo)\n                this._sceneGraphInfo = C3.New(C3.SceneGraphInfo, this);\n            if (parent)\n                this._sceneGraphInfo.SetParent(parent)\n        }\n        _GetSceneGraphInfo() {\n            return this._sceneGraphInfo\n        }\n        _ReleaseSceneGraphInfo() {\n            if (!this._sceneGraphInfo)\n                return;\n            this._sceneGraphInfo.Release();\n            this._sceneGraphInfo = null\n        }\n        _SetParent(parent) {\n            if (parent) {\n                parent._CreateSceneGraphInfo(null);\n                this._CreateSceneGraphInfo(parent)\n            } else {\n                if (this._sceneGraphInfo)\n                    this._sceneGraphInfo.SetParent(null);\n                if (!this.HasChildren())\n                    this._ReleaseSceneGraphInfo()\n            }\n        }\n        _HasAnyParent(child) {\n            if (!this.HasParent())\n                return false;\n            const parent = this.GetParent();\n            if (parent === child)\n                return true;\n            return parent._HasAnyParent(child)\n        }\n        _HasChildRecursive(child) {\n            if (this.HasChild(child))\n                return true;\n            for (const c of this.GetChildren())\n                if (c._HasChildRecursive(child))\n                    return true;\n            return false\n        }\n        _AddChildToSceneGraphInfo(child) {\n            this._sceneGraphInfo.GetChildren().push(child)\n        }\n        _RemoveChildFromSceneGraphInfo(child) {\n            const children = this._sceneGraphInfo.GetChildren();\n            const index = children.indexOf(child);\n            if (index !== -1)\n                children.splice(index, 1);\n            if (children.length === 0 && !this.HasParent())\n                this._ReleaseSceneGraphInfo();\n            if (!child.HasChildren())\n                child._ReleaseSceneGraphInfo()\n        }\n        GetSceneGraphChildrenExportData() {\n            const data = sceneGraphExportDataMap.get(this);\n            return data ? data.childrenData : null\n        }\n        GetSceneGraphZIndexExportData() {\n            const data = sceneGraphExportDataMap.get(this);\n            return data ? data.zIndexData : NaN\n        }\n        GetSceneGraphZIndex() {\n            const sceneGraphZIndex = sceneGraphZIndexMap.get(this);\n            return C3.IsFiniteNumber(sceneGraphZIndex) ? sceneGraphZIndex : NaN\n        }\n        SetSceneGraphZIndex(z) {\n            sceneGraphZIndexMap.set(this, z)\n        }\n        SetUsePointsShaderProgram() {\n            this._SetFlag(FLAG_USE_POINTS_SHADER_PROGRAM, true);\n            this._UpdateRendererStateGroup()\n        }\n        _UpdateRendererStateGroup() {\n            if (!enableUpdateRendererStateGroup)\n                return;\n            const renderer = this._runtime.GetRenderer();\n            if (this._stateGroup)\n                renderer.ReleaseStateGroup(this._stateGroup);\n            let shaderProgram;\n            if ((this._flags & FLAG_USE_POINTS_SHADER_PROGRAM) !== 0)\n                shaderProgram = renderer.GetPointsRenderingProgram() || "<point>";\n            else\n                shaderProgram = renderer.GetTextureFillShaderProgram() || "<default>";\n            this._stateGroup = renderer.AcquireStateGroup(shaderProgram, this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation())\n        }\n        GetRendererStateGroup() {\n            return this._stateGroup\n        }\n        HasDefaultColor() {\n            return this._color === DEFAULT_COLOR\n        }\n        SetBlendMode(bm) {\n            bm = bm | 0;\n            if (bm < 0 || bm > 31)\n                throw new RangeError("invalid blend mode");\n            if (this.GetBlendMode() === bm)\n                return;\n            this._flags = this._flags & ~FLAG_BLEND_MODE_MASK | bm << FLAG_BLEND_MODE_BIT_OFFSET;\n            this._UpdateRendererStateGroup()\n        }\n        GetBlendMode() {\n            return (this._flags & FLAG_BLEND_MODE_MASK) >> FLAG_BLEND_MODE_BIT_OFFSET\n        }\n        _SetLayer(layer) {\n            this._layer = layer;\n            if (this.GetZElevation() !== 0)\n                this._layer._SetAnyInstanceZElevated()\n        }\n        GetLayer() {\n            return this._layer\n        }\n        GetLayout() {\n            return this.GetLayer().GetLayout()\n        }\n        _SetZIndex(z) {\n            this._zIndex = z | 0\n        }\n        GetZIndex() {\n            this._layer._UpdateZIndices();\n            return this._zIndex\n        }\n        _GetLastCachedZIndex() {\n            return this._zIndex\n        }\n        _SetFlag(bit, enable) {\n            if (enable)\n                this._flags |= bit;\n            else\n                this._flags &= ~bit\n        }\n        IsVisible() {\n            return (this._flags & FLAG_IS_VISIBLE) !== 0\n        }\n        SetVisible(v) {\n            this._SetFlag(FLAG_IS_VISIBLE, v)\n        }\n        IsCollisionEnabled() {\n            return (this._flags & FLAG_COLLISION_ENABLED) !== 0\n        }\n        SetCollisionEnabled(e) {\n            e = !!e;\n            if (this.IsCollisionEnabled() === e)\n                return;\n            this._SetFlag(FLAG_COLLISION_ENABLED, e);\n            if (e)\n                this.SetBboxChanged();\n            else\n                this._RemoveFromCollisionCells()\n        }\n        SetSolidCollisionFilter(isInclusive, tags) {\n            this._SetFlag(FLAG_SOLID_FILTER_INCLUSIVE, isInclusive);\n            if (this._solidFilterTags)\n                this._solidFilterTags.clear();\n            if (!tags.trim()) {\n                this._solidFilterTags = null;\n                return\n            }\n            if (!this._solidFilterTags)\n                this._solidFilterTags = new Set;\n            for (const tag of tags.split(" "))\n                if (tag)\n                    this._solidFilterTags.add(tag.toLowerCase())\n        }\n        IsSolidCollisionAllowed(solidTagSet) {\n            const isInclusive = (this._flags & FLAG_SOLID_FILTER_INCLUSIVE) !== 0;\n            const filterTags = this._solidFilterTags;\n            if (!solidTagSet || !filterTags)\n                return !isInclusive;\n            for (const tag of filterTags)\n                if (solidTagSet.has(tag))\n                    return isInclusive;\n            return !isInclusive\n        }\n        SetBboxChanged() {\n            this._flags |= FLAG_BBOX_CHANGED | FLAG_COLLISION_CELL_CHANGED | FLAG_MESH_CHANGED;\n            this._objectClass._SetAnyCollisionCellChanged(true);\n            this._runtime.UpdateRender();\n            if (this._layer.UsesRenderCells()) {\n                this.CalculateBbox(this._boundingBox, this._boundingQuad, true);\n                this._flags &= ~FLAG_BBOX_CHANGED;\n                this._UpdateRenderCell()\n            }\n            if ((this._flags & FLAG_ENABLE_BBOX_CHANGED_EVENT) !== 0)\n                this._inst.Dispatcher().dispatchEvent(bboxChangeEvent);\n            if (this._sceneGraphInfo !== null) {\n                const children = this._sceneGraphInfo.GetChildren();\n                for (let i = 0, len = children.length; i < len; ++i)\n                    children[i].SetBboxChanged()\n            }\n        }\n        CalculateBbox(bbox, bquad, includeMesh) {\n            const x = this.GetX();\n            const y = this.GetY();\n            const w = this.GetWidth();\n            const h = this.GetHeight();\n            const a = this.GetAngle();\n            bbox.setWH(x - this._ox * w, y - this._oy * h, w, h);\n            if (includeMesh && this.HasMesh())\n                this._ExpandBboxForMesh(bbox);\n            if (a === 0)\n                bquad.setFromRect(bbox);\n            else {\n                bbox.offset(-x, -y);\n                bquad.setFromRotatedRectPrecalc(bbox, this.GetSinAngle(), this.GetCosAngle());\n                bquad.offset(x, y);\n                bquad.getBoundingBox(bbox)\n            }\n            bbox.normalize()\n        }\n        _UpdateBbox() {\n            const flags = this._flags;\n            if ((flags & FLAG_BBOX_CHANGED) !== 0) {\n                this.CalculateBbox(this._boundingBox, this._boundingQuad, true);\n                this._flags = flags & ~FLAG_BBOX_CHANGED\n            }\n        }\n        GetBoundingBox() {\n            this._UpdateBbox();\n            return this._boundingBox\n        }\n        GetBoundingQuad() {\n            this._UpdateBbox();\n            return this._boundingQuad\n        }\n        PixelRoundQuad(quad) {\n            const x = this.GetX();\n            const y = this.GetY();\n            const ox = Math.round(x) - x;\n            const oy = Math.round(y) - y;\n            if (ox === 0 && oy === 0)\n                return quad;\n            else {\n                tempQuad.copy(quad);\n                tempQuad.offset(ox, oy);\n                return tempQuad\n            }\n        }\n        OverwriteBoundingBox(box) {\n            this._boundingBox.copy(box);\n            this._boundingQuad.setFromRect(this._boundingBox);\n            this._flags &= ~FLAG_BBOX_CHANGED;\n            this._UpdateCollisionCell();\n            this._UpdateRenderCell()\n        }\n        SetBboxChangeEventEnabled(e) {\n            this._SetFlag(FLAG_ENABLE_BBOX_CHANGED_EVENT, e)\n        }\n        IsBboxChangeEventEnabled() {\n            return (this._flags & FLAG_ENABLE_BBOX_CHANGED_EVENT) !== 0\n        }\n        IsInViewport(viewport, hasVanishingPointOutsideViewport, isOrthographic) {\n            if (hasVanishingPointOutsideViewport && this.GetDepth() !== 0)\n                return this.IsInViewport3D(this.GetLayer()._GetViewFrustum());\n            else\n                return this.GetZElevation() === 0 || isOrthographic ? viewport.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated()\n        }\n        _IsInViewport_ZElevated() {\n            const layer = this.GetLayer();\n            const totalZElevation = this.GetTotalZElevation();\n            if (totalZElevation >= layer.GetCameraZ())\n                return false;\n            layer.GetViewportForZ(totalZElevation, tempRect);\n            return tempRect.intersectsRect(this.GetBoundingBox())\n        }\n        IsInViewport3D(viewFrustum) {\n            const bbox = this.GetBoundingBox();\n            const minX = bbox.getLeft();\n            const maxX = bbox.getRight();\n            const minY = bbox.getTop();\n            const maxY = bbox.getBottom();\n            const minZ = this.GetTotalZElevation();\n            const maxZ = minZ + this.GetDepth();\n            return viewFrustum.ContainsAABB(minX, minY, minZ, maxX, maxY, maxZ)\n        }\n        _SetDrawBackFaceOnly(e) {\n            this._SetFlag(FLAG_DRAW_BACK_FACE_ONLY, e)\n        }\n        _SetDrawNonBackFacesOnly(e) {\n            this._SetFlag(FLAG_DRAW_NON_BACK_FACES_ONLY, e)\n        }\n        IsDrawBackFaceOnly() {\n            return (this._flags & FLAG_DRAW_BACK_FACE_ONLY) !== 0\n        }\n        IsDrawNonBackFacesOnly() {\n            return (this._flags & FLAG_DRAW_NON_BACK_FACES_ONLY) !== 0\n        }\n        SetSourceCollisionPoly(poly) {\n            this._sourceCollisionPoly = poly;\n            this._DiscardTransformedCollisionPoly();\n            if (this.HasMesh())\n                this._meshInfo.meshPoly = null\n        }\n        GetSourceCollisionPoly() {\n            return this._sourceCollisionPoly\n        }\n        HasOwnCollisionPoly() {\n            return this._sourceCollisionPoly !== null || this.HasMesh()\n        }\n        GetTransformedCollisionPoly() {\n            return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle())\n        }\n        GetCustomTransformedCollisionPoly(w, h, a) {\n            let sina = 0;\n            let cosa = 1;\n            if (a !== 0) {\n                sina = Math.sin(a);\n                cosa = Math.cos(a)\n            }\n            return this._GetCustomTransformedCollisionPolyPrecalc(w, h, a, sina, cosa)\n        }\n        _GetCustomTransformedCollisionPolyPrecalc(w, h, a, sinA, cosA) {\n            let tpi = this._transformedPolyInfo;\n            if (tpi === null) {\n                tpi = {\n                    poly: C3.New(C3.CollisionPoly),\n                    width: NaN,\n                    height: NaN,\n                    angle: NaN\n                };\n                this._transformedPolyInfo = tpi\n            }\n            const transformedPoly = tpi.poly;\n            if (tpi.width === w && tpi.height === h && tpi.angle === a)\n                return transformedPoly;\n            const sourcePoly = this._sourceCollisionPoly;\n            if (this.HasMesh()) {\n                const ox = this.GetOriginX();\n                const oy = this.GetOriginY();\n                const sourceMesh = this.GetSourceMesh();\n                let meshPoly = this._meshInfo.meshPoly;\n                if (!meshPoly) {\n                    if (sourcePoly) {\n                        tempCollisionPoly.copy(sourcePoly);\n                        tempCollisionPoly.offset(ox, oy)\n                    } else\n                        tempCollisionPoly.setDefaultPoints();\n                    meshPoly = sourceMesh.InsertPolyMeshVertices(tempCollisionPoly);\n                    this._meshInfo.meshPoly = meshPoly\n                }\n                sourceMesh.TransformCollisionPoly(meshPoly, transformedPoly);\n                transformedPoly.offset(-ox, -oy);\n                transformedPoly.transformPrecalc(w, h, sinA, cosA)\n            } else if (sourcePoly) {\n                transformedPoly.copy(sourcePoly);\n                transformedPoly.transformPrecalc(w, h, sinA, cosA)\n            } else\n                transformedPoly.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY());\n            tpi.width = w;\n            tpi.height = h;\n            tpi.angle = a;\n            return transformedPoly\n        }\n        _DiscardTransformedCollisionPoly() {\n            this.SetPhysicsBodyChanged(true);\n            const tpi = this._transformedPolyInfo;\n            if (tpi === null)\n                return;\n            tpi.width = NaN\n        }\n        CreateMesh(hsize, vsize) {\n            hsize = Math.floor(hsize);\n            vsize = Math.floor(vsize);\n            if (!this.GetInstance().GetPlugin().SupportsMesh())\n                throw new Error("object does not support mesh");\n            this.ReleaseMesh();\n            this._meshInfo = {\n                sourceMesh: C3.New(C3.Gfx.Mesh, hsize, vsize),\n                transformedMesh: C3.New(C3.Gfx.Mesh, hsize, vsize),\n                meshPoly: null\n            }\n        }\n        HasMesh() {\n            return this._meshInfo !== null\n        }\n        GetSourceMesh() {\n            if (!this.HasMesh())\n                throw new Error("no mesh");\n            return this._meshInfo.sourceMesh\n        }\n        GetTransformedMesh() {\n            if (!this.HasMesh())\n                throw new Error("no mesh");\n            return this._meshInfo.transformedMesh\n        }\n        SetMeshChanged(e) {\n            this._SetFlag(FLAG_MESH_CHANGED, e)\n        }\n        IsMeshChanged() {\n            return (this._flags & FLAG_MESH_CHANGED) !== 0\n        }\n        SetPhysicsBodyChanged(e) {\n            this._SetFlag(FLAG_PHYSICS_BODY_CHANGED, e)\n        }\n        IsPhysicsBodyChanged() {\n            return (this._flags & FLAG_PHYSICS_BODY_CHANGED) !== 0\n        }\n        _ExpandBboxForMesh(bbox) {\n            const sourceMesh = this._meshInfo.sourceMesh;\n            const minX = Math.min(sourceMesh.GetMinX(), 0);\n            const minY = Math.min(sourceMesh.GetMinY(), 0);\n            const maxX = Math.max(sourceMesh.GetMaxX(), 1);\n            const maxY = Math.max(sourceMesh.GetMaxY(), 1);\n            const w = bbox.width();\n            const h = bbox.height();\n            bbox.offsetLeft(minX * w);\n            bbox.offsetTop(minY * h);\n            bbox.offsetRight((maxX - 1) * w);\n            bbox.offsetBottom((maxY - 1) * h);\n            this._depth = sourceMesh.GetMaxZ()\n        }\n        ReleaseMesh() {\n            if (!this._meshInfo)\n                return;\n            this._meshInfo.sourceMesh.Release();\n            this._meshInfo.transformedMesh.Release();\n            this._meshInfo = null;\n            this._DiscardTransformedCollisionPoly()\n        }\n        SetMeshPoint(col, row, opts) {\n            col = Math.floor(col);\n            row = Math.floor(row);\n            const mode = opts.mode || "absolute";\n            if (!VALID_SET_MESH_POINT_MODES.has(mode))\n                throw new Error("invalid mode");\n            const isRelative = mode === "relative";\n            let posx = opts.x;\n            let posy = opts.y;\n            const zElevation = opts.zElevation;\n            let texu = typeof opts.u === "number" ? opts.u : isRelative ? 0 : -1;\n            let texv = typeof opts.v === "number" ? opts.v : isRelative ? 0 : -1;\n            if (!this.HasMesh())\n                return false;\n            const sourceMesh = this.GetSourceMesh();\n            const p = sourceMesh.GetMeshPointAt(col, row);\n            if (p === null)\n                return false;\n            let ret = false;\n            if (typeof zElevation === "number" && p.GetZElevation() !== zElevation) {\n                p.SetZElevation(zElevation);\n                ret = true\n            }\n            if (isRelative) {\n                posx += col \/ (sourceMesh.GetHSize() - 1);\n                posy += row \/ (sourceMesh.GetVSize() - 1)\n            }\n            if (texu === -1 && !isRelative)\n                texu = p.GetU();\n            else {\n                if (isRelative)\n                    texu += col \/ (sourceMesh.GetHSize() - 1);\n                texu = C3.clamp(texu, 0, 1)\n            }\n            if (texv === -1 && !isRelative)\n                texv = p.GetV();\n            else {\n                if (isRelative)\n                    texv += row \/ (sourceMesh.GetVSize() - 1);\n                texv = C3.clamp(texv, 0, 1)\n            }\n            if (p.GetX() === posx && p.GetY() === posy && p.GetU() === texu && p.GetV() === texv)\n                return ret;\n            p.SetX(posx);\n            p.SetY(posy);\n            p.SetU(texu);\n            p.SetV(texv);\n            this._DiscardTransformedCollisionPoly();\n            return true\n        }\n        HasTilemap() {\n            return this._inst.HasTilemap()\n        }\n        ContainsPoint(x, y) {\n            if (!this.GetBoundingBox().containsPoint(x, y))\n                return false;\n            if (!this.GetBoundingQuad().containsPoint(x, y))\n                return false;\n            if (this.HasTilemap())\n                return this._inst.GetSdkInstance().TestPointOverlapTile(x, y);\n            if (!this.HasOwnCollisionPoly())\n                return true;\n            return this.GetTransformedCollisionPoly().containsPoint(x - this.GetX(), y - this.GetY())\n        }\n        _IsCollisionCellChanged() {\n            return (this._flags & FLAG_COLLISION_CELL_CHANGED) !== 0\n        }\n        _UpdateCollisionCell() {\n            if (!this._IsCollisionCellChanged() || !this.IsCollisionEnabled() || (this._flags & FLAG_DESTROYED) !== 0)\n                return;\n            const bbox = this.GetBoundingBox();\n            const grid = this._objectClass._GetCollisionCellGrid();\n            const collisionCells = this._collisionCells;\n            tempRect.set(grid.XToCell(bbox.getLeft()), grid.YToCell(bbox.getTop()), grid.XToCell(bbox.getRight()), grid.YToCell(bbox.getBottom()));\n            if (collisionCells.equals(tempRect))\n                return;\n            const inst = this._inst;\n            if (collisionCells === DEFAULT_COLLISION_CELLS) {\n                grid.Update(inst, null, tempRect);\n                this._collisionCells = C3.New(C3.Rect, tempRect)\n            } else {\n                grid.Update(inst, collisionCells, tempRect);\n                collisionCells.copy(tempRect)\n            }\n            this._flags &= ~FLAG_COLLISION_CELL_CHANGED\n        }\n        _RemoveFromCollisionCells() {\n            const collisionCells = this._collisionCells;\n            if (collisionCells === DEFAULT_COLLISION_CELLS)\n                return;\n            this._objectClass._GetCollisionCellGrid().Update(this._inst, collisionCells, null);\n            this._collisionCells = DEFAULT_COLLISION_CELLS\n        }\n        _UpdateRenderCell() {\n            const layer = this.GetLayer();\n            if (!layer.UsesRenderCells() || (this._flags & FLAG_DESTROYED) !== 0)\n                return;\n            const renderGrid = layer.GetRenderGrid();\n            const bbox = this.GetBoundingBox();\n            const renderCells = this._renderCells;\n            tempRect.set(renderGrid.XToCell(bbox.getLeft()), renderGrid.YToCell(bbox.getTop()), renderGrid.XToCell(bbox.getRight()), renderGrid.YToCell(bbox.getBottom()));\n            if (renderCells.equals(tempRect))\n                return;\n            const inst = this._inst;\n            if (renderCells === DEFAULT_RENDER_CELLS) {\n                renderGrid.Update(inst, null, tempRect);\n                this._renderCells = C3.New(C3.Rect, tempRect)\n            } else {\n                renderGrid.Update(inst, renderCells, tempRect);\n                renderCells.copy(tempRect)\n            }\n            layer.SetRenderListStale()\n        }\n        _RemoveFromRenderCells() {\n            const renderCells = this._renderCells;\n            if (renderCells === DEFAULT_RENDER_CELLS)\n                return;\n            this.GetLayer().GetRenderGrid().Update(this._inst, renderCells, null);\n            this._renderCells = DEFAULT_RENDER_CELLS\n        }\n        GetRenderCellRange() {\n            return this._renderCells\n        }\n        ZOrderMoveToTop() {\n            const inst = this._inst;\n            const layer = this._layer;\n            const layerInstances = layer._GetInstances();\n            if (layerInstances.length && layerInstances.at(-1) === inst)\n                return;\n            layer._RemoveInstance(inst, false);\n            layer._AddInstance(inst, false);\n            this._runtime.UpdateRender()\n        }\n        ZOrderMoveToBottom() {\n            const inst = this._inst;\n            const layer = this._layer;\n            const layerInstances = layer._GetInstances();\n            if (layerInstances.length && layerInstances[0] === inst)\n                return;\n            layer._RemoveInstance(inst, false);\n            layer._PrependInstance(inst, false);\n            this._runtime.UpdateRender()\n        }\n        ZOrderMoveToLayer(layerMove) {\n            const inst = this._inst;\n            const curLayer = this._layer;\n            if (curLayer.GetLayout() !== layerMove.GetLayout())\n                throw new Error("layer from different layout");\n            if (layerMove === curLayer)\n                return;\n            curLayer._RemoveInstance(inst, true);\n            this._SetLayer(layerMove);\n            layerMove._AddInstance(inst, true);\n            this._runtime.UpdateRender()\n        }\n        ZOrderMoveAdjacentToInstance(otherInst, isAfter) {\n            const inst = this._inst;\n            let didChangeLayer = false;\n            const curLayer = this._layer;\n            if (otherInst.GetUID() === inst.GetUID())\n                return;\n            const otherWi = otherInst.GetWorldInfo();\n            if (!otherWi)\n                throw new Error("expected world instance");\n            const otherLayer = otherWi.GetLayer();\n            if (curLayer.GetIndex() !== otherLayer.GetIndex()) {\n                curLayer._RemoveInstance(inst, true);\n                this._SetLayer(otherLayer);\n                otherLayer._AddInstance(inst, true);\n                didChangeLayer = true\n            }\n            const didChangeZOrder = otherLayer.MoveInstanceAdjacent(inst, otherInst, !!isAfter);\n            if (didChangeLayer || didChangeZOrder)\n                this._runtime.UpdateRender()\n        }\n        GetInstanceEffectList() {\n            return this._instanceEffectList\n        }\n        _SetHasAnyActiveEffect(e) {\n            this._SetFlag(FLAG_HAS_ANY_ACTIVE_EFFECT, e)\n        }\n        HasAnyActiveEffect() {\n            return (this._flags & FLAG_HAS_ANY_ACTIVE_EFFECT) !== 0\n        }\n        _SaveToJson(mode) {\n            const o = {\n                "x": this.GetX(),\n                "y": this.GetY(),\n                "w": this.GetWidth(),\n                "h": this.GetHeight(),\n                "l": this.GetLayer().GetSID(),\n                "zi": this.GetZIndex()\n            };\n            if (this.GetZElevation() !== 0)\n                o["ze"] = this.GetZElevation();\n            if (this.GetAngle() !== 0)\n                o["a"] = this.GetAngle();\n            if (!this.HasDefaultColor())\n                o["c"] = this._color.toJSON();\n            if (this.GetOriginX() !== .5)\n                o["oX"] = this.GetOriginX();\n            if (this.GetOriginY() !== .5)\n                o["oY"] = this.GetOriginY();\n            if (this.GetBlendMode() !== 0)\n                o["bm"] = this.GetBlendMode();\n            if (!this.IsVisible())\n                o["v"] = this.IsVisible();\n            if (!this.IsCollisionEnabled())\n                o["ce"] = this.IsCollisionEnabled();\n            if (this.IsBboxChangeEventEnabled())\n                o["be"] = this.IsBboxChangeEventEnabled();\n            if (this._instanceEffectList)\n                o["fx"] = this._instanceEffectList._SaveToJson();\n            const isSolidFilterInclusive = (this._flags & FLAG_SOLID_FILTER_INCLUSIVE) !== 0;\n            if (isSolidFilterInclusive)\n                o["sfi"] = isSolidFilterInclusive;\n            if (this._solidFilterTags)\n                o["sft"] = [...this._solidFilterTags].join(" ");\n            if (this._sceneGraphInfo && mode !== "visual-state") {\n                o["sgi"] = this._sceneGraphInfo._SaveToJson(mode);\n                if (sceneGraphExportDataMap.has(this)) {\n                    o["sgcd"] = sceneGraphExportDataMap.get(this).childrenData;\n                    o["sgzid"] = sceneGraphExportDataMap.get(this).zIndexData\n                }\n            }\n            if (this.HasMesh())\n                o["mesh"] = this.GetSourceMesh().SaveToJson();\n            return o\n        }\n        _SaveSceneGraphPropertiesToJson() {\n            return {\n                "x": this._x,\n                "y": this._y,\n                "z": this._zElevation,\n                "w": this._w,\n                "h": this._h,\n                "a": this._a,\n                "sa": this._sinA,\n                "ca": this._cosA\n            }\n        }\n        _LoadSceneGraphPropertiesFromJson(o) {\n            if (!o)\n                return;\n            this._x = o["x"];\n            this._y = o["y"];\n            this._zElevation = o["z"];\n            this._w = o["w"];\n            this._h = o["h"];\n            this._a = o["a"];\n            this._sinA = o["sa"];\n            this._cosA = o["ca"];\n            this.SetBboxChanged()\n        }\n        _OnBeforeLoad(mode) {\n            if (mode !== "visual-state")\n                this._ResetAllSceneGraphState()\n        }\n        _LoadFromJson(o, mode) {\n            enableUpdateRendererStateGroup = false;\n            this.SetX(o["x"]);\n            this.SetY(o["y"]);\n            this.SetWidth(o["w"]);\n            this.SetHeight(o["h"]);\n            this._SetZIndex(o["zi"]);\n            this.SetZElevation(o.hasOwnProperty("ze") ? o["ze"] : 0);\n            this.SetAngle(o.hasOwnProperty("a") ? o["a"] : 0);\n            if (o.hasOwnProperty("c"))\n                tempColor.setFromJSON(o["c"]);\n            else if (o.hasOwnProperty("o")) {\n                tempColor.copyRgb(this._color);\n                tempColor.a = o["o"]\n            } else\n                tempColor.setRgba(1, 1, 1, 1);\n            this._SetColor(tempColor);\n            this.SetOriginX(o.hasOwnProperty("oX") ? o["oX"] : .5);\n            this.SetOriginY(o.hasOwnProperty("oY") ? o["oY"] : .5);\n            this.SetBlendMode(o.hasOwnProperty("bm") ? o["bm"] : 0);\n            this.SetVisible(o.hasOwnProperty("v") ? o["v"] : true);\n            this.SetCollisionEnabled(o.hasOwnProperty("ce") ? o["ce"] : true);\n            this.SetBboxChangeEventEnabled(o.hasOwnProperty("be") ? o["be"] : false);\n            this.SetSolidCollisionFilter(o.hasOwnProperty("sfi") ? o["sfi"] : false, o.hasOwnProperty("sft") ? o["sft"] : "");\n            if (this._instanceEffectList && o.hasOwnProperty("fx"))\n                this._instanceEffectList._LoadFromJson(o["fx"]);\n            if (o.hasOwnProperty("sgi") && mode !== "visual-state") {\n                this._CreateSceneGraphInfo(null);\n                const sgi = this._sceneGraphInfo;\n                const sgiData = o["sgi"];\n                sgi._LoadFromJson(sgiData);\n                const runtimeDispatcher = this.GetRuntime().Dispatcher();\n                const onAfterLoad = (e, opts) => {\n                    runtimeDispatcher.removeEventListener("afterload", onAfterLoad);\n                    runtimeDispatcher.removeEventListener("afterloadinstance", onAfterLoadInstance);\n                    if ((this._flags & FLAG_DESTROYED) === 0)\n                        sgi._OnAfterLoad(sgiData, opts)\n                }\n                ;\n                const onAfterLoadInstance = e => {\n                    if (e["instance"] !== this.GetInstance())\n                        return;\n                    onAfterLoad(e, {\n                        ignoreMissingInstances: true\n                    })\n                }\n                ;\n                runtimeDispatcher.addEventListener("afterload", onAfterLoad);\n                runtimeDispatcher.addEventListener("afterloadinstance", onAfterLoadInstance);\n                if (o["sgcd"] && C3.IsFiniteNumber(o["sgzid"]))\n                    sceneGraphExportDataMap.set(this, {\n                        childrenData: o["sgcd"],\n                        zIndexData: o["sgzid"]\n                    })\n            }\n            if (o.hasOwnProperty("mesh")) {\n                const meshData = o["mesh"];\n                this.CreateMesh(meshData["cols"], meshData["rows"]);\n                this.GetSourceMesh().LoadFromJson(meshData)\n            } else\n                this.ReleaseMesh();\n            this.SetBboxChanged();\n            enableUpdateRendererStateGroup = true;\n            this._UpdateRendererStateGroup()\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/behaviorType.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.BehaviorType = class BehaviorType extends C3.DefendedBase {\n        constructor(objectClass, data) {\n            super();\n            const runtime = objectClass.GetRuntime();\n            const pluginManager = runtime.GetPluginManager();\n            const BehaviorCtor = runtime.GetObjectReference(data[1]);\n            if (!pluginManager.HasBehaviorByConstructorFunction(BehaviorCtor))\n                pluginManager.CreateBehavior(data);\n            this._runtime = runtime;\n            this._objectClass = objectClass;\n            this._behavior = pluginManager.GetBehaviorByConstructorFunction(BehaviorCtor);\n            this._sdkType = null;\n            this._instSdkCtor = BehaviorCtor.Instance;\n            this._sid = data[2];\n            this._name = data[0];\n            this._jsPropName = this._runtime.GetJsPropName(data[3]);\n            this._sdkType = C3.New(BehaviorCtor.Type, this);\n            this.OnCreate()\n        }\n        static Create(objectClass, behaviorTypeData) {\n            return C3.New(C3.BehaviorType, objectClass, behaviorTypeData)\n        }\n        Release() {\n            this._runtime = null;\n            this._behavior = null;\n            this._sdkType.Release();\n            this._sdkType = null;\n            this._instSdkCtor = null\n        }\n        GetSdkType() {\n            return this._sdkType\n        }\n        OnCreate() {\n            this._sdkType.OnCreate()\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetObjectClass() {\n            return this._objectClass\n        }\n        GetBehavior() {\n            return this._behavior\n        }\n        GetInstanceSdkCtor() {\n            return this._instSdkCtor\n        }\n        GetName() {\n            return this._name\n        }\n        GetSID() {\n            return this._sid\n        }\n        GetJsPropName() {\n            return this._jsPropName\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/behaviorInstance.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const IBehaviorInstance = self.IBehaviorInstance;\n    C3.BehaviorInstance = class BehaviorInstance extends C3.DefendedBase {\n        constructor(opts) {\n            super();\n            this._runtime = opts.runtime;\n            this._behaviorType = opts.behaviorType;\n            this._behavior = this._behaviorType.GetBehavior();\n            this._inst = opts.instance;\n            this._index = opts.index;\n            this._sdkInst = null;\n            this._iScriptInterface = null;\n            this._behavior._AddInstance(this._inst)\n        }\n        Release() {\n            if (this._iScriptInterface) {\n                this._iScriptInterface._Release();\n                this._iScriptInterface = null\n            }\n            this._behavior._RemoveInstance(this._inst);\n            this._sdkInst.Release();\n            this._sdkInst = null;\n            this._iScriptInterface = null;\n            this._runtime = null;\n            this._behaviorType = null;\n            this._behavior = null;\n            this._inst = null\n        }\n        _CreateSdkInstance(properties) {\n            if (this._sdkInst)\n                throw new Error("already got sdk instance");\n            this._sdkInst = C3.New(this._behaviorType.GetInstanceSdkCtor(), this, properties);\n            this._InitScriptInterface()\n        }\n        GetSdkInstance() {\n            return this._sdkInst\n        }\n        GetObjectInstance() {\n            return this._inst\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetBehaviorType() {\n            return this._behaviorType\n        }\n        GetBehavior() {\n            return this._behavior\n        }\n        _GetIndex() {\n            return this._index\n        }\n        PostCreate() {\n            this._sdkInst.PostCreate()\n        }\n        OnSpriteFrameChanged(prevFrame, nextFrame) {\n            this._sdkInst.OnSpriteFrameChanged(prevFrame, nextFrame)\n        }\n        _GetDebuggerProperties() {\n            return this._sdkInst.GetDebuggerProperties()\n        }\n        SaveToJson() {\n            return this._sdkInst.SaveToJson()\n        }\n        LoadFromJson(o) {\n            return this._sdkInst.LoadFromJson(o)\n        }\n        static SortByTickSequence(a, b) {\n            const instA = a.GetObjectInstance();\n            const instB = b.GetObjectInstance();\n            const typeIndexA = instA.GetObjectClass().GetIndex();\n            const typeIndexB = instB.GetObjectClass().GetIndex();\n            if (typeIndexA !== typeIndexB)\n                return typeIndexA - typeIndexB;\n            const seqA = instA.GetPUID();\n            const seqB = instB.GetPUID();\n            if (seqA !== seqB)\n                return seqA - seqB;\n            return a.GetBehaviorInstance()._GetIndex() - b.GetBehaviorInstance()._GetIndex()\n        }\n        _InitScriptInterface() {\n            const DefaultScriptClass = IBehaviorInstance;\n            const SdkScriptClass = this._sdkInst.GetScriptInterfaceClass();\n            const ScriptInterfaceClass = SdkScriptClass || DefaultScriptClass;\n            IBehaviorInstance._Init(this);\n            this._iScriptInterface = new ScriptInterfaceClass;\n            IBehaviorInstance._Init(null);\n            if (SdkScriptClass && !(this._iScriptInterface instanceof DefaultScriptClass))\n                throw new TypeError(`script interface class \'${SdkScriptClass.name}\' does not extend the right base class \'${DefaultScriptClass.name}\'`);\n        }\n        GetScriptInterface() {\n            return this._iScriptInterface\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/effectList.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.EffectList = class EffectList extends C3.DefendedBase {\n        constructor(owner, data) {\n            super();\n            this._owner = owner;\n            this._allEffectTypes = [];\n            this._activeEffectTypes = [];\n            this._effectTypesByName = new Map;\n            this._effectParams = [];\n            this._effectParamBuffers = [];\n            this._preservesOpaqueness = true;\n            for (const d of data) {\n                const et = C3.New(C3.EffectType, this, d, this._allEffectTypes.length);\n                this._allEffectTypes.push(et);\n                this._effectTypesByName.set(et.GetName().toLowerCase(), et);\n                if (d.length >= 3)\n                    this._effectParams.push(this._LoadSingleEffectParameters(et, d[2]))\n            }\n            this.GetRuntime()._AddEffectList(this)\n        }\n        Release() {\n            for (const cpb of this._effectParamBuffers)\n                cpb.Release();\n            C3.clearArray(this._effectParamBuffers);\n            C3.clearArray(this._allEffectTypes);\n            C3.clearArray(this._activeEffectTypes);\n            this._effectTypesByName.clear();\n            C3.clearArray(this._effectParams);\n            this._owner = null\n        }\n        _InitRenderer(renderer) {\n            if (renderer.IsWebGPU()) {\n                this._effectParamBuffers = this._allEffectTypes.map(et => {\n                    const shaderProgram = et.GetShaderProgram();\n                    if (shaderProgram.GetCustomParametersByteSize() > 0)\n                        return C3.New(C3.Gfx.WebGPUEffectCustomParamsBuffer, shaderProgram);\n                    else\n                        return null\n                }\n                );\n                this._UpdateAllEffectParamBuffers()\n            }\n        }\n        PrependEffectTypes(arr) {\n            if (!arr.length)\n                return;\n            this._allEffectTypes = arr.concat(this._allEffectTypes);\n            for (const et of arr)\n                this._effectTypesByName.set(et.GetName().toLowerCase(), et);\n            for (let i = 0, len = this._allEffectTypes.length; i < len; ++i)\n                this._allEffectTypes[i]._SetIndex(i)\n        }\n        _LoadSingleEffectParameters(effectType, arr) {\n            effectType.SetActive(arr[0]);\n            const ret = arr.slice(1);\n            for (let i = 0, len = ret.length; i < len; ++i) {\n                const p = ret[i];\n                if (Array.isArray(p)) {\n                    const c = C3.New(C3.Color);\n                    c.setFromJSON(p);\n                    ret[i] = c\n                }\n            }\n            return ret\n        }\n        GetOwner() {\n            return this._owner\n        }\n        GetRuntime() {\n            return this._owner.GetRuntime()\n        }\n        UpdateActiveEffects() {\n            C3.clearArray(this._activeEffectTypes);\n            let preservesOpaqueness = true;\n            for (const et of this._allEffectTypes)\n                if (et.IsActive()) {\n                    this._activeEffectTypes.push(et);\n                    if (!et.GetShaderProgram().PreservesOpaqueness())\n                        preservesOpaqueness = false\n                }\n            this._preservesOpaqueness = preservesOpaqueness\n        }\n        GetAllEffectTypes() {\n            return this._allEffectTypes\n        }\n        HasAnyEffectType() {\n            return this._allEffectTypes.length > 0\n        }\n        GetEffectTypeByName(name) {\n            return this._effectTypesByName.get(name.toLowerCase()) || null\n        }\n        GetEffectTypeByIndex(index) {\n            index = Math.floor(+index);\n            if (index < 0 || index >= this._allEffectTypes.length)\n                throw new RangeError("invalid effect type index");\n            return this._allEffectTypes[index]\n        }\n        IsEffectIndexActive(index) {\n            return this.GetEffectTypeByIndex(index).IsActive()\n        }\n        SetEffectIndexActive(index, a) {\n            this.GetEffectTypeByIndex(index).SetActive(a)\n        }\n        GetActiveEffectTypes() {\n            return this._activeEffectTypes\n        }\n        HasAnyActiveEffect() {\n            return this._activeEffectTypes.length > 0\n        }\n        PreservesOpaqueness() {\n            return this._preservesOpaqueness\n        }\n        GetEffectParametersForIndex(index) {\n            return this._effectParams[index]\n        }\n        _GetEffectChainShaderParametersForIndex(index) {\n            if (index < this._effectParamBuffers.length)\n                return this._effectParamBuffers[index];\n            else\n                return this._effectParams[index]\n        }\n        GetEffectParameter(effectIndex, paramIndex) {\n            if (effectIndex < 0 || effectIndex >= this._effectParams.length)\n                return null;\n            const effectParams = this._effectParams[effectIndex];\n            if (paramIndex < 0 || paramIndex >= effectParams.length)\n                return null;\n            return effectParams[paramIndex]\n        }\n        SetEffectParameter(effectIndex, paramIndex, value) {\n            if (effectIndex < 0 || effectIndex >= this._effectParams.length)\n                return false;\n            const effectParams = this._effectParams[effectIndex];\n            if (paramIndex < 0 || paramIndex >= effectParams.length)\n                return false;\n            const oldValue = effectParams[paramIndex];\n            if (oldValue instanceof C3.Color) {\n                if (oldValue.equalsIgnoringAlpha(value))\n                    return false;\n                oldValue.copyRgb(value)\n            } else {\n                if (oldValue === value)\n                    return false;\n                effectParams[paramIndex] = value\n            }\n            if (effectIndex < this._effectParamBuffers.length)\n                this._effectParamBuffers[effectIndex].SetParameterValue(paramIndex, value);\n            return true\n        }\n        _UpdateAllEffectParamBuffers() {\n            const effectParams = this._effectParams;\n            const effectParamBuffers = this._effectParamBuffers;\n            for (let i = 0, len = Math.min(effectParams.length, effectParamBuffers.length); i < len; ++i) {\n                const paramsBuf = effectParamBuffers[i];\n                const params = effectParams[i];\n                for (let j = 0, lenj = params.length; j < lenj; ++j)\n                    paramsBuf.SetParameterValue(j, params[j])\n            }\n        }\n        static SaveFxParamToJson(param) {\n            if (param && param instanceof C3.Color)\n                return {\n                    "t": "color",\n                    "v": param.toJSON()\n                };\n            else\n                return param\n        }\n        static LoadFxParamFromJson(o) {\n            if (o === null)\n                return NaN;\n            else if (typeof o === "object") {\n                const type = o["t"];\n                if (type === "color") {\n                    const color = C3.New(C3.Color);\n                    color.setFromJSON(o["v"]);\n                    return color\n                } else\n                    throw new Error("invalid effect parameter type");\n            } else\n                return o\n        }\n        static SaveFxParamsToJson(params) {\n            return params.map(C3.EffectList.SaveFxParamToJson)\n        }\n        static LoadFxParamsFromJson(arr) {\n            return arr.map(C3.EffectList.LoadFxParamFromJson)\n        }\n        SaveToJson() {\n            return this._allEffectTypes.map(et => ({\n                "name": et.GetName(),\n                "active": et.IsActive(),\n                "params": C3.EffectList.SaveFxParamsToJson(this._effectParams[et.GetIndex()])\n            }))\n        }\n        LoadFromJson(arr) {\n            for (const o of arr) {\n                const et = this.GetEffectTypeByName(o["name"]);\n                if (!et)\n                    continue;\n                et.SetActive(o["active"]);\n                this._effectParams[et.GetIndex()] = C3.EffectList.LoadFxParamsFromJson(o["params"])\n            }\n            this.UpdateActiveEffects();\n            this._UpdateAllEffectParamBuffers()\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/effectType.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.EffectType = class EffectType extends C3.DefendedBase {\n        constructor(effectList, data, index) {\n            super();\n            this._effectList = effectList;\n            this._id = data[0];\n            this._name = data[1];\n            this._index = index;\n            this._shaderProgram = null;\n            this._isActive = true\n        }\n        Release() {\n            this._effectList = null;\n            this._shaderProgram = null\n        }\n        Clone(effectListOwner) {\n            const ret = C3.New(C3.EffectType, effectListOwner, [this._id, this._name], -1);\n            ret._shaderProgram = this._shaderProgram;\n            ret._isActive = this._isActive;\n            return ret\n        }\n        _InitRenderer(renderer) {\n            const shaderProgram = renderer.GetShaderProgramByName(this._id);\n            if (!shaderProgram)\n                throw new Error("failed to find shader program \'" + this._id + "\'");\n            this._shaderProgram = shaderProgram\n        }\n        GetEffectList() {\n            return this._effectList\n        }\n        GetName() {\n            return this._name\n        }\n        _SetIndex(i) {\n            this._index = i\n        }\n        GetIndex() {\n            return this._index\n        }\n        GetOwner() {\n            return this._effectList.GetOwner()\n        }\n        GetRuntime() {\n            return this._effectList.GetRuntime()\n        }\n        SetActive(a) {\n            this._isActive = !!a\n        }\n        IsActive() {\n            return this._isActive\n        }\n        GetShaderProgram() {\n            return this._shaderProgram\n        }\n        GetDefaultParameterValues() {\n            const ret = [];\n            for (let i = 0, len = this._shaderProgram.GetParameterCount(); i < len; ++i) {\n                const type = this._shaderProgram.GetParameterType(i);\n                if (type === "float" || type === "percent")\n                    ret.push(0);\n                else if (type === "color")\n                    ret.push(C3.New(C3.Color, 1, 1, 1, 1));\n                else\n                    throw new TypeError("unknown effect parameter type");\n            }\n            return ret\n        }\n    }\n    ;\n\n}\n\n\/\/ objects\/instanceEffectList.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.InstanceEffectList = class InstanceEffectList extends C3.DefendedBase {\n        constructor(inst, wi) {\n            super();\n            this._inst = inst;\n            this._wi = wi;\n            this._effectList = inst.GetObjectClass().GetEffectList();\n            this._needsRebuildSteps = true;\n            this._wasDefaultColor = true;\n            this._was3D = false;\n            this._wasRotatedOrNegativeSize = false;\n            this._wasTexRotated = false;\n            this._effectChain = C3.New(C3.Gfx.EffectChain, inst.GetRuntime().GetCanvasManager().GetEffectChainManager(), {\n                drawContent: (renderer, effectChain) => {\n                    const inst = effectChain.GetContentObject();\n                    const wi = inst.GetWorldInfo();\n                    renderer.SetColor(wi.GetPremultipliedColor());\n                    renderer.SetCurrentZ(wi.GetTotalZElevation());\n                    inst.Draw(renderer);\n                    renderer.SetCurrentZ(0)\n                }\n                ,\n                getSourceTextureInfo: inst => {\n                    const srcTexRect = inst.GetCurrentTexRect();\n                    const [srcWidth,srcHeight] = inst.GetCurrentSurfaceSize();\n                    return {\n                        srcTexRect,\n                        srcWidth,\n                        srcHeight\n                    }\n                }\n                ,\n                getShaderParameters: index => this._GetEffectChainShaderParametersForIndex(index)\n            });\n            this._activeEffectFlags = [];\n            this._activeEffectTypes = [];\n            this._preservesOpaqueness = true;\n            this._effectParams = [];\n            this._effectParamBuffers = [];\n            if (inst.GetRuntime().GetRenderer().IsWebGPU())\n                this._effectParamBuffers = this._effectList.GetAllEffectTypes().map(et => {\n                    const shaderProgram = et.GetShaderProgram();\n                    if (shaderProgram.GetCustomParametersByteSize() > 0)\n                        return C3.New(C3.Gfx.WebGPUEffectCustomParamsBuffer, shaderProgram);\n                    else\n                        return null\n                }\n                );\n            for (let i = 0, len = this._effectList.GetAllEffectTypes().length; i < len; ++i)\n                this._activeEffectFlags.push(true);\n            this.UpdateActiveEffects()\n        }\n        Release() {\n            for (const cpb of this._effectParamBuffers)\n                cpb.Release();\n            C3.clearArray(this._effectParamBuffers);\n            this._effectChain.Release();\n            this._effectChain = null;\n            C3.clearArray(this._activeEffectFlags);\n            C3.clearArray(this._activeEffectTypes);\n            C3.clearArray(this._effectParams);\n            this._inst = null;\n            this._effectList = null\n        }\n        _LoadEffectParameters(data) {\n            let index = 0;\n            for (const e of data) {\n                this._effectParams.push(this._LoadSingleEffectParameters(index, e));\n                ++index\n            }\n            this._UpdateAllEffectParamBuffers();\n            this.UpdateActiveEffects()\n        }\n        _LoadSingleEffectParameters(index, arr) {\n            this._activeEffectFlags[index] = arr[0];\n            const ret = arr.slice(1);\n            for (let i = 0, len = ret.length; i < len; ++i) {\n                const p = ret[i];\n                if (Array.isArray(p)) {\n                    const c = C3.New(C3.Color);\n                    c.setFromJSON(p);\n                    ret[i] = c\n                }\n            }\n            return ret\n        }\n        LoadDefaultEffectParameters() {\n            for (const effectType of this._effectList.GetAllEffectTypes())\n                this._effectParams.push(effectType.GetDefaultParameterValues());\n            this._UpdateAllEffectParamBuffers()\n        }\n        GetOwner() {\n            return this._owner\n        }\n        GetEffectList() {\n            return this._effectList\n        }\n        GetEffectChain() {\n            this._MaybeRebuildEffectChainSteps();\n            return this._effectChain\n        }\n        GetRuntime() {\n            return this._inst.GetRuntime()\n        }\n        UpdateActiveEffects() {\n            C3.clearArray(this._activeEffectTypes);\n            const wi = this._wi;\n            const allEffectTypes = this._effectList.GetAllEffectTypes();\n            const activeEffectTypes = this._activeEffectTypes;\n            const activeEffectFlags = this._activeEffectFlags;\n            let preservesOpaqueness = true;\n            for (let i = 0, len = allEffectTypes.length; i < len; ++i)\n                if (activeEffectFlags[i]) {\n                    const et = allEffectTypes[i];\n                    activeEffectTypes.push(et);\n                    if (!et.GetShaderProgram().PreservesOpaqueness())\n                        preservesOpaqueness = false\n                }\n            this._preservesOpaqueness = preservesOpaqueness;\n            wi._SetHasAnyActiveEffect(!!activeEffectTypes.length);\n            this._needsRebuildSteps = true\n        }\n        _MaybeRebuildEffectChainSteps() {\n            const inst = this._inst;\n            const wi = this._wi;\n            const isDefaultColor = wi.HasDefaultColor();\n            const is3D = wi.GetDepth() > 0;\n            const isRotatedOrNegativeSizeInstance = wi.GetAngle() !== 0 || wi.GetWidth() < 0 || wi.GetHeight() < 0;\n            const isTexRotated = inst.IsCurrentTexRotated();\n            if (!this._needsRebuildSteps && isDefaultColor === this._wasDefaultColor && is3D === this._was3D && isRotatedOrNegativeSizeInstance === this._wasRotatedOrNegativeSize && isTexRotated === this._wasTexRotated)\n                return;\n            this._effectChain.BuildSteps(this._activeEffectTypes.map(e => e.GetShaderProgram()), {\n                indexMap: this._activeEffectTypes.map(e => e.GetIndex()),\n                forcePreDraw: !isDefaultColor || inst.MustPreDraw(),\n                is3D,\n                isSourceTextureRotated: isTexRotated,\n                isRotatedOrNegativeSizeInstance\n            });\n            this._needsRebuildSteps = false;\n            this._wasDefaultColor = isDefaultColor;\n            this._was3D = is3D;\n            this._wasRotatedOrNegativeSize = isRotatedOrNegativeSizeInstance;\n            this._wasTexRotated = isTexRotated\n        }\n        GetActiveEffectTypes() {\n            return this._activeEffectTypes\n        }\n        GetEffectParametersForIndex(index) {\n            return this._effectParams[index]\n        }\n        _GetEffectChainShaderParametersForIndex(index) {\n            if (index < this._effectParamBuffers.length)\n                return this._effectParamBuffers[index];\n            else\n                return this._effectParams[index]\n        }\n        GetEffectParameter(effectIndex, paramIndex) {\n            if (effectIndex < 0 || effectIndex >= this._effectParams.length)\n                return null;\n            const effectParams = this._effectParams[effectIndex];\n            if (paramIndex < 0 || paramIndex >= effectParams.length)\n                return null;\n            return effectParams[paramIndex]\n        }\n        SetEffectParameter(effectIndex, paramIndex, value) {\n            if (effectIndex < 0 || effectIndex >= this._effectParams.length)\n                return false;\n            const effectParams = this._effectParams[effectIndex];\n            if (paramIndex < 0 || paramIndex >= effectParams.length)\n                return false;\n            const oldValue = effectParams[paramIndex];\n            if (oldValue instanceof C3.Color) {\n                if (oldValue.equalsIgnoringAlpha(value))\n                    return false;\n                oldValue.copyRgb(value)\n            } else {\n                if (oldValue === value)\n                    return false;\n                effectParams[paramIndex] = value\n            }\n            if (effectIndex < this._effectParamBuffers.length)\n                this._effectParamBuffers[effectIndex].SetParameterValue(paramIndex, value);\n            return true\n        }\n        _UpdateAllEffectParamBuffers() {\n            const effectParams = this._effectParams;\n            const effectParamBuffers = this._effectParamBuffers;\n            for (let i = 0, len = effectParamBuffers.length; i < len; ++i) {\n                const paramsBuf = effectParamBuffers[i];\n                const params = effectParams[i];\n                for (let j = 0, lenj = params.length; j < lenj; ++j)\n                    paramsBuf.SetParameterValue(j, params[j])\n            }\n        }\n        PreservesOpaqueness() {\n            return this._preservesOpaqueness\n        }\n        HasAnyActiveBackgroundBlendingEffect() {\n            return this._activeEffectTypes.some(et => et.GetShaderProgram().BlendsBackground())\n        }\n        IsEffectIndexActive(i) {\n            return this._activeEffectFlags[i]\n        }\n        SetEffectIndexActive(i, e) {\n            this._activeEffectFlags[i] = !!e\n        }\n        GetAllEffectTypes() {\n            return this._effectList.GetAllEffectTypes()\n        }\n        _SaveToJson() {\n            return this._effectList.GetAllEffectTypes().map(et => ({\n                "name": et.GetName(),\n                "active": this._activeEffectFlags[et.GetIndex()],\n                "params": C3.EffectList.SaveFxParamsToJson(this._effectParams[et.GetIndex()])\n            }))\n        }\n        _LoadFromJson(arr) {\n            for (const o of arr) {\n                const et = this._effectList.GetEffectTypeByName(o["name"]);\n                if (!et)\n                    continue;\n                this._activeEffectFlags[et.GetIndex()] = o["active"];\n                this._effectParams[et.GetIndex()] = C3.EffectList.LoadFxParamsFromJson(o["params"])\n            }\n            this.UpdateActiveEffects();\n            this._UpdateAllEffectParamBuffers()\n        }\n    }\n    ;\n\n}\n\n\/\/ collisions\/collisionEngine.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const tempCandidates = [];\n    const tileCollRectCandidates = [];\n    const tempJumpthruRet = [];\n    const tempPolyA = C3.New(C3.CollisionPoly);\n    const tempPolyB = C3.New(C3.CollisionPoly);\n    const tempQuad = C3.New(C3.Quad);\n    const tempRect = C3.New(C3.Rect);\n    const tempRect2 = C3.New(C3.Rect);\n    let tempPolyC = null;\n    let tempRect3 = null;\n    let tempQuadB = null;\n    C3.CollisionEngine = class CollisionEngine extends C3.DefendedBase {\n        constructor(runtime) {\n            super();\n            this._runtime = runtime;\n            this._registeredCollisions = [];\n            this._collisionCheckCount = 0;\n            this._collisionCheckSec = 0;\n            this._polyCheckCount = 0;\n            this._polyCheckSec = 0\n        }\n        Release() {\n            this._runtime = null\n        }\n        _Update1sStats() {\n            this._collisionCheckSec = this._collisionCheckCount;\n            this._collisionCheckCount = 0;\n            this._polyCheckSec = this._polyCheckCount;\n            this._polyCheckCount = 0\n        }\n        Get1secCollisionChecks() {\n            return this._collisionCheckSec\n        }\n        Get1secPolyChecks() {\n            return this._polyCheckSec\n        }\n        RegisterCollision(a, b) {\n            const aw = a.GetWorldInfo();\n            const bw = b.GetWorldInfo();\n            if (!aw || !bw)\n                return;\n            if (!aw.IsCollisionEnabled() || !bw.IsCollisionEnabled())\n                return;\n            this._registeredCollisions.push([a, b])\n        }\n        AddRegisteredCollisionCandidates(inst, otherType, arr) {\n            for (const [a,b] of this._registeredCollisions) {\n                let otherInst = null;\n                if (inst === a)\n                    otherInst = b;\n                else if (inst === b)\n                    otherInst = a;\n                else\n                    continue;\n                if (!otherInst.BelongsToObjectClass(otherType))\n                    continue;\n                if (!arr.includes(otherInst))\n                    arr.push(otherInst)\n            }\n        }\n        CheckRegisteredCollision(a, b) {\n            if (!this._registeredCollisions.length)\n                return false;\n            for (const [c,d] of this._registeredCollisions)\n                if (a === c && b === d || a === d && b === c)\n                    return true;\n            return false\n        }\n        ClearRegisteredCollisions() {\n            C3.clearArray(this._registeredCollisions)\n        }\n        TestOverlap(a, b) {\n            if (!a || !b || a === b)\n                return false;\n            const aw = a.GetWorldInfo();\n            const bw = b.GetWorldInfo();\n            if (!aw.IsCollisionEnabled() || !bw.IsCollisionEnabled())\n                return false;\n            this._collisionCheckCount++;\n            const layerA = aw.GetLayer();\n            const layerB = bw.GetLayer();\n            const areLayerTransformsCompatible = layerA.IsTransformCompatibleWith(layerB);\n            if (areLayerTransformsCompatible)\n                return this._TestOverlap_SameLayers(aw, bw);\n            else\n                return this._TestOverlap_DifferentLayers(aw, bw)\n        }\n        _TestOverlap_SameLayers(aw, bw) {\n            if (!aw.GetBoundingBox().intersectsRect(bw.GetBoundingBox()))\n                return false;\n            this._polyCheckCount++;\n            if (!aw.GetBoundingQuad().intersectsQuad(bw.GetBoundingQuad()))\n                return false;\n            if (aw.HasTilemap() && bw.HasTilemap())\n                return false;\n            if (aw.HasTilemap())\n                return this.TestTilemapOverlap(aw, bw);\n            else if (bw.HasTilemap())\n                return this.TestTilemapOverlap(bw, aw);\n            if (!aw.HasOwnCollisionPoly() && !bw.HasOwnCollisionPoly())\n                return true;\n            const polyA = aw.GetTransformedCollisionPoly();\n            const polyB = bw.GetTransformedCollisionPoly();\n            return polyA.intersectsPoly(polyB, bw.GetX() - aw.GetX(), bw.GetY() - aw.GetY())\n        }\n        _TestOverlap_DifferentLayers(aw, bw) {\n            const aIsTileMap = aw.HasTilemap();\n            const bIsTileMap = bw.HasTilemap();\n            if (aIsTileMap && !bIsTileMap)\n                return this.TestTilemapOverlapDifferentLayers(aw, bw);\n            else if (bIsTileMap && !aIsTileMap)\n                return this.TestTilemapOverlapDifferentLayers(bw, aw);\n            else if (!bIsTileMap && !aIsTileMap) {\n                const layerA = aw.GetLayer();\n                const layerB = bw.GetLayer();\n                tempPolyA.copy(aw.GetTransformedCollisionPoly());\n                tempPolyB.copy(bw.GetTransformedCollisionPoly());\n                const ptsArrA = tempPolyA.pointsArr();\n                for (let i = 0, len = ptsArrA.length; i < len; i += 2) {\n                    const j = i + 1;\n                    const x = ptsArrA[i];\n                    const y = ptsArrA[j];\n                    const [lx,ly] = layerA.LayerToCanvasCss(x + aw.GetX(), y + aw.GetY());\n                    ptsArrA[i] = lx;\n                    ptsArrA[j] = ly\n                }\n                const ptsArrB = tempPolyB.pointsArr();\n                for (let i = 0, len = ptsArrB.length; i < len; i += 2) {\n                    const j = i + 1;\n                    const x = ptsArrB[i];\n                    const y = ptsArrB[j];\n                    const [lx,ly] = layerB.LayerToCanvasCss(x + bw.GetX(), y + bw.GetY());\n                    ptsArrB[i] = lx;\n                    ptsArrB[j] = ly\n                }\n                tempPolyA.setBboxChanged();\n                tempPolyB.setBboxChanged();\n                this._polyCheckCount++;\n                return tempPolyA.intersectsPoly(tempPolyB, 0, 0)\n            } else\n                return false\n        }\n        TestTilemapOverlapDifferentLayers(tilemapWi, nonTilemapWi) {\n            const tilemapLayer = tilemapWi.GetLayer();\n            const nonTilemapLayer = nonTilemapWi.GetLayer();\n            if (!tempPolyC)\n                tempPolyC = C3.New(C3.CollisionPoly);\n            if (!tempRect3)\n                tempRect3 = C3.New(C3.Rect);\n            if (!tempQuadB)\n                tempQuadB = C3.New(C3.Quad);\n            const nonTilemapX = nonTilemapWi.GetX();\n            const nonTilemapY = nonTilemapWi.GetY();\n            const [lx,ly] = nonTilemapLayer.LayerToCanvasCss(nonTilemapX, nonTilemapY);\n            const [nonTilemapTransformedX,nonTilemapTransformedY] = tilemapLayer.CanvasCssToLayer(lx, ly);\n            const deltaX = nonTilemapTransformedX - nonTilemapX;\n            const deltaY = nonTilemapTransformedY - nonTilemapY;\n            tempRect3.copy(nonTilemapWi.GetBoundingBox());\n            tempRect3.offset(deltaX, deltaY);\n            if (!tilemapWi.GetBoundingBox().intersectsRect(tempRect3))\n                return false;\n            tempQuadB.copy(nonTilemapWi.GetBoundingQuad());\n            tempQuadB.offset(deltaX, deltaY);\n            this._polyCheckCount++;\n            if (!tilemapWi.GetBoundingQuad().intersectsQuad(tempQuadB))\n                return false;\n            tempPolyC.copy(nonTilemapWi.GetTransformedCollisionPoly());\n            const ptsArrB = tempPolyC.pointsArr();\n            for (let i = 0, len = ptsArrB.length; i < len; i += 2) {\n                const j = i + 1;\n                const x = ptsArrB[i] += deltaX;\n                const y = ptsArrB[j] += deltaY\n            }\n            tempPolyC.setBboxChanged();\n            return this.TestTilemapOverlap(tilemapWi, nonTilemapWi, nonTilemapTransformedX, nonTilemapTransformedY, tempPolyC, tempRect3, tempQuadB)\n        }\n        TestTilemapOverlap(tmWi, wi, transformedWiX, transformedWiY, transformedCollisionPoly, transformedBoundingBox, transformedBoundingQuad) {\n            const bbox = transformedBoundingBox !== undefined ? transformedBoundingBox : wi.GetBoundingBox();\n            const tmX = tmWi.GetX();\n            const tmY = tmWi.GetY();\n            const tmSdkInst = tmWi.GetInstance().GetSdkInstance();\n            const instX = transformedWiX !== undefined ? transformedWiX : wi.GetX();\n            const instY = transformedWiY !== undefined ? transformedWiY : wi.GetY();\n            const instHasPoly = wi.HasOwnCollisionPoly();\n            const instQuad = transformedBoundingQuad !== undefined ? transformedBoundingQuad : wi.GetBoundingQuad();\n            const collRects = tileCollRectCandidates;\n            tmSdkInst.GetCollisionRectCandidates(bbox, collRects);\n            for (let i = 0, len = collRects.length; i < len; ++i) {\n                const c = collRects[i];\n                const rc = c.GetRect();\n                this._collisionCheckCount++;\n                if (bbox.intersectsRectOffset(rc, tmX, tmY)) {\n                    tempQuad.setFromRect(rc);\n                    tempQuad.offset(tmX, tmY);\n                    if (tempQuad.intersectsQuad(instQuad))\n                        if (instHasPoly) {\n                            const instPoly = transformedCollisionPoly !== undefined ? transformedCollisionPoly : wi.GetTransformedCollisionPoly();\n                            const tilePoly = c.GetPoly();\n                            if (tilePoly) {\n                                this._polyCheckCount++;\n                                if (tilePoly.intersectsPoly(instPoly, instX - (tmX + rc.getLeft()), instY - (tmY + rc.getTop()))) {\n                                    C3.clearArray(collRects);\n                                    return true\n                                }\n                            } else {\n                                tempPolyA.setFromQuad(tempQuad, 0, 0);\n                                if (tempPolyA.intersectsPoly(instPoly, instX, instY)) {\n                                    C3.clearArray(collRects);\n                                    return true\n                                }\n                            }\n                        } else {\n                            const tilePoly = c.GetPoly();\n                            if (tilePoly) {\n                                tempPolyA.setFromQuad(instQuad, 0, 0);\n                                if (tilePoly.intersectsPoly(tempPolyA, -(tmX + rc.getLeft()), -(tmY + rc.getTop()))) {\n                                    C3.clearArray(collRects);\n                                    return true\n                                }\n                            } else {\n                                C3.clearArray(collRects);\n                                return true\n                            }\n                        }\n                }\n            }\n            C3.clearArray(collRects);\n            return false\n        }\n        TestAndSelectCanvasPointOverlap(objectClass, ptx, pty, isInverted) {\n            const sol = objectClass.GetCurrentSol();\n            const currentEvent = this._runtime.GetCurrentEvent();\n            if (!currentEvent)\n                throw new Error("cannot call outside event");\n            const isOrBlock = currentEvent.IsOrBlock();\n            if (sol.IsSelectAll()) {\n                if (!isInverted) {\n                    sol._SetSelectAll(false);\n                    C3.clearArray(sol._GetOwnInstances())\n                }\n                for (const inst of objectClass.GetInstances()) {\n                    const wi = inst.GetWorldInfo();\n                    const layer = wi.GetLayer();\n                    const [lx,ly] = layer.CanvasCssToLayer(ptx, pty, wi.GetTotalZElevation());\n                    if (layer.IsSelfAndParentsInteractive() && wi.ContainsPoint(lx, ly))\n                        if (isInverted)\n                            return false;\n                        else\n                            sol._PushInstance(inst);\n                    else if (isOrBlock)\n                        sol._PushElseInstance(inst)\n                }\n            } else {\n                let arr;\n                let isPickingElseInstances = false;\n                if (isOrBlock)\n                    if (this._runtime.IsCurrentConditionFirst() && !sol._GetOwnElseInstances().length && sol._GetOwnInstances().length)\n                        arr = sol._GetOwnInstances();\n                    else {\n                        arr = sol._GetOwnElseInstances();\n                        isPickingElseInstances = true\n                    }\n                else\n                    arr = sol._GetOwnInstances();\n                let j = 0;\n                for (let i = 0, len = arr.length; i < len; ++i) {\n                    const inst = arr[i];\n                    const wi = inst.GetWorldInfo();\n                    const layer = wi.GetLayer();\n                    const [lx,ly] = layer.CanvasCssToLayer(ptx, pty, wi.GetTotalZElevation());\n                    if (layer.IsSelfAndParentsInteractive() && wi.ContainsPoint(lx, ly))\n                        if (isInverted)\n                            return false;\n                        else if (isPickingElseInstances)\n                            sol._PushInstance(inst);\n                        else\n                            arr[j++] = inst;\n                    else if (isPickingElseInstances)\n                        arr[j++] = inst;\n                    else if (isOrBlock)\n                        sol._PushElseInstance(inst)\n                }\n                if (!isInverted)\n                    arr.length = j\n            }\n            objectClass.ApplySolToContainer();\n            if (isInverted)\n                return true;\n            else\n                return sol.HasAnyInstances()\n        }\n        GetCollisionCandidates(layer, rtype, bbox, candidates) {\n            const isParallaxed = layer ? layer.GetParallaxX() !== 1 || layer.GetParallaxY() !== 1 : false;\n            if (rtype.IsFamily())\n                for (const memberType of rtype.GetFamilyMembers())\n                    if (isParallaxed || memberType.IsAnyInstanceParallaxed())\n                        C3.appendArray(candidates, memberType.GetInstances());\n                    else {\n                        memberType._UpdateAllCollisionCells();\n                        memberType._GetCollisionCellGrid().QueryRange(bbox, candidates)\n                    }\n            else if (isParallaxed || rtype.IsAnyInstanceParallaxed())\n                C3.appendArray(candidates, rtype.GetInstances());\n            else {\n                rtype._UpdateAllCollisionCells();\n                rtype._GetCollisionCellGrid().QueryRange(bbox, candidates)\n            }\n        }\n        GetObjectClassesCollisionCandidates(layer, objectClasses, bbox, candidates) {\n            for (const objectClass of objectClasses)\n                this.GetCollisionCandidates(layer, objectClass, bbox, candidates)\n        }\n        GetSolidCollisionCandidates(layer, bbox, candidates) {\n            const solidBehavior = this._runtime.GetSolidBehavior();\n            if (!solidBehavior)\n                return;\n            this.GetObjectClassesCollisionCandidates(layer, solidBehavior.GetObjectClasses(), bbox, candidates)\n        }\n        GetJumpthruCollisionCandidates(layer, bbox, candidates) {\n            const jumpthruBehavior = this._runtime.GetJumpthruBehavior();\n            if (!jumpthruBehavior)\n                return;\n            this.GetObjectClassesCollisionCandidates(layer, jumpthruBehavior.GetObjectClasses(), bbox, candidates)\n        }\n        IsSolidCollisionAllowed(solidInst, inst) {\n            return solidInst._IsSolidEnabled() && (!inst || inst.GetWorldInfo().IsSolidCollisionAllowed(solidInst.GetSavedDataMap().get("solidTags")))\n        }\n        TestOverlapSolid(inst) {\n            const wi = inst.GetWorldInfo();\n            this.GetSolidCollisionCandidates(wi.GetLayer(), wi.GetBoundingBox(), tempCandidates);\n            for (const s of tempCandidates) {\n                if (!this.IsSolidCollisionAllowed(s, inst))\n                    continue;\n                if (this.TestOverlap(inst, s)) {\n                    C3.clearArray(tempCandidates);\n                    return s\n                }\n            }\n            C3.clearArray(tempCandidates);\n            return null\n        }\n        TestRectOverlapSolid(rect, inst) {\n            this.GetSolidCollisionCandidates(null, rect, tempCandidates);\n            for (const s of tempCandidates) {\n                if (!this.IsSolidCollisionAllowed(s, inst))\n                    continue;\n                if (this.TestRectOverlap(rect, s)) {\n                    C3.clearArray(tempCandidates);\n                    return s\n                }\n            }\n            C3.clearArray(tempCandidates);\n            return null\n        }\n        TestOverlapJumpthru(inst, all) {\n            let ret = null;\n            if (all) {\n                ret = tempJumpthruRet;\n                C3.clearArray(ret)\n            }\n            const wi = inst.GetWorldInfo();\n            this.GetJumpthruCollisionCandidates(wi.GetLayer(), wi.GetBoundingBox(), tempCandidates);\n            for (const j of tempCandidates) {\n                if (!j._IsJumpthruEnabled())\n                    continue;\n                if (this.TestOverlap(inst, j))\n                    if (all)\n                        ret.push(j);\n                    else {\n                        C3.clearArray(tempCandidates);\n                        return j\n                    }\n            }\n            C3.clearArray(tempCandidates);\n            return ret\n        }\n        PushOut(inst, xdir, ydir, dist, otherInst) {\n            dist = dist || 50;\n            const wi = inst.GetWorldInfo();\n            const oldX = wi.GetX();\n            const oldY = wi.GetY();\n            for (let i = 0; i < dist; ++i) {\n                wi.SetXY(oldX + xdir * i, oldY + ydir * i);\n                wi.SetBboxChanged();\n                if (!this.TestOverlap(inst, otherInst))\n                    return true\n            }\n            wi.SetXY(oldX, oldY);\n            wi.SetBboxChanged();\n            return false\n        }\n        PushOutSolid(inst, xdir, ydir, dist, includeJumpthrus, specificJumpthru) {\n            dist = dist || 50;\n            const wi = inst.GetWorldInfo();\n            const oldX = wi.GetX();\n            const oldY = wi.GetY();\n            let lastOverlapped = null;\n            let secondLastOverlapped = null;\n            for (let i = 0; i < dist; ++i) {\n                wi.SetXY(oldX + xdir * i, oldY + ydir * i);\n                wi.SetBboxChanged();\n                if (!this.TestOverlap(inst, lastOverlapped)) {\n                    lastOverlapped = this.TestOverlapSolid(inst);\n                    if (lastOverlapped)\n                        secondLastOverlapped = lastOverlapped;\n                    else {\n                        if (includeJumpthrus) {\n                            if (specificJumpthru)\n                                lastOverlapped = this.TestOverlap(inst, specificJumpthru) ? specificJumpthru : null;\n                            else\n                                lastOverlapped = this.TestOverlapJumpthru(inst);\n                            if (lastOverlapped)\n                                secondLastOverlapped = lastOverlapped\n                        }\n                        if (!lastOverlapped) {\n                            if (secondLastOverlapped)\n                                this.PushInFractional(inst, xdir, ydir, secondLastOverlapped, 16, true);\n                            return true\n                        }\n                    }\n                }\n            }\n            wi.SetXY(oldX, oldY);\n            wi.SetBboxChanged();\n            return false\n        }\n        PushOutSolidAxis(inst, xdir, ydir, dist) {\n            dist = dist || 50;\n            const wi = inst.GetWorldInfo();\n            const oldX = wi.GetX();\n            const oldY = wi.GetY();\n            let lastOverlapped = null;\n            let secondLastOverlapped = null;\n            for (let i = 0; i < dist; ++i)\n                for (let which = 0; which < 2; ++which) {\n                    const sign = which * 2 - 1;\n                    wi.SetXY(oldX + xdir * i * sign, oldY + ydir * i * sign);\n                    wi.SetBboxChanged();\n                    if (!this.TestOverlap(inst, lastOverlapped)) {\n                        lastOverlapped = this.TestOverlapSolid(inst);\n                        if (lastOverlapped)\n                            secondLastOverlapped = lastOverlapped;\n                        else {\n                            if (secondLastOverlapped)\n                                this.PushInFractional(inst, xdir * sign, ydir * sign, secondLastOverlapped, 16, true);\n                            return true\n                        }\n                    }\n                }\n            wi.SetXY(oldX, oldY);\n            wi.SetBboxChanged();\n            return false\n        }\n        PushInFractional(inst, xdir, ydir, otherInst, limit, includeAnySolid) {\n            let divisor = 2;\n            let forward = false;\n            let overlapping = false;\n            const wi = inst.GetWorldInfo();\n            let bestX = wi.GetX();\n            let bestY = wi.GetY();\n            while (divisor <= limit) {\n                const frac = 1 \/ divisor;\n                divisor *= 2;\n                wi.OffsetXY(xdir * frac * (forward ? 1 : -1), ydir * frac * (forward ? 1 : -1));\n                wi.SetBboxChanged();\n                if (this.TestOverlap(inst, otherInst) || includeAnySolid && this.TestOverlapSolid(inst)) {\n                    forward = true;\n                    overlapping = true\n                } else {\n                    forward = false;\n                    overlapping = false;\n                    bestX = wi.GetX();\n                    bestY = wi.GetY()\n                }\n            }\n            if (overlapping) {\n                wi.SetXY(bestX, bestY);\n                wi.SetBboxChanged()\n            }\n        }\n        PushOutSolidNearest(inst, maxDist=100) {\n            let dist = 0;\n            const wi = inst.GetWorldInfo();\n            const oldX = wi.GetX();\n            const oldY = wi.GetY();\n            let dir = 0;\n            let lastOverlapped = this.TestOverlapSolid(inst);\n            if (!lastOverlapped)\n                return true;\n            while (dist <= maxDist) {\n                let dx = 0;\n                let dy = 0;\n                switch (dir) {\n                case 0:\n                    dx = 0;\n                    dy = -1;\n                    dist++;\n                    break;\n                case 1:\n                    dx = 1;\n                    dy = -1;\n                    break;\n                case 2:\n                    dx = 1;\n                    dy = 0;\n                    break;\n                case 3:\n                    dx = 1;\n                    dy = 1;\n                    break;\n                case 4:\n                    dx = 0;\n                    dy = 1;\n                    break;\n                case 5:\n                    dx = -1;\n                    dy = 1;\n                    break;\n                case 6:\n                    dx = -1;\n                    dy = 0;\n                    break;\n                case 7:\n                    dx = -1;\n                    dy = -1;\n                    break\n                }\n                dir = (dir + 1) % 8;\n                wi.SetXY(Math.floor(oldX + dx * dist), Math.floor(oldY + dy * dist));\n                wi.SetBboxChanged();\n                if (!this.TestOverlap(inst, lastOverlapped)) {\n                    lastOverlapped = this.TestOverlapSolid(inst);\n                    if (!lastOverlapped)\n                        return true\n                }\n            }\n            wi.SetXY(oldX, oldY);\n            wi.SetBboxChanged();\n            return false\n        }\n        CalculateBounceAngle(inst, startX, startY, otherInst) {\n            const wi = inst.GetWorldInfo();\n            const oldX = wi.GetX();\n            const oldY = wi.GetY();\n            const radius = Math.max(10, C3.distanceTo(startX, startY, oldX, oldY));\n            const startAngle = C3.angleTo(startX, startY, oldX, oldY);\n            const firstInst = otherInst || this.TestOverlapSolid(inst);\n            if (!firstInst)\n                return C3.clampAngle(startAngle + Math.PI);\n            let curInst = firstInst;\n            let anticlockwiseFreeAngle = 0;\n            let clockwiseFreeAngle = 0;\n            const increment = C3.toRadians(5);\n            let i;\n            for (i = 1; i < 36; ++i) {\n                const curAngle = startAngle - i * increment;\n                wi.SetXY(startX + Math.cos(curAngle) * radius, startY + Math.sin(curAngle) * radius);\n                wi.SetBboxChanged();\n                if (!this.TestOverlap(inst, curInst)) {\n                    curInst = otherInst ? null : this.TestOverlapSolid(inst);\n                    if (!curInst) {\n                        anticlockwiseFreeAngle = curAngle;\n                        break\n                    }\n                }\n            }\n            if (i === 36)\n                anticlockwiseFreeAngle = C3.clampAngle(startAngle + Math.PI);\n            curInst = firstInst;\n            for (i = 1; i < 36; ++i) {\n                const curAngle = startAngle + i * increment;\n                wi.SetXY(startX + Math.cos(curAngle) * radius, startY + Math.sin(curAngle) * radius);\n                wi.SetBboxChanged();\n                if (!this.TestOverlap(inst, curInst)) {\n                    curInst = otherInst ? null : this.TestOverlapSolid(inst);\n                    if (!curInst) {\n                        clockwiseFreeAngle = curAngle;\n                        break\n                    }\n                }\n            }\n            if (i === 36)\n                clockwiseFreeAngle = C3.clampAngle(startAngle + Math.PI);\n            wi.SetXY(oldX, oldY);\n            wi.SetBboxChanged();\n            if (clockwiseFreeAngle === anticlockwiseFreeAngle)\n                return clockwiseFreeAngle;\n            const halfDiff = C3.angleDiff(clockwiseFreeAngle, anticlockwiseFreeAngle) \/ 2;\n            let normal;\n            if (C3.angleClockwise(clockwiseFreeAngle, anticlockwiseFreeAngle))\n                normal = C3.clampAngle(anticlockwiseFreeAngle + halfDiff + Math.PI);\n            else\n                normal = C3.clampAngle(clockwiseFreeAngle + halfDiff);\n            const vx = Math.cos(startAngle);\n            const vy = Math.sin(startAngle);\n            const nx = Math.cos(normal);\n            const ny = Math.sin(normal);\n            const v_dot_n = vx * nx + vy * ny;\n            const rx = vx - 2 * v_dot_n * nx;\n            const ry = vy - 2 * v_dot_n * ny;\n            return C3.angleTo(0, 0, rx, ry)\n        }\n        TestSegmentOverlap(x1, y1, x2, y2, inst) {\n            if (!inst)\n                return false;\n            const wi = inst.GetWorldInfo();\n            if (!wi.IsCollisionEnabled())\n                return false;\n            this._collisionCheckCount++;\n            tempRect.set(Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2));\n            if (!wi.GetBoundingBox().intersectsRect(tempRect))\n                return false;\n            if (inst.HasTilemap())\n                return this._TestSegmentOverlapTilemap(x1, y1, x2, y2, inst, wi);\n            this._polyCheckCount++;\n            if (!wi.GetBoundingQuad().intersectsSegment(x1, y1, x2, y2))\n                return false;\n            if (!wi.HasOwnCollisionPoly())\n                return true;\n            const poly = wi.GetTransformedCollisionPoly();\n            return poly.intersectsSegment(wi.GetX(), wi.GetY(), x1, y1, x2, y2)\n        }\n        _TestSegmentOverlapTilemap(x1, y1, x2, y2, inst, wi) {\n            const tmX = wi.GetX();\n            const tmY = wi.GetY();\n            const sdkInst = inst.GetSdkInstance();\n            const collRects = tileCollRectCandidates;\n            tempRect2.set(x1, y1, x2, y2);\n            tempRect2.normalize();\n            sdkInst.GetCollisionRectCandidates(tempRect2, collRects);\n            for (let i = 0, len = collRects.length; i < len; ++i) {\n                const c = collRects[i];\n                const tileRc = c.GetRect();\n                this._collisionCheckCount++;\n                if (tempRect.intersectsRectOffset(tileRc, tmX, tmY)) {\n                    tempQuad.setFromRect(tileRc);\n                    tempQuad.offset(tmX, tmY);\n                    if (tempQuad.intersectsSegment(x1, y1, x2, y2)) {\n                        const tilePoly = c.GetPoly();\n                        if (tilePoly) {\n                            this._polyCheckCount++;\n                            if (tilePoly.intersectsSegment(tmX + tileRc.getLeft(), tmY + tileRc.getTop(), x1, y1, x2, y2)) {\n                                C3.clearArray(collRects);\n                                return true\n                            }\n                        } else {\n                            C3.clearArray(collRects);\n                            return true\n                        }\n                    }\n                }\n            }\n            C3.clearArray(collRects);\n            return false\n        }\n        TestRectOverlap(rect, inst) {\n            if (!inst)\n                return false;\n            const wi = inst.GetWorldInfo();\n            if (!wi.IsCollisionEnabled())\n                return false;\n            this._collisionCheckCount++;\n            if (!wi.GetBoundingBox().intersectsRect(rect))\n                return false;\n            if (inst.HasTilemap())\n                return this._TestRectOverlapTilemap(rect, inst, wi);\n            this._polyCheckCount++;\n            tempQuad.setFromRect(rect);\n            if (!wi.GetBoundingQuad().intersectsQuad(tempQuad))\n                return false;\n            if (!wi.HasOwnCollisionPoly())\n                return true;\n            const polyA = tempPolyA;\n            polyA.setFromRect(rect, wi.GetX(), wi.GetY());\n            const polyB = wi.GetTransformedCollisionPoly();\n            return polyA.intersectsPoly(polyB, 0, 0)\n        }\n        _TestRectOverlapTilemap(rect, inst, wi) {\n            const tmX = wi.GetX();\n            const tmY = wi.GetY();\n            const sdkInst = inst.GetSdkInstance();\n            const collRects = tileCollRectCandidates;\n            sdkInst.GetCollisionRectCandidates(rect, collRects);\n            for (let i = 0, len = collRects.length; i < len; ++i) {\n                const c = collRects[i];\n                const tileRc = c.GetRect();\n                this._collisionCheckCount++;\n                if (rect.intersectsRectOffset(tileRc, tmX, tmY)) {\n                    const tilePoly = c.GetPoly();\n                    if (tilePoly) {\n                        this._polyCheckCount++;\n                        tempPolyA.setFromRect(rect, 0, 0);\n                        if (tilePoly.intersectsPoly(tempPolyA, -(tmX + tileRc.getLeft()), -(tmY + tileRc.getTop()))) {\n                            C3.clearArray(collRects);\n                            return true\n                        }\n                    } else {\n                        C3.clearArray(collRects);\n                        return true\n                    }\n                }\n            }\n            C3.clearArray(collRects);\n            return false\n        }\n        TestRayIntersectsInstance(inst, ray) {\n            if (!inst)\n                return;\n            const wi = inst.GetWorldInfo();\n            if (!wi.IsCollisionEnabled())\n                return;\n            this._collisionCheckCount++;\n            if (!wi.GetBoundingBox().intersectsRect(ray.rect))\n                return;\n            if (inst.HasTilemap()) {\n                this._TestRayIntersectsTilemap(inst, wi, ray);\n                return\n            }\n            this._polyCheckCount++;\n            if (wi.HasOwnCollisionPoly())\n                ray.TestInstancePoly(inst, wi.GetX(), wi.GetY(), wi.GetTransformedCollisionPoly());\n            else\n                ray.TestInstanceQuad(inst, wi.GetBoundingQuad())\n        }\n        _TestRayIntersectsTilemap(inst, wi, ray) {\n            const xOffset = wi.GetX();\n            const yOffset = wi.GetY();\n            const collRects = tileCollRectCandidates;\n            inst.GetSdkInstance().GetCollisionRectCandidates(ray.rect, collRects);\n            for (let i = 0, l = collRects.length; i < l; i++) {\n                const c = collRects[i];\n                const tileRc = c.GetRect();\n                this._collisionCheckCount++;\n                if (ray.rect.intersectsRectOffset(tileRc, xOffset, yOffset)) {\n                    const tilePoly = c.GetPoly();\n                    this._polyCheckCount++;\n                    if (tilePoly)\n                        ray.TestInstancePoly(inst, xOffset + tileRc.getLeft(), yOffset + tileRc.getTop(), tilePoly);\n                    else\n                        ray.TestInstanceRect(inst, wi.GetX(), wi.GetY(), tileRc)\n                }\n            }\n            C3.clearArray(collRects)\n        }\n    }\n    ;\n\n}\n\n\/\/ collisions\/sparseGrid.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.SparseGrid = class SparseGrid extends C3.DefendedBase {\n        constructor(cellWidth, cellHeight) {\n            super();\n            this._cellWidth = cellWidth;\n            this._cellHeight = cellHeight;\n            this._cells = C3.New(C3.PairMap)\n        }\n        Release() {\n            this._cells.Release();\n            this._cells = null\n        }\n        GetCell(x, y, createIfMissing) {\n            let ret = this._cells.Get(x, y);\n            if (ret)\n                return ret;\n            else if (createIfMissing) {\n                ret = C3.New(C3.GridCell, this, x, y);\n                this._cells.Set(x, y, ret);\n                return ret\n            } else\n                return null\n        }\n        XToCell(x) {\n            const ret = Math.floor(x \/ this._cellWidth);\n            return isFinite(ret) ? ret : 0\n        }\n        YToCell(y) {\n            const ret = Math.floor(y \/ this._cellHeight);\n            return isFinite(ret) ? ret : 0\n        }\n        Update(inst, oldRange, newRange) {\n            if (oldRange)\n                for (let x = oldRange.getLeft(), lenx = oldRange.getRight(); x <= lenx; ++x)\n                    for (let y = oldRange.getTop(), leny = oldRange.getBottom(); y <= leny; ++y) {\n                        if (newRange && newRange.containsPoint(x, y))\n                            continue;\n                        const cell = this.GetCell(x, y, false);\n                        if (!cell)\n                            continue;\n                        cell.Remove(inst);\n                        if (cell.IsEmpty())\n                            this._cells.Delete(x, y)\n                    }\n            if (newRange)\n                for (let x = newRange.getLeft(), lenx = newRange.getRight(); x <= lenx; ++x)\n                    for (let y = newRange.getTop(), leny = newRange.getBottom(); y <= leny; ++y) {\n                        if (oldRange && oldRange.containsPoint(x, y))\n                            continue;\n                        this.GetCell(x, y, true).Insert(inst)\n                    }\n        }\n        QueryRange(rc, result) {\n            let x = this.XToCell(rc.getLeft());\n            const ystart = this.YToCell(rc.getTop());\n            const lenx = this.XToCell(rc.getRight());\n            const leny = this.YToCell(rc.getBottom());\n            if (!isFinite(lenx) || !isFinite(leny))\n                return;\n            for (; x <= lenx; ++x)\n                for (let y = ystart; y <= leny; ++y) {\n                    const cell = this.GetCell(x, y, false);\n                    if (!cell)\n                        continue;\n                    cell.Dump(result)\n                }\n        }\n    }\n    ;\n\n}\n\n\/\/ collisions\/gridCell.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.GridCell = class GridCell extends C3.DefendedBase {\n        constructor(grid, x, y) {\n            super();\n            this._grid = grid;\n            this._x = x;\n            this._y = y;\n            this._instances = C3.New(C3.ArraySet)\n        }\n        Release() {\n            this._instances.Release();\n            this._instances = null;\n            this._grid = null\n        }\n        IsEmpty() {\n            return this._instances.IsEmpty()\n        }\n        Insert(inst) {\n            this._instances.Add(inst)\n        }\n        Remove(inst) {\n            this._instances.Delete(inst)\n        }\n        Dump(result) {\n            C3.appendArray(result, this._instances.GetArray())\n        }\n    }\n    ;\n\n}\n\n\/\/ collisions\/ray.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const PADDING = 1E-6;\n    const NO_HIT = 2;\n    C3.Ray = class Ray {\n        constructor() {\n            this.x1 = 0;\n            this.y1 = 0;\n            this.x2 = 0;\n            this.y2 = 0;\n            this.dx = 0;\n            this.dy = 0;\n            this.rect = new C3.Rect;\n            this.hitFraction = NO_HIT;\n            this.hitUid = null;\n            this.hitNormal = 0;\n            this.hitNormalDx = 0;\n            this.hitNormalDy = 0;\n            this.hitX = 0;\n            this.hitY = 0;\n            this.distance = 0;\n            this.normalX = 1;\n            this.normalY = 0;\n            this.reflectionX = 1;\n            this.reflectionY = 0\n        }\n        DidCollide() {\n            return this.hitFraction < 1 + PADDING\n        }\n        Set(x1, y1, x2, y2) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n            this.dx = x2 - x1;\n            this.dy = y2 - y1;\n            this.rect.set(x1, y1, x2, y2);\n            this.rect.normalize();\n            this.hitFraction = NO_HIT;\n            this.hitUid = null;\n            this.hitNormal = 0;\n            this.hitNormalDx = 0;\n            this.hitNormalDy = 0;\n            this.hitX = 0;\n            this.hitY = 0;\n            this.distance = 0;\n            this.normalX = 1;\n            this.normalY = 0;\n            this.reflectionX = 1;\n            this.reflectionY = 0;\n            return this\n        }\n        Complete() {\n            if (this.DidCollide() === false)\n                return;\n            const dx = this.dx * this.hitFraction;\n            const dy = this.dy * this.hitFraction;\n            const length = Math.sqrt(dx * dx + dy * dy);\n            const dirx = dx \/ length;\n            const diry = dy \/ length;\n            this.distance = length - PADDING;\n            this.hitX = this.x1 + dirx * this.distance;\n            this.hitY = this.y1 + diry * this.distance;\n            this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI \/ 2;\n            this.normalX = Math.cos(this.hitNormal);\n            this.normalY = Math.sin(this.hitNormal);\n            const dot = dirx * this.normalX + diry * this.normalY;\n            this.reflectionX = dirx - 2 * this.normalX * dot;\n            this.reflectionY = diry - 2 * this.normalY * dot;\n            if (dot > 0) {\n                const PI = Math.PI;\n                this.hitNormal = C3.clampAngle(this.hitNormal + PI);\n                this.normalX = -this.normalX;\n                this.normalY = -this.normalY\n            }\n        }\n        TestInstanceSegment(inst, sx1, sy1, sx2, sy2) {\n            const t = C3.rayIntersect(this.x1, this.y1, this.x2, this.y2, sx1, sy1, sx2, sy2);\n            if (t >= 0 && t < this.hitFraction) {\n                this.hitFraction = t;\n                this.hitUid = inst.GetUID();\n                this.hitNormalDx = sx1 - sx2;\n                this.hitNormalDy = sy1 - sy2\n            }\n        }\n        TestInstanceRect(inst, offX, offY, rect) {\n            const lt = offX + rect.getLeft()\n              , rt = offX + rect.getRight()\n              , tp = offY + rect.getTop()\n              , bm = offY + rect.getBottom();\n            this.TestInstanceSegment(inst, lt, tp, rt, tp);\n            this.TestInstanceSegment(inst, rt, tp, rt, bm);\n            this.TestInstanceSegment(inst, rt, bm, lt, bm);\n            this.TestInstanceSegment(inst, lt, bm, lt, tp)\n        }\n        TestInstanceQuad(inst, quad) {\n            const tlX = quad.getTlx()\n              , tlY = quad.getTly()\n              , trX = quad.getTrx()\n              , trY = quad.getTry()\n              , brX = quad.getBrx()\n              , brY = quad.getBry()\n              , blX = quad.getBlx()\n              , blY = quad.getBly();\n            this.TestInstanceSegment(inst, tlX, tlY, trX, trY);\n            this.TestInstanceSegment(inst, trX, trY, brX, brY);\n            this.TestInstanceSegment(inst, brX, brY, blX, blY);\n            this.TestInstanceSegment(inst, blX, blY, tlX, tlY)\n        }\n        TestInstancePoly(inst, offX, offY, poly) {\n            const points = poly.pointsArr();\n            for (let i = 0, l = points.length; i < l; i += 2) {\n                const ii = (i + 2) % l;\n                const x1 = points[i] + offX;\n                const y1 = points[i + 1] + offY;\n                const x2 = points[ii] + offX;\n                const y2 = points[ii + 1] + offY;\n                this.TestInstanceSegment(inst, x1, y1, x2, y2)\n            }\n        }\n    }\n    ;\n\n}\n\n\/\/ canvasManager.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const VALID_FULLSCREEN_MODES = new Set(["off", "crop", "scale-inner", "scale-outer", "letterbox-scale", "letterbox-integer-scale"]);\n    const VALID_FULLSCREEN_SCALING_QUALITIES = new Set(["high", "low"]);\n    const glMatrix = self.glMatrix;\n    const mat4 = glMatrix.mat4;\n    const vec3 = glMatrix.vec3;\n    const tempProjection = mat4.create();\n    const PERCENTTEXT_WIDTH = 300;\n    const PERCENTTEXT_HEIGHT = 200;\n    const PROGRESSBAR_WIDTH = 120;\n    const PROGRESSBAR_HEIGHT = 8;\n    const tempQuad = C3.New(C3.Quad);\n    const tempRect = C3.New(C3.Rect);\n    const SPLASH_MIN_DISPLAY_TIME = 3E3;\n    const SPLASH_AFTER_FADEOUT_WAIT_TIME = 200;\n    const SPLASH_FADE_DURATION = 300;\n    C3.CanvasManager = class CanvasManager extends C3.DefendedBase {\n        constructor(runtime) {\n            super();\n            this._runtime = runtime;\n            this._canvas = null;\n            this._isWebGPUEnabled = false;\n            this._webglRenderer = null;\n            this._webgpuRenderer = null;\n            this._gpuPreference = "high-performance";\n            this._windowInnerWidth = 0;\n            this._windowInnerHeight = 0;\n            this._canvasCssWidth = 0;\n            this._canvasCssHeight = 0;\n            this._canvasDeviceWidth = 0;\n            this._canvasDeviceHeight = 0;\n            this._canvasCssOffsetX = 0;\n            this._canvasCssOffsetY = 0;\n            this._zAxisScale = "normalized";\n            this._fieldOfView = 0;\n            this._enableMipmaps = true;\n            this._textureAnisotropy = 0;\n            this._drawWidth = 0;\n            this._drawHeight = 0;\n            this._fullscreenMode = "letterbox-scale";\n            this._documentFullscreenMode = "letterbox-scale";\n            this._deviceTransformOffX = 0;\n            this._deviceTransformOffY = 0;\n            this._defaultProjectionMatrix = mat4.create();\n            this._wantFullscreenScalingQuality = "high";\n            this._fullscreenScalingQuality = this._wantFullscreenScalingQuality;\n            this._isDocumentFullscreen = false;\n            this._availableAdditionalRenderTargets = [];\n            this._usedAdditionalRenderTargets = new Set;\n            this._shaderData = self["C3_Shaders"];\n            this._effectChainManager = C3.New(C3.Gfx.EffectChainManager, {\n                getDrawSize: () => [this.GetDrawWidth(), this.GetDrawHeight()],\n                getRenderTarget: () => this.GetEffectCompositorRenderTarget(),\n                releaseRenderTarget: rt => this.ReleaseEffectCompositorRenderTarget(rt),\n                getTime: () => this.GetRuntime().GetGameTime(),\n                redraw: () => this.GetRuntime().UpdateRender()\n            });\n            this._gpuTimeStartFrame = 0;\n            this._gpuTimeEndFrame = 0;\n            this._gpuLastUtilisation = NaN;\n            this._gpuFrameTimingsBuffer = null;\n            this._layersGpuProfile = new Map;\n            this._gpuCurUtilisation = NaN;\n            this._webgpuFrameTimings = new Map;\n            this._snapshotFormat = "";\n            this._snapshotQuality = 1;\n            this._snapshotArea = C3.New(C3.Rect);\n            this._snapshotUrl = "";\n            this._snapshotPromise = null;\n            this._snapshotResolve = null;\n            this._isPastingToDrawingCanvas = 0;\n            this._loaderStartTime = 0;\n            this._rafId = -1;\n            this._loadingProgress = 0;\n            this._loadingprogress_handler = e => this._loadingProgress = e.progress;\n            this._percentText = null;\n            this._splashTextures = {\n                logo: null,\n                powered: null,\n                website: null\n            };\n            this._splashFrameNumber = 0;\n            this._splashFadeInFinishTime = 0;\n            this._splashFadeOutStartTime = 0;\n            this._splashState = "fade-in";\n            this._splashDoneResolve = null;\n            this._splashDonePromise = new Promise(resolve => this._splashDoneResolve = resolve)\n        }\n        _SetGPUPowerPreference(pref) {\n            this._gpuPreference = pref\n        }\n        _SetWebGPUEnabled(e) {\n            this._isWebGPUEnabled = !!e\n        }\n        _SetZAxisScale(s) {\n            this._zAxisScale = s\n        }\n        _SetFieldOfView(f) {\n            this._fieldOfView = f\n        }\n        async CreateCanvas(opts) {\n            this._canvas = opts["canvas"];\n            this._runtime.AddDOMComponentMessageHandler("runtime", "window-resize", e => this._OnWindowResize(e));\n            this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenchange", e => this._OnFullscreenChange(e));\n            this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenerror", e => this._OnFullscreenError(e));\n            this._canvas.addEventListener("webglcontextlost", e => this._OnWebGLContextLost(e));\n            this._canvas.addEventListener("webglcontextrestored", e => this._OnWebGLContextRestored(e));\n            this._isDocumentFullscreen = !!opts["isFullscreen"];\n            const useWebGPU = navigator["gpu"] && this._isWebGPUEnabled;\n            let hasMajorPerformanceCaveat = false;\n            if (useWebGPU)\n                try {\n                    await this._InitWebGPUContext(true)\n                } catch (err) {\n                    this._webgpuRenderer = null\n                }\n            if (!this.GetRenderer())\n                try {\n                    await this._InitWebGLContext(true)\n                } catch (err) {\n                    this._webglRenderer = null\n                }\n            if (!this.GetRenderer())\n                hasMajorPerformanceCaveat = true;\n            if (!this.GetRenderer() && useWebGPU)\n                try {\n                    await this._InitWebGPUContext(false)\n                } catch (err) {\n                    this._webgpuRenderer = null\n                }\n            if (!this.GetRenderer())\n                try {\n                    await this._InitWebGLContext(false)\n                } catch (err) {\n                    this._webglRenderer = null\n                }\n            const renderer = this.GetRenderer();\n            if (!renderer)\n                throw new Error("failed to acquire a renderer - check WebGL or WebGPU is supported");\n            renderer.SetHasMajorPerformanceCaveat(hasMajorPerformanceCaveat);\n            if (this._zAxisScale === "normalized")\n                renderer.SetZAxisScaleNormalized();\n            else {\n                renderer.SetZAxisScaleRegular();\n                renderer.SetFovY(this._fieldOfView)\n            }\n            this.SetSize(opts["windowInnerWidth"], opts["windowInnerHeight"], true);\n            if (this._webgpuRenderer)\n                await this._InitWebGPU();\n            else if (this._webglRenderer)\n                await this._InitWebGL();\n            renderer.SetMipmapsEnabled(this._enableMipmaps);\n            if (renderer.SupportsGPUProfiling())\n                this._gpuLastUtilisation = 0;\n            for (const effectList of this._runtime._GetAllEffectLists()) {\n                for (const effectType of effectList.GetAllEffectTypes())\n                    effectType._InitRenderer(renderer);\n                effectList._InitRenderer(renderer);\n                effectList.UpdateActiveEffects()\n            }\n        }\n        async _InitWebGPUContext(failIfMajorPerformanceCaveat) {\n            const rendererOpts = {\n                powerPreference: this._gpuPreference,\n                depth: this._runtime.Uses3DFeatures(),\n                failIfMajorPerformanceCaveat,\n                usesBackgroundBlending: this._runtime.UsesAnyBackgroundBlending(),\n                canSampleBackbuffer: this._runtime.UsesAnyCrossSampling(),\n                canSampleDepth: this._runtime.UsesAnyDepthSampling()\n            };\n            this._webgpuRenderer = C3.New(C3.Gfx.WebGPURenderer);\n            await this._webgpuRenderer.Create(this._canvas, rendererOpts)\n        }\n        async _InitWebGLContext(failIfMajorPerformanceCaveat) {\n            const rendererOpts = {\n                powerPreference: this._gpuPreference,\n                enableGpuProfiling: true,\n                depth: this._runtime.Uses3DFeatures(),\n                canSampleDepth: this._runtime.UsesAnyDepthSampling(),\n                failIfMajorPerformanceCaveat\n            };\n            if (C3.Platform.OS === "Android" && C3.Platform.BrowserEngine === "Chromium" && C3.Platform.BrowserVersionNumber < 75) {\n                console.warn("[Construct] Disabling WebGL 2 because this device appears to be affected by crbug.com\/934823. Install software updates to avoid this.");\n                rendererOpts.maxWebGLVersion = 1\n            }\n            if (this._runtime.GetCompositingMode() === "standard")\n                rendererOpts.alpha = true;\n            else {\n                rendererOpts.alpha = false;\n                rendererOpts.lowLatency = true\n            }\n            this._webglRenderer = C3.New(C3.Gfx.WebGLRenderer, this._canvas, rendererOpts);\n            await this._webglRenderer.InitState()\n        }\n        async _InitWebGPU() {\n            if (this._shaderData) {\n                const promises = [];\n                for (const [id,data] of Object.entries(this._shaderData)) {\n                    data.src = data.wgsl;\n                    const vertexSrc = C3.Gfx.WebGPUShaderProgram.GetDefaultVertexShaderSource();\n                    promises.push(this._webgpuRenderer.CreateShaderProgram(data, vertexSrc, id))\n                }\n                await Promise.all(promises)\n            }\n        }\n        async _InitWebGL() {\n            if (this._shaderData) {\n                const promises = [];\n                for (const [id,data] of Object.entries(this._shaderData)) {\n                    data.src = data.glsl;\n                    const vertexSrc = C3.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource();\n                    promises.push(this._webglRenderer.CreateShaderProgram(data, vertexSrc, id))\n                }\n                await Promise.all(promises);\n                this._webglRenderer.ResetLastProgram();\n                this._webglRenderer.SetTextureFillMode()\n            }\n            if (this._webglRenderer.SupportsGPUProfiling())\n                this._gpuFrameTimingsBuffer = C3.New(C3.Gfx.WebGLQueryResultBuffer, this._webglRenderer)\n        }\n        Release() {\n            this._runtime = null;\n            this._webglRenderer = null;\n            this._canvas = null\n        }\n        _OnWindowResize(e) {\n            const runtime = this._runtime;\n            if (runtime.IsExportToVideo())\n                return;\n            const dpr = e["devicePixelRatio"];\n            if (runtime.IsInWorker())\n                self.devicePixelRatio = dpr;\n            runtime._SetDevicePixelRatio(dpr);\n            this._isDocumentFullscreen = !!e["isFullscreen"];\n            this.SetSize(e["innerWidth"], e["innerHeight"]);\n            runtime.UpdateRender();\n            const ev = new C3.Event("window-resize");\n            ev.data = e;\n            runtime.Dispatcher().dispatchEventAndWaitAsyncSequential(ev);\n            if (runtime.IsDebug() && (runtime.HitBreakpoint() || self.C3Debugger.IsDebuggerPaused()))\n                runtime.Render()\n        }\n        _OnFullscreenChange(e) {\n            this._isDocumentFullscreen = !!e["isFullscreen"];\n            this.SetSize(e["innerWidth"], e["innerHeight"], true);\n            this._runtime.UpdateRender()\n        }\n        _OnFullscreenError(e) {\n            this._isDocumentFullscreen = !!e["isFullscreen"];\n            this.SetSize(e["innerWidth"], e["innerHeight"], true);\n            this._runtime.UpdateRender()\n        }\n        SetSize(availableWidth, availableHeight, force=false) {\n            availableWidth = Math.floor(availableWidth);\n            availableHeight = Math.floor(availableHeight);\n            if (availableWidth <= 0 || availableHeight <= 0)\n                throw new Error("invalid size");\n            if (this._windowInnerWidth === availableWidth && this._windowInnerHeight === availableHeight && !force)\n                return;\n            this._windowInnerWidth = availableWidth;\n            this._windowInnerHeight = availableHeight;\n            const fullscreenMode = this.GetCurrentFullscreenMode();\n            if (fullscreenMode === "letterbox-scale")\n                this._CalculateLetterboxScale(availableWidth, availableHeight);\n            else if (fullscreenMode === "letterbox-integer-scale")\n                this._CalculateLetterboxIntegerScale(availableWidth, availableHeight);\n            else if (fullscreenMode === "off")\n                this._CalculateFixedSizeCanvas(availableWidth, availableHeight);\n            else\n                this._CalculateFullsizeCanvas(availableWidth, availableHeight);\n            this._UpdateFullscreenScalingQuality(fullscreenMode);\n            this._canvas.width = this._canvasDeviceWidth;\n            this._canvas.height = this._canvasDeviceHeight;\n            this._runtime.PostComponentMessageToDOM("canvas", "update-size", {\n                "marginLeft": this._canvasCssOffsetX,\n                "marginTop": this._canvasCssOffsetY,\n                "styleWidth": this._canvasCssWidth,\n                "styleHeight": this._canvasCssHeight\n            });\n            const renderer = this.GetRenderer();\n            renderer.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, true);\n            for (const rt of this._availableAdditionalRenderTargets)\n                renderer.DeleteRenderTarget(rt);\n            C3.clearArray(this._availableAdditionalRenderTargets);\n            renderer.CalculatePerspectiveMatrix(this._defaultProjectionMatrix, this.GetDrawWidth() \/ this.GetDrawHeight());\n            const layoutManager = this._runtime.GetLayoutManager();\n            layoutManager.SetAllLayerProjectionChanged();\n            layoutManager.SetAllLayerMVChanged()\n        }\n        GetDefaultProjectionMatrix() {\n            return this._defaultProjectionMatrix\n        }\n        _CalculateLetterboxScale(availableWidth, availableHeight) {\n            const dpr = this._runtime.GetDevicePixelRatio();\n            const originalViewportWidth = this._runtime.GetOriginalViewportWidth();\n            const originalViewportHeight = this._runtime.GetOriginalViewportHeight();\n            const originalAspectRatio = originalViewportWidth \/ originalViewportHeight;\n            const availableAspectRatio = availableWidth \/ availableHeight;\n            if (availableAspectRatio > originalAspectRatio) {\n                const letterboxedWidth = availableHeight * originalAspectRatio;\n                this._canvasCssWidth = Math.round(letterboxedWidth);\n                this._canvasCssHeight = availableHeight;\n                this._canvasCssOffsetX = Math.floor((availableWidth - this._canvasCssWidth) \/ 2);\n                this._canvasCssOffsetY = 0\n            } else {\n                const letterboxedHeight = availableWidth \/ originalAspectRatio;\n                this._canvasCssWidth = availableWidth;\n                this._canvasCssHeight = Math.round(letterboxedHeight);\n                this._canvasCssOffsetX = 0;\n                this._canvasCssOffsetY = Math.floor((availableHeight - this._canvasCssHeight) \/ 2)\n            }\n            this._canvasDeviceWidth = Math.round(this._canvasCssWidth * dpr);\n            this._canvasDeviceHeight = Math.round(this._canvasCssHeight * dpr);\n            this._runtime.SetViewportSize(originalViewportWidth, originalViewportHeight)\n        }\n        _CalculateLetterboxIntegerScale(availableWidth, availableHeight) {\n            const dpr = this._runtime.GetDevicePixelRatio();\n            if (dpr !== 1) {\n                availableWidth += 1;\n                availableHeight += 1\n            }\n            const originalViewportWidth = this._runtime.GetOriginalViewportWidth();\n            const originalViewportHeight = this._runtime.GetOriginalViewportHeight();\n            const originalAspectRatio = originalViewportWidth \/ originalViewportHeight;\n            const availableAspectRatio = availableWidth \/ availableHeight;\n            let intScale;\n            if (availableAspectRatio > originalAspectRatio) {\n                const letterboxedWidth = availableHeight * originalAspectRatio;\n                intScale = letterboxedWidth * dpr \/ originalViewportWidth\n            } else {\n                const letterboxedHeight = availableWidth \/ originalAspectRatio;\n                intScale = letterboxedHeight * dpr \/ originalViewportHeight\n            }\n            if (intScale > 1)\n                intScale = Math.floor(intScale);\n            else if (intScale < 1)\n                intScale = 1 \/ Math.ceil(1 \/ intScale);\n            this._canvasDeviceWidth = Math.round(originalViewportWidth * intScale);\n            this._canvasDeviceHeight = Math.round(originalViewportHeight * intScale);\n            this._canvasCssWidth = this._canvasDeviceWidth \/ dpr;\n            this._canvasCssHeight = this._canvasDeviceHeight \/ dpr;\n            this._canvasCssOffsetX = Math.max(Math.floor((availableWidth - this._canvasCssWidth) \/ 2), 0);\n            this._canvasCssOffsetY = Math.max(Math.floor((availableHeight - this._canvasCssHeight) \/ 2), 0);\n            this._runtime.SetViewportSize(originalViewportWidth, originalViewportHeight)\n        }\n        _CalculateFullsizeCanvas(availableWidth, availableHeight) {\n            const dpr = this._runtime.GetDevicePixelRatio();\n            this._canvasCssWidth = availableWidth;\n            this._canvasCssHeight = availableHeight;\n            this._canvasDeviceWidth = Math.round(this._canvasCssWidth * dpr);\n            this._canvasDeviceHeight = Math.round(this._canvasCssHeight * dpr);\n            this._canvasCssOffsetX = 0;\n            this._canvasCssOffsetY = 0;\n            const displayScale = this.GetDisplayScale();\n            this._runtime.SetViewportSize(this._canvasCssWidth \/ displayScale, this._canvasCssHeight \/ displayScale)\n        }\n        _CalculateFixedSizeCanvas(availableWidth, availableHeight) {\n            const dpr = this._runtime.GetDevicePixelRatio();\n            this._canvasCssWidth = this._runtime.GetViewportWidth();\n            this._canvasCssHeight = this._runtime.GetViewportHeight();\n            this._canvasDeviceWidth = Math.round(this._canvasCssWidth * dpr);\n            this._canvasDeviceHeight = Math.round(this._canvasCssHeight * dpr);\n            if (this.IsDocumentFullscreen()) {\n                this._canvasCssOffsetX = Math.floor((availableWidth - this._canvasCssWidth) \/ 2);\n                this._canvasCssOffsetY = Math.floor((availableHeight - this._canvasCssHeight) \/ 2)\n            } else {\n                this._canvasCssOffsetX = 0;\n                this._canvasCssOffsetY = 0\n            }\n            this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight())\n        }\n        _UpdateFullscreenScalingQuality(fullscreenMode) {\n            if (this._wantFullscreenScalingQuality === "high") {\n                this._drawWidth = this._canvasDeviceWidth;\n                this._drawHeight = this._canvasDeviceHeight;\n                this._fullscreenScalingQuality = "high"\n            } else {\n                let viewportWidth, viewportHeight;\n                if (this.GetCurrentFullscreenMode() === "off") {\n                    viewportWidth = this._runtime.GetViewportWidth();\n                    viewportHeight = this._runtime.GetViewportHeight()\n                } else {\n                    viewportWidth = this._runtime.GetOriginalViewportWidth();\n                    viewportHeight = this._runtime.GetOriginalViewportHeight()\n                }\n                if (this._canvasDeviceWidth < viewportWidth || this._canvasDeviceHeight < viewportHeight) {\n                    this._drawWidth = this._canvasDeviceWidth;\n                    this._drawHeight = this._canvasDeviceHeight;\n                    this._fullscreenScalingQuality = "high"\n                } else {\n                    this._drawWidth = viewportWidth;\n                    this._drawHeight = viewportHeight;\n                    this._fullscreenScalingQuality = "low";\n                    if (fullscreenMode === "scale-inner") {\n                        const originalAspectRatio = viewportWidth \/ viewportHeight;\n                        const currentAspectRatio = this._windowInnerWidth \/ this._windowInnerHeight;\n                        if (currentAspectRatio < originalAspectRatio)\n                            this._drawWidth = this._drawHeight * currentAspectRatio;\n                        else if (currentAspectRatio > originalAspectRatio)\n                            this._drawHeight = this._drawWidth \/ currentAspectRatio\n                    } else if (fullscreenMode === "scale-outer") {\n                        const originalAspectRatio = viewportWidth \/ viewportHeight;\n                        const currentAspectRatio = this._windowInnerWidth \/ this._windowInnerHeight;\n                        if (currentAspectRatio > originalAspectRatio)\n                            this._drawWidth = this._drawHeight * currentAspectRatio;\n                        else if (currentAspectRatio < originalAspectRatio)\n                            this._drawHeight = this._drawWidth \/ currentAspectRatio\n                    }\n                }\n            }\n        }\n        GetRuntime() {\n            return this._runtime\n        }\n        GetCanvas() {\n            return this._canvas\n        }\n        GetEffectChainManager() {\n            return this._effectChainManager\n        }\n        IsDocumentFullscreen() {\n            return this._isDocumentFullscreen\n        }\n        SetFullscreenMode(m) {\n            if (!VALID_FULLSCREEN_MODES.has(m))\n                throw new Error("invalid fullscreen mode");\n            this._fullscreenMode = m;\n            const layoutManager = this._runtime.GetLayoutManager();\n            layoutManager.SetAllLayerProjectionChanged();\n            layoutManager.SetAllLayerMVChanged()\n        }\n        GetFullscreenMode() {\n            return this._fullscreenMode\n        }\n        SetDocumentFullscreenMode(m) {\n            if (!VALID_FULLSCREEN_MODES.has(m))\n                throw new Error("invalid fullscreen mode");\n            this._documentFullscreenMode = m;\n            const layoutManager = this._runtime.GetLayoutManager();\n            layoutManager.SetAllLayerProjectionChanged();\n            layoutManager.SetAllLayerMVChanged()\n        }\n        GetDocumentFullscreenMode() {\n            return this._documentFullscreenMode\n        }\n        GetCurrentFullscreenMode() {\n            if (this.IsDocumentFullscreen())\n                return this.GetDocumentFullscreenMode();\n            else\n                return this.GetFullscreenMode()\n        }\n        SetFullscreenScalingQuality(q) {\n            if (!VALID_FULLSCREEN_SCALING_QUALITIES.has(q))\n                throw new Error("invalid fullscreen scaling quality");\n            this._wantFullscreenScalingQuality = q;\n            this._runtime.GetLayoutManager().SetAllLayerProjectionChanged()\n        }\n        GetSetFullscreenScalingQuality() {\n            return this._wantFullscreenScalingQuality\n        }\n        GetCurrentFullscreenScalingQuality() {\n            return this._fullscreenScalingQuality\n        }\n        static _FullscreenModeNumberToString(n) {\n            switch (n) {\n            case 0:\n                return "off";\n            case 1:\n                return "crop";\n            case 2:\n                return "scale-inner";\n            case 3:\n                return "scale-outer";\n            case 4:\n                return "letterbox-scale";\n            case 5:\n                return "letterbox-integer-scale";\n            default:\n                throw new Error("invalid fullscreen mode");\n            }\n        }\n        GetLastWidth() {\n            return this._windowInnerWidth\n        }\n        GetLastHeight() {\n            return this._windowInnerHeight\n        }\n        GetDrawWidth() {\n            return this._drawWidth\n        }\n        GetDrawHeight() {\n            return this._drawHeight\n        }\n        SetMipmapsEnabled(e) {\n            this._enableMipmaps = !!e\n        }\n        _SetTextureAnisotropy(a) {\n            this._textureAnisotropy = a\n        }\n        GetTextureAnisotropy() {\n            return this._textureAnisotropy\n        }\n        IsRendererContextLost() {\n            return this.GetRenderer().IsContextLost()\n        }\n        _OnWebGLContextLost(e) {\n            console.log("[Construct] WebGL context lost");\n            e.preventDefault();\n            this._availableAdditionalRenderTargets = [];\n            this._usedAdditionalRenderTargets.clear();\n            this._webglRenderer.OnContextLost();\n            this._runtime._OnWebGLContextLost()\n        }\n        async _OnWebGLContextRestored(e) {\n            await this._webglRenderer.OnContextRestored();\n            await this._LoadWebGLShaderPrograms();\n            for (const effectList of this._runtime._GetAllEffectLists()) {\n                for (const effectType of effectList.GetAllEffectTypes())\n                    effectType._InitRenderer(this._webglRenderer);\n                effectList._InitRenderer(this._webglRenderer)\n            }\n            await this._runtime._OnWebGLContextRestored();\n            console.log("[Construct] WebGL context restored")\n        }\n        GetWebGLRenderer() {\n            return this._webglRenderer\n        }\n        GetWebGPURenderer() {\n            return this._webgpuRenderer\n        }\n        GetRenderer() {\n            return this._webgpuRenderer || this._webglRenderer\n        }\n        GetRenderScale() {\n            if (this._fullscreenScalingQuality === "low")\n                return 1 \/ this._runtime.GetDevicePixelRatio();\n            return this.GetDisplayScale()\n        }\n        GetDisplayScale() {\n            const fullscreenMode = this.GetCurrentFullscreenMode();\n            if (fullscreenMode === "off" || fullscreenMode === "crop")\n                return 1;\n            const originalViewportWidth = this._runtime.GetOriginalViewportWidth();\n            const originalViewportHeight = this._runtime.GetOriginalViewportHeight();\n            const originalAspectRatio = originalViewportWidth \/ originalViewportHeight;\n            const currentAspectRatio = this._canvasDeviceWidth \/ this._canvasDeviceHeight;\n            if (fullscreenMode !== "scale-inner" && currentAspectRatio > originalAspectRatio || fullscreenMode === "scale-inner" && currentAspectRatio < originalAspectRatio)\n                return this._canvasCssHeight \/ originalViewportHeight;\n            else\n                return this._canvasCssWidth \/ originalViewportWidth\n        }\n        GetEffectLayerScaleParam() {\n            if (this.GetCurrentFullscreenScalingQuality() === "low")\n                return 1;\n            else\n                return this.GetDisplayScale()\n        }\n        GetEffectDevicePixelRatioParam() {\n            if (this.GetCurrentFullscreenScalingQuality() === "low")\n                return 1;\n            else\n                return this._runtime.GetDevicePixelRatio()\n        }\n        SetDeviceTransformOffset(x, y) {\n            this._deviceTransformOffX = x;\n            this._deviceTransformOffY = y\n        }\n        SetDeviceTransform(renderer, w, h, updateProjection=true) {\n            w = w || this._drawWidth;\n            h = h || this._drawHeight;\n            const scrollX = w \/ 2 + this._deviceTransformOffX;\n            const scrollY = h \/ 2 + this._deviceTransformOffY;\n            if (updateProjection) {\n                let projectionMatrix = this.GetDefaultProjectionMatrix();\n                if (w !== this._drawWidth || h !== this._drawHeight) {\n                    renderer.CalculatePerspectiveMatrix(tempProjection, w \/ h);\n                    projectionMatrix = tempProjection\n                }\n                renderer.SetProjectionMatrix(projectionMatrix)\n            }\n            const tempMat4 = renderer.CalculateLookAtModelView2(scrollX, scrollY, renderer.GetDefaultCameraZ(h), scrollX, scrollY, 0, h);\n            renderer.SetModelViewMatrix(tempMat4)\n        }\n        SetCssTransform(renderer, updateProjection=true) {\n            const width = this.GetCssWidth();\n            const height = this.GetCssHeight();\n            const scrollX = width \/ 2;\n            const scrollY = height \/ 2;\n            if (updateProjection)\n                renderer.SetProjectionMatrix(this.GetDefaultProjectionMatrix());\n            const tempMat4 = renderer.CalculateLookAtModelView2(scrollX, scrollY, renderer.GetDefaultCameraZ(height), scrollX, scrollY, 0, height);\n            renderer.SetModelViewMatrix(tempMat4)\n        }\n        GetDeviceWidth() {\n            return this._canvasDeviceWidth\n        }\n        GetDeviceHeight() {\n            return this._canvasDeviceHeight\n        }\n        GetCssWidth() {\n            return this._canvasCssWidth\n        }\n        GetCssHeight() {\n            return this._canvasCssHeight\n        }\n        GetCanvasClientX() {\n            return this._canvasCssOffsetX\n        }\n        GetCanvasClientY() {\n            return this._canvasCssOffsetY\n        }\n        GetAdditionalRenderTarget(opts) {\n            opts.depth = this._runtime.Uses3DFeatures();\n            const arr = this._availableAdditionalRenderTargets;\n            const useIndex = arr.findIndex(rt => rt.IsCompatibleWithOptions(opts));\n            let ret;\n            if (useIndex !== -1) {\n                ret = arr[useIndex];\n                arr.splice(useIndex, 1)\n            } else\n                ret = this.GetRenderer().CreateRenderTarget(opts);\n            this._usedAdditionalRenderTargets.add(ret);\n            return ret\n        }\n        ReleaseAdditionalRenderTarget(renderTarget) {\n            if (!this._usedAdditionalRenderTargets.has(renderTarget))\n                throw new Error("render target not in use");\n            this._usedAdditionalRenderTargets.delete(renderTarget);\n            this._availableAdditionalRenderTargets.push(renderTarget)\n        }\n        GetEffectCompositorRenderTarget() {\n            const opts = {\n                sampling: this._runtime.GetSampling()\n            };\n            if (this.GetCurrentFullscreenScalingQuality() === "low") {\n                opts.width = this.GetDrawWidth();\n                opts.height = this.GetDrawHeight()\n            }\n            return this.GetAdditionalRenderTarget(opts)\n        }\n        ReleaseEffectCompositorRenderTarget(renderTarget) {\n            this.ReleaseAdditionalRenderTarget(renderTarget)\n        }\n        *activeLayersGpuProfiles() {\n            for (const layout of this._runtime.GetLayoutManager().runningLayouts())\n                for (const layer of layout.GetLayers()) {\n                    const p = this._layersGpuProfile.get(layer);\n                    if (p)\n                        yield p\n                }\n        }\n        GetLayerTimingsBuffer(layer) {\n            if (!this.GetRenderer().SupportsGPUProfiling())\n                return null;\n            let p = this._layersGpuProfile.get(layer);\n            if (!p) {\n                p = {\n                    name: layer.GetName(),\n                    timingsBuffer: C3.New(C3.Gfx.WebGLQueryResultBuffer, this._webglRenderer),\n                    curUtilisation: 0,\n                    lastUtilisation: 0\n                };\n                this._layersGpuProfile.set(layer, p)\n            }\n            return p.timingsBuffer\n        }\n        _Update1sFrameRange() {\n            const renderer = this.GetRenderer();\n            if (!renderer.SupportsGPUProfiling())\n                return;\n            if (this._gpuTimeEndFrame === 0) {\n                this._gpuTimeEndFrame = renderer.GetFrameNumber();\n                this._gpuCurUtilisation = NaN;\n                for (const p of this.activeLayersGpuProfiles())\n                    p.curUtilisation = NaN\n            }\n        }\n        _UpdateTick() {\n            if (this._webglRenderer && this._webglRenderer.SupportsGPUProfiling())\n                this._UpdateTick_WebGL();\n            if (this._webgpuRenderer && this._webgpuRenderer.SupportsGPUProfiling())\n                this._UpdateTick_WebGPU()\n        }\n        _UpdateTick_WebGL() {\n            if (!isNaN(this._gpuCurUtilisation))\n                return;\n            this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame);\n            if (isNaN(this._gpuCurUtilisation))\n                return;\n            if (this._runtime.IsDebug())\n                for (const p of this.activeLayersGpuProfiles()) {\n                    p.curUtilisation = p.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame);\n                    if (isNaN(p.curUtilisation))\n                        return\n                }\n            this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame);\n            this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1);\n            if (this._runtime.IsDebug()) {\n                for (const p of this.activeLayersGpuProfiles()) {\n                    p.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame);\n                    p.lastUtilisation = Math.min(p.curUtilisation, 1)\n                }\n                self.C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()])\n            }\n            this._gpuTimeStartFrame = this._gpuTimeEndFrame;\n            this._gpuTimeEndFrame = 0\n        }\n        GetGPUFrameTimingsBuffer() {\n            return this._gpuFrameTimingsBuffer\n        }\n        _UpdateTick_WebGPU() {\n            if (this._gpuTimeEndFrame === 0)\n                return;\n            for (let frameNumber = this._gpuTimeStartFrame; frameNumber < this._gpuTimeEndFrame; ++frameNumber) {\n                const frameTiming = this._webgpuFrameTimings.get(frameNumber);\n                if (frameTiming && !frameTiming.HasResult())\n                    return\n            }\n            const layout = this._runtime.GetMainRunningLayout();\n            const profileResults = C3.MakeFilledArray(layout.GetLayerCount() + 1, 0);\n            for (let frameNumber = this._gpuTimeStartFrame; frameNumber < this._gpuTimeEndFrame; ++frameNumber) {\n                const frameTiming = this._webgpuFrameTimings.get(frameNumber);\n                if (!frameTiming)\n                    continue;\n                const results = frameTiming.GetResult();\n                for (let i = 0, len = Math.min(profileResults.length, results.length \/ 2); i < len; ++i) {\n                    const start64 = results[i * 2];\n                    const end64 = results[i * 2 + 1];\n                    if (Number(start64) === 0 || Number(end64) === 0) {\n                        profileResults[i] = NaN;\n                        continue\n                    }\n                    const diff64 = end64 - start64;\n                    const duration = Number(diff64) \/ 1E9;\n                    profileResults[i] += duration\n                }\n            }\n            this._gpuLastUtilisation = C3.clamp(profileResults[0], 0, 1);\n            if (this._runtime.IsDebug()) {\n                const layerProfiles = [];\n                const layers = layout.GetLayers();\n                for (let i = 0, len = Math.min(layers.length, profileResults.length - 1); i < len; ++i)\n                    layerProfiles.push({\n                        name: layers[i].GetName(),\n                        lastUtilisation: C3.clamp(profileResults[i + 1], 0, 1)\n                    });\n                self.C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, layerProfiles)\n            }\n            for (let frameNumber = this._gpuTimeStartFrame; frameNumber < this._gpuTimeEndFrame; ++frameNumber)\n                this._webgpuFrameTimings.delete(frameNumber);\n            this._gpuTimeStartFrame = this._gpuTimeEndFrame;\n            this._gpuTimeEndFrame = 0\n        }\n        _AddWebGPUFrameTiming(frameTiming) {\n            this._webgpuFrameTimings.set(this._webgpuRenderer.GetFrameNumber(), frameTiming)\n        }\n        GetGPUUtilisation() {\n            return this._gpuLastUtilisation\n        }\n        SnapshotCanvas(format, quality, x, y, width, height) {\n            this._snapshotFormat = format;\n            this._snapshotQuality = quality;\n            this._snapshotArea.setWH(x, y, width, height);\n            if (this._snapshotPromise)\n                return this._snapshotPromise;\n            this._snapshotPromise = new Promise(resolve => {\n                this._snapshotResolve = resolve\n            }\n            );\n            return this._snapshotPromise\n        }\n        _MaybeTakeSnapshot() {\n            if (!this._snapshotFormat)\n                return;\n            let canvas = this._canvas;\n            const snapArea = this._snapshotArea;\n            const x = C3.clamp(Math.floor(snapArea.getLeft()), 0, canvas.width);\n            const y = C3.clamp(Math.floor(snapArea.getTop()), 0, canvas.height);\n            let w = snapArea.width();\n            if (w === 0)\n                w = canvas.width - x;\n            else\n                w = C3.clamp(Math.floor(w), 0, canvas.width - x);\n            let h = snapArea.height();\n            if (h === 0)\n                h = canvas.height - y;\n            else\n                h = C3.clamp(Math.floor(h), 0, canvas.height - y);\n            if ((x !== 0 || y !== 0 || w !== canvas.width || h !== canvas.height) && (w > 0 && h > 0)) {\n                canvas = C3.CreateCanvas(w, h);\n                const ctx = canvas.getContext("2d");\n                ctx.drawImage(this._canvas, x, y, w, h, 0, 0, w, h)\n            }\n            C3.CanvasToBlob(canvas, this._snapshotFormat, this._snapshotQuality).then(blob => {\n                this._snapshotUrl = URL.createObjectURL(blob);\n                this._snapshotPromise = null;\n                this._snapshotResolve(this._snapshotUrl)\n            }\n            );\n            this._snapshotFormat = "";\n            this._snapshotQuality = 1\n        }\n        GetCanvasSnapshotUrl() {\n            return this._snapshotUrl\n        }\n        SetIsPastingToDrawingCanvas(p) {\n            if (p)\n                this._isPastingToDrawingCanvas++;\n            else\n                this._isPastingToDrawingCanvas--\n        }\n        IsPastingToDrawingCanvas() {\n            return this._isPastingToDrawingCanvas > 0\n        }\n        InitLoadingScreen(loaderStyle) {\n            if (!this._webglRenderer)\n                return;\n            if (loaderStyle === 2) {\n                this._percentText = C3.New(C3.Gfx.RendererText, this.GetRenderer());\n                this._percentText.SetIsAsync(false);\n                this._percentText.SetFontName("Arial");\n                this._percentText.SetFontSize(16);\n                this._percentText.SetHorizontalAlignment("center");\n                this._percentText.SetVerticalAlignment("center");\n                this._percentText.SetSize(PERCENTTEXT_WIDTH, PERCENTTEXT_HEIGHT)\n            } else if (loaderStyle === 0) {\n                const loadingLogoAsset = this._runtime.GetLoadingLogoAsset();\n                if (loadingLogoAsset)\n                    loadingLogoAsset.LoadStaticTexture(this._webglRenderer).catch(err => console.warn(`[C3 runtime] Failed to create texture for loading logo: `, err))\n            } else if (loaderStyle === 4) {\n                this._LoadSvgSplashImage("splash-images\/splash-logo.svg").then(tex => {\n                    if (this._splashState === "done")\n                        this._webglRenderer.DeleteTexture(tex);\n                    else\n                        this._splashTextures.logo = tex\n                }\n                ).catch(err => console.warn("Failed to load splash image: ", err));\n                this._LoadBitmapSplashImage("splash-images\/splash-poweredby-512.png").then(tex => {\n                    if (this._splashState === "done")\n                        this._webglRenderer.DeleteTexture(tex);\n                    else\n                        this._splashTextures.powered = tex\n                }\n                ).catch(err => console.warn("Failed to load splash image: ", err));\n                this._LoadBitmapSplashImage("splash-images\/splash-website-512.png").then(tex => {\n                    if (this._splashState === "done")\n                        this._webglRenderer.DeleteTexture(tex);\n                    else\n                        this._splashTextures.website = tex\n                }\n                ).catch(err => console.warn("Failed to load splash image: ", err))\n            }\n        }\n        async _LoadSvgSplashImage(url) {\n            url = (new URL(url,this._runtime.GetRuntimeBaseURL())).toString();\n            const blob = await C3.FetchBlob(url);\n            const drawable = await this._runtime.RasterSvgImage(blob, 2048, 2048);\n            return await this._webglRenderer.CreateStaticTextureAsync(drawable, {\n                mipMapQuality: "high"\n            })\n        }\n        async _LoadBitmapSplashImage(url) {\n            url = (new URL(url,this._runtime.GetRuntimeBaseURL())).toString();\n            const blob = await C3.FetchBlob(url);\n            return await this._webglRenderer.CreateStaticTextureAsync(blob, {\n                mipMapQuality: "high"\n            })\n        }\n        HideCordovaSplashScreen() {\n            this._runtime.PostComponentMessageToDOM("runtime", "hide-cordova-splash")\n        }\n        StartLoadingScreen() {\n            this._loaderStartTime = Date.now();\n            this._runtime.Dispatcher().addEventListener("loadingprogress", this._loadingprogress_handler);\n            this._rafId = requestAnimationFrame( () => this._DrawLoadingScreen());\n            const loaderStyle = this._runtime.GetLoaderStyle();\n            if (loaderStyle !== 3)\n                this.HideCordovaSplashScreen()\n        }\n        async EndLoadingScreen() {\n            if (!this._webglRenderer)\n                return;\n            this._loadingProgress = 1;\n            const loaderStyle = this._runtime.GetLoaderStyle();\n            if (loaderStyle === 4)\n                await this._splashDonePromise;\n            this._splashDoneResolve = null;\n            this._splashDonePromise = null;\n            if (this._rafId !== -1) {\n                cancelAnimationFrame(this._rafId);\n                this._rafId = -1\n            }\n            this._runtime.Dispatcher().removeEventListener("loadingprogress", this._loadingprogress_handler);\n            this._loadingprogress_handler = null;\n            if (this._percentText) {\n                this._percentText.Release();\n                this._percentText = null\n            }\n            this._runtime.ReleaseLoadingLogoAsset();\n            this._webglRenderer.Start();\n            if (this._splashTextures.logo) {\n                this._webglRenderer.DeleteTexture(this._splashTextures.logo);\n                this._splashTextures.logo = null\n            }\n            if (this._splashTextures.powered) {\n                this._webglRenderer.DeleteTexture(this._splashTextures.powered);\n                this._splashTextures.powered = null\n            }\n            if (this._splashTextures.website) {\n                this._webglRenderer.DeleteTexture(this._splashTextures.website);\n                this._splashTextures.website = null\n            }\n            this._webglRenderer.ClearRgba(0, 0, 0, 0);\n            this._webglRenderer.Finish();\n            this._splashState = "done";\n            this._gpuTimeStartFrame = this._webglRenderer.GetFrameNumber();\n            if (loaderStyle === 3)\n                this.HideCordovaSplashScreen()\n        }\n        _DrawLoadingScreen() {\n            if (this._rafId === -1)\n                return;\n            const renderer = this._webglRenderer;\n            if (!renderer)\n                return;\n            renderer.Start();\n            this._rafId = -1;\n            const hasHadError = this._runtime.GetAssetManager().HasHadErrorLoading();\n            const loaderStyle = this._runtime.GetLoaderStyle();\n            if (loaderStyle !== 3) {\n                this.SetCssTransform(renderer);\n                renderer.ClearRgba(0, 0, 0, 0);\n                renderer.ResetColor();\n                renderer.SetTextureFillMode();\n                renderer.SetTexture(null)\n            }\n            if (loaderStyle === 0)\n                this._DrawProgressBarAndLogoLoadingScreen(hasHadError);\n            else if (loaderStyle === 1)\n                this._DrawProgressBarLoadingScreen(hasHadError, PROGRESSBAR_WIDTH, 0);\n            else if (loaderStyle === 2)\n                this._DrawPercentTextLoadingScreen(hasHadError);\n            else if (loaderStyle === 3)\n                C3.noop();\n            else if (loaderStyle === 4)\n                this._DrawSplashLoadingScreen(hasHadError);\n            else\n                throw new Error("invalid loader style");\n            renderer.Finish();\n            this._rafId = requestAnimationFrame( () => this._DrawLoadingScreen())\n        }\n        _DrawPercentTextLoadingScreen(hasHadError) {\n            if (hasHadError)\n                this._percentText.SetColorRgb(1, 0, 0);\n            else\n                this._percentText.SetColorRgb(.6, .6, .6);\n            this._percentText.SetText(Math.round(this._loadingProgress * 100) + "%");\n            const midX = this._canvasCssWidth \/ 2;\n            const midY = this._canvasCssHeight \/ 2;\n            const hw = PERCENTTEXT_WIDTH \/ 2;\n            const hh = PERCENTTEXT_HEIGHT \/ 2;\n            tempQuad.setRect(midX - hw, midY - hh, midX + hw, midY + hh);\n            this._webglRenderer.SetTexture(this._percentText.GetTexture());\n            this._webglRenderer.Quad3(tempQuad, this._percentText.GetTexRect())\n        }\n        _DrawProgressBarLoadingScreen(hasHadError, width, yOff) {\n            const renderer = this._webglRenderer;\n            const height = PROGRESSBAR_HEIGHT;\n            renderer.SetColorFillMode();\n            if (hasHadError)\n                renderer.SetColorRgba(1, 0, 0, 1);\n            else\n                renderer.SetColorRgba(.118, .565, 1, 1);\n            const midX = this._canvasCssWidth \/ 2;\n            const midY = this._canvasCssHeight \/ 2;\n            const hw = width \/ 2;\n            const hh = height \/ 2;\n            tempRect.setWH(midX - hw, midY - hh + yOff, Math.floor(width * this._loadingProgress), height);\n            renderer.Rect(tempRect);\n            tempRect.setWH(midX - hw, midY - hh + yOff, width, height);\n            tempRect.offset(-.5, -.5);\n            tempRect.inflate(.5, .5);\n            renderer.SetColorRgba(0, 0, 0, 1);\n            renderer.LineRect2(tempRect);\n            tempRect.inflate(1, 1);\n            renderer.SetColorRgba(1, 1, 1, 1);\n            renderer.LineRect2(tempRect)\n        }\n        _DrawProgressBarAndLogoLoadingScreen(hasHadError) {\n            const loadingLogoAsset = this._runtime.GetLoadingLogoAsset();\n            if (!loadingLogoAsset) {\n                this._DrawProgressBarLoadingScreen(hasHadError, PROGRESSBAR_WIDTH, 0);\n                return\n            }\n            const logoTexture = loadingLogoAsset.GetTexture();\n            if (!logoTexture) {\n                this._DrawProgressBarLoadingScreen(hasHadError, PROGRESSBAR_WIDTH, 0);\n                return\n            }\n            const logoW = logoTexture.GetWidth();\n            const logoH = logoTexture.GetHeight();\n            const midX = this._canvasCssWidth \/ 2;\n            const midY = this._canvasCssHeight \/ 2;\n            const hw = logoW \/ 2;\n            const hh = logoH \/ 2;\n            tempQuad.setRect(midX - hw, midY - hh, midX + hw, midY + hh);\n            this._webglRenderer.SetTexture(logoTexture);\n            this._webglRenderer.Quad(tempQuad);\n            this._DrawProgressBarLoadingScreen(hasHadError, logoW, hh + 16)\n        }\n        _DrawSplashLoadingScreen(hasHadError) {\n            const renderer = this._webglRenderer;\n            const logoTex = this._splashTextures.logo;\n            const poweredTex = this._splashTextures.powered;\n            const websiteTex = this._splashTextures.website;\n            const nowTime = Date.now();\n            if (this._splashFrameNumber === 0)\n                this._loaderStartTime = nowTime;\n            const allowQuickSplash = this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova();\n            const splashAfterFadeOutWait = allowQuickSplash ? 0 : SPLASH_AFTER_FADEOUT_WAIT_TIME;\n            const splashMinDisplayTime = allowQuickSplash ? 0 : SPLASH_MIN_DISPLAY_TIME;\n            let a = 1;\n            if (this._splashState === "fade-in")\n                a = Math.min((nowTime - this._loaderStartTime) \/ SPLASH_FADE_DURATION, 1);\n            else if (this._splashState === "fade-out")\n                a = Math.max(1 - (nowTime - this._splashFadeOutStartTime) \/ SPLASH_FADE_DURATION, 0);\n            renderer.SetColorFillMode();\n            renderer.SetColorRgba(.231 * a, .251 * a, .271 * a, a);\n            tempRect.set(0, 0, this._canvasCssWidth, this._canvasCssHeight);\n            renderer.Rect(tempRect);\n            const w = Math.ceil(this._canvasCssWidth);\n            const h = Math.ceil(this._canvasCssHeight);\n            let drawW, drawH;\n            if (this._canvasCssHeight > 256) {\n                renderer.SetColorRgba(.302 * a, .334 * a, .365 * a, a);\n                drawW = w;\n                drawH = Math.max(h * .005, 2);\n                tempRect.setWH(0, h * .8 - drawH \/ 2, drawW, drawH);\n                renderer.Rect(tempRect);\n                if (hasHadError)\n                    renderer.SetColorRgba(a, 0, 0, a);\n                else\n                    renderer.SetColorRgba(.161 * a, .953 * a, .816 * a, a);\n                drawW = w * this._loadingProgress;\n                tempRect.setWH(w * .5 - drawW \/ 2, h * .8 - drawH \/ 2, drawW, drawH);\n                renderer.Rect(tempRect);\n                renderer.SetColorRgba(a, a, a, a);\n                renderer.SetTextureFillMode();\n                if (poweredTex) {\n                    drawW = C3.clamp(h * .22, 105, w * .6) * 1.5;\n                    drawH = drawW \/ 8;\n                    tempRect.setWH(w * .5 - drawW \/ 2, h * .2 - drawH \/ 2, drawW, drawH);\n                    renderer.SetTexture(poweredTex);\n                    renderer.Rect(tempRect)\n                }\n                if (logoTex) {\n                    drawW = Math.min(h * .395, w * .95);\n                    drawH = drawW;\n                    tempRect.setWH(w * .5 - drawW \/ 2, h * .485 - drawH \/ 2, drawW, drawH);\n                    renderer.SetTexture(logoTex);\n                    renderer.Rect(tempRect)\n                }\n                if (websiteTex) {\n                    drawW = C3.clamp(h * .22, 105, w * .6) * 1.5;\n                    drawH = drawW \/ 8;\n                    tempRect.setWH(w * .5 - drawW \/ 2, h * .868 - drawH \/ 2, drawW, drawH);\n                    renderer.SetTexture(websiteTex);\n                    renderer.Rect(tempRect)\n                }\n            } else {\n                renderer.SetColorRgba(.302 * a, .334 * a, .365 * a, a);\n                drawW = w;\n                drawH = Math.max(h * .005, 2);\n                tempRect.setWH(0, h * .85 - drawH \/ 2, drawW, drawH);\n                renderer.Rect(tempRect);\n                if (hasHadError)\n                    renderer.SetColorRgba(a, 0, 0, a);\n                else\n                    renderer.SetColorRgba(.161 * a, .953 * a, .816 * a, a);\n                drawW = w * this._loadingProgress;\n                tempRect.setWH(w * .5 - drawW \/ 2, h * .85 - drawH \/ 2, drawW, drawH);\n                renderer.Rect(tempRect);\n                renderer.SetColorRgba(a, a, a, a);\n                renderer.SetTextureFillMode();\n                if (logoTex) {\n                    drawW = h * .55;\n                    drawH = drawW;\n                    tempRect.setWH(w * .5 - drawW \/ 2, h * .45 - drawH \/ 2, drawW, drawH);\n                    renderer.SetTexture(logoTex);\n                    renderer.Rect(tempRect)\n                }\n            }\n            this._splashFrameNumber++;\n            if (this._splashState === "fade-in" && nowTime - this._loaderStartTime >= SPLASH_FADE_DURATION && this._splashFrameNumber >= 2) {\n                this._splashState = "wait";\n                this._splashFadeInFinishTime = nowTime\n            }\n            if (this._splashState === "wait" && nowTime - this._splashFadeInFinishTime >= splashMinDisplayTime && this._loadingProgress >= 1) {\n                this._splashState = "fade-out";\n                this._splashFadeOutStartTime = nowTime\n            }\n            if (this._splashState === "fade-out" && nowTime - this._splashFadeOutStartTime >= SPLASH_FADE_DURATION + splashAfterFadeOutWait || allowQuickSplash && this._loadingProgress >= 1 && nowTime - this._loaderStartTime < 500)\n                this._splashDoneResolve()\n        }\n    }\n    ;\n\n}\n\n\/\/ runtime.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const C3Debugger = self.C3Debugger;\n    const assert = self.assert;\n    const DEFAULT_RUNTIME_OPTS = {\n        "messagePort": null,\n        "runtimeBaseUrl": "",\n        "headless": false,\n        "hasDom": true,\n        "isInWorker": false,\n        "useAudio": true,\n        "projectData": "",\n        "exportType": ""\n    };\n    let ife = true;\n    C3.Runtime = class C3Runtime extends C3.DefendedBase {\n        constructor(opts) {\n            opts = Object.assign({}, DEFAULT_RUNTIME_OPTS, opts);\n            super();\n            this._messagePort = opts["messagePort"];\n            this._runtimeBaseUrl = opts["runtimeBaseUrl"];\n            this._previewUrl = opts["previewUrl"];\n            this._isHeadless = !!opts["headless"];\n            this._hasDom = !!opts["hasDom"];\n            this._isInWorker = !!opts["isInWorker"];\n            ife = opts["ife"];\n            this._useAudio = !!opts["useAudio"];\n            this._exportType = opts["exportType"];\n            this._isiOSCordova = !!opts["isiOSCordova"];\n            this._isiOSWebView = !!opts["isiOSWebView"];\n            this._isFBInstantAvailable = !!opts["isFBInstantAvailable"];\n            this._opusWasmScriptUrl = opts["opusWasmScriptUrl"];\n            this._opusWasmBinaryUrl = opts["opusWasmBinaryUrl"];\n            this._isDebug = !!(this._exportType === "preview" && opts["isDebug"]);\n            this._breakpointsEnabled = this._isDebug;\n            this._isDebugging = this._isDebug;\n            this._debuggingDisabled = 0;\n            this._additionalLoadPromises = [];\n            this._additionalCreatePromises = [];\n            this._isUsingCreatePromises = false;\n            this._projectName = "";\n            this._projectVersion = "";\n            this._projectUniqueId = "";\n            this._appId = "";\n            this._originalViewportWidth = 0;\n            this._originalViewportHeight = 0;\n            this._devicePixelRatio = self.devicePixelRatio;\n            this._parallaxXorigin = 0;\n            this._parallaxYorigin = 0;\n            this._viewportWidth = 0;\n            this._viewportHeight = 0;\n            this._loaderStyle = 0;\n            this._usesLoaderLayout = false;\n            this._isLoading = true;\n            this._usesAnyBackgroundBlending = false;\n            this._usesAnyCrossSampling = false;\n            this._usesAnyDepthSampling = false;\n            this._loadingLogoAsset = null;\n            this._assetManager = C3.New(C3.AssetManager, this, opts);\n            this._layoutManager = C3.New(C3.LayoutManager, this);\n            this._eventSheetManager = C3.New(C3.EventSheetManager, this);\n            this._pluginManager = C3.New(C3.PluginManager, this);\n            this._collisionEngine = C3.New(C3.CollisionEngine, this);\n            this._timelineManager = C3.New(C3.TimelineManager, this);\n            this._transitionManager = C3.New(C3.TransitionManager, this);\n            this._templateManager = C3.New(C3.TemplateManager, this);\n            this._allObjectClasses = [];\n            this._objectClassesByName = new Map;\n            this._objectClassesBySid = new Map;\n            this._familyCount = 0;\n            this._allContainers = [];\n            this._allEffectLists = [];\n            this._currentLayoutStack = [];\n            this._instancesPendingCreate = [];\n            this._instancesPendingDestroy = new Map;\n            this._hasPendingInstances = false;\n            this._isFlushingPendingInstances = false;\n            this._objectCount = 0;\n            this._nextUid = 0;\n            this._instancesByUid = new Map;\n            this._instancesToReleaseAtEndOfTick = new Set;\n            this._instancesToReleaseAffectedObjectClasses = new Set;\n            this._objectReferenceTable = [];\n            this._jsPropNameTable = [];\n            this._canvasManager = null;\n            this._uses3dFeatures = false;\n            this._framerateMode = "vsync";\n            this._compositingMode = "standard";\n            this._sampling = "trilinear";\n            this._isPixelRoundingEnabled = false;\n            this._needRender = true;\n            this._pauseOnBlur = false;\n            this._isPausedOnBlur = false;\n            this._exportToVideo = null;\n            this._tickCallbacks = {\n                normal: timestamp => {\n                    this._rafId = -1;\n                    this._ruafId = -1;\n                    this.Tick(timestamp)\n                }\n                ,\n                tickOnly: timestamp => {\n                    this._ruafId = -1;\n                    this.Tick(timestamp, false, "skip-render")\n                }\n                ,\n                renderOnly: () => {\n                    this._rafId = -1;\n                    this.Render()\n                }\n            };\n            this._rafId = -1;\n            this._ruafId = -1;\n            this._tickCount = 0;\n            this._tickCountNoSave = 0;\n            this._hasStarted = false;\n            this._isInTick = false;\n            this._hasStartedTicking = false;\n            this._isLayoutFirstTick = true;\n            this._suspendCount = 0;\n            this._scheduleTriggersThrottle = new C3.PromiseThrottle(1);\n            this._randomNumberCallback = () => Math.random();\n            this._startTime = 0;\n            this._lastTickTime = 0;\n            this._dt1 = 0;\n            this._dt = 0;\n            this._timeScale = 1;\n            this._minimumFramerate = 30;\n            this._gameTime = C3.New(C3.KahanSum);\n            this._gameTimeRaw = C3.New(C3.KahanSum);\n            this._wallTime = C3.New(C3.KahanSum);\n            this._instanceTimes = new Map;\n            this._fpsFrameCount = -1;\n            this._fpsLastTime = 0;\n            this._fps = 0;\n            this._mainThreadTimeCounter = 0;\n            this._mainThreadTime = 0;\n            this._isLoadingState = false;\n            this._saveToSlotName = "";\n            this._loadFromSlotName = "";\n            this._loadFromJson = null;\n            this._lastSaveJson = "";\n            this._projectStorage = null;\n            this._savegamesStorage = null;\n            this._dispatcher = C3.New(C3.Event.Dispatcher);\n            this._domEventHandlers = new Map;\n            this._pendingResponsePromises = new Map;\n            this._nextDomResponseId = 0;\n            this._didRequestDeviceOrientationEvent = false;\n            this._didRequestDeviceMotionEvent = false;\n            this._isReadyToHandleEvents = false;\n            this._waitingToHandleEvents = [];\n            this._eventObjects = {\n                "pretick": C3.New(C3.Event, "pretick", false),\n                "tick": C3.New(C3.Event, "tick", false),\n                "tick2": C3.New(C3.Event, "tick2", false),\n                "instancedestroy": C3.New(C3.Event, "instancedestroy", false),\n                "beforelayoutchange": C3.New(C3.Event, "beforelayoutchange", false),\n                "layoutchange": C3.New(C3.Event, "layoutchange", false)\n            };\n            this._eventObjects["instancedestroy"].instance = null;\n            this._userScriptDispatcher = C3.New(C3.Event.Dispatcher);\n            this._userScriptEventObjects = null;\n            this._behInstsToTick = C3.New(C3.RedBlackSet, C3.BehaviorInstance.SortByTickSequence);\n            this._behInstsToPostTick = C3.New(C3.RedBlackSet, C3.BehaviorInstance.SortByTickSequence);\n            this._behInstsToTick2 = C3.New(C3.RedBlackSet, C3.BehaviorInstance.SortByTickSequence);\n            this._jobScheduler = C3.New(C3.JobSchedulerRuntime, this, opts["jobScheduler"]);\n            if (opts["canvas"])\n                this._canvasManager = C3.New(C3.CanvasManager, this);\n            this._messagePort.onmessage = e => this["_OnMessageFromDOM"](e.data);\n            this.AddDOMComponentMessageHandler("runtime", "visibilitychange", e => this._OnVisibilityChange(e));\n            this.AddDOMComponentMessageHandler("runtime", "opus-decode", e => this._WasmDecodeWebMOpus(e["arrayBuffer"]));\n            this.AddDOMComponentMessageHandler("runtime", "get-remote-preview-status-info", () => this._GetRemotePreviewStatusInfo());\n            this.AddDOMComponentMessageHandler("runtime", "js-invoke-function", e => this._InvokeFunctionFromJS(e));\n            this.AddDOMComponentMessageHandler("runtime", "go-to-last-error-script", self["goToLastErrorScript"]);\n            this.AddDOMComponentMessageHandler("runtime", "offline-audio-render-completed", e => this._OnOfflineAudioRenderCompleted(e));\n            this._dispatcher.addEventListener("window-blur", e => this._OnWindowBlur(e));\n            this._dispatcher.addEventListener("window-focus", () => this._OnWindowFocus());\n            this._timelineManager.AddRuntimeListeners();\n            this._templateManager.AddRuntimeListeners();\n            this._iRuntime = null;\n            this._interfaceMap = new WeakMap;\n            this._commonScriptInterfaces = {\n                keyboard: null,\n                mouse: null,\n                touch: null\n            }\n        }\n        static Create(opts) {\n            return C3.New(C3.Runtime, opts)\n        }\n        Release() {\n            C3.clearArray(this._allObjectClasses);\n            this._objectClassesByName.clear();\n            this._objectClassesBySid.clear();\n            this._layoutManager.Release();\n            this._layoutManager = null;\n            this._eventSheetManager.Release();\n            this._eventSheetManager = null;\n            this._pluginManager.Release();\n            this._pluginManager = null;\n            this._assetManager.Release();\n            this._assetManager = null;\n            this._collisionEngine.Release();\n            this._collisionEngine = null;\n            this._timelineManager.Release();\n            this._timelineManager = null;\n            this._transitionManager.Release();\n            this._transitionManager = null;\n            this._templateManager.Release();\n            this._templateManager = null;\n            if (this._canvasManager) {\n                this._canvasManager.Release();\n                this._canvasManager = null\n            }\n            this._dispatcher.Release();\n            this._dispatcher = null;\n            this._tickEvent = null\n        }\n        ["_OnMessageFromDOM"](data) {\n            const type = data["type"];\n            if (type === "event")\n                this._OnEventFromDOM(data);\n            else if (type === "result")\n                this._OnResultFromDOM(data);\n            else\n                throw new Error(`unknown message \'${type}\'`);\n        }\n        _OnEventFromDOM(e) {\n            if (!this._isReadyToHandleEvents) {\n                this._waitingToHandleEvents.push(e);\n                return\n            }\n            const component = e["component"];\n            const handler = e["handler"];\n            const data = e["data"];\n            const dispatchOpts = e["dispatchOpts"];\n            const dispatchRuntimeEvent = !!(dispatchOpts && dispatchOpts["dispatchRuntimeEvent"]);\n            const dispatchUserScriptEvent = !!(dispatchOpts && dispatchOpts["dispatchUserScriptEvent"]);\n            const responseId = e["responseId"];\n            if (component === "runtime") {\n                if (dispatchRuntimeEvent) {\n                    const event = new C3.Event(handler);\n                    event.data = data;\n                    this._dispatcher.dispatchEventAndWaitAsyncSequential(event)\n                }\n                if (dispatchUserScriptEvent) {\n                    const event = new C3.Event(handler,true);\n                    for (const [key,value] of Object.entries(data))\n                        event[key] = value;\n                    this.DispatchUserScriptEvent(event)\n                }\n            }\n            const handlerMap = this._domEventHandlers.get(component);\n            if (!handlerMap) {\n                if (!dispatchRuntimeEvent && !dispatchUserScriptEvent)\n                    console.warn(`[Runtime] No DOM event handlers for component \'${component}\'`);\n                return\n            }\n            const func = handlerMap.get(handler);\n            if (!func) {\n                if (!dispatchRuntimeEvent && !dispatchUserScriptEvent)\n                    console.warn(`[Runtime] No DOM handler \'${handler}\' for component \'${component}\'`);\n                return\n            }\n            let ret = null;\n            try {\n                ret = func(data)\n            } catch (err) {\n                console.error(`Exception in \'${component}\' handler \'${handler}\':`, err);\n                if (responseId !== null)\n                    this._PostResultToDOM(responseId, false, "" + err);\n                return\n            }\n            if (responseId !== null)\n                if (ret && ret.then)\n                    ret.then(result => this._PostResultToDOM(responseId, true, result)).catch(err => {\n                        console.error(`Rejection from \'${component}\' handler \'${handler}\':`, err);\n                        this._PostResultToDOM(responseId, false, "" + err)\n                    }\n                    );\n                else\n                    this._PostResultToDOM(responseId, true, ret)\n        }\n        _PostResultToDOM(responseId, isOk, result) {\n            this._messagePort.postMessage({\n                "type": "result",\n                "responseId": responseId,\n                "isOk": isOk,\n                "result": result\n            })\n        }\n        _OnResultFromDOM(data) {\n            const responseId = data["responseId"];\n            const isOk = data["isOk"];\n            const result = data["result"];\n            const pendingPromise = this._pendingResponsePromises.get(responseId);\n            if (isOk)\n                pendingPromise.resolve(result);\n            else\n                pendingPromise.reject(result);\n            this._pendingResponsePromises.delete(responseId)\n        }\n        AddDOMComponentMessageHandler(component, handler, func) {\n            let handlerMap = this._domEventHandlers.get(component);\n            if (!handlerMap) {\n                handlerMap = new Map;\n                this._domEventHandlers.set(component, handlerMap)\n            }\n            if (handlerMap.has(handler))\n                throw new Error(`[Runtime] Component \'${component}\' already has handler \'${handler}\'`);\n            handlerMap.set(handler, func)\n        }\n        PostComponentMessageToDOM(component, handler, data) {\n            this._messagePort.postMessage({\n                "type": "event",\n                "component": component,\n                "handler": handler,\n                "data": data,\n                "responseId": null\n            })\n        }\n        PostComponentMessageToDOMAsync(component, handler, data) {\n            const responseId = this._nextDomResponseId++;\n            const ret = new Promise( (resolve, reject) => {\n                this._pendingResponsePromises.set(responseId, {\n                    resolve,\n                    reject\n                })\n            }\n            );\n            this._messagePort.postMessage({\n                "type": "event",\n                "component": component,\n                "handler": handler,\n                "data": data,\n                "responseId": responseId\n            });\n            return ret\n        }\n        PostToDebugger(data) {\n            if (!this.IsDebug())\n                throw new Error("not in debug mode");\n            this.PostComponentMessageToDOM("runtime", "post-to-debugger", data)\n        }\n        async Init(opts) {\n            if (this.IsDebug())\n                await C3Debugger.Init(this);\n            else if (self.C3Debugger)\n                self.C3Debugger.InitPreview(this);\n            const [o] = await Promise.all([this._assetManager.FetchJson("data.json"), this._MaybeLoadOpusDecoder(), this._jobScheduler.Init()]);\n            await this._LoadDataJson(o);\n            await this._InitialiseCanvas(opts);\n            if (!this.IsPreview())\n                console.info("Made with Construct, the game and app creator :: https:\/\/www.construct.net");\n            if (this.GetWebGLRenderer()) {\n                const webglRenderer = this.GetWebGLRenderer();\n                console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with WebGL ${webglRenderer.GetWebGLVersionNumber()} [${webglRenderer.GetUnmaskedRenderer()}] (${webglRenderer.IsDesynchronized() ? "desynchronized" : "standard"} compositing)`)\n            } else if (this.GetWebGPURenderer())\n                console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with experimental WebGPU`);\n            if (this.GetRenderer().HasMajorPerformanceCaveat())\n                console.warn("[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance.");\n            this._isReadyToHandleEvents = true;\n            for (const e of this._waitingToHandleEvents)\n                this._OnEventFromDOM(e);\n            C3.clearArray(this._waitingToHandleEvents);\n            if (this._canvasManager)\n                this._canvasManager.StartLoadingScreen();\n            for (const f of opts["runOnStartupFunctions"])\n                this._additionalLoadPromises.push(this._RunOnStartupFunction(f));\n            await Promise.all([this._assetManager.WaitForAllToLoad(), ...this._additionalLoadPromises]);\n            C3.clearArray(this._additionalLoadPromises);\n            if (this._assetManager.HasHadErrorLoading()) {\n                if (this._canvasManager)\n                    this._canvasManager.HideCordovaSplashScreen();\n                return\n            }\n            if (this._canvasManager)\n                await this._canvasManager.EndLoadingScreen();\n            await this._dispatcher.dispatchEventAndWaitAsync(new C3.Event("beforeruntimestart"));\n            await this.Start();\n            this._messagePort.postMessage({\n                "type": "runtime-ready"\n            });\n            return this\n        }\n        async _RunOnStartupFunction(f) {\n            try {\n                await f(this._iRuntime)\n            } catch (err) {\n                console.error("[C3 runtime] Error in runOnStartup function: ", err)\n            }\n        }\n        async _LoadDataJson(o) {\n            const projectData = o["project"];\n            this._projectName = projectData[0];\n            this._projectVersion = projectData[16];\n            this._projectUniqueId = projectData[31];\n            this._appId = projectData[38];\n            const loadingLogoFilename = projectData[39] || "loading-logo.png";\n            this._isPixelRoundingEnabled = !!projectData[9];\n            this._originalViewportWidth = this._viewportWidth = projectData[10];\n            this._originalViewportHeight = this._viewportHeight = projectData[11];\n            this._parallaxXorigin = this._originalViewportWidth \/ 2;\n            this._parallaxYorigin = this._originalViewportHeight \/ 2;\n            this._compositingMode = projectData[36];\n            this._framerateMode = projectData[37];\n            if (this._compositingMode === "low-latency" && this.IsAndroidWebView() && C3.Platform.BrowserVersionNumber <= 77) {\n                console.warn("[C3 runtime] Desynchronized (low-latency) compositing is enabled, but is disabled in the Android WebView <=77 due to crbug.com\/1008842. Reverting to synchronized (standard) compositing.");\n                this._compositingMode = "standard"\n            }\n            this._uses3dFeatures = !!projectData[40];\n            this._sampling = projectData[14];\n            this._usesAnyBackgroundBlending = projectData[15];\n            this._usesAnyCrossSampling = projectData[42];\n            this._usesAnyDepthSampling = projectData[17];\n            this._usesLoaderLayout = !!projectData[18];\n            this._loaderStyle = projectData[19];\n            this._nextUid = projectData[21];\n            this._pauseOnBlur = projectData[22];\n            const assetManager = this._assetManager;\n            assetManager._SetAudioFiles(projectData[7], projectData[25]);\n            assetManager._SetMediaSubfolder(projectData[8]);\n            assetManager._SetFontsSubfolder(projectData[32]);\n            assetManager._SetIconsSubfolder(projectData[28]);\n            assetManager._SetWebFonts(projectData[29]);\n            if (this._loaderStyle === 0) {\n                let url = "";\n                if (this.IsPreview()) {\n                    if (assetManager._HasLocalUrlBlob(loadingLogoFilename))\n                        url = assetManager.GetLocalUrlAsBlobUrl(loadingLogoFilename)\n                } else\n                    url = assetManager.GetIconsSubfolder() + loadingLogoFilename;\n                if (url)\n                    this._loadingLogoAsset = assetManager.LoadImage({\n                        url\n                    })\n            }\n            if (this._canvasManager) {\n                this._canvasManager.SetFullscreenMode(C3.CanvasManager._FullscreenModeNumberToString(projectData[12]));\n                this._canvasManager.SetFullscreenScalingQuality(projectData[23] ? "high" : "low");\n                this._canvasManager.SetMipmapsEnabled(projectData[24] !== 0);\n                this._canvasManager._SetGPUPowerPreference(projectData[34]);\n                this._canvasManager._SetTextureAnisotropy(projectData[41]);\n                this._canvasManager._SetWebGPUEnabled(projectData[13]);\n                this._canvasManager._SetZAxisScale(projectData[30]);\n                this._canvasManager._SetFieldOfView(projectData[26])\n            }\n            const exportToVideoOpts = projectData[43];\n            if (exportToVideoOpts)\n                await this._LoadExportToVideoData(exportToVideoOpts);\n            this._pluginManager.CreateSystemPlugin();\n            this._objectReferenceTable = self.C3_GetObjectRefTable();\n            for (const pluginData of projectData[2])\n                this._pluginManager.CreatePlugin(pluginData);\n            this._objectReferenceTable = self.C3_GetObjectRefTable();\n            this._LoadJsPropNameTable();\n            for (const objectClassData of projectData[3]) {\n                const objectClass = C3.ObjectClass.Create(this, this._allObjectClasses.length, objectClassData);\n                this._allObjectClasses.push(objectClass);\n                this._objectClassesByName.set(objectClass.GetName().toLowerCase(), objectClass);\n                this._objectClassesBySid.set(objectClass.GetSID(), objectClass)\n            }\n            for (const familyData of projectData[4]) {\n                const familyType = this._allObjectClasses[familyData[0]];\n                familyType._LoadFamily(familyData)\n            }\n            for (const containerData of projectData[27]) {\n                const containerTypes = containerData.map(index => this._allObjectClasses[index]);\n                this._allContainers.push(C3.New(C3.Container, this, containerTypes))\n            }\n            for (const objectClass of this._allObjectClasses)\n                objectClass._OnAfterCreate();\n            for (const layoutData of projectData[5])\n                this._layoutManager.Create(layoutData);\n            const firstLayoutName = projectData[1];\n            if (firstLayoutName) {\n                const firstLayout = this._layoutManager.GetLayoutByName(firstLayoutName);\n                if (firstLayout)\n                    this._layoutManager.SetFirstLayout(firstLayout)\n            }\n            for (const timelineData of projectData[33])\n                this._timelineManager.Create(timelineData);\n            for (const transitionData of projectData[35])\n                this._transitionManager.Create(transitionData);\n            for (const templateInstanceData of projectData[44])\n                this._templateManager.Create(templateInstanceData);\n            if (!this._templateManager.HasTemplates()) {\n                this._templateManager.Release();\n                this._templateManager = null\n            }\n            this._InitScriptInterfaces();\n            for (const eventSheetData of projectData[6])\n                this._eventSheetManager.Create(eventSheetData);\n            this._eventSheetManager._PostInit();\n            this._InitGlobalVariableScriptInterface();\n            C3.clearArray(this._objectReferenceTable);\n            this.FlushPendingInstances();\n            let targetOrientation = "any";\n            const orientations = projectData[20];\n            if (orientations === 1)\n                targetOrientation = "portrait";\n            else if (orientations === 2)\n                targetOrientation = "landscape";\n            this.PostComponentMessageToDOM("runtime", "set-target-orientation", {\n                "targetOrientation": targetOrientation\n            })\n        }\n        async _LoadExportToVideoData(exportToVideoOpts) {\n            const format = exportToVideoOpts["format"];\n            if (format === "image-sequence")\n                this._exportToVideo = new self.C3ExportToImageSequence(this,exportToVideoOpts);\n            else if (format === "webm")\n                this._exportToVideo = new self.C3ExportToWebMVideo(this,exportToVideoOpts);\n            else if (format === "mp4")\n                this._exportToVideo = new self.C3ExportToMP4Video(this,exportToVideoOpts);\n            else\n                ;this._framerateMode = "unlimited-frame";\n            this._canvasManager.SetFullscreenMode("off");\n            this._devicePixelRatio = 1;\n            self.devicePixelRatio = 1;\n            await this.PostComponentMessageToDOMAsync("runtime", "set-exporting-to-video", {\n                "message": this._exportToVideo.GetExportingMessageForPercent(0),\n                "duration": this._exportToVideo.GetDuration()\n            })\n        }\n        GetLoaderStyle() {\n            return this._loaderStyle\n        }\n        IsExportToVideo() {\n            return this._exportToVideo !== null\n        }\n        GetExportVideoDuration() {\n            return this._exportToVideo.GetDuration()\n        }\n        GetExportVideoFramerate() {\n            return this._exportToVideo.GetFramerate()\n        }\n        _InitExportToVideo() {\n            return this._exportToVideo.Init({\n                width: this._canvasManager.GetDeviceWidth(),\n                height: this._canvasManager.GetDeviceHeight()\n            })\n        }\n        _ExportToVideoAddFrame() {\n            const time = this._tickCount \/ this.GetExportVideoFramerate();\n            return this._exportToVideo.AddFrame(this._canvasManager.GetCanvas(), time)\n        }\n        _ExportToVideoAddKeyframe() {\n            if (this._exportToVideo)\n                this._exportToVideo.AddKeyframe()\n        }\n        _OnOfflineAudioRenderCompleted(e) {\n            this._exportToVideo.OnOfflineAudioRenderCompleted(e)\n        }\n        _ExportToVideoFinish() {\n            return this._exportToVideo.Finish()\n        }\n        IsFBInstantAvailable() {\n            return this._isFBInstantAvailable\n        }\n        IsLoading() {\n            return this._isLoading\n        }\n        AddLoadPromise(promise) {\n            this._additionalLoadPromises.push(promise)\n        }\n        SetUsingCreatePromises(e) {\n            this._isUsingCreatePromises = !!e\n        }\n        AddCreatePromise(promise) {\n            if (!this._isUsingCreatePromises)\n                return;\n            this._additionalCreatePromises.push(promise)\n        }\n        GetCreatePromises() {\n            return this._additionalCreatePromises\n        }\n        _GetNextFamilyIndex() {\n            return this._familyCount++\n        }\n        GetFamilyCount() {\n            return this._familyCount\n        }\n        _AddEffectList(el) {\n            this._allEffectLists.push(el)\n        }\n        _GetAllEffectLists() {\n            return this._allEffectLists\n        }\n        async _InitialiseCanvas(opts) {\n            if (!this._canvasManager)\n                return;\n            await this._canvasManager.CreateCanvas(opts);\n            this._canvasManager.InitLoadingScreen(this._loaderStyle)\n        }\n        async _MaybeLoadOpusDecoder() {\n            if (this._assetManager.IsAudioFormatSupported("audio\/webm; codecs=opus"))\n                return;\n            let wasmBlob = null;\n            let wasmBuffer = null;\n            try {\n                if (this.IsiOSCordova() && this._assetManager.IsFileProtocol())\n                    wasmBuffer = await this._assetManager.CordovaFetchLocalFileAsArrayBuffer(this._opusWasmBinaryUrl);\n                else\n                    wasmBuffer = await this._assetManager.FetchArrayBuffer(this._opusWasmBinaryUrl)\n            } catch (err) {\n                console.info("Failed to fetch Opus decoder WASM; assuming project has no Opus audio.", err);\n                return\n            }\n            if (wasmBuffer)\n                this.AddJobWorkerBuffer(wasmBuffer, "opus-decoder-wasm");\n            else\n                this.AddJobWorkerBlob(wasmBlob, "opus-decoder-wasm");\n            await this.AddJobWorkerScripts([this._opusWasmScriptUrl])\n        }\n        async _WasmDecodeWebMOpus(arrayBuffer) {\n            const result = await this.AddJob("OpusDecode", {\n                "arrayBuffer": arrayBuffer\n            }, [arrayBuffer]);\n            return result\n        }\n        async Start() {\n            this._hasStarted = true;\n            this._startTime = Date.now();\n            if (this._usesLoaderLayout) {\n                for (const objectClass of this._allObjectClasses)\n                    if (!objectClass.IsFamily() && !objectClass.IsOnLoaderLayout() && objectClass.IsWorldType())\n                        objectClass.OnCreate();\n                this._assetManager.WaitForAllToLoad().then( () => {\n                    this._isLoading = false;\n                    this._OnLoadFinished()\n                }\n                )\n            } else\n                this._isLoading = false;\n            this._assetManager.SetInitialLoadFinished();\n            if (this.IsDebug())\n                C3Debugger.RuntimeInit(ife);\n            for (const layout of this._layoutManager.GetAllLayouts())\n                layout._CreateGlobalNonWorlds();\n            if (this.IsExportToVideo())\n                await this._InitExportToVideo();\n            const firstLayout = this._layoutManager.GetFirstLayout();\n            await firstLayout._Load(null, this.GetRenderer());\n            await firstLayout._StartRunning(true);\n            this._fpsLastTime = performance.now();\n            if (!this._usesLoaderLayout)\n                this._OnLoadFinished();\n            const state = await this.PostComponentMessageToDOMAsync("runtime", "before-start-ticking");\n            if (state["isSuspended"] && !this.IsExportToVideo())\n                this._suspendCount++;\n            else\n                this.Tick()\n        }\n        _OnLoadFinished() {\n            this.Trigger(C3.Plugins.System.Cnds.OnLoadFinished, null, null);\n            this.PostComponentMessageToDOM("runtime", "register-sw")\n        }\n        GetObjectReference(index) {\n            index = Math.floor(index);\n            const objRefTable = this._objectReferenceTable;\n            if (index < 0 || index >= objRefTable.length)\n                throw new Error("invalid object reference");\n            return objRefTable[index]\n        }\n        _LoadJsPropNameTable() {\n            for (const entry of self.C3_JsPropNameTable) {\n                const propName = C3.first(Object.keys(entry));\n                this._jsPropNameTable.push(propName)\n            }\n        }\n        GetJsPropName(index) {\n            index = Math.floor(index);\n            const jsPropNameTable = this._jsPropNameTable;\n            if (index < 0 || index >= jsPropNameTable.length)\n                throw new Error("invalid prop reference");\n            return jsPropNameTable[index]\n        }\n        HasDOM() {\n            return this._hasDom\n        }\n        IsHeadless() {\n            return this._isHeadless\n        }\n        IsInWorker() {\n            return this._isInWorker\n        }\n        GetRuntimeBaseURL() {\n            return this._runtimeBaseUrl\n        }\n        GetPreviewURL() {\n            return this._previewUrl\n        }\n        GetEventSheetManager() {\n            return this._eventSheetManager\n        }\n        GetEventStack() {\n            return this._eventSheetManager.GetEventStack()\n        }\n        GetCurrentEventStackFrame() {\n            return this._eventSheetManager.GetCurrentEventStackFrame()\n        }\n        GetCurrentEvent() {\n            return this._eventSheetManager.GetCurrentEvent()\n        }\n        GetCurrentCondition() {\n            return this._eventSheetManager.GetCurrentCondition()\n        }\n        IsCurrentConditionFirst() {\n            return this.GetCurrentEventStackFrame().GetConditionIndex() === 0\n        }\n        GetCurrentAction() {\n            return this._eventSheetManager.GetCurrentAction()\n        }\n        GetPluginManager() {\n            return this._pluginManager\n        }\n        GetSystemPlugin() {\n            return this._pluginManager.GetSystemPlugin()\n        }\n        GetObjectClassByIndex(i) {\n            i = Math.floor(i);\n            if (i < 0 || i >= this._allObjectClasses.length)\n                throw new RangeError("invalid index");\n            return this._allObjectClasses[i]\n        }\n        GetObjectClassByName(name) {\n            return this._objectClassesByName.get(name.toLowerCase()) || null\n        }\n        GetObjectClassBySID(sid) {\n            return this._objectClassesBySid.get(sid) || null\n        }\n        GetSingleGlobalObjectClassByCtor(ctor) {\n            const plugin = this._pluginManager.GetPluginByConstructorFunction(ctor);\n            if (!plugin)\n                return null;\n            return plugin.GetSingleGlobalObjectClass()\n        }\n        GetAllObjectClasses() {\n            return this._allObjectClasses\n        }\n        *allInstances() {\n            for (const objectClass of this._allObjectClasses) {\n                if (objectClass.IsFamily())\n                    continue;\n                yield*objectClass.instances()\n            }\n        }\n        Dispatcher() {\n            return this._dispatcher\n        }\n        UserScriptDispatcher() {\n            return this._userScriptDispatcher\n        }\n        DispatchUserScriptEvent(e) {\n            e.runtime = this.GetIRuntime();\n            const shouldTime = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();\n            if (shouldTime)\n                C3Debugger.StartMeasuringScriptTime();\n            this._userScriptDispatcher.dispatchEvent(e);\n            if (shouldTime)\n                C3Debugger.AddScriptTime()\n        }\n        DispatchUserScriptEventAsyncWait(e) {\n            e.runtime = this.GetIRuntime();\n            return this._userScriptDispatcher.dispatchEventAndWaitAsync(e)\n        }\n        GetOriginalViewportWidth() {\n            return this._originalViewportWidth\n        }\n        GetOriginalViewportHeight() {\n            return this._originalViewportHeight\n        }\n        SetOriginalViewportSize(w, h) {\n            if (this._originalViewportWidth === w && this._originalViewportHeight === h)\n                return;\n            this._originalViewportWidth = w;\n            this._originalViewportHeight = h;\n            const layoutManager = this.GetLayoutManager();\n            layoutManager.SetAllLayerProjectionChanged();\n            layoutManager.SetAllLayerMVChanged()\n        }\n        GetViewportWidth() {\n            return this._viewportWidth\n        }\n        GetViewportHeight() {\n            return this._viewportHeight\n        }\n        SetViewportSize(w, h) {\n            if (this._viewportWidth === w && this._viewportHeight === h)\n                return;\n            this._viewportWidth = w;\n            this._viewportHeight = h;\n            const layoutManager = this.GetLayoutManager();\n            layoutManager.SetAllLayerProjectionChanged();\n            layoutManager.SetAllLayerMVChanged()\n        }\n        _SetDevicePixelRatio(r) {\n            if (this.IsExportToVideo())\n                return;\n            this._devicePixelRatio = r\n        }\n        GetDevicePixelRatio() {\n            return this._devicePixelRatio\n        }\n        GetParallaxXOrigin() {\n            return this._parallaxXorigin\n        }\n        GetParallaxYOrigin() {\n            return this._parallaxYorigin\n        }\n        GetCanvasManager() {\n            return this._canvasManager\n        }\n        GetDrawWidth() {\n            if (!this._canvasManager)\n                return this._viewportWidth;\n            return this._canvasManager.GetDrawWidth()\n        }\n        GetDrawHeight() {\n            if (!this._canvasManager)\n                return this._viewportHeight;\n            return this._canvasManager.GetDrawHeight()\n        }\n        GetRenderScale() {\n            if (!this._canvasManager)\n                return 1;\n            return this._canvasManager.GetRenderScale()\n        }\n        GetDisplayScale() {\n            if (!this._canvasManager)\n                return 1;\n            return this._canvasManager.GetDisplayScale()\n        }\n        GetEffectLayerScaleParam() {\n            if (!this._canvasManager)\n                return 1;\n            return this._canvasManager.GetEffectLayerScaleParam()\n        }\n        GetEffectDevicePixelRatioParam() {\n            if (!this._canvasManager)\n                return 1;\n            return this._canvasManager.GetEffectDevicePixelRatioParam()\n        }\n        GetCanvasClientX() {\n            if (!this._canvasManager)\n                return 0;\n            return this._canvasManager.GetCanvasClientX()\n        }\n        GetCanvasClientY() {\n            if (!this._canvasManager)\n                return 0;\n            return this._canvasManager.GetCanvasClientY()\n        }\n        GetCanvasCssWidth() {\n            if (!this._canvasManager)\n                return 0;\n            return this._canvasManager.GetCssWidth()\n        }\n        GetCanvasCssHeight() {\n            if (!this._canvasManager)\n                return 0;\n            return this._canvasManager.GetCssHeight()\n        }\n        GetFullscreenMode() {\n            if (!this._canvasManager)\n                return "off";\n            return this._canvasManager.GetFullscreenMode()\n        }\n        GetAdditionalRenderTarget(opts) {\n            if (!this._canvasManager)\n                return null;\n            return this._canvasManager.GetAdditionalRenderTarget(opts)\n        }\n        ReleaseAdditionalRenderTarget(renderTarget) {\n            if (!this._canvasManager)\n                return;\n            this._canvasManager.ReleaseAdditionalRenderTarget(renderTarget)\n        }\n        UsesAnyBackgroundBlending() {\n            return this._usesAnyBackgroundBlending\n        }\n        UsesAnyCrossSampling() {\n            return this._usesAnyCrossSampling\n        }\n        UsesAnyDepthSampling() {\n            return this._usesAnyDepthSampling\n        }\n        GetGPUUtilisation() {\n            if (!this._canvasManager)\n                return NaN;\n            return this._canvasManager.GetGPUUtilisation()\n        }\n        IsLinearSampling() {\n            return this.GetSampling() !== "nearest"\n        }\n        GetFramerateMode() {\n            return this._framerateMode\n        }\n        GetCompositingMode() {\n            return this._compositingMode\n        }\n        GetSampling() {\n            return this._sampling\n        }\n        UsesLoaderLayout() {\n            return this._usesLoaderLayout\n        }\n        GetLoadingLogoAsset() {\n            return this._loadingLogoAsset\n        }\n        ReleaseLoadingLogoAsset() {\n            if (this._loadingLogoAsset) {\n                this._loadingLogoAsset.Release();\n                this._loadingLogoAsset = null\n            }\n        }\n        GetLayoutManager() {\n            return this._layoutManager\n        }\n        GetMainRunningLayout() {\n            return this._layoutManager.GetMainRunningLayout()\n        }\n        GetTimelineManager() {\n            return this._timelineManager\n        }\n        GetTransitionManager() {\n            return this._transitionManager\n        }\n        GetTemplateManager() {\n            return this._templateManager\n        }\n        GetAssetManager() {\n            return this._assetManager\n        }\n        LoadImage(opts) {\n            return this._assetManager.LoadImage(opts)\n        }\n        CreateInstance(objectClass, layer, x, y, createHierarchy, templateName) {\n            if (templateName && this._templateManager) {\n                const templateData = this._templateManager.GetTemplateData(objectClass, templateName);\n                if (templateData) {\n                    const inst = this.CreateInstanceFromData(templateData, layer, false, x, y, false, createHierarchy, undefined, createHierarchy);\n                    this._templateManager.MapInstanceToTemplateName(inst, templateName);\n                    return inst\n                }\n            }\n            return this.CreateInstanceFromData(objectClass, layer, false, x, y, false, createHierarchy, undefined, createHierarchy)\n        }\n        CreateInstanceFromData(instData_or_objectClass, layer, isStartupInstance, x, y, skipSiblings, createHierarchy, previousInstance, creatingHierarchy) {\n            let instData = null;\n            let objectClass = null;\n            if (instData_or_objectClass instanceof C3.ObjectClass) {\n                objectClass = instData_or_objectClass;\n                if (objectClass.IsFamily()) {\n                    const members = objectClass.GetFamilyMembers();\n                    const i = Math.floor(this.Random() * members.length);\n                    objectClass = members[i]\n                }\n                instData = objectClass.GetDefaultInstanceData()\n            } else {\n                instData = instData_or_objectClass;\n                objectClass = this.GetObjectClassByIndex(instData[1])\n            }\n            const isWorld = objectClass.GetPlugin().IsWorldType();\n            if (this._isLoading && isWorld && !objectClass.IsOnLoaderLayout())\n                return null;\n            const originalLayer = layer;\n            if (!isWorld)\n                layer = null;\n            let uid;\n            if (isStartupInstance && !skipSiblings && instData && !this._instancesByUid.has(instData[2]))\n                uid = instData[2];\n            else\n                uid = this._nextUid++;\n            const worldData = instData ? instData[0] : null;\n            const inst = C3.New(C3.Instance, {\n                runtime: this,\n                objectType: objectClass,\n                layer: layer,\n                worldData,\n                instVarData: instData ? instData[3] : null,\n                uid: uid\n            });\n            this._instancesByUid.set(uid, inst);\n            let wi = null;\n            if (isWorld) {\n                wi = inst.GetWorldInfo();\n                if (typeof x !== "undefined" && typeof y !== "undefined") {\n                    wi.SetX(x);\n                    wi.SetY(y)\n                }\n                objectClass._SetAnyCollisionCellChanged(true)\n            }\n            if (layer) {\n                if (!creatingHierarchy)\n                    layer._AddInstance(inst, true);\n                if (layer.GetParallaxX() !== 1 || layer.GetParallaxY() !== 1)\n                    objectClass._SetAnyInstanceParallaxed(true);\n                layer.GetLayout().MaybeLoadTexturesFor(objectClass)\n            }\n            this._objectCount++;\n            let needsSiblingCreation = true;\n            if (previousInstance) {\n                const previousObjectClass = previousInstance.GetObjectClass();\n                if (previousObjectClass.IsInContainer() && objectClass.IsInContainer()) {\n                    const container = objectClass.GetContainer();\n                    const previousContainer = previousObjectClass.GetContainer();\n                    if (container === previousContainer)\n                        needsSiblingCreation = false\n                }\n            }\n            if (objectClass.IsInContainer() && !isStartupInstance && !skipSiblings && needsSiblingCreation) {\n                for (const containerType of objectClass.GetContainer().objectTypes()) {\n                    if (containerType === objectClass)\n                        continue;\n                    const siblingInst = this.CreateInstanceFromData(containerType, originalLayer, false, wi ? wi.GetX() : x, wi ? wi.GetY() : y, true, false, undefined, creatingHierarchy);\n                    inst._AddSibling(siblingInst)\n                }\n                for (const s of inst.siblings()) {\n                    s._AddSibling(inst);\n                    for (const s2 of inst.siblings())\n                        if (s !== s2)\n                            s._AddSibling(s2)\n                }\n            }\n            if (isWorld && !isStartupInstance && !!createHierarchy)\n                this._CreateChildInstancesFromData(inst, worldData, wi, layer, x, y, creatingHierarchy);\n            if (objectClass.IsInContainer() && !isStartupInstance && !skipSiblings && !!createHierarchy)\n                for (const sibling of inst.siblings()) {\n                    const swi = sibling.GetWorldInfo();\n                    if (!swi)\n                        continue;\n                    const siblingPlugin = sibling.GetPlugin();\n                    const sWorldData = sibling.GetObjectClass().GetDefaultInstanceData()[0];\n                    if (siblingPlugin.IsWorldType())\n                        this._CreateChildInstancesFromData(sibling, sWorldData, swi, layer, swi.GetX(), swi.GetY(), creatingHierarchy);\n                    else\n                        this._CreateChildInstancesFromData(sibling, sWorldData, swi, layer, undefined, undefined, creatingHierarchy)\n                }\n            if (!skipSiblings && !!createHierarchy) {\n                if (typeof x === "undefined")\n                    x = worldData[0];\n                if (typeof y === "undefined")\n                    y = worldData[1];\n                const pwi = wi.GetTopParent();\n                const newX = x - wi.GetX() + pwi.GetX();\n                const newY = y - wi.GetY() + pwi.GetY();\n                pwi.SetXY(newX, newY)\n            }\n            objectClass._SetIIDsStale();\n            const instPropertyData = instData ? C3.cloneArray(instData[5]) : null;\n            const behPropertyData = instData ? instData[4].map(bp => C3.cloneArray(bp)) : null;\n            const hasTilemap = isWorld && worldData && worldData[13];\n            if (hasTilemap)\n                inst._SetHasTilemap();\n            inst._CreateSdkInstance(instPropertyData, behPropertyData);\n            if (hasTilemap) {\n                const tilemapData = worldData[13];\n                inst.GetSdkInstance().LoadTilemapData(tilemapData[2], tilemapData[0], tilemapData[1])\n            }\n            this._instancesPendingCreate.push(inst);\n            this._hasPendingInstances = true;\n            if (this.IsDebug())\n                C3Debugger.InstanceCreated(inst);\n            return inst\n        }\n        _CreateChildInstancesFromData(parentInstance, parentWorldData, parentWorldInfo, layer, x, y, creatingHierarchy) {\n            const parentZIndex = parentWorldInfo.GetSceneGraphZIndexExportData();\n            const childrenData = parentWorldInfo.GetSceneGraphChildrenExportData();\n            parentInstance.GetWorldInfo().SetSceneGraphZIndex(parentZIndex);\n            if (!childrenData)\n                return;\n            if (typeof x === "undefined")\n                x = parentWorldData[0];\n            if (typeof y === "undefined")\n                y = parentWorldData[1];\n            const sceneGraphSiblings = new Set;\n            const parentX = parentWorldData[0];\n            const parentY = parentWorldData[1];\n            for (const childData of childrenData) {\n                const childLayoutSID = childData[0];\n                const childLayerIndex = childData[1];\n                const childUID = childData[2];\n                const childFlags = childData[3];\n                const childIsInContainer = !!childData[4];\n                const childZIndex = childData[5];\n                const layout = this._layoutManager.GetLayoutBySID(childLayoutSID);\n                const l = layout.GetLayer(childLayerIndex);\n                const childInstData = l.GetInitialInstanceData(childUID);\n                const childObjectClass = this.GetObjectClassByIndex(childInstData[1]);\n                const hasSibling = parentInstance.HasSibling(childObjectClass);\n                const siblingProcessed = sceneGraphSiblings.has(childObjectClass);\n                if (hasSibling && !siblingProcessed && childIsInContainer) {\n                    const childInst = parentInstance.GetSibling(childObjectClass);\n                    const childX = x + childInstData[0][0] - parentX;\n                    const childY = y + childInstData[0][1] - parentY;\n                    childInst.GetWorldInfo().SetXY(childX, childY);\n                    childInst.GetWorldInfo().SetSceneGraphZIndex(childZIndex);\n                    parentInstance.AddChild(childInst, {\n                        transformX: !!(childFlags >> 0 & 1),\n                        transformY: !!(childFlags >> 1 & 1),\n                        transformWidth: !!(childFlags >> 2 & 1),\n                        transformHeight: !!(childFlags >> 3 & 1),\n                        transformAngle: !!(childFlags >> 4 & 1),\n                        destroyWithParent: !!(childFlags >> 5 & 1),\n                        transformZElevation: !!(childFlags >> 6 & 1)\n                    });\n                    sceneGraphSiblings.add(childObjectClass)\n                } else {\n                    const childX = x + childInstData[0][0] - parentX;\n                    const childY = y + childInstData[0][1] - parentY;\n                    const childInst = this.CreateInstanceFromData(childInstData, layer, false, childX, childY, false, true, parentInstance, creatingHierarchy);\n                    childInst.GetWorldInfo().SetSceneGraphZIndex(childZIndex);\n                    parentInstance.AddChild(childInst, {\n                        transformX: !!(childFlags >> 0 & 1),\n                        transformY: !!(childFlags >> 1 & 1),\n                        transformWidth: !!(childFlags >> 2 & 1),\n                        transformHeight: !!(childFlags >> 3 & 1),\n                        transformAngle: !!(childFlags >> 4 & 1),\n                        destroyWithParent: !!(childFlags >> 5 & 1),\n                        transformZElevation: !!(childFlags >> 6 & 1)\n                    })\n                }\n            }\n        }\n        DestroyInstance(inst) {\n            if (this._instancesToReleaseAtEndOfTick.has(inst))\n                return;\n            const objectClass = inst.GetObjectClass();\n            let s = this._instancesPendingDestroy.get(objectClass);\n            if (s) {\n                if (s.has(inst))\n                    return;\n                s.add(inst)\n            } else {\n                s = new Set;\n                s.add(inst);\n                this._instancesPendingDestroy.set(objectClass, s)\n            }\n            if (this.IsDebug())\n                C3Debugger.InstanceDestroyed(inst);\n            inst._MarkDestroyed();\n            this._hasPendingInstances = true;\n            if (inst.IsInContainer())\n                for (const s of inst.siblings())\n                    this.DestroyInstance(s);\n            for (const c of inst.children())\n                if (c.GetDestroyWithParent())\n                    this.DestroyInstance(c);\n            if (!this._layoutManager.IsEndingLayout() && !this._isLoadingState) {\n                const eventSheetManager = this.GetEventSheetManager();\n                eventSheetManager.BlockFlushingInstances(true);\n                inst._TriggerOnDestroyed();\n                eventSheetManager.BlockFlushingInstances(false)\n            }\n            inst._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout())\n        }\n        FlushPendingInstances() {\n            if (!this._hasPendingInstances)\n                return;\n            this._isFlushingPendingInstances = true;\n            this._FlushInstancesPendingCreate();\n            this._FlushInstancesPendingDestroy();\n            this._isFlushingPendingInstances = false;\n            this._hasPendingInstances = false;\n            this.UpdateRender()\n        }\n        _FlushInstancesPendingCreate() {\n            for (const inst of this._instancesPendingCreate) {\n                const objectType = inst.GetObjectClass();\n                objectType._AddInstance(inst);\n                for (const family of objectType.GetFamilies()) {\n                    family._AddInstance(inst);\n                    family._SetIIDsStale()\n                }\n            }\n            C3.clearArray(this._instancesPendingCreate)\n        }\n        _FlushInstancesPendingDestroy() {\n            this._dispatcher.SetDelayRemoveEventsEnabled(true);\n            for (const [objectClass,s] of this._instancesPendingDestroy.entries()) {\n                this._FlushInstancesPendingDestroyForObjectClass(objectClass, s);\n                s.clear()\n            }\n            this._instancesPendingDestroy.clear();\n            this._dispatcher.SetDelayRemoveEventsEnabled(false)\n        }\n        _FlushInstancesPendingDestroyForObjectClass(objectClass, s) {\n            for (const inst of s) {\n                const instanceDestroyEvent = this._eventObjects["instancedestroy"];\n                instanceDestroyEvent.instance = inst;\n                this._dispatcher.dispatchEvent(instanceDestroyEvent);\n                this._instancesByUid.delete(inst.GetUID());\n                this._instanceTimes.delete(inst);\n                const wi = inst.GetWorldInfo();\n                if (wi) {\n                    wi._RemoveFromCollisionCells();\n                    wi._RemoveFromRenderCells();\n                    wi._MarkDestroyed()\n                }\n                this._instancesToReleaseAtEndOfTick.add(inst);\n                this._objectCount--\n            }\n            C3.arrayRemoveAllInSet(objectClass.GetInstances(), s);\n            objectClass._SetIIDsStale();\n            this._instancesToReleaseAffectedObjectClasses.add(objectClass);\n            if (objectClass.GetInstances().length === 0)\n                objectClass._SetAnyInstanceParallaxed(false);\n            for (const family of objectClass.GetFamilies()) {\n                C3.arrayRemoveAllInSet(family.GetInstances(), s);\n                family._SetIIDsStale();\n                this._instancesToReleaseAffectedObjectClasses.add(family)\n            }\n            if (objectClass.GetPlugin().IsWorldType()) {\n                const layers = new Set([...s].map(i => i.GetWorldInfo().GetLayer()));\n                for (const layer of layers)\n                    layer._RemoveAllInstancesInSet(s)\n            }\n        }\n        _GetInstancesPendingCreate() {\n            return this._instancesPendingCreate\n        }\n        *instancesPendingCreateForObjectClass(objectClass) {\n            for (const inst of this._GetInstancesPendingCreate())\n                if (objectClass.IsFamily()) {\n                    if (inst.GetObjectClass().BelongsToFamily(objectClass))\n                        yield inst\n                } else if (inst.GetObjectClass() === objectClass)\n                    yield inst\n        }\n        _GetNewUID() {\n            return this._nextUid++\n        }\n        _MapInstanceByUID(uid, inst) {\n            this._instancesByUid.set(uid, inst)\n        }\n        _OnWebGLContextLost() {\n            this._dispatcher.dispatchEvent(C3.New(C3.Event, "webglcontextlost"));\n            this.SetSuspended(true);\n            for (const objectClass of this._allObjectClasses)\n                if (!objectClass.IsFamily() && objectClass.HasLoadedTextures())\n                    objectClass.ReleaseTextures();\n            const runningLayout = this.GetMainRunningLayout();\n            if (runningLayout)\n                runningLayout._OnWebGLContextLost();\n            C3.ImageInfo.OnWebGLContextLost();\n            C3.ImageAsset.OnWebGLContextLost()\n        }\n        async _OnWebGLContextRestored() {\n            await this.GetMainRunningLayout()._Load(null, this.GetWebGLRenderer());\n            this._dispatcher.dispatchEvent(C3.New(C3.Event, "webglcontextrestored"));\n            this.SetSuspended(false);\n            this.UpdateRender()\n        }\n        _OnVisibilityChange(e) {\n            this.SetSuspended(e["hidden"])\n        }\n        _OnWindowBlur(e) {\n            if (!this.IsPreview() || !this._pauseOnBlur || C3.Platform.IsMobile)\n                return;\n            if (!e.data["parentHasFocus"]) {\n                this.SetSuspended(true);\n                this._isPausedOnBlur = true\n            }\n        }\n        _OnWindowFocus() {\n            if (!this._isPausedOnBlur)\n                return;\n            this.SetSuspended(false);\n            this._isPausedOnBlur = false\n        }\n        _RequestAnimationFrame() {\n            const tickCallbacks = this._tickCallbacks;\n            if (this._framerateMode === "vsync") {\n                if (this._rafId === -1)\n                    this._rafId = self.requestAnimationFrame(tickCallbacks.normal)\n            } else if (this._framerateMode === "unlimited-tick") {\n                if (this._ruafId === -1)\n                    this._ruafId = C3.RequestUnlimitedAnimationFrame(tickCallbacks.tickOnly);\n                if (this._rafId === -1)\n                    this._rafId = self.requestAnimationFrame(tickCallbacks.renderOnly)\n            } else if (this._ruafId === -1)\n                this._ruafId = C3.RequestUnlimitedAnimationFrame(tickCallbacks.normal)\n        }\n        _CancelAnimationFrame() {\n            if (this._rafId !== -1) {\n                self.cancelAnimationFrame(this._rafId);\n                this._rafId = -1\n            }\n            if (this._ruafId !== -1) {\n                C3.CancelUnlimitedAnimationFrame(this._ruafId);\n                this._ruafId = -1\n            }\n        }\n        IsSuspended() {\n            return this._suspendCount > 0\n        }\n        SetSuspended(s) {\n            if (this.IsExportToVideo())\n                return;\n            const wasSuspended = this.IsSuspended();\n            this._suspendCount += s ? 1 : -1;\n            if (this._suspendCount < 0)\n                this._suspendCount = 0;\n            const isSuspended = this.IsSuspended();\n            if (!wasSuspended && isSuspended) {\n                console.log("[Construct] Suspending");\n                this._CancelAnimationFrame();\n                this._dispatcher.dispatchEvent(C3.New(C3.Event, "suspend"));\n                this.Trigger(C3.Plugins.System.Cnds.OnSuspend, null, null)\n            } else if (wasSuspended && !isSuspended) {\n                console.log("[Construct] Resuming");\n                const now = performance.now();\n                this._lastTickTime = now;\n                this._fpsLastTime = now;\n                this._fpsFrameCount = 0;\n                this._fps = 0;\n                this._mainThreadTime = 0;\n                this._mainThreadTimeCounter = 0;\n                this._dispatcher.dispatchEvent(C3.New(C3.Event, "resume"));\n                this.Trigger(C3.Plugins.System.Cnds.OnResume, null, null);\n                if (!this.HitBreakpoint())\n                    this.Tick(now)\n            }\n        }\n        _AddBehInstToTick(behSdkInst) {\n            this._behInstsToTick.Add(behSdkInst)\n        }\n        _AddBehInstToPostTick(behSdkInst) {\n            this._behInstsToPostTick.Add(behSdkInst)\n        }\n        _AddBehInstToTick2(behSdkInst) {\n            this._behInstsToTick2.Add(behSdkInst)\n        }\n        _RemoveBehInstToTick(behSdkInst) {\n            this._behInstsToTick.Remove(behSdkInst)\n        }\n        _RemoveBehInstToPostTick(behSdkInst) {\n            this._behInstsToPostTick.Remove(behSdkInst)\n        }\n        _RemoveBehInstToTick2(behSdkInst) {\n            this._behInstsToTick2.Remove(behSdkInst)\n        }\n        _BehaviorTick() {\n            this._behInstsToTick.SetQueueingEnabled(true);\n            for (const bi of this._behInstsToTick)\n                bi.Tick();\n            this._behInstsToTick.SetQueueingEnabled(false)\n        }\n        _BehaviorPostTick() {\n            this._behInstsToPostTick.SetQueueingEnabled(true);\n            for (const bi of this._behInstsToPostTick)\n                bi.PostTick();\n            this._behInstsToPostTick.SetQueueingEnabled(false)\n        }\n        _BehaviorTick2() {\n            this._behInstsToTick2.SetQueueingEnabled(true);\n            for (const bi of this._behInstsToTick2)\n                bi.Tick2();\n            this._behInstsToTick2.SetQueueingEnabled(false)\n        }\n        *_DebugBehaviorTick() {\n            this._behInstsToTick.SetQueueingEnabled(true);\n            for (const bi of this._behInstsToTick) {\n                const ret = bi.Tick();\n                if (C3.IsIterator(ret))\n                    yield*ret\n            }\n            this._behInstsToTick.SetQueueingEnabled(false)\n        }\n        *_DebugBehaviorPostTick() {\n            this._behInstsToPostTick.SetQueueingEnabled(true);\n            for (const bi of this._behInstsToPostTick) {\n                const ret = bi.PostTick();\n                if (C3.IsIterator(ret))\n                    yield*ret\n            }\n            this._behInstsToPostTick.SetQueueingEnabled(false)\n        }\n        *_DebugBehaviorTick2() {\n            this._behInstsToTick2.SetQueueingEnabled(true);\n            for (const bi of this._behInstsToTick2) {\n                const ret = bi.Tick2();\n                if (C3.IsIterator(ret))\n                    yield*ret\n            }\n            this._behInstsToTick2.SetQueueingEnabled(false)\n        }\n        async Tick(timestamp, isDebugStep, mode) {\n            this._hasStartedTicking = true;\n            const isBackgroundWake = mode === "background-wake";\n            const shouldRender = mode !== "background-wake" && mode !== "skip-render";\n            if (!this._hasStarted || this.IsSuspended() && !isDebugStep && !isBackgroundWake)\n                return;\n            const startTime = performance.now();\n            this._isInTick = true;\n            this._MeasureDt(timestamp || 0);\n            const beforePreTickRet = this.Step_BeforePreTick();\n            if (this.IsDebugging())\n                await beforePreTickRet;\n            const pretickRet = this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects["pretick"]);\n            if (pretickRet instanceof Promise)\n                await pretickRet;\n            const afterPreTickRet = this.Step_AfterPreTick();\n            if (this.IsDebugging())\n                await afterPreTickRet;\n            if (this._NeedsHandleSaveOrLoad())\n                await this._HandleSaveOrLoad();\n            if (this.GetLayoutManager().IsPendingChangeMainLayout())\n                await this._MaybeChangeLayout();\n            const runEventsRet = this.Step_RunEventsEtc();\n            if (this.IsDebugging())\n                await runEventsRet;\n            if (shouldRender)\n                this.Render();\n            if (this.IsExportToVideo()) {\n                await this._ExportToVideoAddFrame();\n                if (this.GetGameTime() >= this.GetExportVideoDuration()) {\n                    this._ExportToVideoFinish();\n                    return\n                }\n            }\n            if (!this.IsSuspended() && !isBackgroundWake)\n                this._RequestAnimationFrame();\n            this._tickCount++;\n            this._tickCountNoSave++;\n            this._isInTick = false;\n            this._mainThreadTimeCounter += performance.now() - startTime\n        }\n        async Step_BeforePreTick() {\n            const eventSheetManager = this._eventSheetManager;\n            const isDebug = this.IsDebug();\n            this.FlushPendingInstances();\n            eventSheetManager.BlockFlushingInstances(true);\n            this.PushCurrentLayout(this.GetMainRunningLayout());\n            if (isDebug)\n                C3Debugger.StartMeasuringTime();\n            if (this.IsDebugging())\n                await eventSheetManager.DebugRunScheduledWaits();\n            else\n                eventSheetManager.RunScheduledWaits();\n            if (isDebug)\n                C3Debugger.AddEventsTime();\n            this.PopCurrentLayout();\n            eventSheetManager.BlockFlushingInstances(false);\n            this.FlushPendingInstances();\n            eventSheetManager.BlockFlushingInstances(true)\n        }\n        async Step_AfterPreTick() {\n            const isDebug = this.IsDebug();\n            const isDebugging = this.IsDebugging();\n            const dispatcher = this._dispatcher;\n            const eventObjects = this._eventObjects;\n            const userScriptEventObjects = this._userScriptEventObjects;\n            if (isDebug)\n                C3Debugger.StartMeasuringTime();\n            if (isDebugging)\n                await this.DebugIterateAndBreak(this._DebugBehaviorTick());\n            else\n                this._BehaviorTick();\n            if (isDebugging)\n                await this.DebugIterateAndBreak(this._DebugBehaviorPostTick());\n            else\n                this._BehaviorPostTick();\n            if (isDebug)\n                C3Debugger.AddBehaviorTickTime();\n            if (isDebug)\n                C3Debugger.StartMeasuringTime();\n            if (isDebugging)\n                await this.DebugFireGeneratorEventAndBreak(eventObjects["tick"]);\n            else\n                dispatcher.dispatchEvent(eventObjects["tick"]);\n            if (isDebug)\n                C3Debugger.AddPluginTickTime();\n            this._eventSheetManager.BlockFlushingInstances(false);\n            this.DispatchUserScriptEvent(userScriptEventObjects["tick"])\n        }\n        async Step_RunEventsEtc() {\n            const eventSheetManager = this._eventSheetManager;\n            const dispatcher = this._dispatcher;\n            const eventObjects = this._eventObjects;\n            const isDebug = this.IsDebug();\n            const isDebugging = this.IsDebugging();\n            if (isDebug)\n                C3Debugger.StartMeasuringTime();\n            if (isDebugging)\n                await eventSheetManager.DebugRunEvents(this._layoutManager);\n            else\n                eventSheetManager.RunEvents(this._layoutManager);\n            if (isDebug)\n                C3Debugger.AddEventsTime();\n            this._collisionEngine.ClearRegisteredCollisions();\n            this._ReleaseInstancesAtEndOfTick();\n            this._isLayoutFirstTick = false;\n            eventSheetManager.BlockFlushingInstances(true);\n            if (isDebug)\n                C3Debugger.StartMeasuringTime();\n            if (isDebugging)\n                await this.DebugIterateAndBreak(this._DebugBehaviorTick2());\n            else\n                this._BehaviorTick2();\n            if (isDebug)\n                C3Debugger.AddBehaviorTickTime();\n            if (isDebug)\n                C3Debugger.StartMeasuringTime();\n            if (isDebugging)\n                await this.DebugFireGeneratorEventAndBreak(eventObjects["tick2"]);\n            else\n                dispatcher.dispatchEvent(eventObjects["tick2"]);\n            if (isDebug)\n                C3Debugger.AddPluginTickTime();\n            eventSheetManager.BlockFlushingInstances(false);\n            if (isDebugging)\n                await eventSheetManager.RunQueuedDebugTriggersAsync()\n        }\n        _ReleaseInstancesAtEndOfTick() {\n            if (this._instancesToReleaseAtEndOfTick.size === 0)\n                return;\n            const dispatcher = this._dispatcher;\n            dispatcher.SetDelayRemoveEventsEnabled(true);\n            for (const objectClass of this._instancesToReleaseAffectedObjectClasses)\n                objectClass.GetSolStack().RemoveInstances(this._instancesToReleaseAtEndOfTick);\n            this._instancesToReleaseAffectedObjectClasses.clear();\n            this._eventSheetManager.RemoveInstancesFromScheduledWaits(this._instancesToReleaseAtEndOfTick);\n            for (const inst of this._instancesToReleaseAtEndOfTick)\n                inst.Release();\n            this._instancesToReleaseAtEndOfTick.clear();\n            dispatcher.SetDelayRemoveEventsEnabled(false)\n        }\n        async _MaybeChangeLayout() {\n            const layoutManager = this.GetLayoutManager();\n            let i = 0;\n            while (layoutManager.IsPendingChangeMainLayout() && i++ < 10)\n                await this._DoChangeLayout(layoutManager.GetPendingChangeMainLayout())\n        }\n        _MeasureDt(timestamp) {\n            let dtRaw = 0;\n            if (this.IsExportToVideo()) {\n                dtRaw = 1 \/ this.GetExportVideoFramerate();\n                this._dt1 = dtRaw\n            } else if (this._lastTickTime !== 0) {\n                const msDiff = Math.max(timestamp - this._lastTickTime, 0);\n                dtRaw = msDiff \/ 1E3;\n                if (dtRaw > .5)\n                    dtRaw = 0;\n                const maxDt1 = 1 \/ this._minimumFramerate;\n                this._dt1 = Math.min(dtRaw, maxDt1)\n            }\n            this._lastTickTime = timestamp;\n            this._dt = this._dt1 * this._timeScale;\n            this._gameTime.Add(this._dt);\n            this._gameTimeRaw.Add(dtRaw * this._timeScale);\n            this._wallTime.Add(this._dt1);\n            for (const [inst,instTime] of this._instanceTimes)\n                instTime.Add(this._dt1 * inst.GetTimeScale());\n            if (this._canvasManager)\n                this._canvasManager._UpdateTick();\n            if (timestamp - this._fpsLastTime >= 1E3) {\n                this._fpsLastTime += 1E3;\n                if (timestamp - this._fpsLastTime >= 1E3)\n                    this._fpsLastTime = timestamp;\n                this._fps = this._fpsFrameCount;\n                this._fpsFrameCount = 0;\n                this._mainThreadTime = Math.min(this._mainThreadTimeCounter \/ 1E3, 1);\n                this._mainThreadTimeCounter = 0;\n                if (this._canvasManager)\n                    this._canvasManager._Update1sFrameRange();\n                this._collisionEngine._Update1sStats();\n                if (this.IsDebug())\n                    C3Debugger.Update1sPerfStats()\n            }\n            this._fpsFrameCount++\n        }\n        _SetTrackingInstanceTime(inst, enable) {\n            if (enable) {\n                if (!this._instanceTimes.has(inst)) {\n                    const instTime = C3.New(C3.KahanSum);\n                    instTime.Copy(this._gameTime);\n                    this._instanceTimes.set(inst, instTime)\n                }\n            } else\n                this._instanceTimes.delete(inst)\n        }\n        _GetInstanceGameTime(inst) {\n            const instTime = this._instanceTimes.get(inst);\n            return instTime ? instTime.Get() : this.GetGameTime()\n        }\n        async _DoChangeLayout(changeToLayout) {\n            const dispatcher = this._dispatcher;\n            const layoutManager = this.GetLayoutManager();\n            const prevLayout = layoutManager.GetMainRunningLayout();\n            await prevLayout._StopRunning();\n            prevLayout._Unload(changeToLayout, this.GetRenderer());\n            if (prevLayout === changeToLayout)\n                this._eventSheetManager.ClearAllScheduledWaits();\n            this._collisionEngine.ClearRegisteredCollisions();\n            this._ReleaseInstancesAtEndOfTick();\n            dispatcher.dispatchEvent(this._eventObjects["beforelayoutchange"]);\n            C3.Asyncify.SetHighThroughputMode(true);\n            await changeToLayout._Load(prevLayout, this.GetRenderer());\n            C3.Asyncify.SetHighThroughputMode(false);\n            await changeToLayout._StartRunning(false);\n            dispatcher.dispatchEvent(this._eventObjects["layoutchange"]);\n            this.UpdateRender();\n            this._isLayoutFirstTick = true;\n            this.FlushPendingInstances();\n            this._ExportToVideoAddKeyframe()\n        }\n        UpdateRender() {\n            this._needRender = true\n        }\n        GetWebGLRenderer() {\n            if (!this._canvasManager)\n                return null;\n            return this._canvasManager.GetWebGLRenderer()\n        }\n        GetWebGPURenderer() {\n            if (!this._canvasManager)\n                return null;\n            return this._canvasManager.GetWebGPURenderer()\n        }\n        GetRenderer() {\n            if (!this._canvasManager)\n                return null;\n            return this._canvasManager.GetRenderer()\n        }\n        Render() {\n            const canvasManager = this._canvasManager;\n            if (!canvasManager || canvasManager.IsRendererContextLost())\n                return;\n            const renderer = this.GetRenderer();\n            const supportsGPUProfiling = renderer.SupportsGPUProfiling();\n            const isWebGLProfiling = supportsGPUProfiling && renderer.IsWebGL();\n            const isWebGPUProfiling = supportsGPUProfiling && renderer.IsWebGPU();\n            if (isWebGLProfiling)\n                renderer.CheckForQueryResults();\n            if (!this._needRender && !this.IsExportToVideo()) {\n                renderer.IncrementFrameNumber();\n                return\n            }\n            const layout = this._layoutManager.GetMainRunningLayout();\n            renderer.Start();\n            const isDebug = this.IsDebug();\n            if (isDebug)\n                C3Debugger.StartMeasuringTime();\n            this._needRender = false;\n            let webglFrameQuery = null;\n            if (isWebGLProfiling) {\n                webglFrameQuery = canvasManager.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery();\n                renderer.StartQuery(webglFrameQuery)\n            }\n            let webgpuFrameTimings = null;\n            if (isWebGPUProfiling) {\n                webgpuFrameTimings = renderer.StartFrameTiming((1 + layout.GetLayerCount()) * 2);\n                renderer.WriteTimestamp(0)\n            }\n            if (this.Uses3DFeatures() && canvasManager.GetCurrentFullscreenScalingQuality() === "low")\n                renderer.SetFixedSizeDepthBuffer(canvasManager.GetDrawWidth(), canvasManager.GetDrawHeight());\n            else\n                renderer.SetAutoSizeDepthBuffer();\n            this._Render(this.GetRenderer(), layout);\n            if (webglFrameQuery)\n                renderer.EndQuery(webglFrameQuery);\n            if (isWebGPUProfiling) {\n                renderer.WriteTimestamp(1);\n                this._canvasManager._AddWebGPUFrameTiming(webgpuFrameTimings)\n            }\n            renderer.Finish();\n            if (isDebug) {\n                C3Debugger.AddDrawCallsTime();\n                C3Debugger.UpdateInspectHighlight()\n            }\n            if (canvasManager)\n                canvasManager._MaybeTakeSnapshot()\n        }\n        _Render(renderer, layout) {\n            renderer.SetTextureFillMode();\n            renderer.SetAlphaBlend();\n            renderer.SetColorRgba(1, 1, 1, 1);\n            renderer.SetRenderTarget(null);\n            renderer.SetTexture(null);\n            renderer.SetDepthEnabled(this.Uses3DFeatures());\n            layout.Draw(renderer)\n        }\n        Trigger(method, inst, behaviorType) {\n            if (!this._hasStarted)\n                return false;\n            const isTopLevel = !this._isInTick && !this._eventSheetManager.IsInTrigger();\n            let startTime = 0;\n            if (isTopLevel)\n                startTime = performance.now();\n            const isDebug = this.IsDebug();\n            if (isDebug)\n                this.SetDebuggingEnabled(false);\n            const ret = this._eventSheetManager._Trigger(this._layoutManager, method, inst, behaviorType);\n            if (isTopLevel) {\n                const triggerTime = performance.now() - startTime;\n                this._mainThreadTimeCounter += triggerTime;\n                if (isDebug)\n                    C3Debugger.AddTriggersTime(triggerTime)\n            }\n            if (isDebug)\n                this.SetDebuggingEnabled(true);\n            return ret\n        }\n        DebugTrigger(method, inst, behaviorType) {\n            if (!this.IsDebug())\n                return this.Trigger(method, inst, behaviorType);\n            if (this.HitBreakpoint())\n                throw new Error("called DebugTrigger() while stopped on breakpoint");\n            if (!this._isInTick && !this._eventSheetManager.IsInTrigger())\n                throw new Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");\n            return this._eventSheetManager._DebugTrigger(this._layoutManager, method, inst, behaviorType)\n        }\n        async TriggerAsync(method, inst, behaviorType) {\n            if (!this.IsDebugging())\n                return this.Trigger(method, inst, behaviorType);\n            if (!this._hasStarted)\n                return false;\n            if (this.HitBreakpoint())\n                return this._eventSheetManager.QueueDebugTrigger(method, inst, behaviorType);\n            if (!this.GetMainRunningLayout())\n                return this._eventSheetManager.QueueTrigger(method, inst, behaviorType);\n            const startTime = performance.now();\n            const iter = this._eventSheetManager._DebugTrigger(this._layoutManager, method, inst, behaviorType);\n            let result = iter.next();\n            while (!result.done) {\n                await this.DebugBreak(result.value);\n                result = iter.next()\n            }\n            if (!this.IsSuspended() && !this._eventSheetManager.IsInTrigger()) {\n                await this._eventSheetManager.RunQueuedDebugTriggersAsync();\n                if (this._hasStartedTicking && !this._isInTick)\n                    this._RequestAnimationFrame()\n            }\n            this._mainThreadTimeCounter += performance.now() - startTime;\n            return result.value\n        }\n        FastTrigger(method, inst, value) {\n            const isDebug = this.IsDebug();\n            if (isDebug)\n                this.SetDebuggingEnabled(false);\n            const ret = this._eventSheetManager._FastTrigger(this._layoutManager, method, inst, value);\n            if (isDebug)\n                this.SetDebuggingEnabled(true);\n            return ret\n        }\n        DebugFastTrigger(method, inst, value) {\n            return this._eventSheetManager._DebugFastTrigger(this._layoutManager, method, inst, value)\n        }\n        ScheduleTriggers(f) {\n            return this._scheduleTriggersThrottle.Add(f)\n        }\n        PushCurrentLayout(layout) {\n            this._currentLayoutStack.push(layout)\n        }\n        PopCurrentLayout() {\n            if (!this._currentLayoutStack.length)\n                throw new Error("layout stack empty");\n            this._currentLayoutStack.pop()\n        }\n        GetCurrentLayout() {\n            if (!this._currentLayoutStack.length)\n                return this.GetMainRunningLayout();\n            return this._currentLayoutStack.at(-1)\n        }\n        GetDt(inst) {\n            if (!inst || inst.GetTimeScale() === -1)\n                return this._dt;\n            return this._dt1 * inst.GetTimeScale()\n        }\n        _GetDtFast() {\n            return this._dt\n        }\n        GetDt1() {\n            return this._dt1\n        }\n        GetTimeScale() {\n            return this._timeScale\n        }\n        SetTimeScale(ts) {\n            if (isNaN(ts) || ts < 0)\n                ts = 0;\n            this._timeScale = ts\n        }\n        SetMinimumFramerate(fps) {\n            this._minimumFramerate = C3.clamp(fps, 1, 120)\n        }\n        GetMinimumFramerate() {\n            return this._minimumFramerate\n        }\n        GetFPS() {\n            return this._fps\n        }\n        GetMainThreadTime() {\n            return this._mainThreadTime\n        }\n        GetStartTime() {\n            return this._startTime\n        }\n        GetGameTime() {\n            return this._gameTime.Get()\n        }\n        GetGameTimeRaw() {\n            return this._gameTimeRaw.Get()\n        }\n        GetWallTime() {\n            return this._wallTime.Get()\n        }\n        GetTickCount() {\n            return this._tickCount\n        }\n        GetTickCountNoSave() {\n            return this._tickCountNoSave\n        }\n        GetObjectCount() {\n            return this._objectCount\n        }\n        GetProjectName() {\n            return this._projectName\n        }\n        GetProjectVersion() {\n            return this._projectVersion\n        }\n        GetProjectUniqueId() {\n            return this._projectUniqueId\n        }\n        GetAppId() {\n            return this._appId\n        }\n        GetInstanceByUID(uid) {\n            if (this._isLoadingState)\n                throw new Error("cannot call while loading state - wait until afterload event");\n            return this._instancesByUid.get(uid) || null\n        }\n        _RefreshUidMap() {\n            this._instancesByUid.clear();\n            for (const objectClass of this._allObjectClasses) {\n                if (objectClass.IsFamily())\n                    continue;\n                for (const inst of objectClass.GetInstances())\n                    this._instancesByUid.set(inst.GetUID(), inst)\n            }\n        }\n        IsPreview() {\n            return this._exportType === "preview"\n        }\n        IsDebug() {\n            return this._isDebug\n        }\n        GetExportType() {\n            return this._exportType\n        }\n        IsCordova() {\n            return this._exportType === "cordova"\n        }\n        IsAndroidWebView() {\n            return C3.Platform.OS === "Android" && (this._exportType === "cordova" || this._exportType === "playable-ad" || this._exportType === "instant-games")\n        }\n        IsiOSCordova() {\n            return this._isiOSCordova\n        }\n        IsiOSWebView() {\n            return this._isiOSWebView\n        }\n        GetCollisionEngine() {\n            return this._collisionEngine\n        }\n        GetSolidBehavior() {\n            return this._pluginManager.GetSolidBehavior()\n        }\n        GetJumpthruBehavior() {\n            return this._pluginManager.GetJumpthruBehavior()\n        }\n        Uses3DFeatures() {\n            return this._uses3dFeatures\n        }\n        GetZScaleFactor() {\n            return this.GetRenderer().GetZAxisScaleFactor(this.GetViewportHeight())\n        }\n        GetDefaultCameraZ(viewH) {\n            return this.GetRenderer().GetDefaultCameraZ(viewH || this.GetViewportHeight())\n        }\n        IsLayoutFirstTick() {\n            return this._isLayoutFirstTick\n        }\n        SetPixelRoundingEnabled(e) {\n            e = !!e;\n            if (this._isPixelRoundingEnabled === e)\n                return;\n            this._isPixelRoundingEnabled = e;\n            this.GetLayoutManager().SetAllLayerMVChanged();\n            this.UpdateRender()\n        }\n        IsPixelRoundingEnabled() {\n            return this._isPixelRoundingEnabled\n        }\n        SaveToSlot(slotName) {\n            this._saveToSlotName = slotName\n        }\n        LoadFromSlot(slotName) {\n            this._loadFromSlotName = slotName\n        }\n        LoadFromJsonString(str) {\n            this._loadFromJson = str\n        }\n        GetLastSaveJsonString() {\n            return this._lastSaveJson\n        }\n        _NeedsHandleSaveOrLoad() {\n            return !!(this._saveToSlotName || this._loadFromSlotName || this._loadFromJson !== null)\n        }\n        async _HandleSaveOrLoad() {\n            if (this._saveToSlotName) {\n                this.FlushPendingInstances();\n                await this._DoSaveToSlot(this._saveToSlotName);\n                this._ClearSaveOrLoad()\n            }\n            if (this._loadFromSlotName) {\n                await this._DoLoadFromSlot(this._loadFromSlotName);\n                this._ClearSaveOrLoad();\n                if (this.IsDebug())\n                    C3Debugger.StepIfPausedInDebugger()\n            }\n            if (this._loadFromJson !== null) {\n                this.FlushPendingInstances();\n                try {\n                    await this._DoLoadFromJsonString(this._loadFromJson);\n                    this._lastSaveJson = this._loadFromJson;\n                    await this.TriggerAsync(C3.Plugins.System.Cnds.OnLoadComplete, null);\n                    this._lastSaveJson = ""\n                } catch (err) {\n                    console.error("[Construct] Failed to load state from JSON string: ", err);\n                    await this.TriggerAsync(C3.Plugins.System.Cnds.OnLoadFailed, null)\n                }\n                this._ClearSaveOrLoad()\n            }\n        }\n        _ClearSaveOrLoad() {\n            this._saveToSlotName = "";\n            this._loadFromSlotName = "";\n            this._loadFromJson = null\n        }\n        _GetProjectStorage() {\n            if (!this._projectStorage)\n                this._projectStorage = localforage.createInstance({\n                    name: "c3-localstorage-" + this.GetProjectUniqueId(),\n                    description: this.GetProjectName()\n                });\n            return this._projectStorage\n        }\n        _GetSavegamesStorage() {\n            if (!this._savegamesStorage)\n                this._savegamesStorage = localforage.createInstance({\n                    name: "c3-savegames-" + this.GetProjectUniqueId(),\n                    description: this.GetProjectName()\n                });\n            return this._savegamesStorage\n        }\n        async _DoSaveToSlot(slotName) {\n            const saveJson = await this._SaveToJsonString();\n            try {\n                await this._GetSavegamesStorage().setItem(slotName, saveJson);\n                console.log("[Construct] Saved state to storage (" + saveJson.length + " chars)");\n                this._lastSaveJson = saveJson;\n                await this.TriggerAsync(C3.Plugins.System.Cnds.OnSaveComplete, null);\n                this._lastSaveJson = ""\n            } catch (err) {\n                console.error("[Construct] Failed to save state to storage: ", err);\n                await this.TriggerAsync(C3.Plugins.System.Cnds.OnSaveFailed, null)\n            }\n        }\n        async _DoLoadFromSlot(slotName) {\n            try {\n                const loadJson = await this._GetSavegamesStorage().getItem(slotName);\n                if (!loadJson)\n                    throw new Error("empty slot");\n                console.log("[Construct] Loaded state from storage (" + loadJson.length + " chars)");\n                await this._DoLoadFromJsonString(loadJson);\n                this._lastSaveJson = loadJson;\n                await this.TriggerAsync(C3.Plugins.System.Cnds.OnLoadComplete, null);\n                this._lastSaveJson = ""\n            } catch (err) {\n                console.error("[Construct] Failed to load state from storage: ", err);\n                await this.TriggerAsync(C3.Plugins.System.Cnds.OnLoadFailed, null)\n            }\n        }\n        async _SaveToJsonString() {\n            const o = {\n                "c3save": true,\n                "version": 1,\n                "rt": {\n                    "time": this.GetGameTime(),\n                    "timeRaw": this.GetGameTimeRaw(),\n                    "walltime": this.GetWallTime(),\n                    "timescale": this.GetTimeScale(),\n                    "tickcount": this.GetTickCount(),\n                    "next_uid": this._nextUid,\n                    "running_layout": this.GetMainRunningLayout().GetSID(),\n                    "start_time_offset": Date.now() - this._startTime\n                },\n                "types": {},\n                "layouts": {},\n                "events": this._eventSheetManager._SaveToJson(),\n                "timelines": this._timelineManager._SaveToJson(),\n                "user_script_data": null\n            };\n            for (const objectClass of this._allObjectClasses) {\n                if (objectClass.IsFamily() || objectClass.HasNoSaveBehavior())\n                    continue;\n                o["types"][objectClass.GetSID().toString()] = objectClass._SaveToJson()\n            }\n            for (const layout of this._layoutManager.GetAllLayouts())\n                o["layouts"][layout.GetSID().toString()] = layout._SaveToJson();\n            const saveEvent = this._CreateUserScriptEvent("save");\n            saveEvent.saveData = null;\n            await this.DispatchUserScriptEventAsyncWait(saveEvent);\n            o["user_script_data"] = saveEvent.saveData;\n            return JSON.stringify(o)\n        }\n        IsLoadingState() {\n            return this._isLoadingState\n        }\n        async _DoLoadFromJsonString(jsonStr) {\n            const layoutManager = this.GetLayoutManager();\n            const o = JSON.parse(jsonStr);\n            if (o["c2save"])\n                throw new Error("C2 saves are incompatible with C3 runtime");\n            if (!o["c3save"])\n                throw new Error("not valid C3 save data");\n            if (o["version"] > 1)\n                throw new Error("C3 save data from future version");\n            this._dispatcher.dispatchEvent(C3.New(C3.Event, "beforeload"));\n            for (const inst of this.allInstances())\n                inst._OnBeforeLoad();\n            this._isLoadingState = true;\n            const rt = o["rt"];\n            this._gameTime.Set(rt["time"]);\n            if (rt.hasOwnProperty("timeRaw"))\n                this._gameTimeRaw.Set(rt["timeRaw"]);\n            this._wallTime.Set(rt["walltime"]);\n            this._timeScale = rt["timescale"];\n            this._tickCount = rt["tickcount"];\n            this._startTime = Date.now() - rt["start_time_offset"];\n            const layoutSid = rt["running_layout"];\n            if (layoutSid !== this.GetMainRunningLayout().GetSID()) {\n                const changeToLayout = layoutManager.GetLayoutBySID(layoutSid);\n                if (changeToLayout)\n                    await this._DoChangeLayout(changeToLayout);\n                else\n                    return\n            }\n            for (const [sidStr,data] of Object.entries(o["types"])) {\n                const sid = parseInt(sidStr, 10);\n                const objectClass = this.GetObjectClassBySID(sid);\n                if (!objectClass || objectClass.IsFamily() || objectClass.HasNoSaveBehavior())\n                    continue;\n                objectClass._LoadFromJson(data)\n            }\n            this.FlushPendingInstances();\n            this._RefreshUidMap();\n            this._isLoadingState = false;\n            this._nextUid = rt["next_uid"];\n            for (const [sidStr,data] of Object.entries(o["layouts"])) {\n                const sid = parseInt(sidStr, 10);\n                const layout = layoutManager.GetLayoutBySID(sid);\n                if (!layout)\n                    continue;\n                layout._LoadFromJson(data)\n            }\n            this._eventSheetManager._LoadFromJson(o["events"]);\n            for (const objectClass of this._allObjectClasses) {\n                if (objectClass.IsFamily() || !objectClass.IsInContainer())\n                    continue;\n                for (const inst of objectClass.GetInstances()) {\n                    const iid = inst.GetIID();\n                    for (const otherType of objectClass.GetContainer().objectTypes()) {\n                        if (otherType === objectClass)\n                            continue;\n                        const otherInstances = otherType.GetInstances();\n                        if (iid < 0 || iid >= otherInstances.length)\n                            throw new Error("missing sibling instance");\n                        inst._AddSibling(otherInstances[iid])\n                    }\n                }\n            }\n            this._timelineManager._LoadFromJson(o["timelines"]);\n            layoutManager.SetAllLayerProjectionChanged();\n            layoutManager.SetAllLayerMVChanged();\n            this._dispatcher.dispatchEvent(C3.New(C3.Event, "afterload"));\n            const loadEvent = this._CreateUserScriptEvent("load");\n            loadEvent.saveData = o["user_script_data"];\n            await this.DispatchUserScriptEventAsyncWait(loadEvent);\n            this.UpdateRender()\n        }\n        async AddJobWorkerScripts(scripts) {\n            const blobs = await Promise.all(scripts.map(url => this._assetManager.FetchBlob(url)));\n            const blobUrls = blobs.map(b => URL.createObjectURL(b));\n            this._jobScheduler.ImportScriptsToJobWorkers(blobUrls)\n        }\n        AddJobWorkerBlob(blob, id) {\n            this._jobScheduler.SendBlobToJobWorkers(blob, id)\n        }\n        AddJobWorkerBuffer(buffer, id) {\n            this._jobScheduler.SendBufferToJobWorkers(buffer, id)\n        }\n        AddJob(type, params, transferables) {\n            return this._jobScheduler.AddJob(type, params, transferables)\n        }\n        BroadcastJob(type, params, transferables) {\n            return this._jobScheduler.BroadcastJob(type, params, transferables)\n        }\n        InvokeDownload(url, filename) {\n            this.PostComponentMessageToDOM("runtime", "invoke-download", {\n                "url": url,\n                "filename": filename\n            })\n        }\n        async RasterSvgImage(blob, imageWidth, imageHeight, surfaceWidth, surfaceHeight, imageBitmapOpts) {\n            surfaceWidth = surfaceWidth || imageWidth;\n            surfaceHeight = surfaceHeight || imageHeight;\n            if (this.IsInWorker()) {\n                const result = await this.PostComponentMessageToDOMAsync("runtime", "raster-svg-image", {\n                    "blob": blob,\n                    "imageWidth": imageWidth,\n                    "imageHeight": imageHeight,\n                    "surfaceWidth": surfaceWidth,\n                    "surfaceHeight": surfaceHeight,\n                    "imageBitmapOpts": imageBitmapOpts\n                });\n                return result["imageBitmap"]\n            } else {\n                const canvas = await self["C3_RasterSvgImageBlob"](blob, imageWidth, imageHeight, surfaceWidth, surfaceHeight);\n                if (imageBitmapOpts)\n                    return await self.createImageBitmap(canvas, imageBitmapOpts);\n                else\n                    return canvas\n            }\n        }\n        async GetSvgImageSize(blob) {\n            if (this.IsInWorker())\n                return await this.PostComponentMessageToDOMAsync("runtime", "get-svg-image-size", {\n                    "blob": blob\n                });\n            else\n                return await self["C3_GetSvgImageSize"](blob)\n        }\n        RequestDeviceOrientationEvent() {\n            if (this._didRequestDeviceOrientationEvent)\n                return;\n            this._didRequestDeviceOrientationEvent = true;\n            this.PostComponentMessageToDOM("runtime", "enable-device-orientation")\n        }\n        RequestDeviceMotionEvent() {\n            if (this._didRequestDeviceMotionEvent)\n                return;\n            this._didRequestDeviceMotionEvent = true;\n            this.PostComponentMessageToDOM("runtime", "enable-device-motion")\n        }\n        Random() {\n            return this._randomNumberCallback()\n        }\n        SetRandomNumberGeneratorCallback(f) {\n            this._randomNumberCallback = f\n        }\n        _GetRemotePreviewStatusInfo() {\n            const webglRenderer = this.GetWebGLRenderer();\n            return {\n                "fps": this.GetFPS(),\n                "cpu": this.GetMainThreadTime(),\n                "gpu": this.GetGPUUtilisation(),\n                "layout": this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : "",\n                "renderer": webglRenderer ? webglRenderer.GetUnmaskedRenderer() : "<unavailable>"\n            }\n        }\n        HitBreakpoint() {\n            if (!this.IsDebug())\n                return false;\n            return C3Debugger.HitBreakpoint()\n        }\n        DebugBreak(eventObject) {\n            if (!this.IsDebugging())\n                return Promise.resolve();\n            return C3Debugger.DebugBreak(eventObject)\n        }\n        DebugBreakNext() {\n            if (!this.IsDebugging())\n                return false;\n            return C3Debugger.BreakNext()\n        }\n        SetDebugBreakpointsEnabled(e) {\n            this._breakpointsEnabled = !!e;\n            this._UpdateDebuggingFlag()\n        }\n        AreDebugBreakpointsEnabled() {\n            return this._breakpointsEnabled\n        }\n        IsDebugging() {\n            return this._isDebugging\n        }\n        SetDebuggingEnabled(d) {\n            if (d)\n                this._debuggingDisabled--;\n            else\n                this._debuggingDisabled++;\n            this._UpdateDebuggingFlag()\n        }\n        _UpdateDebuggingFlag() {\n            this._isDebugging = this.IsDebug() && this._breakpointsEnabled && this._debuggingDisabled === 0\n        }\n        IsCPUProfiling() {\n            return this.IsDebug() && C3Debugger.IsCPUProfiling()\n        }\n        IsGPUProfiling() {\n            return this.IsDebug() && this.GetRenderer().SupportsGPUProfiling() && C3Debugger.IsGPUProfiling()\n        }\n        async DebugIterateAndBreak(iter) {\n            if (!iter)\n                return;\n            for (const breakEventObject of iter)\n                await this.DebugBreak(breakEventObject)\n        }\n        DebugFireGeneratorEventAndBreak(event) {\n            return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(event))\n        }\n        _InvokeFunctionFromJS(e) {\n            return this._eventSheetManager._InvokeFunctionFromJS(e["name"], e["params"])\n        }\n        GetIRuntime() {\n            return this._iRuntime\n        }\n        _CreateUserScriptEvent(name) {\n            const e = C3.New(C3.Event, name, false);\n            e.runtime = this._iRuntime;\n            return e\n        }\n        _InitScriptInterfaces() {\n            const objectDescriptors = {};\n            for (const objectClass of this._allObjectClasses)\n                objectDescriptors[objectClass.GetJsPropName()] = {\n                    value: objectClass.GetIObjectClass(),\n                    enumerable: true,\n                    writable: false\n                };\n            const objects = Object.create(Object.prototype, objectDescriptors);\n            this._iRuntime = new self.IRuntime(this,objects);\n            this._userScriptEventObjects = {\n                "tick": this._CreateUserScriptEvent("tick")\n            }\n        }\n        _InitGlobalVariableScriptInterface() {\n            const globalVarDescriptors = {};\n            for (const globalVar of this.GetEventSheetManager().GetAllGlobalVariables())\n                globalVarDescriptors[globalVar.GetJsPropName()] = globalVar._GetScriptInterfaceDescriptor();\n            this._iRuntime._InitGlobalVars(globalVarDescriptors)\n        }\n        _GetCommonScriptInterfaces() {\n            return this._commonScriptInterfaces\n        }\n        _MapScriptInterface(interface_, class_) {\n            this._interfaceMap.set(interface_, class_)\n        }\n        _UnwrapScriptInterface(interface_) {\n            return this._interfaceMap.get(interface_)\n        }\n        _UnwrapIObjectClass(iObjectClass) {\n            if (!(iObjectClass instanceof self.IObjectClass))\n                throw new TypeError("expected IObjectClass");\n            const objectClass = this._UnwrapScriptInterface(iObjectClass);\n            if (!objectClass || !(objectClass instanceof C3.ObjectClass))\n                throw new Error("invalid IObjectClass");\n            return objectClass\n        }\n        _UnwrapIWorldInstance(iinst) {\n            if (!(iinst instanceof self.IWorldInstance))\n                throw new TypeError("expected IWorldInstance");\n            const inst = this._UnwrapScriptInterface(iinst);\n            if (!inst || !(inst instanceof C3.Instance))\n                throw new Error("invalid IInstance");\n            return inst\n        }\n    }\n    ;\n    self["C3_CreateRuntime"] = C3.Runtime.Create;\n    self["C3_InitRuntime"] = (runtime, opts) => runtime.Init(opts);\n\n}\n\n\/\/ workers\/jobSchedulerRuntime.js\n{\n    \'use strict\';\n    const C3 = self.C3;\n    C3.JobSchedulerRuntime = class JobSchedulerRuntime extends C3.DefendedBase {\n        constructor(runtime, data) {\n            super();\n            this._runtime = runtime;\n            this._jobPromises = new Map;\n            this._nextJobId = 0;\n            this._inputPort = data["inputPort"];\n            data["outputPort"].onmessage = e => this._OnJobWorkerMessage(e);\n            this._maxNumWorkers = data["maxNumWorkers"];\n            this._jobWorkerCount = 1;\n            this._isCreatingWorker = false;\n            this._hadErrorCreatingWorker = false\n        }\n        async Init() {}\n        ImportScriptsToJobWorkers(scripts) {\n            this._inputPort.postMessage({\n                "type": "_import_scripts",\n                "scripts": scripts\n            })\n        }\n        SendBlobToJobWorkers(blob, id) {\n            this._inputPort.postMessage({\n                "type": "_send_blob",\n                "blob": blob,\n                "id": id\n            })\n        }\n        SendBufferToJobWorkers(buffer, id) {\n            this._inputPort.postMessage({\n                "type": "_send_buffer",\n                "buffer": buffer,\n                "id": id\n            }, [buffer])\n        }\n        AddJob(type, params, transferables, progressHandler, abortDisposable) {\n            if (!transferables)\n                transferables = [];\n            const jobId = this._nextJobId++;\n            const job = {\n                "type": type,\n                "isBroadcast": false,\n                "jobId": jobId,\n                "params": params,\n                "transferables": transferables\n            };\n            const promise = new Promise( (resolve, reject) => {\n                this._jobPromises.set(jobId, {\n                    resolve: resolve,\n                    progress: progressHandler,\n                    reject: reject,\n                    cancelled: false\n                })\n            }\n            );\n            if (abortDisposable)\n                abortDisposable.SetAction( () => this._CancelJob(jobId));\n            this._inputPort.postMessage(job, transferables);\n            this._MaybeCreateExtraWorker();\n            return promise\n        }\n        BroadcastJob(type, params, transferables) {\n            if (!transferables)\n                transferables = [];\n            const jobId = this._nextJobId++;\n            const job = {\n                "type": type,\n                "isBroadcast": true,\n                "jobId": jobId,\n                "params": params,\n                "transferables": transferables\n            };\n            this._inputPort.postMessage(job, transferables)\n        }\n        _CancelJob(jobId) {\n            const job = this._jobPromises.get(jobId);\n            if (job) {\n                job.cancelled = true;\n                job.resolve = null;\n                job.progress = null;\n                job.reject = null;\n                this._inputPort.postMessage({\n                    "type": "_cancel",\n                    "jobId": jobId\n                })\n            }\n        }\n        _OnJobWorkerMessage(e) {\n            const msg = e.data;\n            const type = msg["type"];\n            const id = msg["jobId"];\n            switch (type) {\n            case "result":\n                this._OnJobResult(id, msg["result"]);\n                break;\n            case "progress":\n                this._OnJobProgress(id, msg["progress"]);\n                break;\n            case "error":\n                this._OnJobError(id, msg["error"]);\n                break;\n            case "ready":\n                this._OnJobWorkerReady();\n                break;\n            default:\n                throw new Error(`unknown message from worker \'${type}\'`);\n            }\n        }\n        _OnJobResult(jobId, result) {\n            const p = this._jobPromises.get(jobId);\n            if (!p)\n                throw new Error("invalid job ID");\n            if (!p.cancelled)\n                p.resolve(result);\n            this._jobPromises.delete(jobId)\n        }\n        _OnJobProgress(jobId, progress) {\n            const p = this._jobPromises.get(jobId);\n            if (!p)\n                throw new Error("invalid job ID");\n            if (!p.cancelled && p.progress)\n                p.progress(progress)\n        }\n        _OnJobError(jobId, error) {\n            const p = this._jobPromises.get(jobId);\n            if (!p)\n                throw new Error("invalid job ID");\n            if (!p.cancelled)\n                p.reject(error);\n            this._jobPromises.delete(jobId)\n        }\n        _OnJobWorkerReady() {\n            if (!this._isCreatingWorker)\n                return;\n            this._isCreatingWorker = false;\n            this._jobWorkerCount++;\n            if (this._jobWorkerCount < this._maxNumWorkers)\n                this._MaybeCreateExtraWorker();\n            else\n                this._inputPort.postMessage({\n                    "type": "_no_more_workers"\n                })\n        }\n        async _MaybeCreateExtraWorker() {\n            if (this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._jobPromises.size <= this._jobWorkerCount)\n                return;\n            try {\n                this._isCreatingWorker = true;\n                const result = await this._runtime.PostComponentMessageToDOMAsync("runtime", "create-job-worker");\n                result["outputPort"].onmessage = e => this._OnJobWorkerMessage(e)\n            } catch (err) {\n                this._hadErrorCreatingWorker = true;\n                this._isCreatingWorker = false;\n                console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, err)\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    self["C3_Shaders"] = {};\n    self["C3_Shaders"]["warpripple"] = {\n        glsl: "#ifdef GL_FRAGMENT_PRECISION_HIGH\\n#define highmedp highp\\n#else\\n#define highmedp mediump\\n#endif\\nvarying mediump vec2 vTex;\\nuniform lowp sampler2D samplerFront;\\nuniform mediump vec2 srcOriginStart;\\nuniform mediump vec2 srcOriginEnd;\\nuniform highmedp float seconds;\\nuniform mediump vec2 pixelSize;\\nuniform mediump float freq;\\nuniform mediump float amp;\\nuniform mediump float speed;\\nconst mediump float PI = 3.1415926;\\nvoid main(void)\\n{\\nmediump vec2 srcOriginSize = srcOriginEnd - srcOriginStart;\\nmediump vec2 tex = (vTex - srcOriginStart) \/ srcOriginSize;\\ntex = tex * 2.0 - 1.0;\\nmediump float d = length(tex);\\nmediump float a = atan(tex.y, tex.x);\\nd += sin((d * 2.0 * PI) * freq \/ (pixelSize.x * 750.0) + (seconds * speed)) * amp * (pixelSize.x * 750.0);\\ntex.x = cos(a) * d;\\ntex.y = sin(a) * d;\\ntex = (tex + 1.0) \/ 2.0;\\ntex = clamp(tex, 0.0, 1.0);\\ntex = tex * srcOriginSize + srcOriginStart;\\ngl_FragColor = texture2D(samplerFront, tex);\\n}",\n        wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\\nstruct ShaderParams {\\nfreq : f32,\\namp : f32,\\nspeed : f32\\n};\\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\\n%%C3PARAMS_STRUCT%%\\n%%C3_UTILITY_FUNCTIONS%%\\n%%FRAGMENTINPUT_STRUCT%%\\n%%FRAGMENTOUTPUT_STRUCT%%\\nlet pi : f32 = 3.1415926;\\n@stage(fragment)\\nfn main(input : FragmentInput) -> FragmentOutput\\n{\\nvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\\nvar tex = c3_srcOriginToNorm(input.fragUV);\\ntex = tex * 2.0 - 1.0;\\nvar d : f32 = length(tex);\\nvar a = atan2(tex.y, tex.x);\\nd = d + sin((d * 2.0 * pi) * shaderParams.freq \/ (pixelSize.x * 750.0) + (c3Params.seconds * shaderParams.speed)) * shaderParams.amp * (pixelSize.x * 750.0);\\ntex.x = cos(a) * d;\\ntex.y = sin(a) * d;\\ntex = (tex + 1.0) \/ 2.0;\\ntex = c3_clamp2(tex, 0.0, 1.0);\\ntex = c3_normToSrcOrigin(tex);\\nvar output : FragmentOutput;\\noutput.color = textureSample(textureFront, samplerFront, tex);\\nreturn output;\\n}",\n        blendsBackground: false,\n        usesDepth: false,\n        extendBoxHorizontal: 50,\n        extendBoxVertical: 50,\n        crossSampling: false,\n        mustPreDraw: false,\n        preservesOpaqueness: false,\n        animated: true,\n        parameters: [["freq", 0, "float"], ["amp", 0, "percent"], ["speed", 0, "float"]]\n    };\n    self["C3_Shaders"]["tint"] = {\n        glsl: "varying mediump vec2 vTex;\\nuniform lowp sampler2D samplerFront;\\nuniform lowp vec3 tintColor;\\nvoid main(void)\\n{\\nlowp vec4 front = texture2D(samplerFront, vTex);\\ngl_FragColor = front * vec4(tintColor.r, tintColor.g, tintColor.b, 1.0);\\n}",\n        wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\\nstruct ShaderParams {\\ntintColor : vec3<f32>\\n};\\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\\n%%FRAGMENTINPUT_STRUCT%%\\n%%FRAGMENTOUTPUT_STRUCT%%\\n@stage(fragment)\\nfn main(input : FragmentInput) -> FragmentOutput {\\nvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\\nvar output : FragmentOutput;\\noutput.color = front * vec4<f32>(shaderParams.tintColor, 1.0);\\nreturn output;\\n}",\n        blendsBackground: false,\n        usesDepth: false,\n        extendBoxHorizontal: 0,\n        extendBoxVertical: 0,\n        crossSampling: false,\n        mustPreDraw: false,\n        preservesOpaqueness: true,\n        animated: false,\n        parameters: [["tintColor", 0, "color"]]\n    };\n    self["C3_Shaders"]["water"] = {\n        glsl: "#ifdef GL_FRAGMENT_PRECISION_HIGH\\n#define highmedp highp\\n#else\\n#define highmedp mediump\\n#endif\\nvarying mediump vec2 vTex;\\nuniform lowp sampler2D samplerFront;\\nuniform mediump vec2 srcStart;\\nuniform mediump vec2 srcEnd;\\nprecision mediump float;\\nuniform highmedp float seconds;\\nuniform mediump vec2 pixelSize;\\nconst float PI = 3.1415926535897932;\\nuniform float speed;\\nuniform float speed_x;\\nuniform float speed_y;\\nuniform float intensity;\\nconst float steps = 8.0;\\nuniform float frequency;\\nuniform float angle; \/\/ better when a prime\\nuniform float delta;\\nuniform float intence;\\nuniform float emboss;\\nfloat col(vec2 coord)\\n{\\nfloat delta_theta = 2.0 * PI \/ angle;\\nfloat col = 0.0;\\nfloat theta = 0.0;\\nfor (float i = 0.0; i < steps; i++)\\n{\\nvec2 adjc = coord;\\ntheta = delta_theta*i;\\nadjc.x += cos(theta)*seconds*speed + seconds * speed_x;\\nadjc.y -= sin(theta)*seconds*speed - seconds * speed_y;\\ncol = col + cos( (adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;\\n}\\nreturn cos(col);\\n}\\nvoid main(void)\\n{\\nmediump vec2 tex = (vTex - srcStart) \/ (srcEnd - srcStart);\\nvec2 p = tex, c1 = p, c2 = p;\\nfloat cc1 = col(c1);\\nc2.x += (1.0 \/ pixelSize.x) \/ delta;\\nfloat dx = emboss*(cc1-col(c2))\/delta;\\nc2.x = p.x;\\nc2.y += (1.0 \/ pixelSize.y) \/ delta;\\nfloat dy = emboss*(cc1-col(c2))\/delta;\\nc1.x += dx;\\nc1.y = -(c1.y+dy);\\nfloat alpha = 1.+dot(dx,dy)*intence;\\nc1.y = -c1.y;\\nc1 = clamp(c1, 0.0, 1.0);\\ngl_FragColor = texture2D(samplerFront, mix(srcStart, srcEnd, c1)) * alpha;\\n}",\n        wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\\nstruct ShaderParams {\\nspeed : f32,\\nspeed_x : f32,\\nspeed_y : f32,\\nintensity : f32,\\nfrequency : f32,\\nangle : f32,\\ndelta : f32,\\nintence : f32,\\nemboss : f32\\n};\\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\\n%%C3PARAMS_STRUCT%%\\n%%C3_UTILITY_FUNCTIONS%%\\n%%FRAGMENTINPUT_STRUCT%%\\n%%FRAGMENTOUTPUT_STRUCT%%\\nlet pi : f32 = 3.1415926535897932;\\nlet steps = 8.0;\\nfn col(coord : vec2<f32>) -> f32\\n{\\nvar delta_theta : f32 = 2.0 * pi \/ shaderParams.angle;\\nvar col : f32 = 0.0;\\nvar theta : f32 = 0.0;\\nfor (var i : f32 = 0.0; i < steps; i = i + 1.0)\\n{\\nvar adjc : vec2<f32> = coord;\\ntheta = delta_theta * i;\\nadjc.x = adjc.x + cos(theta) * c3Params.seconds * shaderParams.speed + c3Params.seconds * shaderParams.speed_x;\\nadjc.y = adjc.y - (sin(theta) * c3Params.seconds * shaderParams.speed - c3Params.seconds * shaderParams.speed_y);\\ncol = col + cos((adjc.x * cos(theta) - adjc.y * sin(theta)) * shaderParams.frequency) * shaderParams.intensity;\\n}\\nreturn cos(col);\\n}\\n@stage(fragment)\\nfn main(input : FragmentInput) -> FragmentOutput\\n{\\nvar texSize : vec2<f32> = vec2<f32>(textureDimensions(textureFront));\\nvar tex : vec2<f32> = c3_srcToNorm(input.fragUV);\\nvar p : vec2<f32> = tex;\\nvar c1 : vec2<f32> = tex;\\nvar c2 : vec2<f32> = tex;\\nvar cc1 : f32 = col(c1);\\nc2.x = c2.x + texSize.x \/ shaderParams.delta;\\nvar dx : f32 = shaderParams.emboss * (cc1 - col(c2)) \/ shaderParams.delta;\\nc2.x = p.x;\\nc2.y = c2.y + texSize.y \/ shaderParams.delta;\\nvar dy : f32 = shaderParams.emboss * (cc1 - col(c2)) \/ shaderParams.delta;\\nc1.x = c1.x + dx;\\nc1.y = -(c1.y + dy);\\nvar alpha : f32 = 1.0 + dx * dy * shaderParams.intence;\\nc1.y = -c1.y;\\nc1 = c3_clamp2(c1, 0.0, 1.0);\\nvar output : FragmentOutput;\\noutput.color = textureSample(textureFront, samplerFront, mix(c3Params.srcStart, c3Params.srcEnd, c1)) * alpha;\\nreturn output;\\n}",\n        blendsBackground: false,\n        usesDepth: false,\n        extendBoxHorizontal: 40,\n        extendBoxVertical: 40,\n        crossSampling: false,\n        mustPreDraw: false,\n        preservesOpaqueness: false,\n        animated: true,\n        parameters: [["speed", 0, "percent"], ["speed_x", 0, "percent"], ["speed_y", 0, "percent"], ["intensity", 0, "float"], ["frequency", 0, "float"], ["angle", 0, "float"], ["delta", 0, "float"], ["intence", 0, "float"], ["emboss", 0, "percent"]]\n    };\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        let cacheRegex = null;\n        let lastRegex = "";\n        let lastFlags = "";\n        let regexMatches = [];\n        let lastMatchesStr = "";\n        let lastMatchesRegex = "";\n        let lastMatchesFlags = "";\n        const forEachStack = C3.New(C3.ArrayStack);\n        function ForEachOrdered_SortInstances(a, b) {\n            const va = a[1];\n            const vb = b[1];\n            if (typeof va === "number" && typeof vb === "number")\n                return va - vb;\n            else {\n                const sa = "" + va;\n                const sb = "" + vb;\n                if (sa < sb)\n                    return -1;\n                else if (sa > sb)\n                    return 1;\n                else\n                    return 0\n            }\n        }\n        C3.Plugins.System = class SystemPlugin extends C3.SDKPluginBase {\n            constructor(opts) {\n                super(opts);\n                this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack();\n                this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();\n                this._imagesLoadingTotal = 0;\n                this._imagesLoadingComplete = 0;\n                this._functionMaps = new Map\n            }\n            Release() {\n                super.Release()\n            }\n            UpdateRender() {\n                this._runtime.UpdateRender()\n            }\n            Trigger(method) {\n                this._runtime.Trigger(method, null, null)\n            }\n            GetRegex(regex, flags) {\n                if (!cacheRegex || regex !== lastRegex || flags !== lastFlags) {\n                    cacheRegex = new RegExp(regex,flags);\n                    lastRegex = regex;\n                    lastFlags = flags\n                }\n                cacheRegex.lastIndex = 0;\n                return cacheRegex\n            }\n            GetRegexMatches(str, regex, flags) {\n                if (str === lastMatchesStr && regex === lastMatchesRegex && flags === lastMatchesFlags)\n                    return regexMatches;\n                const cacheRegex = this.GetRegex(regex, flags);\n                regexMatches = str.match(cacheRegex);\n                lastMatchesStr = str;\n                lastMatchesRegex = regex;\n                lastMatchesFlags = flags;\n                return regexMatches\n            }\n            async _LoadTexturesForObjectClasses(layout, objectClasses) {\n                if (!objectClasses.length)\n                    return;\n                this._imagesLoadingTotal += objectClasses.length;\n                const promises = [];\n                for (const oc of objectClasses)\n                    promises.push(layout.MaybeLoadTexturesFor(oc));\n                await C3.PromiseAllWithProgress(promises, () => {\n                    this._imagesLoadingComplete++\n                }\n                );\n                this._imagesLoadingComplete++;\n                if (this._imagesLoadingComplete === this._imagesLoadingTotal) {\n                    this._runtime.Trigger(C3.Plugins.System.Cnds.OnImageLoadingComplete, null, null);\n                    this._imagesLoadingComplete = 0;\n                    this._imagesLoadingTotal = 0\n                }\n            }\n            _UnloadTexturesForObjectClasses(layout, objectClasses) {\n                for (const oc of objectClasses)\n                    if (oc.GetInstanceCount() === 0)\n                        layout.MaybeUnloadTexturesFor(oc)\n            }\n            _GetForEachStack() {\n                return forEachStack\n            }\n            _Repeat(count) {\n                const eventSheetManager = this._runtime.GetEventSheetManager();\n                const eventStack = eventSheetManager.GetEventStack();\n                const oldFrame = eventStack.GetCurrentStackFrame();\n                const currentEvent = oldFrame.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiers();\n                const isSolModifierAfterCnds = oldFrame.IsSolModifierAfterCnds();\n                const newFrame = eventStack.Push(currentEvent);\n                const loopStack = eventSheetManager.GetLoopStack();\n                const loop = loopStack.Push();\n                loop.SetEnd(count);\n                if (isSolModifierAfterCnds)\n                    for (let i = 0; i < count && !loop.IsStopped(); ++i) {\n                        eventSheetManager.PushCopySol(solModifiers);\n                        loop.SetIndex(i);\n                        currentEvent.Retrigger(oldFrame, newFrame);\n                        eventSheetManager.PopSol(solModifiers)\n                    }\n                else\n                    for (let i = 0; i < count && !loop.IsStopped(); ++i) {\n                        loop.SetIndex(i);\n                        currentEvent.Retrigger(oldFrame, newFrame)\n                    }\n                eventStack.Pop();\n                loopStack.Pop();\n                return false\n            }\n            *_DebugRepeat(count) {\n                const eventSheetManager = this._runtime.GetEventSheetManager();\n                const eventStack = eventSheetManager.GetEventStack();\n                const oldFrame = eventStack.GetCurrentStackFrame();\n                const currentEvent = oldFrame.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiers();\n                const isSolModifierAfterCnds = oldFrame.IsSolModifierAfterCnds();\n                const newFrame = eventStack.Push(currentEvent);\n                const loopStack = eventSheetManager.GetLoopStack();\n                const loop = loopStack.Push();\n                loop.SetEnd(count);\n                if (isSolModifierAfterCnds)\n                    for (let i = 0; i < count && !loop.IsStopped(); ++i) {\n                        eventSheetManager.PushCopySol(solModifiers);\n                        loop.SetIndex(i);\n                        yield*currentEvent.DebugRetrigger(oldFrame, newFrame);\n                        eventSheetManager.PopSol(solModifiers)\n                    }\n                else\n                    for (let i = 0; i < count && !loop.IsStopped(); ++i) {\n                        loop.SetIndex(i);\n                        yield*currentEvent.DebugRetrigger(oldFrame, newFrame)\n                    }\n                eventStack.Pop();\n                loopStack.Pop();\n                return false\n            }\n            _While() {\n                const eventSheetManager = this._runtime.GetEventSheetManager();\n                const eventStack = eventSheetManager.GetEventStack();\n                const oldFrame = eventStack.GetCurrentStackFrame();\n                const currentEvent = oldFrame.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiers();\n                const isSolModifierAfterCnds = oldFrame.IsSolModifierAfterCnds();\n                const newFrame = eventStack.Push(currentEvent);\n                const loopStack = eventSheetManager.GetLoopStack();\n                const loop = loopStack.Push();\n                if (isSolModifierAfterCnds)\n                    for (let i = 0; !loop.IsStopped(); ++i) {\n                        eventSheetManager.PushCopySol(solModifiers);\n                        loop.SetIndex(i);\n                        if (!currentEvent.Retrigger(oldFrame, newFrame))\n                            loop.Stop();\n                        eventSheetManager.PopSol(solModifiers)\n                    }\n                else\n                    for (let i = 0; !loop.IsStopped(); ++i) {\n                        loop.SetIndex(i);\n                        if (!currentEvent.Retrigger(oldFrame, newFrame))\n                            loop.Stop()\n                    }\n                eventStack.Pop();\n                loopStack.Pop();\n                return false\n            }\n            *_DebugWhile() {\n                const eventSheetManager = this._runtime.GetEventSheetManager();\n                const eventStack = eventSheetManager.GetEventStack();\n                const oldFrame = eventStack.GetCurrentStackFrame();\n                const currentEvent = oldFrame.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiers();\n                const isSolModifierAfterCnds = oldFrame.IsSolModifierAfterCnds();\n                const newFrame = eventStack.Push(currentEvent);\n                const loopStack = eventSheetManager.GetLoopStack();\n                const loop = loopStack.Push();\n                if (isSolModifierAfterCnds)\n                    for (let i = 0; !loop.IsStopped(); ++i) {\n                        eventSheetManager.PushCopySol(solModifiers);\n                        loop.SetIndex(i);\n                        const ret = yield*currentEvent.DebugRetrigger(oldFrame, newFrame);\n                        if (!ret)\n                            loop.Stop();\n                        eventSheetManager.PopSol(solModifiers)\n                    }\n                else\n                    for (let i = 0; !loop.IsStopped(); ++i) {\n                        loop.SetIndex(i);\n                        const ret = yield*currentEvent.DebugRetrigger(oldFrame, newFrame);\n                        if (!ret)\n                            loop.Stop()\n                    }\n                eventStack.Pop();\n                loopStack.Pop();\n                return false\n            }\n            _For(name, start, end) {\n                const eventSheetManager = this._runtime.GetEventSheetManager();\n                const eventStack = eventSheetManager.GetEventStack();\n                const oldFrame = eventStack.GetCurrentStackFrame();\n                const currentEvent = oldFrame.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiers();\n                const isSolModifierAfterCnds = oldFrame.IsSolModifierAfterCnds();\n                const newFrame = eventStack.Push(currentEvent);\n                const loopStack = eventSheetManager.GetLoopStack();\n                const loop = loopStack.Push();\n                loop.SetName(name);\n                loop.SetEnd(end);\n                if (end < start)\n                    if (isSolModifierAfterCnds)\n                        for (let i = start; i >= end && !loop.IsStopped(); --i) {\n                            eventSheetManager.PushCopySol(solModifiers);\n                            loop.SetIndex(i);\n                            currentEvent.Retrigger(oldFrame, newFrame);\n                            eventSheetManager.PopSol(solModifiers)\n                        }\n                    else\n                        for (let i = start; i >= end && !loop.IsStopped(); --i) {\n                            loop.SetIndex(i);\n                            currentEvent.Retrigger(oldFrame, newFrame)\n                        }\n                else if (isSolModifierAfterCnds)\n                    for (let i = start; i <= end && !loop.IsStopped(); ++i) {\n                        eventSheetManager.PushCopySol(solModifiers);\n                        loop.SetIndex(i);\n                        currentEvent.Retrigger(oldFrame, newFrame);\n                        eventSheetManager.PopSol(solModifiers)\n                    }\n                else\n                    for (let i = start; i <= end && !loop.IsStopped(); ++i) {\n                        loop.SetIndex(i);\n                        currentEvent.Retrigger(oldFrame, newFrame)\n                    }\n                eventStack.Pop();\n                loopStack.Pop();\n                return false\n            }\n            *_DebugFor(name, start, end) {\n                const eventSheetManager = this._runtime.GetEventSheetManager();\n                const eventStack = eventSheetManager.GetEventStack();\n                const oldFrame = eventStack.GetCurrentStackFrame();\n                const currentEvent = oldFrame.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiers();\n                const isSolModifierAfterCnds = oldFrame.IsSolModifierAfterCnds();\n                const newFrame = eventStack.Push(currentEvent);\n                const loopStack = eventSheetManager.GetLoopStack();\n                const loop = loopStack.Push();\n                loop.SetName(name);\n                loop.SetEnd(end);\n                if (end < start)\n                    if (isSolModifierAfterCnds)\n                        for (let i = start; i >= end && !loop.IsStopped(); --i) {\n                            eventSheetManager.PushCopySol(solModifiers);\n                            loop.SetIndex(i);\n                            yield*currentEvent.DebugRetrigger(oldFrame, newFrame);\n                            eventSheetManager.PopSol(solModifiers)\n                        }\n                    else\n                        for (let i = start; i >= end && !loop.IsStopped(); --i) {\n                            loop.SetIndex(i);\n                            yield*currentEvent.DebugRetrigger(oldFrame, newFrame)\n                        }\n                else if (isSolModifierAfterCnds)\n                    for (let i = start; i <= end && !loop.IsStopped(); ++i) {\n                        eventSheetManager.PushCopySol(solModifiers);\n                        loop.SetIndex(i);\n                        yield*currentEvent.DebugRetrigger(oldFrame, newFrame);\n                        eventSheetManager.PopSol(solModifiers)\n                    }\n                else\n                    for (let i = start; i <= end && !loop.IsStopped(); ++i) {\n                        loop.SetIndex(i);\n                        yield*currentEvent.DebugRetrigger(oldFrame, newFrame)\n                    }\n                eventStack.Pop();\n                loopStack.Pop();\n                return false\n            }\n            _ForEach(objectClass) {\n                const eventSheetManager = this._runtime.GetEventSheetManager();\n                const eventStack = eventSheetManager.GetEventStack();\n                const oldFrame = eventStack.GetCurrentStackFrame();\n                const currentEvent = oldFrame.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiers();\n                const isSolModifierAfterCnds = oldFrame.IsSolModifierAfterCnds();\n                const newFrame = eventStack.Push(currentEvent);\n                const loopStack = eventSheetManager.GetLoopStack();\n                const loop = loopStack.Push();\n                const isInContainer = objectClass.IsInContainer();\n                const sol = objectClass.GetCurrentSol();\n                const instances = forEachStack.Push();\n                C3.shallowAssignArray(instances, sol.GetInstances());\n                loop.SetEnd(instances.length);\n                if (isSolModifierAfterCnds)\n                    for (let i = 0, len = instances.length; i < len && !loop.IsStopped(); ++i) {\n                        eventSheetManager.PushCopySol(solModifiers);\n                        const inst = instances[i];\n                        objectClass.GetCurrentSol().SetSinglePicked(inst);\n                        if (isInContainer)\n                            inst.SetSiblingsSinglePicked();\n                        loop.SetIndex(i);\n                        currentEvent.Retrigger(oldFrame, newFrame);\n                        eventSheetManager.PopSol(solModifiers)\n                    }\n                else {\n                    sol._SetSelectAll(false);\n                    const solInstances = sol._GetOwnInstances();\n                    C3.clearArray(solInstances);\n                    solInstances.push(null);\n                    for (let i = 0, len = instances.length; i < len && !loop.IsStopped(); ++i) {\n                        const inst = instances[i];\n                        solInstances[0] = inst;\n                        if (isInContainer)\n                            inst.SetSiblingsSinglePicked();\n                        loop.SetIndex(i);\n                        currentEvent.Retrigger(oldFrame, newFrame)\n                    }\n                }\n                eventStack.Pop();\n                loopStack.Pop();\n                C3.clearArray(instances);\n                forEachStack.Pop();\n                return false\n            }\n            *_DebugForEach(objectClass) {\n                const eventSheetManager = this._runtime.GetEventSheetManager();\n                const eventStack = eventSheetManager.GetEventStack();\n                const oldFrame = eventStack.GetCurrentStackFrame();\n                const currentEvent = oldFrame.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiers();\n                const isSolModifierAfterCnds = oldFrame.IsSolModifierAfterCnds();\n                const newFrame = eventStack.Push(currentEvent);\n                const loopStack = eventSheetManager.GetLoopStack();\n                const loop = loopStack.Push();\n                const isInContainer = objectClass.IsInContainer();\n                const sol = objectClass.GetCurrentSol();\n                const instances = forEachStack.Push();\n                C3.shallowAssignArray(instances, sol.GetInstances());\n                loop.SetEnd(instances.length);\n                if (isSolModifierAfterCnds)\n                    for (let i = 0, len = instances.length; i < len && !loop.IsStopped(); ++i) {\n                        eventSheetManager.PushCopySol(solModifiers);\n                        const inst = instances[i];\n                        objectClass.GetCurrentSol().SetSinglePicked(inst);\n                        if (isInContainer)\n                            inst.SetSiblingsSinglePicked();\n                        loop.SetIndex(i);\n                        yield*currentEvent.DebugRetrigger(oldFrame, newFrame);\n                        eventSheetManager.PopSol(solModifiers)\n                    }\n                else {\n                    sol._SetSelectAll(false);\n                    const solInstances = sol._GetOwnInstances();\n                    C3.clearArray(solInstances);\n                    solInstances.push(null);\n                    for (let i = 0, len = instances.length; i < len && !loop.IsStopped(); ++i) {\n                        const inst = instances[i];\n                        solInstances[0] = inst;\n                        if (isInContainer)\n                            inst.SetSiblingsSinglePicked();\n                        loop.SetIndex(i);\n                        yield*currentEvent.DebugRetrigger(oldFrame, newFrame)\n                    }\n                }\n                eventStack.Pop();\n                loopStack.Pop();\n                C3.clearArray(instances);\n                forEachStack.Pop();\n                return false\n            }\n            _ForEachOrdered(objectClass, order) {\n                const eventSheetManager = this._runtime.GetEventSheetManager();\n                const eventStack = eventSheetManager.GetEventStack();\n                const cnd = eventSheetManager.GetCurrentCondition();\n                const oldFrame = eventStack.GetCurrentStackFrame();\n                const currentEvent = oldFrame.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiers();\n                const isSolModifierAfterCnds = oldFrame.IsSolModifierAfterCnds();\n                const newFrame = eventStack.Push(currentEvent);\n                const loopStack = eventSheetManager.GetLoopStack();\n                const loop = loopStack.Push();\n                const isInContainer = objectClass.IsInContainer();\n                const sol = objectClass.GetCurrentSol();\n                const instancesData = forEachStack.Push();\n                C3.clearArray(instancesData);\n                const iterInstances = sol.GetInstances();\n                loop.SetEnd(iterInstances.length);\n                for (let i = 0, len = iterInstances.length; i < len; ++i)\n                    instancesData.push([iterInstances[i], cnd.ReevaluateParameter(1, i)]);\n                instancesData.sort(ForEachOrdered_SortInstances);\n                if (order === 1)\n                    instancesData.reverse();\n                if (isSolModifierAfterCnds)\n                    for (let i = 0, len = instancesData.length; i < len && !loop.IsStopped(); ++i) {\n                        eventSheetManager.PushCopySol(solModifiers);\n                        const inst = instancesData[i][0];\n                        objectClass.GetCurrentSol().SetSinglePicked(inst);\n                        if (isInContainer)\n                            inst.SetSiblingsSinglePicked();\n                        loop.SetIndex(i);\n                        currentEvent.Retrigger(oldFrame, newFrame);\n                        eventSheetManager.PopSol(solModifiers)\n                    }\n                else {\n                    sol._SetSelectAll(false);\n                    const solInstances = sol._GetOwnInstances();\n                    C3.clearArray(solInstances);\n                    solInstances.push(null);\n                    for (let i = 0, len = instancesData.length; i < len && !loop.IsStopped(); ++i) {\n                        const inst = instancesData[i][0];\n                        solInstances[0] = inst;\n                        if (isInContainer)\n                            inst.SetSiblingsSinglePicked();\n                        loop.SetIndex(i);\n                        currentEvent.Retrigger(oldFrame, newFrame)\n                    }\n                }\n                eventStack.Pop();\n                loopStack.Pop();\n                C3.clearArray(instancesData);\n                forEachStack.Pop();\n                return false\n            }\n            *_DebugForEachOrdered(objectClass, order) {\n                const eventSheetManager = this._runtime.GetEventSheetManager();\n                const eventStack = eventSheetManager.GetEventStack();\n                const cnd = eventSheetManager.GetCurrentCondition();\n                const oldFrame = eventStack.GetCurrentStackFrame();\n                const currentEvent = oldFrame.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiers();\n                const isSolModifierAfterCnds = oldFrame.IsSolModifierAfterCnds();\n                const newFrame = eventStack.Push(currentEvent);\n                const loopStack = eventSheetManager.GetLoopStack();\n                const loop = loopStack.Push();\n                const isInContainer = objectClass.IsInContainer();\n                const sol = objectClass.GetCurrentSol();\n                const instancesData = forEachStack.Push();\n                C3.clearArray(instancesData);\n                const iterInstances = sol.GetInstances();\n                loop.SetEnd(iterInstances.length);\n                for (let i = 0, len = iterInstances.length; i < len; ++i)\n                    instancesData.push([iterInstances[i], cnd.ReevaluateParameter(1, i)]);\n                instancesData.sort(ForEachOrdered_SortInstances);\n                if (order === 1)\n                    instancesData.reverse();\n                if (isSolModifierAfterCnds)\n                    for (let i = 0, len = instancesData.length; i < len && !loop.IsStopped(); ++i) {\n                        eventSheetManager.PushCopySol(solModifiers);\n                        const inst = instancesData[i][0];\n                        objectClass.GetCurrentSol().SetSinglePicked(inst);\n                        if (isInContainer)\n                            inst.SetSiblingsSinglePicked();\n                        loop.SetIndex(i);\n                        yield*currentEvent.DebugRetrigger(oldFrame, newFrame);\n                        eventSheetManager.PopSol(solModifiers)\n                    }\n                else {\n                    sol._SetSelectAll(false);\n                    const solInstances = sol._GetOwnInstances();\n                    C3.clearArray(solInstances);\n                    solInstances.push(null);\n                    for (let i = 0, len = instancesData.length; i < len && !loop.IsStopped(); ++i) {\n                        const inst = instancesData[i][0];\n                        solInstances[0] = inst;\n                        if (isInContainer)\n                            inst.SetSiblingsSinglePicked();\n                        loop.SetIndex(i);\n                        yield*currentEvent.DebugRetrigger(oldFrame, newFrame)\n                    }\n                }\n                eventStack.Pop();\n                loopStack.Pop();\n                C3.clearArray(instancesData);\n                forEachStack.Pop();\n                return false\n            }\n            _GetFunctionMap(name, createIfMissing) {\n                let ret = this._functionMaps.get(name);\n                if (ret)\n                    return ret;\n                if (!createIfMissing)\n                    return null;\n                ret = {\n                    defaultFunc: null,\n                    strMap: new Map\n                };\n                this._functionMaps.set(name, ret);\n                return ret\n            }\n            _DoCallMappedFunction(eventSheetManager, functionBlock, paramResults, hasAnySolModifiers, solModifiers) {\n                functionBlock.GetEventBlock().RunAsMappedFunctionCall(paramResults);\n                if (hasAnySolModifiers)\n                    eventSheetManager.PopSol(solModifiers)\n            }\n            *_DebugDoCallMappedFunction(eventSheetManager, functionBlock, paramResults, hasAnySolModifiers, solModifiers) {\n                yield*functionBlock.GetEventBlock().DebugRunAsMappedFunctionCall(paramResults);\n                if (hasAnySolModifiers)\n                    eventSheetManager.PopSol(solModifiers)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.System.Type = class SystemType extends C3.DefendedBase {\n            constructor(objectClass) {\n                super();\n                this._objectClass = objectClass;\n                this._runtime = objectClass.GetRuntime();\n                this._plugin = objectClass.GetPlugin()\n            }\n            OnCreate() {}\n            Release() {\n                this._objectClass = null;\n                this._runtime = null;\n                this._plugin = null\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.System.Instance = class SystemInstance extends C3.DefendedBase {\n            constructor(inst, properties) {\n                super();\n                this._inst = inst;\n                this._objectClass = this._inst.GetObjectClass();\n                this._sdkType = this._objectClass.GetSdkType();\n                this._runtime = this._inst.GetRuntime()\n            }\n            Release() {\n                this._inst = null;\n                this._objectClass = null;\n                this._sdkType = null;\n                this._runtime = null\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const tmpPickArray = [];\n        C3.Plugins.System.Cnds = {\n            EveryTick() {\n                return true\n            },\n            OnLayoutStart() {\n                return true\n            },\n            OnLayoutEnd() {\n                return true\n            },\n            OnSuspend() {\n                return true\n            },\n            OnResume() {\n                return true\n            },\n            IsSuspended() {\n                return this._runtime.IsSuspended()\n            },\n            Else() {\n                const frame = this._runtime.GetCurrentEventStackFrame();\n                if (frame.GetElseBranchRan())\n                    return false;\n                else\n                    return !frame.GetLastEventTrue()\n            },\n            TriggerOnce() {\n                const cnd = this._runtime.GetCurrentCondition();\n                const cndSavedData = cnd.GetSavedDataMap();\n                let lastTick = cndSavedData.get("TriggerOnce_lastTick");\n                if (typeof lastTick === "undefined") {\n                    lastTick = -1;\n                    cndSavedData.set("TriggerOnce_lastTick", -1)\n                }\n                const curTick = this._runtime.GetTickCount();\n                cndSavedData.set("TriggerOnce_lastTick", curTick);\n                return this._runtime.IsLayoutFirstTick() || lastTick !== curTick - 1\n            },\n            Every(seconds) {\n                const cnd = this._runtime.GetCurrentCondition();\n                const cndSavedData = cnd.GetSavedDataMap();\n                const lastTime = cndSavedData.get("Every_lastTime") || 0;\n                const curTime = this._runtime.GetGameTime();\n                if (!cndSavedData.has("Every_seconds"))\n                    cndSavedData.set("Every_seconds", seconds);\n                const thisSeconds = cndSavedData.get("Every_seconds");\n                if (curTime >= lastTime + thisSeconds) {\n                    cndSavedData.set("Every_lastTime", lastTime + thisSeconds);\n                    if (curTime >= cndSavedData.get("Every_lastTime") + .04)\n                        cndSavedData.set("Every_lastTime", curTime);\n                    cndSavedData.set("Every_seconds", seconds);\n                    return true\n                } else if (curTime < lastTime - .1)\n                    cndSavedData.set("Every_lastTime", curTime);\n                return false\n            },\n            IsGroupActive(groupName) {\n                const eventGroup = this._runtime.GetEventSheetManager().GetEventGroupByName(groupName);\n                return eventGroup && eventGroup.IsGroupActive()\n            },\n            IsPreview() {\n                return this._runtime.IsPreview()\n            },\n            IsMobile() {\n                return C3.Platform.IsMobile\n            },\n            OnLoadFinished() {\n                return true\n            },\n            OnCanvasSnapshot() {\n                return true\n            },\n            EffectsSupported() {\n                return true\n            },\n            OnSaveComplete() {\n                return true\n            },\n            OnSaveFailed() {\n                return true\n            },\n            OnLoadComplete() {\n                return true\n            },\n            OnLoadFailed() {\n                return true\n            },\n            ObjectUIDExists(uid) {\n                return !!this._runtime.GetInstanceByUID(uid)\n            },\n            IsOnPlatform(p) {\n                switch (p) {\n                case 0:\n                    return C3.Platform.Context === "browser";\n                case 1:\n                    return C3.Platform.OS === "iOS";\n                case 2:\n                    return C3.Platform.OS === "Android";\n                case 8:\n                    return C3.Platform.Context === "cordova";\n                case 9:\n                    return this._runtime.GetExportType() === "scirra-arcade";\n                case 10:\n                    return C3.Platform.Context === "nwjs";\n                case 13:\n                    return this._runtime.GetExportType() === "windows-uwp";\n                default:\n                    return false\n                }\n            },\n            RegexTest(str, regex, flags) {\n                const cacheRegex = this.GetRegex(regex, flags);\n                return cacheRegex.test(str)\n            },\n            Compare(x, cmp, y) {\n                return C3.compare(x, cmp, y)\n            },\n            CompareBetween(x, a, b) {\n                return x >= a && x <= b\n            },\n            CompareVar(ev, cmp, val) {\n                return C3.compare(ev.GetValue(), cmp, val)\n            },\n            CompareBoolVar(ev) {\n                return !!ev.GetValue()\n            },\n            CompareTime(cmp, t) {\n                const gameTime = this._runtime.GetGameTime();\n                if (cmp === 0) {\n                    const cnd = this._runtime.GetCurrentCondition();\n                    const cndSavedData = cnd.GetSavedDataMap();\n                    if (!cndSavedData.get("CompareTime_executed"))\n                        if (gameTime >= t) {\n                            cndSavedData.set("CompareTime_executed", true);\n                            return true\n                        }\n                    return false\n                } else\n                    return C3.compare(gameTime, cmp, t)\n            },\n            IsNaN(n) {\n                return isNaN(n)\n            },\n            AngleWithin(a1, within, a2) {\n                return C3.angleDiff(C3.toRadians(a1), C3.toRadians(a2)) <= C3.toRadians(within)\n            },\n            IsClockwiseFrom(a1, a2) {\n                return C3.angleClockwise(C3.toRadians(a1), C3.toRadians(a2))\n            },\n            IsBetweenAngles(a, la, ua) {\n                let angle = C3.toRadians(a);\n                let lower = C3.toRadians(la);\n                let upper = C3.toRadians(ua);\n                let obtuse = !C3.angleClockwise(upper, lower);\n                if (obtuse)\n                    return !(!C3.angleClockwise(angle, lower) && C3.angleClockwise(angle, upper));\n                else\n                    return C3.angleClockwise(angle, lower) && !C3.angleClockwise(angle, upper)\n            },\n            IsValueType(v, t) {\n                if (typeof v === "number")\n                    return t === 0;\n                else\n                    return t === 1\n            },\n            EvaluateExpression(v) {\n                return !!v\n            },\n            PickByComparison(objectClass, exp, cmp, val) {\n                if (!objectClass)\n                    return false;\n                const forEachStack = this._GetForEachStack();\n                const tempInstances = forEachStack.Push();\n                const sol = objectClass.GetCurrentSol();\n                C3.shallowAssignArray(tempInstances, sol.GetInstances());\n                if (sol.IsSelectAll())\n                    C3.clearArray(sol._GetOwnElseInstances());\n                const cnd = this._runtime.GetCurrentCondition();\n                let k = 0;\n                for (let i = 0, len = tempInstances.length; i < len; ++i) {\n                    const inst = tempInstances[i];\n                    tempInstances[k] = inst;\n                    exp = cnd.ReevaluateParameter(1, i);\n                    val = cnd.ReevaluateParameter(3, i);\n                    if (C3.compare(exp, cmp, val))\n                        ++k;\n                    else\n                        sol._PushElseInstance(inst)\n                }\n                C3.truncateArray(tempInstances, k);\n                sol.SetArrayPicked(tempInstances);\n                const ret = !!tempInstances.length;\n                C3.clearArray(tempInstances);\n                forEachStack.Pop();\n                objectClass.ApplySolToContainer();\n                return ret\n            },\n            PickByEvaluate(objectClass, exp) {\n                if (!objectClass)\n                    return false;\n                const forEachStack = this._GetForEachStack();\n                const tempInstances = forEachStack.Push();\n                const sol = objectClass.GetCurrentSol();\n                C3.shallowAssignArray(tempInstances, sol.GetInstances());\n                if (sol.IsSelectAll())\n                    C3.clearArray(sol._GetOwnElseInstances());\n                const cnd = this._runtime.GetCurrentCondition();\n                let k = 0;\n                for (let i = 0, len = tempInstances.length; i < len; ++i) {\n                    const inst = tempInstances[i];\n                    tempInstances[k] = inst;\n                    exp = cnd.ReevaluateParameter(1, i);\n                    if (exp)\n                        ++k;\n                    else\n                        sol._PushElseInstance(inst)\n                }\n                C3.truncateArray(tempInstances, k);\n                sol.SetArrayPicked(tempInstances);\n                const ret = !!tempInstances.length;\n                C3.clearArray(tempInstances);\n                forEachStack.Pop();\n                objectClass.ApplySolToContainer();\n                return ret\n            },\n            PickNth(objectClass, index) {\n                if (!objectClass)\n                    return false;\n                const sol = objectClass.GetCurrentSol();\n                const instances = sol.GetInstances();\n                index = Math.floor(index);\n                if (index >= instances.length)\n                    return false;\n                const inst = instances[index];\n                sol.PickOne(inst);\n                objectClass.ApplySolToContainer();\n                return true\n            },\n            PickRandom(objectClass) {\n                if (!objectClass)\n                    return false;\n                const sol = objectClass.GetCurrentSol();\n                const instances = sol.GetInstances();\n                const index = Math.floor(this._runtime.Random() * instances.length);\n                if (index >= instances.length)\n                    return false;\n                const inst = instances[index];\n                sol.PickOne(inst);\n                objectClass.ApplySolToContainer();\n                return true\n            },\n            PickAll(objectClass) {\n                if (!objectClass)\n                    return false;\n                if (!objectClass.GetInstanceCount())\n                    return false;\n                const sol = objectClass.GetCurrentSol();\n                sol._SetSelectAll(true);\n                objectClass.ApplySolToContainer();\n                return true\n            },\n            PickOverlappingPoint(objectClass, x, y) {\n                if (!objectClass)\n                    return false;\n                const sol = objectClass.GetCurrentSol();\n                const instances = sol.GetInstances();\n                const currentEvent = this._runtime.GetCurrentEvent();\n                const isOrBlock = currentEvent.IsOrBlock();\n                const isInverted = this._runtime.GetCurrentCondition().IsInverted();\n                if (sol.IsSelectAll()) {\n                    C3.shallowAssignArray(tmpPickArray, instances);\n                    sol.ClearArrays();\n                    sol._SetSelectAll(false)\n                } else if (isOrBlock) {\n                    C3.shallowAssignArray(tmpPickArray, sol._GetOwnElseInstances());\n                    C3.clearArray(sol._GetOwnElseInstances())\n                } else {\n                    C3.shallowAssignArray(tmpPickArray, sol._GetOwnInstances());\n                    C3.clearArray(sol._GetOwnInstances())\n                }\n                for (let i = 0, len = tmpPickArray.length; i < len; ++i) {\n                    const inst = tmpPickArray[i];\n                    if (C3.xor(inst.GetWorldInfo().ContainsPoint(x, y), isInverted))\n                        sol._PushInstance(inst);\n                    else\n                        sol._PushElseInstance(inst)\n                }\n                objectClass.ApplySolToContainer();\n                return C3.xor(!!sol._GetOwnInstances().length, isInverted)\n            },\n            PickLastCreated(objectClass) {\n                if (!objectClass)\n                    return false;\n                const isFamily = objectClass.IsFamily();\n                let pick = null;\n                const instancesPendingCreate = this._runtime._GetInstancesPendingCreate();\n                for (let i = instancesPendingCreate.length - 1; i >= 0; --i) {\n                    const inst = instancesPendingCreate[i];\n                    if (isFamily) {\n                        if (inst.GetObjectClass().BelongsToFamily(objectClass)) {\n                            pick = inst;\n                            break\n                        }\n                    } else if (inst.GetObjectClass() === objectClass) {\n                        pick = inst;\n                        break\n                    }\n                }\n                if (!pick) {\n                    const instances = objectClass.GetInstances();\n                    if (instances.length)\n                        pick = instances.at(-1)\n                }\n                if (!pick)\n                    return false;\n                const sol = objectClass.GetCurrentSol();\n                sol.PickOne(pick);\n                objectClass.ApplySolToContainer();\n                return true\n            },\n            Repeat(count) {\n                if (this._runtime.IsDebugging())\n                    return this._DebugRepeat(count);\n                else\n                    return this._Repeat(count)\n            },\n            While() {\n                if (this._runtime.IsDebugging())\n                    return this._DebugWhile();\n                else\n                    return this._While()\n            },\n            For(name, start, end) {\n                if (this._runtime.IsDebugging())\n                    return this._DebugFor(name, start, end);\n                else\n                    return this._For(name, start, end)\n            },\n            ForEach(objectClass) {\n                if (this._runtime.IsDebugging())\n                    return this._DebugForEach(objectClass);\n                else\n                    return this._ForEach(objectClass)\n            },\n            ForEachOrdered(objectClass, expression, order) {\n                if (this._runtime.IsDebugging())\n                    return this._DebugForEachOrdered(objectClass, order);\n                else\n                    return this._ForEachOrdered(objectClass, order)\n            },\n            LayerVisible(layer) {\n                return layer ? layer.IsVisible() : false\n            },\n            LayerInteractive(layer) {\n                return layer ? layer.IsSelfAndParentsInteractive() : false\n            },\n            LayerEmpty(layer) {\n                return layer ? !layer.GetInstanceCount() : false\n            },\n            LayerCmpOpacity(layer, cmp, o) {\n                if (!layer)\n                    return false;\n                return C3.compare(layer.GetOpacity() * 100, cmp, o)\n            },\n            OnImageLoadingComplete() {\n                return true\n            },\n            IsLoadingImages() {\n                return this._imagesLoadingTotal > 0\n            },\n            TemplateExists(objectClass, template) {\n                const templateManager = this._runtime.GetTemplateManager();\n                if (!templateManager)\n                    return false;\n                if (!template)\n                    return false;\n                return !!templateManager.GetTemplateData(objectClass, template)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        function SortZOrderList(a, b) {\n            const layerA = a[0];\n            const layerB = b[0];\n            const diff = layerA - layerB;\n            if (diff !== 0)\n                return diff;\n            const indexA = a[1];\n            const indexB = b[1];\n            return indexA - indexB\n        }\n        function SortInstancesByValue(a, b) {\n            return a[1] - b[1]\n        }\n        const tempZOrderList = [];\n        const tempInstValues = [];\n        const tempRect = C3.New(C3.Rect);\n        const tempColor = C3.New(C3.Color);\n        C3.Plugins.System.Acts = {\n            SetVar(ev, x) {\n                ev.SetValue(x)\n            },\n            AddVar(ev, x) {\n                if (ev.IsNumber() && typeof x !== "number")\n                    x = parseFloat(x);\n                ev.SetValue(ev.GetValue() + x)\n            },\n            SubVar(ev, x) {\n                if (!ev.IsNumber())\n                    return;\n                ev.SetValue(ev.GetValue() - x)\n            },\n            SetBoolVar(ev, x) {\n                ev.SetValue(!!x)\n            },\n            ToggleBoolVar(ev) {\n                ev.SetValue(!ev.GetValue())\n            },\n            ResetGlobals() {\n                this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue()\n            },\n            CreateObject(objectClass, layer, x, y, createHierarchy, template) {\n                if (!objectClass || !layer)\n                    return;\n                const inst = this._runtime.CreateInstance(objectClass, layer, x, y, createHierarchy, template);\n                if (!inst)\n                    return;\n                if (createHierarchy)\n                    layer.SortAndAddInstancesByZIndex(inst);\n                const eventSheetManager = this._runtime.GetEventSheetManager();\n                eventSheetManager.BlockFlushingInstances(true);\n                inst._TriggerOnCreatedOnSelfAndRelated();\n                eventSheetManager.BlockFlushingInstances(false);\n                const pickMap = new Map;\n                inst.CollectInstancesToPick(pickMap, objectClass, createHierarchy);\n                for (const [pickObjectClass,instSet] of pickMap)\n                    pickObjectClass.GetCurrentSol().SetSetPicked(instSet)\n            },\n            CreateObjectByName(objectClassName, layer, x, y, createHierarchy, template) {\n                if (!objectClassName || !layer)\n                    return;\n                const objectClass = this._runtime.GetObjectClassByName(objectClassName);\n                if (!objectClass)\n                    return;\n                C3.Plugins.System.Acts.CreateObject.call(this, objectClass, layer, x, y, createHierarchy, template)\n            },\n            RecreateInitialObjects(objectClass, x1, y1, x2, y2, sourceLayoutName, sourceLayerParam, offsetX, offsetY, createHierarchy) {\n                if (!objectClass)\n                    return;\n                let sourceLayout = this._runtime.GetCurrentLayout();\n                if (sourceLayoutName) {\n                    const lookupLayout = this._runtime.GetLayoutManager().GetLayoutByName(sourceLayoutName);\n                    if (lookupLayout)\n                        sourceLayout = lookupLayout;\n                    else\n                        return\n                }\n                let sourceLayer = null;\n                if (typeof sourceLayerParam !== "number" || sourceLayerParam >= 0) {\n                    sourceLayer = sourceLayout.GetLayer(sourceLayerParam);\n                    if (!sourceLayer)\n                        return\n                }\n                tempRect.set(x1, y1, x2, y2);\n                const allCreatedInstances = sourceLayout.RecreateInitialObjects(objectClass, tempRect, sourceLayer, offsetX, offsetY, createHierarchy);\n                objectClass.GetCurrentSol().SetArrayPicked(allCreatedInstances);\n                objectClass.ApplySolToContainer()\n            },\n            StopLoop() {\n                const loopStack = this._loopStack;\n                if (!loopStack.IsInLoop())\n                    return;\n                loopStack.GetCurrent().Stop()\n            },\n            SetGroupActive(groupName, a) {\n                const group = this._runtime.GetEventSheetManager().GetEventGroupByName(groupName);\n                if (!group)\n                    return;\n                if (a === 0)\n                    group.SetGroupActive(false);\n                else if (a === 1)\n                    group.SetGroupActive(true);\n                else\n                    group.SetGroupActive(!group.IsGroupActive())\n            },\n            SetTimescale(ts) {\n                this._runtime.SetTimeScale(ts)\n            },\n            SetObjectTimescale(objectClass, ts) {\n                if (ts < 0)\n                    ts = 0;\n                if (!objectClass)\n                    return;\n                const sol = objectClass.GetCurrentSol();\n                const instances = sol.GetInstances();\n                for (const inst of instances)\n                    inst.SetTimeScale(ts)\n            },\n            RestoreObjectTimescale(objectClass) {\n                if (!objectClass)\n                    return;\n                const sol = objectClass.GetCurrentSol();\n                const instances = sol.GetInstances();\n                for (const inst of instances)\n                    inst.RestoreTimeScale()\n            },\n            Wait(seconds) {\n                if (seconds < 0)\n                    return;\n                this._runtime.GetEventSheetManager().AddScheduledWait().InitTimer(seconds);\n                return true\n            },\n            WaitForSignal(tag) {\n                this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(tag);\n                return true\n            },\n            WaitForPreviousActions() {\n                const eventSheetManager = this._runtime.GetEventSheetManager();\n                eventSheetManager.AddScheduledWait().InitPromise(eventSheetManager.GetPromiseForAllAsyncActions());\n                return true\n            },\n            Signal(tag) {\n                const lowerTag = tag.toLowerCase();\n                for (const w of this._runtime.GetEventSheetManager().scheduledWaits())\n                    if (w.IsSignal() && w.GetSignalTag() === lowerTag)\n                        w.SetSignalled()\n            },\n            async SnapshotCanvas(format, quality, x, y, width, height) {\n                const canvasManager = this._runtime.GetCanvasManager();\n                if (!canvasManager)\n                    return;\n                this.UpdateRender();\n                await canvasManager.SnapshotCanvas(format === 0 ? "image\/png" : "image\/jpeg", quality \/ 100, x, y, width, height);\n                await this._runtime.TriggerAsync(C3.Plugins.System.Cnds.OnCanvasSnapshot, null)\n            },\n            SetCanvasSize(w, h) {\n                if (w <= 0 || h <= 0)\n                    return;\n                this._runtime.SetViewportSize(w, h);\n                this._runtime.GetCurrentLayout().BoundScrolling();\n                const canvasManager = this._runtime.GetCanvasManager();\n                if (!canvasManager)\n                    return;\n                if (canvasManager.GetCurrentFullscreenMode() === "off")\n                    canvasManager.SetSize(canvasManager.GetLastWidth(), canvasManager.GetLastHeight(), true);\n                else {\n                    this._runtime.SetOriginalViewportSize(w, h);\n                    canvasManager.SetSize(canvasManager.GetLastWidth(), canvasManager.GetLastHeight(), true)\n                }\n                this._runtime.UpdateRender()\n            },\n            SetFullscreenQuality(q) {\n                const canvasManager = this._runtime.GetCanvasManager();\n                if (!canvasManager)\n                    return;\n                if (canvasManager.GetCurrentFullscreenMode() === "off")\n                    return;\n                canvasManager.SetFullscreenScalingQuality(q !== 0 ? "high" : "low");\n                canvasManager.SetSize(canvasManager.GetLastWidth(), canvasManager.GetLastHeight(), true)\n            },\n            SaveState(slot) {\n                this._runtime.SaveToSlot(slot)\n            },\n            LoadState(slot) {\n                this._runtime.LoadFromSlot(slot)\n            },\n            LoadStateJSON(jsonStr) {\n                this._runtime.LoadFromJsonString(jsonStr)\n            },\n            SetHalfFramerateMode(m) {},\n            ResetPersisted() {\n                for (const layout of this._runtime.GetLayoutManager().GetAllLayouts())\n                    layout.ResetPersistData()\n            },\n            SetPixelRounding(m) {\n                this._runtime.SetPixelRoundingEnabled(m !== 0)\n            },\n            SetMinimumFramerate(fps) {\n                this._runtime.SetMinimumFramerate(fps)\n            },\n            SortZOrderByInstVar(objectClass, instVar) {\n                if (!objectClass)\n                    return;\n                const sol = objectClass.GetCurrentSol();\n                const pickedInstances = sol.GetInstances();\n                const zOrderList = tempZOrderList;\n                const instValues = tempInstValues;\n                const layout = this._runtime.GetCurrentLayout();\n                const isFamily = objectClass.IsFamily();\n                const familyIndex = objectClass.GetFamilyIndex();\n                for (let i = 0, len = pickedInstances.length; i < len; ++i) {\n                    const inst = pickedInstances[i];\n                    const wi = inst.GetWorldInfo();\n                    if (!wi)\n                        continue;\n                    let value;\n                    if (isFamily)\n                        value = inst.GetInstanceVariableValue(instVar + inst.GetObjectClass().GetFamilyInstanceVariableOffset(familyIndex));\n                    else\n                        value = inst.GetInstanceVariableValue(instVar);\n                    zOrderList.push([wi.GetLayer().GetIndex(), wi.GetZIndex()]);\n                    instValues.push([inst, value])\n                }\n                if (!zOrderList.length)\n                    return;\n                zOrderList.sort(SortZOrderList);\n                instValues.sort(SortInstancesByValue);\n                let anyChanged = false;\n                for (let i = 0, len = zOrderList.length; i < len; ++i) {\n                    const inst = instValues[i][0];\n                    const layer = layout.GetLayerByIndex(zOrderList[i][0]);\n                    const toZ = zOrderList[i][1];\n                    const layerInstances = layer._GetInstances();\n                    if (layerInstances[toZ] !== inst) {\n                        layerInstances[toZ] = inst;\n                        inst.GetWorldInfo()._SetLayer(layer);\n                        layer.SetZIndicesChanged();\n                        anyChanged = true\n                    }\n                }\n                if (anyChanged)\n                    this._runtime.UpdateRender();\n                C3.clearArray(tempZOrderList);\n                C3.clearArray(tempInstValues)\n            },\n            GoToLayout(layout) {\n                if (this._runtime.IsLoading())\n                    return;\n                const layoutManager = this._runtime.GetLayoutManager();\n                if (layoutManager.IsPendingChangeMainLayout())\n                    return;\n                layoutManager.ChangeMainLayout(layout)\n            },\n            GoToLayoutByName(layoutName) {\n                if (this._runtime.IsLoading())\n                    return;\n                const layoutManager = this._runtime.GetLayoutManager();\n                if (layoutManager.IsPendingChangeMainLayout())\n                    return;\n                const toLayout = layoutManager.GetLayoutByName(layoutName);\n                if (toLayout)\n                    layoutManager.ChangeMainLayout(toLayout)\n            },\n            NextPrevLayout(prev) {\n                if (this._runtime.IsLoading())\n                    return;\n                const layoutManager = this._runtime.GetLayoutManager();\n                if (layoutManager.IsPendingChangeMainLayout())\n                    return;\n                const allLayouts = layoutManager.GetAllLayouts();\n                const index = allLayouts.indexOf(layoutManager.GetMainRunningLayout());\n                if (prev && index === 0)\n                    return;\n                if (!prev && index === allLayouts.length - 1)\n                    return;\n                const toLayout = allLayouts[index + (prev ? -1 : 1)];\n                layoutManager.ChangeMainLayout(toLayout)\n            },\n            RestartLayout() {\n                if (this._runtime.IsLoading())\n                    return;\n                const layoutManager = this._runtime.GetLayoutManager();\n                if (layoutManager.IsPendingChangeMainLayout())\n                    return;\n                layoutManager.ChangeMainLayout(layoutManager.GetMainRunningLayout());\n                this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation()\n            },\n            SetLayerVisible(layer, v) {\n                if (!layer)\n                    return;\n                layer.SetVisible(v)\n            },\n            SetLayerInteractive(layer, i) {\n                if (!layer)\n                    return;\n                layer.SetInteractive(i)\n            },\n            SetLayerOpacity(layer, o) {\n                if (!layer)\n                    return;\n                layer.SetOpacity(o \/ 100)\n            },\n            SetLayerScale(layer, s) {\n                if (!layer)\n                    return;\n                layer.SetOwnScale(s)\n            },\n            SetLayerScaleRate(layer, r) {\n                if (!layer)\n                    return;\n                layer.SetScaleRate(r)\n            },\n            SetLayerAngle(layer, a) {\n                if (!layer)\n                    return;\n                layer.SetAngle(C3.toRadians(+a))\n            },\n            SetLayerScroll(layer, scrollX, scrollY) {\n                if (!layer)\n                    return;\n                layer.SetOwnScrollPositionEnabled(true);\n                layer.SetScrollX(scrollX);\n                layer.SetScrollY(scrollY)\n            },\n            RestoreLayerScroll(layer) {\n                if (!layer)\n                    return;\n                layer.SetOwnScrollPositionEnabled(false)\n            },\n            SetLayerParallax(layer, px, py) {\n                if (!layer)\n                    return;\n                layer.SetParallax(px \/ 100, py \/ 100)\n            },\n            SetLayerZElevation(layer, z) {\n                if (!layer)\n                    return;\n                layer.SetZElevation(+z)\n            },\n            SetLayerBackground(layer, rgb) {\n                if (!layer)\n                    return;\n                tempColor.setFromRgbValue(rgb);\n                tempColor.clamp();\n                const layerBgColor = layer.GetBackgroundColor();\n                if (layerBgColor.equalsIgnoringAlpha(tempColor))\n                    return;\n                layerBgColor.copyRgb(tempColor);\n                this.UpdateRender()\n            },\n            SetLayerTransparent(layer, t) {\n                if (!layer)\n                    return;\n                layer.SetTransparent(t)\n            },\n            SetLayerBlendMode(layer, bm) {\n                if (!layer)\n                    return;\n                layer.SetBlendMode(bm)\n            },\n            SetLayerEffectEnabled(layer, enabled, effectName) {\n                if (!layer)\n                    return;\n                const effectList = layer.GetEffectList();\n                const effectType = effectList.GetEffectTypeByName(effectName);\n                if (!effectType)\n                    return;\n                const e = enabled === 1;\n                if (effectType.IsActive() === e)\n                    return;\n                effectType.SetActive(e);\n                layer.UpdateActiveEffects();\n                this._runtime.UpdateRender()\n            },\n            SetLayerEffectParam(layer, effectName, paramIndex, value) {\n                if (!layer)\n                    return;\n                const effectList = layer.GetEffectList();\n                const effectType = effectList.GetEffectTypeByName(effectName);\n                if (!effectType)\n                    return;\n                paramIndex = Math.floor(paramIndex);\n                const paramType = effectType.GetShaderProgram().GetParameterType(paramIndex);\n                if (!paramType)\n                    return;\n                if (paramType === "color") {\n                    tempColor.setFromRgbValue(value);\n                    value = tempColor\n                } else if (paramType === "percent")\n                    value \/= 100;\n                const didChange = effectList.SetEffectParameter(effectType.GetIndex(), paramIndex, value);\n                if (didChange && effectType.IsActive())\n                    this._runtime.UpdateRender()\n            },\n            SetLayerForceOwnTexture(layer, f) {\n                if (!layer)\n                    return;\n                layer.SetForceOwnTexture(f)\n            },\n            SetLayoutScale(s) {\n                this._runtime.GetCurrentLayout().SetScale(+s)\n            },\n            SetLayoutAngle(a) {\n                this._runtime.GetCurrentLayout().SetAngle(C3.toRadians(+a))\n            },\n            SetLayoutEffectEnabled(enabled, effectName) {\n                const layout = this._runtime.GetCurrentLayout();\n                const effectList = layout.GetEffectList();\n                const effectType = effectList.GetEffectTypeByName(effectName);\n                if (!effectType)\n                    return;\n                const e = enabled === 1;\n                if (effectType.IsActive() === e)\n                    return;\n                effectType.SetActive(e);\n                layout.UpdateActiveEffects();\n                this._runtime.UpdateRender()\n            },\n            SetLayoutEffectParam(effectName, paramIndex, value) {\n                const layout = this._runtime.GetCurrentLayout();\n                const effectList = layout.GetEffectList();\n                const effectType = effectList.GetEffectTypeByName(effectName);\n                if (!effectType)\n                    return;\n                paramIndex = Math.floor(paramIndex);\n                const paramType = effectType.GetShaderProgram().GetParameterType(paramIndex);\n                if (!paramType)\n                    return;\n                if (paramType === "color") {\n                    tempColor.setFromRgbValue(value);\n                    value = tempColor\n                } else if (paramType === "percent")\n                    value \/= 100;\n                const didChange = effectList.SetEffectParameter(effectType.GetIndex(), paramIndex, value);\n                if (didChange && effectType.IsActive())\n                    this._runtime.UpdateRender()\n            },\n            SetLayoutVanishingPoint(vpX, vpY) {\n                const layout = this._runtime.GetCurrentLayout();\n                layout.SetVanishingPointXY(vpX \/ 100, vpY \/ 100)\n            },\n            SetLayoutProjection(p) {\n                const layout = this._runtime.GetCurrentLayout();\n                if (p === 0)\n                    layout.SetPerspectiveProjection();\n                else\n                    layout.SetOrthographicProjection()\n            },\n            ScrollX(x) {\n                const layout = this._runtime.GetCurrentLayout();\n                layout.SetScrollX(x)\n            },\n            ScrollY(y) {\n                const layout = this._runtime.GetCurrentLayout();\n                layout.SetScrollY(y)\n            },\n            Scroll(x, y) {\n                const layout = this._runtime.GetCurrentLayout();\n                layout.SetScrollX(x);\n                layout.SetScrollY(y)\n            },\n            ScrollToObject(objectClass) {\n                if (!objectClass)\n                    return;\n                const inst = objectClass.GetFirstPicked();\n                if (!inst)\n                    return;\n                const wi = inst.GetWorldInfo();\n                if (!wi)\n                    return;\n                const layout = this._runtime.GetCurrentLayout();\n                layout.SetScrollX(wi.GetX());\n                layout.SetScrollY(wi.GetY())\n            },\n            async LoadObjectTextures(objectClass) {\n                const layout = this._runtime.GetMainRunningLayout();\n                if (!layout || !objectClass || this._runtime.IsLoading())\n                    return;\n                const objectClasses = objectClass.IsFamily() ? objectClass.GetFamilyMembers() : [objectClass];\n                await this._LoadTexturesForObjectClasses(layout, objectClasses)\n            },\n            async LoadObjectTexturesByName(objectClassName) {\n                await C3.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(objectClassName))\n            },\n            UnloadObjectTextures(objectClass) {\n                const layout = this._runtime.GetMainRunningLayout();\n                if (!layout || !objectClass)\n                    return;\n                const objectClasses = objectClass.IsFamily() ? objectClass.GetFamilyMembers() : [objectClass];\n                this._UnloadTexturesForObjectClasses(layout, objectClasses)\n            },\n            UnloadObjectTexturesByName(objectClassName) {\n                C3.Plugins.System.Acts.UnloadObjectTextures.call(this, this._runtime.GetObjectClassByName(objectClassName))\n            },\n            UnloadUnusedTextures() {\n                const layout = this._runtime.GetMainRunningLayout();\n                if (!layout)\n                    return;\n                const objectClasses = layout._GetTextureLoadedObjectTypes();\n                this._UnloadTexturesForObjectClasses(layout, objectClasses)\n            },\n            async LoadLayoutTextures(loadLayout) {\n                const curLayout = this._runtime.GetMainRunningLayout();\n                if (!loadLayout || !curLayout || this._runtime.IsLoading())\n                    return;\n                await this._LoadTexturesForObjectClasses(curLayout, loadLayout._GetInitialObjectClasses())\n            },\n            async LoadLayoutTexturesByName(layoutName) {\n                const curLayout = this._runtime.GetMainRunningLayout();\n                const loadLayout = this._runtime.GetLayoutManager().GetLayoutByName(layoutName);\n                if (!loadLayout || !curLayout || this._runtime.IsLoading())\n                    return;\n                await this._LoadTexturesForObjectClasses(curLayout, loadLayout._GetInitialObjectClasses())\n            },\n            SetFunctionReturnValue(v) {\n                const frame = this._eventStack.GetCurrentExpFuncStackFrame();\n                if (!frame)\n                    return;\n                switch (frame.GetFunctionReturnType()) {\n                case 1:\n                    if (typeof v === "number")\n                        frame.SetFunctionReturnValue(v);\n                    break;\n                case 2:\n                    if (typeof v === "string")\n                        frame.SetFunctionReturnValue(v);\n                    break;\n                case 3:\n                    frame.SetFunctionReturnValue(v);\n                    break\n                }\n            },\n            MapFunction(name, str, functionBlock) {\n                const mapEntry = this._GetFunctionMap(name.toLowerCase(), true);\n                const strMap = mapEntry.strMap;\n                const lowerStr = str.toLowerCase();\n                if (strMap.has(lowerStr))\n                    console.warn(`[Construct] Function map \'${name}\' string \'${str}\' already in map; overwriting entry`);\n                const firstFunctionBlock = C3.first(strMap.values()) || mapEntry.defaultFunc;\n                if (firstFunctionBlock) {\n                    const firstReturnsValue = firstFunctionBlock.GetReturnType() !== 0;\n                    const curReturnsValue = functionBlock.GetReturnType() !== 0;\n                    if (firstReturnsValue !== curReturnsValue) {\n                        console.error(`[Construct] Function map \'${name}\' string \'${str}\' function return type not compatible with other functions in the map; entry ignored`);\n                        return\n                    }\n                }\n                strMap.set(lowerStr, functionBlock)\n            },\n            MapFunctionDefault(name, functionBlock) {\n                const mapEntry = this._GetFunctionMap(name.toLowerCase(), true);\n                if (mapEntry.defaultFunc)\n                    console.warn(`[Construct] Function map \'${name}\' already has a default; overwriting entry`);\n                const firstFunctionBlock = C3.first(mapEntry.strMap.values()) || mapEntry.defaultFunc;\n                if (firstFunctionBlock) {\n                    const firstReturnsValue = firstFunctionBlock.GetReturnType() !== 0;\n                    const curReturnsValue = functionBlock.GetReturnType() !== 0;\n                    if (firstReturnsValue !== curReturnsValue) {\n                        console.error(`[Construct] Function map \'${name}\' default: function return type not compatible with other functions in the map; entry ignored`);\n                        return\n                    }\n                }\n                mapEntry.defaultFunc = functionBlock\n            },\n            CallMappedFunction(name, str, forwardParams) {\n                forwardParams = Math.floor(forwardParams);\n                const mapEntry = this._GetFunctionMap(name.toLowerCase(), false);\n                if (!mapEntry) {\n                    console.warn(`[Construct] Call mapped function: map name \'${name}\' not found; call ignored`);\n                    return\n                }\n                let functionBlock = mapEntry.strMap.get(str.toLowerCase());\n                if (!functionBlock)\n                    if (mapEntry.defaultFunc) {\n                        functionBlock = mapEntry.defaultFunc;\n                        forwardParams = 0\n                    } else {\n                        console.warn(`[Construct] Call mapped function: no function associated with map \'${name}\' string \'${str}\'; call ignored (consider setting a default)`);\n                        return\n                    }\n                if (!functionBlock.IsEnabled())\n                    return;\n                if (functionBlock.GetReturnType() !== 0) {\n                    console.warn(`[Construct] Call mapped function: map \'${name}\' string \'${str}\' has a return type so cannot be called`);\n                    return\n                }\n                const runtime = this._runtime;\n                const eventSheetManager = runtime.GetEventSheetManager();\n                const currentEvent = eventSheetManager.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiersIncludingParents();\n                const hasAnySolModifiers = solModifiers.length > 0;\n                if (hasAnySolModifiers)\n                    eventSheetManager.PushCleanSol(solModifiers);\n                const paramResults = [];\n                const callerFunctionBlock = eventSheetManager.FindFirstFunctionBlockParent(currentEvent);\n                if (callerFunctionBlock) {\n                    const callerParameters = callerFunctionBlock.GetFunctionParameters();\n                    for (let i = forwardParams, len = callerParameters.length; i < len; ++i)\n                        paramResults.push(callerParameters[i].GetValue())\n                }\n                const calleeParameters = functionBlock.GetFunctionParameters();\n                for (let i = paramResults.length, len = calleeParameters.length; i < len; ++i)\n                    paramResults.push(calleeParameters[i].GetInitialValue());\n                if (runtime.IsDebugging())\n                    return this._DebugDoCallMappedFunction(eventSheetManager, functionBlock, paramResults, hasAnySolModifiers, solModifiers);\n                else\n                    return this._DoCallMappedFunction(eventSheetManager, functionBlock, paramResults, hasAnySolModifiers, solModifiers)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.System.Exps = {\n            int: function(x) {\n                if (typeof x === "string") {\n                    x = parseInt(x, 10);\n                    if (isNaN(x))\n                        x = 0\n                }\n                return Math.floor(x)\n            },\n            float: function(x) {\n                if (typeof x === "string") {\n                    x = parseFloat(x);\n                    if (isNaN(x))\n                        x = 0\n                }\n                return x\n            },\n            str(x) {\n                return x.toString()\n            },\n            len(x) {\n                if (typeof x === "string")\n                    return x.length;\n                else\n                    return 0\n            },\n            random(a, b) {\n                if (typeof b === "undefined")\n                    return this._runtime.Random() * a;\n                else\n                    return this._runtime.Random() * (b - a) + a\n            },\n            choose(...args) {\n                const index = Math.floor(this._runtime.Random() * args.length);\n                return args[index]\n            },\n            pi() {\n                return Math.PI\n            },\n            infinity() {\n                return Infinity\n            },\n            sqrt(v) {\n                return Math.sqrt(v)\n            },\n            abs(v) {\n                return Math.abs(v)\n            },\n            round(v) {\n                return Math.round(v)\n            },\n            roundtodp(v, dp) {\n                dp = Math.max(Math.floor(dp), 0);\n                const m = Math.pow(10, dp);\n                return Math.round((v + Number.EPSILON) * m) \/ m\n            },\n            floor(v) {\n                return Math.floor(v)\n            },\n            ceil(v) {\n                return Math.ceil(v)\n            },\n            sign(v) {\n                return Math.sign(v)\n            },\n            sin(x) {\n                return Math.sin(C3.toRadians(x))\n            },\n            cos(x) {\n                return Math.cos(C3.toRadians(x))\n            },\n            tan(x) {\n                return Math.tan(C3.toRadians(x))\n            },\n            asin(x) {\n                return C3.toDegrees(Math.asin(x))\n            },\n            acos(x) {\n                return C3.toDegrees(Math.acos(x))\n            },\n            atan(x) {\n                return C3.toDegrees(Math.atan(x))\n            },\n            exp(x) {\n                return Math.exp(x)\n            },\n            ln(x) {\n                return Math.log(x)\n            },\n            log10(x) {\n                return Math.log(x) \/ Math.LN10\n            },\n            max(...args) {\n                let ret = args[0];\n                if (typeof ret !== "number")\n                    ret = 0;\n                for (let i = 1, len = args.length; i < len; ++i) {\n                    let n = args[i];\n                    if (typeof n !== "number")\n                        continue;\n                    if (ret < n)\n                        ret = n\n                }\n                return ret\n            },\n            min(...args) {\n                let ret = args[0];\n                if (typeof ret !== "number")\n                    ret = 0;\n                for (let i = 1, len = args.length; i < len; ++i) {\n                    let n = args[i];\n                    if (typeof n !== "number")\n                        continue;\n                    if (ret > n)\n                        ret = n\n                }\n                return ret\n            },\n            clamp(x, l, u) {\n                return C3.clamp(x, l, u)\n            },\n            distance(x1, y1, x2, y2) {\n                return C3.distanceTo(x1, y1, x2, y2)\n            },\n            angle(x1, y1, x2, y2) {\n                return C3.toDegrees(C3.angleTo(x1, y1, x2, y2))\n            },\n            lerp(a, b, x) {\n                return C3.lerp(a, b, x)\n            },\n            unlerp(a, b, y) {\n                return C3.unlerp(a, b, y)\n            },\n            qarp(a, b, c, x) {\n                return C3.qarp(a, b, c, x)\n            },\n            cubic(a, b, c, d, x) {\n                return C3.cubic(a, b, c, d, x)\n            },\n            cosp(a, b, x) {\n                return C3.cosp(a, b, x)\n            },\n            anglediff(a, b) {\n                return C3.toDegrees(C3.angleDiff(C3.toRadians(a), C3.toRadians(b)))\n            },\n            anglelerp(a, b, x) {\n                return C3.toDegrees(C3.angleLerp(C3.toRadians(a), C3.toRadians(b), x))\n            },\n            anglerotate(a, b, c) {\n                return C3.toDegrees(C3.angleRotate(C3.toRadians(a), C3.toRadians(b), C3.toRadians(c)))\n            },\n            setbit(n, b, v) {\n                n = n | 0;\n                b = b | 0;\n                v = v !== 0 ? 1 : 0;\n                return n & ~(1 << b) | v << b\n            },\n            togglebit(n, b) {\n                n = n | 0;\n                b = b | 0;\n                return n ^ 1 << b\n            },\n            getbit(n, b) {\n                n = n | 0;\n                b = b | 0;\n                return n & 1 << b ? 1 : 0\n            },\n            newline() {\n                return "\\n"\n            },\n            uppercase(s) {\n                return typeof s === "string" ? s.toUpperCase() : ""\n            },\n            lowercase(s) {\n                return typeof s === "string" ? s.toLowerCase() : ""\n            },\n            left(text, n) {\n                return typeof text === "string" ? text.substr(0, n) : ""\n            },\n            mid(text, index, count) {\n                if (typeof text !== "string")\n                    return "";\n                if (count < 0)\n                    return text.substr(index);\n                else\n                    return text.substr(index, count)\n            },\n            right(text, n) {\n                return typeof text === "string" ? text.substr(Math.max(text.length - n, 0)) : ""\n            },\n            trim(text) {\n                return typeof text === "string" ? text.trim() : ""\n            },\n            tokenat(text, index, sep) {\n                if (typeof text !== "string" || typeof sep !== "string")\n                    return "";\n                let arr = text.split(sep);\n                index = Math.floor(index);\n                if (index < 0 || index >= arr.length)\n                    return "";\n                return arr[index]\n            },\n            tokencount(text, sep) {\n                if (typeof text !== "string" || typeof sep !== "string" || !text.length)\n                    return 0;\n                return text.split(sep).length\n            },\n            find(text, searchStr) {\n                if (typeof text === "string" && typeof searchStr === "string")\n                    return text.search(new RegExp(C3.EscapeRegex(searchStr),"i"));\n                else\n                    return -1\n            },\n            findcase(text, searchStr) {\n                if (typeof text === "string" && typeof searchStr === "string")\n                    return text.search(new RegExp(C3.EscapeRegex(searchStr),""));\n                else\n                    return -1\n            },\n            replace(text, find, replace) {\n                if (typeof text === "string" && typeof find === "string" && typeof replace === "string")\n                    return text.replace(new RegExp(C3.EscapeRegex(find),"gi"), replace);\n                else\n                    return typeof text === "string" ? text : ""\n            },\n            regexsearch(text, regex, flags) {\n                const cacheRegex = this.GetRegex(regex, flags);\n                return text ? text.search(cacheRegex) : -1\n            },\n            regexreplace(text, regex, flags, replace) {\n                const cacheRegex = this.GetRegex(regex, flags);\n                return text ? text.replace(cacheRegex, replace) : ""\n            },\n            regexmatchcount(text, regex, flags) {\n                const matches = this.GetRegexMatches(text.toString(), regex, flags);\n                return matches ? matches.length : 0\n            },\n            regexmatchat(text, regex, flags, index) {\n                index = Math.floor(index);\n                const matches = this.GetRegexMatches(text.toString(), regex, flags);\n                if (!matches || index < 0 || index >= matches.length)\n                    return "";\n                else\n                    return matches[index]\n            },\n            zeropad(n, d) {\n                let s = n < 0 ? "-" : "";\n                if (n < 0)\n                    n = -n;\n                const zeroes = d - n.toString().length;\n                s += "0".repeat(Math.max(zeroes, 0));\n                return s + n.toString()\n            },\n            urlencode(s) {\n                return encodeURIComponent(s)\n            },\n            urldecode(s) {\n                return decodeURIComponent(s)\n            },\n            dt() {\n                return this._runtime._GetDtFast()\n            },\n            timescale() {\n                return this._runtime.GetTimeScale()\n            },\n            wallclocktime() {\n                return (Date.now() - this._runtime.GetStartTime()) \/ 1E3\n            },\n            unixtime() {\n                return Date.now()\n            },\n            time() {\n                return this._runtime.GetGameTime()\n            },\n            tickcount() {\n                return this._runtime.GetTickCount()\n            },\n            objectcount() {\n                return this._runtime.GetObjectCount()\n            },\n            fps() {\n                return this._runtime.GetFPS()\n            },\n            cpuutilisation() {\n                return this._runtime.GetMainThreadTime()\n            },\n            gpuutilisation() {\n                return this._runtime.GetGPUUtilisation()\n            },\n            windowwidth() {\n                return this._runtime.GetCanvasManager().GetDeviceWidth()\n            },\n            windowheight() {\n                return this._runtime.GetCanvasManager().GetDeviceHeight()\n            },\n            originalwindowwidth() {\n                return this._runtime.GetOriginalViewportWidth()\n            },\n            originalwindowheight() {\n                return this._runtime.GetOriginalViewportHeight()\n            },\n            originalviewportwidth() {\n                return this._runtime.GetOriginalViewportWidth()\n            },\n            originalviewportheight() {\n                return this._runtime.GetOriginalViewportHeight()\n            },\n            scrollx() {\n                return this._runtime.GetCurrentLayout().GetScrollX()\n            },\n            scrolly() {\n                return this._runtime.GetCurrentLayout().GetScrollY()\n            },\n            layoutname() {\n                return this._runtime.GetCurrentLayout().GetName()\n            },\n            layoutscale() {\n                return this._runtime.GetCurrentLayout().GetScale()\n            },\n            layoutangle() {\n                return C3.toDegrees(this._runtime.GetCurrentLayout().GetAngle())\n            },\n            layoutwidth() {\n                return this._runtime.GetCurrentLayout().GetWidth()\n            },\n            layoutheight() {\n                return this._runtime.GetCurrentLayout().GetHeight()\n            },\n            vanishingpointx() {\n                return this._runtime.GetCurrentLayout().GetVanishingPointX() * 100\n            },\n            vanishingpointy() {\n                return this._runtime.GetCurrentLayout().GetVanishingPointY() * 100\n            },\n            viewportleft(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetViewport3D().getLeft() : 0\n            },\n            viewporttop(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetViewport3D().getTop() : 0\n            },\n            viewportright(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetViewport3D().getRight() : 0\n            },\n            viewportbottom(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetViewport3D().getBottom() : 0\n            },\n            viewportwidth(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetViewport3D().width() : 0\n            },\n            viewportheight(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetViewport3D().height() : 0\n            },\n            canvastolayerx(layerParam, x, y) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.CanvasCssToLayer(x, y)[0] : 0\n            },\n            canvastolayery(layerParam, x, y) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.CanvasCssToLayer(x, y)[1] : 0\n            },\n            layertocanvasx(layerParam, x, y) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.LayerToCanvasCss(x, y)[0] : 0\n            },\n            layertocanvasy(layerParam, x, y) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.LayerToCanvasCss(x, y)[1] : 0\n            },\n            layerscale(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetOwnScale() : 0\n            },\n            layerangle(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? C3.toDegrees(layer.GetOwnAngle()) : 0\n            },\n            layeropacity(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetOpacity() * 100 : 0\n            },\n            layerscalerate(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetScaleRate() : 0\n            },\n            layerscrollx(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetScrollX() : 0\n            },\n            layerscrolly(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetScrollY() : 0\n            },\n            layerparallaxx(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetParallaxX() * 100 : 0\n            },\n            layerparallaxy(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetParallaxY() * 100 : 0\n            },\n            layerzelevation(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetZElevation() : 0\n            },\n            layerindex(layerParam) {\n                const layer = this._runtime.GetCurrentLayout().GetLayer(layerParam);\n                return layer ? layer.GetIndex() : -1\n            },\n            canvassnapshot() {\n                const canvasManager = this._runtime.GetCanvasManager();\n                if (!canvasManager)\n                    return "";\n                return canvasManager.GetCanvasSnapshotUrl()\n            },\n            loopindex(name) {\n                const loopStack = this._loopStack;\n                if (!loopStack.IsInLoop())\n                    return 0;\n                if (name) {\n                    const loop = loopStack.FindByName(name);\n                    return loop ? loop.GetIndex() : 0\n                } else\n                    return loopStack.GetCurrent().GetIndex()\n            },\n            savestatejson() {\n                return this._runtime.GetLastSaveJsonString()\n            },\n            callmapped(name, str, ...paramResults) {\n                const mapEntry = this._GetFunctionMap(name.toLowerCase(), false);\n                if (!mapEntry) {\n                    console.warn(`[Construct] Call mapped function: map name \'${name}\' not found; returning 0`);\n                    return 0\n                }\n                let functionBlock = mapEntry.strMap.get(str.toLowerCase());\n                if (!functionBlock)\n                    if (mapEntry.defaultFunc)\n                        functionBlock = mapEntry.defaultFunc;\n                    else {\n                        console.warn(`[Construct] Call mapped function: no function associated with map \'${name}\' string \'${str}\'; returning 0 (consider setting a default)`);\n                        return 0\n                    }\n                const returnType = functionBlock.GetReturnType();\n                const defaultReturnValue = functionBlock.GetDefaultReturnValue();\n                if (returnType === 0) {\n                    console.warn(`[Construct] Call mapped function: map \'${name}\' string \'${str}\' has no return type so cannot be called from an expression; returning 0`);\n                    return 0\n                }\n                if (!functionBlock.IsEnabled())\n                    return defaultReturnValue;\n                const runtime = this._runtime;\n                const eventSheetManager = runtime.GetEventSheetManager();\n                const currentEvent = eventSheetManager.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiersIncludingParents();\n                const hasAnySolModifiers = solModifiers.length > 0;\n                if (hasAnySolModifiers)\n                    eventSheetManager.PushCleanSol(solModifiers);\n                const calleeParameters = functionBlock.GetFunctionParameters();\n                for (let i = paramResults.length, len = calleeParameters.length; i < len; ++i)\n                    paramResults.push(calleeParameters[i].GetInitialValue());\n                const callEventBlock = functionBlock.GetEventBlock();\n                const returnValue = callEventBlock.RunAsExpressionFunctionCall(callEventBlock.GetSolModifiersIncludingParents(), returnType, defaultReturnValue, ...paramResults);\n                if (hasAnySolModifiers)\n                    eventSheetManager.PopSol(solModifiers);\n                return returnValue\n            },\n            loadingprogress() {\n                return this._runtime.GetAssetManager().GetLoadProgress()\n            },\n            imageloadingprogress() {\n                if (this._imagesLoadingTotal === 0)\n                    return 1;\n                return this._imagesLoadingComplete \/ this._imagesLoadingTotal\n            },\n            renderer() {\n                if (this._runtime.GetWebGPURenderer())\n                    return "webgpu";\n                else\n                    return "webgl"\n            },\n            rendererdetail() {\n                if (this._runtime.GetWebGPURenderer())\n                    return "<unavailable>";\n                else\n                    return this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()\n            },\n            imagememoryusage() {\n                let ret = this._runtime.GetRenderer().GetEstimatedTextureMemoryUsage();\n                return Math.round(100 * ret \/ (1024 * 1024)) \/ 100\n            },\n            rgb(r, g, b) {\n                return C3.PackRGB(r, g, b)\n            },\n            rgbex(r, g, b) {\n                return C3.PackRGBEx(r \/ 100, g \/ 100, b \/ 100)\n            },\n            rgba(r, g, b, a) {\n                return C3.PackRGBAEx(r \/ 100, g \/ 100, b \/ 100, a \/ 100)\n            },\n            rgbex255(r, g, b) {\n                return C3.PackRGBEx(r \/ 255, g \/ 255, b \/ 255)\n            },\n            rgba255(r, g, b, a) {\n                return C3.PackRGBAEx(r \/ 255, g \/ 255, b \/ 255, a \/ 255)\n            },\n            projectname() {\n                return this._runtime.GetProjectName()\n            },\n            projectversion() {\n                return this._runtime.GetProjectVersion()\n            },\n            currenteventsheetname() {\n                return this._runtime.GetCurrentEvent().GetEventSheet().GetName()\n            },\n            currenteventnumber() {\n                return this._runtime.GetCurrentEvent().GetDisplayNumber()\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Plugins.Text = class TextPlugin extends C3.SDKPluginBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Text.Type = class TextType extends C3.SDKTypeBase {\n            constructor(objectClass) {\n                super(objectClass)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n            LoadTextures(renderer) {}\n            ReleaseTextures() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        const TEMP_COLOR_ARRAY = [0, 0, 0];\n        const TEXT = 0;\n        const ENABLE_BBCODE = 1;\n        const FONT = 2;\n        const SIZE = 3;\n        const LINE_HEIGHT = 4;\n        const BOLD = 5;\n        const ITALIC = 6;\n        const COLOR = 7;\n        const HORIZONTAL_ALIGNMENT = 8;\n        const VERTICAL_ALIGNMENT = 9;\n        const WRAPPING = 10;\n        const INITIALLY_VISIBLE = 11;\n        const ORIGIN = 12;\n        const HORIZONTAL_ALIGNMENTS = ["left", "center", "right"];\n        const VERTICAL_ALIGNMENTS = ["top", "center", "bottom"];\n        const WORD_WRAP = 0;\n        const CHARACTER_WRAP = 1;\n        const tempRect = new C3.Rect;\n        const tempQuad = new C3.Quad;\n        const tempColor = new C3.Color;\n        C3.Plugins.Text.Instance = class TextInstance extends C3.SDKWorldInstanceBase {\n            constructor(inst, properties) {\n                super(inst);\n                this._text = "";\n                this._enableBBcode = true;\n                this._faceName = "Arial";\n                this._ptSize = 12;\n                this._lineHeightOffset = 0;\n                this._isBold = false;\n                this._isItalic = false;\n                this._color = C3.New(C3.Color);\n                this._horizontalAlign = 0;\n                this._verticalAlign = 0;\n                this._wrapByWord = true;\n                this._typewriterStartTime = -1;\n                this._typewriterEndTime = -1;\n                this._typewriterLength = 0;\n                this._rendererText = C3.New(C3.Gfx.RendererText, this._runtime.GetRenderer(), {\n                    timeout: 5\n                });\n                this._rendererText.ontextureupdate = () => this._runtime.UpdateRender();\n                this._rendererText.SetIsAsync(false);\n                if (properties) {\n                    this._text = properties[TEXT];\n                    this._enableBBcode = !!properties[ENABLE_BBCODE];\n                    this._faceName = properties[FONT];\n                    this._ptSize = properties[SIZE];\n                    this._lineHeightOffset = properties[LINE_HEIGHT];\n                    this._isBold = !!properties[BOLD];\n                    this._isItalic = !!properties[ITALIC];\n                    this._horizontalAlign = properties[HORIZONTAL_ALIGNMENT];\n                    this._verticalAlign = properties[VERTICAL_ALIGNMENT];\n                    this._wrapByWord = properties[WRAPPING] === WORD_WRAP;\n                    const v = properties[COLOR];\n                    this._color.setRgb(v[0], v[1], v[2]);\n                    this.GetWorldInfo().SetVisible(properties[INITIALLY_VISIBLE])\n                }\n                this._UpdateTextSettings()\n            }\n            Release() {\n                this._CancelTypewriter();\n                this._rendererText.Release();\n                this._rendererText = null;\n                super.Release()\n            }\n            _UpdateTextSettings() {\n                const rendererText = this._rendererText;\n                rendererText.SetText(this._text);\n                rendererText.SetBBCodeEnabled(this._enableBBcode);\n                rendererText.SetFontName(this._faceName);\n                rendererText.SetLineHeight(this._lineHeightOffset);\n                rendererText.SetBold(this._isBold);\n                rendererText.SetItalic(this._isItalic);\n                rendererText.SetColor(this._color);\n                rendererText.SetHorizontalAlignment(HORIZONTAL_ALIGNMENTS[this._horizontalAlign]);\n                rendererText.SetVerticalAlignment(VERTICAL_ALIGNMENTS[this._verticalAlign]);\n                rendererText.SetWordWrapMode(this._wrapByWord ? "word" : "character")\n            }\n            _UpdateTextSize() {\n                const wi = this.GetWorldInfo();\n                this._rendererText.SetFontSize(this._ptSize);\n                this._rendererText.SetFontSizeScale(wi.GetSceneGraphScale());\n                const layer = wi.GetLayer();\n                const textZoom = layer.GetRenderScale() * layer.Get2DScaleFactorToZ(wi.GetTotalZElevation());\n                this._rendererText.SetSize(wi.GetWidth(), wi.GetHeight(), textZoom)\n            }\n            Draw(renderer) {\n                const wi = this.GetWorldInfo();\n                this._UpdateTextSize();\n                const texture = this._rendererText.GetTexture();\n                if (!texture)\n                    return;\n                const layer = wi.GetLayer();\n                if (wi.GetAngle() === 0 && layer.GetAngle() === 0 && wi.GetTotalZElevation() === 0 && !wi.HasMesh() && layer.RendersIn2DMode()) {\n                    const quad = wi.GetBoundingQuad();\n                    const [dl,dt] = layer.LayerToDrawSurface(quad.getTlx(), quad.getTly());\n                    const [dr,db] = layer.LayerToDrawSurface(quad.getBrx(), quad.getBry());\n                    const offX = dl - Math.round(dl);\n                    const offY = dt - Math.round(dt);\n                    tempRect.set(dl, dt, dr, db);\n                    tempRect.offset(-offX, -offY);\n                    tempQuad.setFromRect(tempRect);\n                    const [rtWidth,rtHeight] = renderer.GetRenderTargetSize(renderer.GetRenderTarget());\n                    this._runtime.GetCanvasManager().SetDeviceTransform(renderer, rtWidth, rtHeight);\n                    renderer.SetTexture(texture);\n                    renderer.Quad3(tempQuad, this._rendererText.GetTexRect());\n                    layer._SetTransform(renderer)\n                } else {\n                    renderer.SetTexture(texture);\n                    if (wi.HasMesh())\n                        this._DrawMesh(wi, renderer);\n                    else\n                        this._DrawStandard(wi, renderer)\n                }\n            }\n            _DrawStandard(wi, renderer) {\n                let quad = wi.GetBoundingQuad();\n                if (this._runtime.IsPixelRoundingEnabled())\n                    quad = this._PixelRoundQuad(quad);\n                renderer.Quad3(quad, this._rendererText.GetTexRect())\n            }\n            _DrawMesh(wi, renderer) {\n                const transformedMesh = wi.GetTransformedMesh();\n                if (wi.IsMeshChanged()) {\n                    wi.CalculateBbox(tempRect, tempQuad, false);\n                    let quad = tempQuad;\n                    if (this._runtime.IsPixelRoundingEnabled())\n                        quad = this._PixelRoundQuad(quad);\n                    transformedMesh.CalculateTransformedMesh(wi.GetSourceMesh(), quad, this._rendererText.GetTexRect());\n                    wi.SetMeshChanged(false)\n                }\n                transformedMesh.Draw(renderer)\n            }\n            _PixelRoundQuad(quad) {\n                const offX = quad.getTlx() - Math.round(quad.getTlx());\n                const offY = quad.getTly() - Math.round(quad.getTly());\n                if (offX === 0 && offY === 0)\n                    return quad;\n                else {\n                    tempQuad.copy(quad);\n                    tempQuad.offset(-offX, -offY);\n                    return tempQuad\n                }\n            }\n            GetCurrentSurfaceSize() {\n                const texture = this._rendererText.GetTexture();\n                if (texture)\n                    return [texture.GetWidth(), texture.GetHeight()];\n                else\n                    return [100, 100]\n            }\n            GetCurrentTexRect() {\n                return this._rendererText.GetTexRect()\n            }\n            IsCurrentTexRotated() {\n                return false\n            }\n            SaveToJson() {\n                const o = {\n                    "t": this._text,\n                    "c": this._color.toJSON(),\n                    "fn": this._faceName,\n                    "ps": this._ptSize\n                };\n                if (this._enableBBcode)\n                    o["bbc"] = this._enableBBcode;\n                if (this._horizontalAlign !== 0)\n                    o["ha"] = this._horizontalAlign;\n                if (this._verticalAlign !== 0)\n                    o["va"] = this._verticalAlign;\n                if (!this._wrapByWord)\n                    o["wr"] = this._wrapByWord;\n                if (this._lineHeightOffset !== 0)\n                    o["lho"] = this._lineHeightOffset;\n                if (this._isBold)\n                    o["b"] = this._isBold;\n                if (this._isItalic)\n                    o["i"] = this._isItalic;\n                if (this._typewriterEndTime !== -1)\n                    o["tw"] = {\n                        "st": this._typewriterStartTime,\n                        "en": this._typewriterEndTime,\n                        "l": this._typewriterLength\n                    };\n                return o\n            }\n            LoadFromJson(o) {\n                this._CancelTypewriter();\n                this._text = o["t"],\n                this._color.setFromJSON(o["c"]);\n                this._faceName = o["fn"],\n                this._ptSize = o["ps"];\n                this._enableBBcode = o.hasOwnProperty("bbc") ? o["bbc"] : false;\n                this._horizontalAlign = o.hasOwnProperty("ha") ? o["ha"] : 0;\n                this._verticalAlign = o.hasOwnProperty("va") ? o["va"] : 0;\n                this._wrapByWord = o.hasOwnProperty("wr") ? o["wr"] : true;\n                this._lineHeightOffset = o.hasOwnProperty("lho") ? o["lho"] : 0;\n                this._isBold = o.hasOwnProperty("b") ? o["b"] : false;\n                this._isItalic = o.hasOwnProperty("i") ? o["i"] : false;\n                if (o.hasOwnProperty("tw")) {\n                    const tw = o["tw"];\n                    this._typewriterStartTime = tw["st"];\n                    this._typewriterEndTime = tw["en"];\n                    this._typewriterLength = tw["l"]\n                }\n                this._UpdateTextSettings();\n                if (this._typewriterEndTime !== -1)\n                    this._StartTicking()\n            }\n            GetPropertyValueByIndex(index) {\n                switch (index) {\n                case TEXT:\n                    return this._text;\n                case ENABLE_BBCODE:\n                    return this._enableBBcode;\n                case FONT:\n                    return this._faceName;\n                case SIZE:\n                    return this._ptSize;\n                case LINE_HEIGHT:\n                    return this._lineHeightOffset;\n                case BOLD:\n                    return this._isBold;\n                case ITALIC:\n                    return this._isItalic;\n                case COLOR:\n                    TEMP_COLOR_ARRAY[0] = this._color.getR();\n                    TEMP_COLOR_ARRAY[1] = this._color.getG();\n                    TEMP_COLOR_ARRAY[2] = this._color.getB();\n                    return TEMP_COLOR_ARRAY;\n                case HORIZONTAL_ALIGNMENT:\n                    return this._horizontalAlign;\n                case VERTICAL_ALIGNMENT:\n                    return this._verticalAlign;\n                case WRAPPING:\n                    return this._wrapByWord ? CHARACTER_WRAP : WORD_WRAP\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                switch (index) {\n                case TEXT:\n                    if (this._text === value)\n                        return;\n                    this._text = value;\n                    this._UpdateTextSettings();\n                    break;\n                case ENABLE_BBCODE:\n                    if (this._enableBBcode === !!value)\n                        return;\n                    this._enableBBcode = !!value;\n                    this._UpdateTextSettings();\n                    break;\n                case FONT:\n                    if (this._faceName === value)\n                        return;\n                    this._faceName = value;\n                    this._UpdateTextSettings();\n                    break;\n                case SIZE:\n                    if (this._ptSize === value)\n                        return;\n                    this._ptSize = value;\n                    this._UpdateTextSettings();\n                    break;\n                case LINE_HEIGHT:\n                    if (this._lineHeightOffset === value)\n                        return;\n                    this._lineHeightOffset = value;\n                    this._UpdateTextSettings();\n                    break;\n                case BOLD:\n                    if (this._isBold === !!value)\n                        return;\n                    this._isBold = !!value;\n                    this._UpdateTextSettings();\n                    break;\n                case ITALIC:\n                    if (this._isItalic === !!value)\n                        return;\n                    this._isItalic = !!value;\n                    this._UpdateTextSettings();\n                    break;\n                case COLOR:\n                    const c = this._color;\n                    const v = value;\n                    if (c.getR() === v[0] && c.getG() === v[1] && c.getB() === v[2])\n                        return;\n                    this._color.setRgb(v[0], v[1], v[2]);\n                    this._UpdateTextSettings();\n                    break;\n                case HORIZONTAL_ALIGNMENT:\n                    if (this._horizontalAlign === value)\n                        return;\n                    this._horizontalAlign = value;\n                    this._UpdateTextSettings();\n                    break;\n                case VERTICAL_ALIGNMENT:\n                    if (this._verticalAlign === value)\n                        return;\n                    this._verticalAlign = value;\n                    this._UpdateTextSettings();\n                    break;\n                case WRAPPING:\n                    if (this._wrapByWord === (value === WORD_WRAP))\n                        return;\n                    this._wrapByWord = value === WORD_WRAP;\n                    this._UpdateTextSettings();\n                    break\n                }\n            }\n            SetPropertyColorOffsetValueByIndex(index, r, g, b) {\n                if (r === 0 && g === 0 && b === 0)\n                    return;\n                switch (index) {\n                case COLOR:\n                    this._color.addRgb(r, g, b);\n                    this._UpdateTextSettings();\n                    break\n                }\n            }\n            _SetText(text) {\n                if (this._text === text)\n                    return;\n                this._text = text;\n                this._rendererText.SetText(text);\n                this._runtime.UpdateRender()\n            }\n            GetText() {\n                return this._text\n            }\n            _StartTypewriter(text, duration) {\n                this._SetText(text);\n                this._typewriterStartTime = this._runtime.GetWallTime();\n                this._typewriterEndTime = this._typewriterStartTime + duration \/ this.GetInstance().GetActiveTimeScale();\n                this._typewriterLength = C3.CountGraphemes(C3.BBString.StripAnyTags(text));\n                this._rendererText.SetDrawMaxCharacterCount(0);\n                this._StartTicking()\n            }\n            _CancelTypewriter() {\n                this._typewriterStartTime = -1;\n                this._typewriterEndTime = -1;\n                this._typewriterLength = 0;\n                this._rendererText.SetDrawMaxCharacterCount(-1);\n                this._StopTicking()\n            }\n            _FinishTypewriter() {\n                if (this._typewriterEndTime === -1)\n                    return;\n                this._CancelTypewriter();\n                this.Trigger(C3.Plugins.Text.Cnds.OnTypewriterTextFinished);\n                this._runtime.UpdateRender()\n            }\n            _SetFontFace(face) {\n                if (this._faceName === face)\n                    return;\n                this._faceName = face;\n                this._rendererText.SetFontName(face);\n                this._runtime.UpdateRender()\n            }\n            _GetFontFace() {\n                return this._faceName\n            }\n            _SetBold(b) {\n                b = !!b;\n                if (this._isBold === b)\n                    return;\n                this._isBold = b;\n                this._rendererText.SetBold(b);\n                this._runtime.UpdateRender()\n            }\n            _IsBold() {\n                return this._isBold\n            }\n            _SetItalic(i) {\n                i = !!i;\n                if (this._isItalic === i)\n                    return;\n                this._isItalic = i;\n                this._rendererText.SetItalic(i);\n                this._runtime.UpdateRender()\n            }\n            _IsItalic() {\n                return this._isItalic\n            }\n            _SetFontSize(size) {\n                if (this._ptSize === size)\n                    return;\n                this._ptSize = size;\n                this._runtime.UpdateRender()\n            }\n            _GetFontSize() {\n                return this._ptSize\n            }\n            _SetFontColor(color) {\n                if (this._color.equalsIgnoringAlpha(color))\n                    return;\n                this._color.copyRgb(color);\n                this._rendererText.SetColor(this._color);\n                this._runtime.UpdateRender()\n            }\n            _GetFontColor() {\n                return this._color\n            }\n            _SetLineHeight(lho) {\n                if (this._lineHeightOffset === lho)\n                    return;\n                this._lineHeightOffset = lho;\n                this._UpdateTextSettings();\n                this._runtime.UpdateRender()\n            }\n            _GetLineHeight() {\n                return this._lineHeightOffset\n            }\n            _SetHAlign(h) {\n                if (this._horizontalAlign === h)\n                    return;\n                this._horizontalAlign = h;\n                this._UpdateTextSettings();\n                this._runtime.UpdateRender()\n            }\n            _GetHAlign() {\n                return this._horizontalAlign\n            }\n            _SetVAlign(v) {\n                if (this._verticalAlign === v)\n                    return;\n                this._verticalAlign = v;\n                this._UpdateTextSettings();\n                this._runtime.UpdateRender()\n            }\n            _GetVAlign() {\n                return this._verticalAlign\n            }\n            _SetWrapByWord(w) {\n                w = !!w;\n                if (this._wrapByWord === w)\n                    return;\n                this._wrapByWord = w;\n                this._UpdateTextSettings();\n                this._runtime.UpdateRender()\n            }\n            _IsWrapByWord() {\n                return this._wrapByWord\n            }\n            _GetTextWidth() {\n                this._UpdateTextSize();\n                return this._rendererText.GetTextWidth()\n            }\n            _GetTextHeight() {\n                this._UpdateTextSize();\n                return this._rendererText.GetTextHeight()\n            }\n            Tick() {\n                const wallTime = this._runtime.GetWallTime();\n                if (wallTime >= this._typewriterEndTime) {\n                    this._CancelTypewriter();\n                    this.Trigger(C3.Plugins.Text.Cnds.OnTypewriterTextFinished);\n                    this._runtime.UpdateRender()\n                } else {\n                    let displayLength = C3.relerp(this._typewriterStartTime, this._typewriterEndTime, wallTime, 0, this._typewriterLength);\n                    displayLength = Math.floor(displayLength);\n                    if (displayLength !== this._rendererText.GetDrawMaxCharacterCount()) {\n                        this._rendererText.SetDrawMaxCharacterCount(displayLength);\n                        this._runtime.UpdateRender()\n                    }\n                }\n            }\n            GetDebuggerProperties() {\n                const prefix = "plugins.text";\n                return [{\n                    title: prefix + ".name",\n                    properties: [{\n                        name: prefix + ".properties.text.name",\n                        value: this._text,\n                        onedit: v => this._SetText(v)\n                    }]\n                }]\n            }\n            GetScriptInterfaceClass() {\n                return self.ITextInstance\n            }\n        }\n        ;\n        const map = new WeakMap;\n        const SCRIPT_HORIZONTAL_ALIGNMENTS = new Map([["left", 0], ["center", 1], ["right", 2]]);\n        const SCRIPT_VERTICAL_ALIGNMENTS = new Map([["top", 0], ["center", 1], ["bottom", 2]]);\n        const SCRIPT_WRAP_MODES = new Map([["word", true], ["character", false]]);\n        self.ITextInstance = class ITextInstance extends self.IWorldInstance {\n            constructor() {\n                super();\n                map.set(this, self.IInstance._GetInitInst().GetSdkInstance())\n            }\n            get text() {\n                return map.get(this).GetText()\n            }\n            set text(str) {\n                C3X.RequireString(str);\n                const inst = map.get(this);\n                inst._CancelTypewriter();\n                inst._SetText(str)\n            }\n            typewriterText(str, duration) {\n                C3X.RequireString(str);\n                C3X.RequireFiniteNumber(duration);\n                const inst = map.get(this);\n                inst._CancelTypewriter();\n                inst._StartTypewriter(str, duration)\n            }\n            typewriterFinish() {\n                map.get(this)._FinishTypewriter()\n            }\n            set fontFace(str) {\n                C3X.RequireString(str);\n                map.get(this)._SetFontFace(str)\n            }\n            get fontFace() {\n                return map.get(this)._GetFontFace()\n            }\n            set isBold(b) {\n                map.get(this)._SetBold(b)\n            }\n            get isBold() {\n                return map.get(this)._IsBold()\n            }\n            set isItalic(i) {\n                map.get(this)._SetItalic(i)\n            }\n            get isItalic() {\n                return map.get(this)._IsItalic()\n            }\n            set sizePt(pt) {\n                C3X.RequireFiniteNumber(pt);\n                map.get(this)._SetFontSize(pt)\n            }\n            get sizePt() {\n                return map.get(this)._GetFontSize()\n            }\n            set fontColor(arr) {\n                C3X.RequireArray(arr);\n                if (arr.length < 3)\n                    throw new Error("expected 3 elements");\n                tempColor.setRgb(arr[0], arr[1], arr[2]);\n                map.get(this)._SetFontColor(tempColor)\n            }\n            get fontColor() {\n                const c = map.get(this)._GetFontColor();\n                return [c.getR(), c.getG(), c.getB()]\n            }\n            set lineHeight(lho) {\n                C3X.RequireFiniteNumber(lho);\n                map.get(this)._SetLineHeight(lho)\n            }\n            get lineHeight() {\n                return map.get(this)._GetLineHeight()\n            }\n            set horizontalAlign(str) {\n                C3X.RequireString(str);\n                const h = SCRIPT_HORIZONTAL_ALIGNMENTS.get(str);\n                if (typeof h === "undefined")\n                    throw new Error("invalid mode");\n                map.get(this)._SetHAlign(h)\n            }\n            get horizontalAlign() {\n                return HORIZONTAL_ALIGNMENTS[map.get(this)._GetHAlign()]\n            }\n            set verticalAlign(str) {\n                C3X.RequireString(str);\n                const v = SCRIPT_VERTICAL_ALIGNMENTS.get(str);\n                if (typeof v === "undefined")\n                    throw new Error("invalid mode");\n                map.get(this)._SetVAlign(v)\n            }\n            get verticalAlign() {\n                return VERTICAL_ALIGNMENTS[map.get(this)._GetVAlign()]\n            }\n            set wordWrapMode(str) {\n                C3X.RequireString(str);\n                const isWrapByWord = SCRIPT_WRAP_MODES.get(str);\n                if (typeof isWrapByWord === "undefined")\n                    throw new Error("invalid mode");\n                map.get(this)._SetWrapByWord(isWrapByWord)\n            }\n            get wordWrapMode() {\n                return map.get(this)._IsWrapByWord() ? "word" : "character"\n            }\n            get textWidth() {\n                return map.get(this)._GetTextWidth()\n            }\n            get textHeight() {\n                return map.get(this)._GetTextHeight()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Text.Cnds = {\n            CompareText(str, caseSensitive) {\n                if (caseSensitive)\n                    return this._text === str;\n                else\n                    return C3.equalsNoCase(this._text, str)\n            },\n            IsRunningTypewriterText() {\n                return this._typewriterEndTime !== -1\n            },\n            OnTypewriterTextFinished() {\n                return true\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const tempColor = C3.New(C3.Color);\n        C3.Plugins.Text.Acts = {\n            SetText(param) {\n                this._CancelTypewriter();\n                if (typeof param === "number" && param < 1E9)\n                    param = Math.round(param * 1E10) \/ 1E10;\n                this._SetText(param.toString())\n            },\n            AppendText(param) {\n                this._CancelTypewriter();\n                if (typeof param === "number" && param < 1E9)\n                    param = Math.round(param * 1E10) \/ 1E10;\n                param = param.toString();\n                if (!param)\n                    return;\n                this._SetText(this._text + param)\n            },\n            TypewriterText(param, duration) {\n                this._CancelTypewriter();\n                if (typeof param === "number" && param < 1E9)\n                    param = Math.round(param * 1E10) \/ 1E10;\n                this._StartTypewriter(param.toString(), duration)\n            },\n            SetFontFace(face, style) {\n                let bold = false;\n                let italic = false;\n                switch (style) {\n                case 1:\n                    bold = true;\n                    break;\n                case 2:\n                    italic = true;\n                    break;\n                case 3:\n                    bold = true;\n                    italic = true;\n                    break\n                }\n                if (face === this._faceName && bold === this._isBold && italic === this._isItalic)\n                    return;\n                this._SetFontFace(face);\n                this._SetBold(bold);\n                this._SetItalic(italic)\n            },\n            SetFontSize(size) {\n                this._SetFontSize(size)\n            },\n            SetFontColor(rgb) {\n                tempColor.setFromRgbValue(rgb);\n                tempColor.clamp();\n                this._SetFontColor(tempColor)\n            },\n            SetWebFont(familyName, cssUrl) {\n                console.warn("[Text] \'Set web font\' action is deprecated and no longer has any effect")\n            },\n            SetEffect(effect) {\n                this.GetWorldInfo().SetBlendMode(effect);\n                this._runtime.UpdateRender()\n            },\n            TypewriterFinish() {\n                this._FinishTypewriter()\n            },\n            SetLineHeight(lho) {\n                this._SetLineHeight(lho)\n            },\n            SetHAlign(h) {\n                this._SetHAlign(h)\n            },\n            SetVAlign(v) {\n                this._SetVAlign(v)\n            },\n            SetWrapping(w) {\n                this._SetWrapByWord(w === 0)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Text.Exps = {\n            Text() {\n                return this._text\n            },\n            PlainText() {\n                if (this._enableBBcode)\n                    return C3.BBString.StripAnyTags(this._text);\n                else\n                    return this._text\n            },\n            FaceName() {\n                return this._faceName\n            },\n            FaceSize() {\n                return this._ptSize\n            },\n            TextWidth() {\n                return this._GetTextWidth()\n            },\n            TextHeight() {\n                return this._GetTextHeight()\n            },\n            LineHeight() {\n                return this._lineHeightOffset\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Plugins.Sprite = class SpritePlugin extends C3.SDKPluginBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const spawnPickStack = [];\n        C3.Plugins.Sprite.Type = class SpriteType extends C3.SDKTypeBase {\n            constructor(objectClass) {\n                super(objectClass);\n                this._animations = objectClass.GetAnimations()\n            }\n            Release() {\n                C3.clearArray(this._animations);\n                super.Release()\n            }\n            OnCreate() {\n                for (const a of this._animations)\n                    a.LoadAllAssets(this._runtime)\n            }\n            LoadTextures(renderer) {\n                const opts = {\n                    sampling: this._runtime.GetSampling()\n                };\n                return Promise.all(this._animations.map(a => a.LoadAllTextures(renderer, opts)))\n            }\n            ReleaseTextures() {\n                for (const a of this._animations)\n                    a.ReleaseAllTextures()\n            }\n            OnDynamicTextureLoadComplete() {\n                this._UpdateAllCurrentTexture()\n            }\n            _UpdateAllCurrentTexture() {\n                for (const inst of this._objectClass.instancesIncludingPendingCreate())\n                    inst.GetSdkInstance()._UpdateCurrentTexture()\n            }\n            FinishCondition(doPick) {\n                C3.Plugins.Sprite.FinishCollisionCondition(this, doPick)\n            }\n            BeforeRunAction(method) {\n                spawnPickStack.push({\n                    objectClass: null,\n                    createHierarchy: false,\n                    instances: []\n                })\n            }\n            _SpawnPickInstance(objectClass, inst, createHierarchy) {\n                const entry = spawnPickStack.at(-1);\n                entry.objectClass = objectClass;\n                entry.createHierarchy = createHierarchy;\n                entry.instances.push(inst)\n            }\n            AfterRunAction(method) {\n                const entry = spawnPickStack.pop();\n                const objectClass = entry.objectClass;\n                const createHierarchy = entry.createHierarchy;\n                if (!objectClass)\n                    return;\n                const pickMap = new Map;\n                for (const inst of entry.instances)\n                    inst.CollectInstancesToPick(pickMap, objectClass, createHierarchy);\n                for (const [pickObjectClass,instSet] of pickMap)\n                    pickObjectClass.GetCurrentSol().SetSetPicked(instSet)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        const INITIALLY_VISIBLE = 0;\n        const INITIAL_ANIMATION = 1;\n        const INITIAL_FRAME = 2;\n        const ENABLE_COLLISIONS = 3;\n        const tempRect = C3.New(C3.Rect);\n        const tempQuad = C3.New(C3.Quad);\n        const tempVec2 = C3.New(C3.Vector2);\n        const FLAG_PLAYING_FORWARDS = 1 << 0;\n        const FLAG_ANIMATION_PLAYING = 1 << 1;\n        const FLAG_ANIMATION_TRIGGER = 1 << 2;\n        C3.Plugins.Sprite.Instance = class SpriteInstance extends C3.SDKWorldInstanceBase {\n            constructor(inst, properties) {\n                super(inst);\n                let initiallyVisible = true;\n                let initialAnimation = "";\n                let initialFrame = 0;\n                let collisionEnabled = true;\n                if (properties) {\n                    initiallyVisible = !!properties[INITIALLY_VISIBLE];\n                    initialAnimation = properties[INITIAL_ANIMATION];\n                    initialFrame = properties[INITIAL_FRAME];\n                    collisionEnabled = properties[ENABLE_COLLISIONS]\n                }\n                this._currentAnimation = this._objectClass.GetAnimationByName(initialAnimation) || this._objectClass.GetAnimations()[0];\n                this._currentFrameIndex = C3.clamp(initialFrame, 0, this._currentAnimation.GetFrameCount() - 1);\n                this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);\n                const initialImageInfo = this._currentAnimationFrame.GetImageInfo();\n                this._currentTexture = initialImageInfo.GetTexture();\n                this._currentRcTex = initialImageInfo.GetTexRect();\n                this._currentQuadTex = initialImageInfo.GetTexQuad();\n                this.HandleWebGLContextLoss();\n                inst.SetFlag(FLAG_ANIMATION_PLAYING, true);\n                inst.SetFlag(FLAG_PLAYING_FORWARDS, this._currentAnimation.GetSpeed() >= 0);\n                this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed());\n                this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo();\n                this._animationTimer = C3.New(C3.KahanSum);\n                this._frameStartTime = 0;\n                this._animationRepeats = 0;\n                this._animTriggerName = "";\n                this._changeAnimFrameIndex = -1;\n                this._changeAnimationName = "";\n                this._changeAnimationFrom = 0;\n                const wi = this.GetWorldInfo();\n                this._bquadRef = wi.GetBoundingQuad();\n                wi.SetVisible(initiallyVisible);\n                wi.SetCollisionEnabled(collisionEnabled);\n                wi.SetOriginX(this._currentAnimationFrame.GetOriginX());\n                wi.SetOriginY(this._currentAnimationFrame.GetOriginY());\n                wi.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly());\n                wi.SetBboxChanged();\n                if ((this._objectClass.GetAnimationCount() !== 1 || this._objectClass.GetAnimations()[0].GetFrameCount() !== 1) && this._currentAnimationSpeed !== 0)\n                    this._StartTicking()\n            }\n            Release() {\n                this._currentAnimation = null;\n                this._currentAnimationFrame = null;\n                this._currentTexture = null;\n                this._animationTimer = null;\n                super.Release()\n            }\n            GetCurrentImageInfo() {\n                return this._currentAnimationFrame.GetImageInfo()\n            }\n            IsOriginalSizeKnown() {\n                return true\n            }\n            OnWebGLContextLost() {\n                this._currentTexture = null\n            }\n            OnWebGLContextRestored() {\n                this._UpdateCurrentTexture()\n            }\n            Draw(renderer) {\n                const texture = this._currentTexture;\n                if (texture === null)\n                    return;\n                renderer.SetTexture(texture);\n                const wi = this.GetWorldInfo();\n                if (wi.HasMesh())\n                    this._DrawMesh(wi, renderer);\n                else\n                    this._DrawStandard(wi, renderer)\n            }\n            _DrawStandard(wi, renderer) {\n                let quad = this._bquadRef;\n                if (this._runtime.IsPixelRoundingEnabled())\n                    quad = wi.PixelRoundQuad(quad);\n                renderer.Quad4(quad, this._currentQuadTex)\n            }\n            _DrawMesh(wi, renderer) {\n                const transformedMesh = wi.GetTransformedMesh();\n                if (wi.IsMeshChanged()) {\n                    wi.CalculateBbox(tempRect, tempQuad, false);\n                    let quad = tempQuad;\n                    if (this._runtime.IsPixelRoundingEnabled())\n                        quad = wi.PixelRoundQuad(quad);\n                    transformedMesh.CalculateTransformedMesh(wi.GetSourceMesh(), quad, this._currentQuadTex);\n                    wi.SetMeshChanged(false)\n                }\n                transformedMesh.Draw(renderer)\n            }\n            GetAnimationTime() {\n                return this._animationTimer.Get()\n            }\n            IsAnimationPlaying() {\n                return this._inst.GetFlag(FLAG_ANIMATION_PLAYING)\n            }\n            SetAnimationPlaying(e) {\n                this._inst.SetFlag(FLAG_ANIMATION_PLAYING, e)\n            }\n            IsPlayingForwards() {\n                return this._inst.GetFlag(FLAG_PLAYING_FORWARDS)\n            }\n            SetPlayingForwards(e) {\n                this._inst.SetFlag(FLAG_PLAYING_FORWARDS, e)\n            }\n            IsInAnimationTrigger() {\n                return this._inst.GetFlag(FLAG_ANIMATION_TRIGGER)\n            }\n            SetInAnimationTrigger(e) {\n                this._inst.SetFlag(FLAG_ANIMATION_TRIGGER, e)\n            }\n            Tick() {\n                if (this._changeAnimationName)\n                    this._DoChangeAnimation();\n                if (this._changeAnimFrameIndex >= 0)\n                    this._DoChangeAnimFrame();\n                const currentAnimationSpeed = this._currentAnimationSpeed;\n                if (!this.IsAnimationPlaying() || currentAnimationSpeed === 0) {\n                    this._StopTicking();\n                    return\n                }\n                const dt = this._runtime.GetDt(this._inst);\n                this._animationTimer.Add(dt);\n                const now = this.GetAnimationTime();\n                const prevFrame = this._currentAnimationFrame;\n                const currentFrameTime = prevFrame.GetDuration() \/ currentAnimationSpeed;\n                if (now < this._frameStartTime + currentFrameTime)\n                    return;\n                const currentAnimation = this._currentAnimation;\n                const repeatTo = this._currentAnimationRepeatTo;\n                const frameCount = currentAnimation.GetFrameCount();\n                const repeatCount = currentAnimation.GetRepeatCount();\n                const isLooping = currentAnimation.IsLooping();\n                const isPingPong = currentAnimation.IsPingPong();\n                if (this.IsPlayingForwards())\n                    this._currentFrameIndex++;\n                else\n                    this._currentFrameIndex--;\n                this._frameStartTime += currentFrameTime;\n                if (this._currentFrameIndex >= frameCount)\n                    if (isPingPong) {\n                        this.SetPlayingForwards(false);\n                        this._currentFrameIndex = frameCount - 2\n                    } else if (isLooping)\n                        this._currentFrameIndex = repeatTo;\n                    else {\n                        this._animationRepeats++;\n                        if (this._animationRepeats >= repeatCount)\n                            this._FinishAnimation(false);\n                        else\n                            this._currentFrameIndex = repeatTo\n                    }\n                if (this._currentFrameIndex < 0)\n                    if (isPingPong) {\n                        this._currentFrameIndex = 1;\n                        this.SetPlayingForwards(true);\n                        if (!isLooping) {\n                            this._animationRepeats++;\n                            if (this._animationRepeats >= repeatCount)\n                                this._FinishAnimation(true)\n                        }\n                    } else if (isLooping)\n                        this._currentFrameIndex = repeatTo;\n                    else {\n                        this._animationRepeats++;\n                        if (this._animationRepeats >= repeatCount)\n                            this._FinishAnimation(true);\n                        else\n                            this._currentFrameIndex = repeatTo\n                    }\n                this._currentFrameIndex = C3.clamp(this._currentFrameIndex, 0, frameCount - 1);\n                const nextFrame = currentAnimation.GetFrameAt(this._currentFrameIndex);\n                if (now > this._frameStartTime + nextFrame.GetDuration() \/ currentAnimationSpeed)\n                    this._frameStartTime = now;\n                this._OnFrameChanged(prevFrame, nextFrame)\n            }\n            _FinishAnimation(reverse) {\n                this._currentFrameIndex = reverse ? 0 : this._currentAnimation.GetFrameCount() - 1;\n                this.SetAnimationPlaying(false);\n                this._animTriggerName = this._currentAnimation.GetName();\n                this.SetInAnimationTrigger(true);\n                this.DispatchScriptEvent("animationend", false, {\n                    animationName: this._animTriggerName\n                });\n                this.Trigger(C3.Plugins.Sprite.Cnds.OnAnyAnimFinished);\n                this.Trigger(C3.Plugins.Sprite.Cnds.OnAnimFinished);\n                this.SetInAnimationTrigger(false);\n                this._animationRepeats = 0\n            }\n            _OnFrameChanged(prevFrame, nextFrame) {\n                if (prevFrame === nextFrame)\n                    return;\n                const wi = this.GetWorldInfo();\n                const prevImage = prevFrame.GetImageInfo();\n                const nextImage = nextFrame.GetImageInfo();\n                const oldW = prevImage.GetWidth();\n                const oldH = prevImage.GetHeight();\n                const newW = nextImage.GetWidth();\n                const newH = nextImage.GetHeight();\n                if (oldW !== newW)\n                    wi.SetWidth(wi.GetWidth() * (newW \/ oldW));\n                if (oldH !== newH)\n                    wi.SetHeight(wi.GetHeight() * (newH \/ oldH));\n                wi.SetOriginX(nextFrame.GetOriginX());\n                wi.SetOriginY(nextFrame.GetOriginY());\n                wi.SetSourceCollisionPoly(nextFrame.GetCollisionPoly());\n                wi.SetBboxChanged();\n                this._currentAnimationFrame = nextFrame;\n                this._currentTexture = nextImage.GetTexture();\n                this._currentRcTex = nextImage.GetTexRect();\n                this._currentQuadTex = nextImage.GetTexQuad();\n                const behaviorInstances = this.GetInstance().GetBehaviorInstances();\n                for (let i = 0, len = behaviorInstances.length; i < len; ++i)\n                    behaviorInstances[i].OnSpriteFrameChanged(prevFrame, nextFrame);\n                this.DispatchScriptEvent("framechange", false, {\n                    animationName: this._currentAnimation.GetName(),\n                    animationFrame: this._currentFrameIndex\n                });\n                this.Trigger(C3.Plugins.Sprite.Cnds.OnFrameChanged);\n                this._runtime.UpdateRender()\n            }\n            _StartAnim(from) {\n                this.SetAnimationPlaying(true);\n                this._frameStartTime = this.GetAnimationTime();\n                if (from === 1 && this._currentFrameIndex !== 0) {\n                    this._changeAnimFrameIndex = 0;\n                    if (!this.IsInAnimationTrigger())\n                        this._DoChangeAnimFrame()\n                }\n                this._StartTicking()\n            }\n            _SetAnim(animName, from) {\n                this._changeAnimationName = animName;\n                this._changeAnimationFrom = from;\n                this._StartTicking();\n                if (!this.IsInAnimationTrigger())\n                    this._DoChangeAnimation()\n            }\n            _GetCurrentAnimation() {\n                return this._currentAnimation\n            }\n            _GetCurrentAnimationName() {\n                if (this._changeAnimationName)\n                    return this._changeAnimationName;\n                else\n                    return this._currentAnimation.GetName()\n            }\n            _SetAnimFrame(frameNum) {\n                if (!isFinite(frameNum))\n                    return;\n                this._changeAnimFrameIndex = frameNum;\n                if (!this.IsInAnimationTrigger())\n                    this._DoChangeAnimFrame()\n            }\n            _GetAnimFrame() {\n                return this._currentFrameIndex\n            }\n            _SetAnimSpeed(s) {\n                this._currentAnimationSpeed = Math.abs(s);\n                this.SetPlayingForwards(s >= 0);\n                if (this._currentAnimationSpeed > 0)\n                    this._StartTicking()\n            }\n            _GetAnimSpeed() {\n                return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed\n            }\n            _SetAnimRepeatToFrame(f) {\n                f = C3.clamp(Math.floor(f), 0, this._currentAnimation.GetFrameCount() - 1);\n                this._currentAnimationRepeatTo = f\n            }\n            _GetAnimRepeatToFrame() {\n                return this._currentAnimationRepeatTo\n            }\n            _DoChangeAnimation() {\n                const prevFrame = this._currentAnimationFrame;\n                const animation = this._objectClass.GetAnimationByName(this._changeAnimationName);\n                this._changeAnimationName = "";\n                if (!animation)\n                    return;\n                if (animation === this._currentAnimation && this.IsAnimationPlaying())\n                    return;\n                this._currentAnimation = animation;\n                this.SetPlayingForwards(animation.GetSpeed() >= 0);\n                this._currentAnimationSpeed = Math.abs(animation.GetSpeed());\n                this._currentAnimationRepeatTo = animation.GetRepeatTo();\n                this._currentFrameIndex = C3.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1);\n                if (this._changeAnimationFrom === 1)\n                    this._currentFrameIndex = 0;\n                this.SetAnimationPlaying(true);\n                this._frameStartTime = this.GetAnimationTime();\n                const nextFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);\n                this._OnFrameChanged(prevFrame, nextFrame)\n            }\n            _DoChangeAnimFrame() {\n                const prevFrame = this._currentAnimationFrame;\n                const prevFrameIndex = this._currentFrameIndex;\n                this._currentFrameIndex = C3.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1);\n                this._changeAnimFrameIndex = -1;\n                if (prevFrameIndex === this._currentFrameIndex)\n                    return;\n                const nextFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);\n                this._OnFrameChanged(prevFrame, nextFrame);\n                this._frameStartTime = this.GetAnimationTime()\n            }\n            _UpdateCurrentTexture() {\n                const curImageInfo = this._currentAnimationFrame.GetImageInfo();\n                this._currentTexture = curImageInfo.GetTexture();\n                this._currentRcTex = curImageInfo.GetTexRect();\n                this._currentQuadTex = curImageInfo.GetTexQuad();\n                this.GetWorldInfo().SetMeshChanged(true)\n            }\n            GetTexture() {\n                return this._currentTexture\n            }\n            GetTexRect() {\n                return this._currentRcTex\n            }\n            GetTexQuad() {\n                return this._currentQuadTex\n            }\n            GetImagePointCount() {\n                return this._currentAnimationFrame.GetImagePointCount()\n            }\n            GetImagePoint(nameOrIndex) {\n                const frame = this._currentAnimationFrame;\n                const wi = this.GetWorldInfo();\n                let ip = null;\n                if (typeof nameOrIndex === "string")\n                    ip = frame.GetImagePointByName(nameOrIndex);\n                else if (typeof nameOrIndex === "number")\n                    ip = frame.GetImagePointByIndex(nameOrIndex - 1);\n                else\n                    throw new TypeError("expected string or number");\n                if (!ip)\n                    return [wi.GetX(), wi.GetY()];\n                tempVec2.copy(ip.GetVec2());\n                if (wi.HasMesh()) {\n                    const [tx,ty] = wi.GetSourceMesh().TransformPoint(tempVec2.getX(), tempVec2.getY());\n                    tempVec2.set(tx, ty)\n                }\n                tempVec2.offset(-frame.GetOriginX(), -frame.GetOriginY());\n                tempVec2.scale(wi.GetWidth(), wi.GetHeight());\n                tempVec2.rotate(wi.GetAngle());\n                tempVec2.offset(wi.GetX(), wi.GetY());\n                return [tempVec2.getX(), tempVec2.getY()]\n            }\n            GetCollisionPolyPointCount() {\n                return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount()\n            }\n            GetCollisionPolyPoint(index) {\n                index = Math.floor(index);\n                const wi = this.GetWorldInfo();\n                const poly = wi.GetTransformedCollisionPoly();\n                const pointCount = poly.pointCount();\n                if (index === pointCount)\n                    index = 0;\n                if (index < 0 || index >= pointCount)\n                    return [0, 0];\n                const pointsArr = poly.pointsArr();\n                return [pointsArr[index * 2 + 0] + wi.GetX(), pointsArr[index * 2 + 1] + wi.GetY()]\n            }\n            GetDebuggerProperties() {\n                const Acts = C3.Plugins.Sprite.Acts;\n                const prefix = "plugins.sprite.debugger.animation-properties";\n                return [{\n                    title: prefix + ".title",\n                    properties: [{\n                        name: prefix + ".current-animation",\n                        value: this._currentAnimation.GetName(),\n                        onedit: v => this.CallAction(Acts.SetAnim, v, 0)\n                    }, {\n                        name: prefix + ".current-frame",\n                        value: this._currentFrameIndex,\n                        onedit: v => this.CallAction(Acts.SetAnimFrame, v)\n                    }, {\n                        name: prefix + ".is-playing",\n                        value: this.IsAnimationPlaying(),\n                        onedit: v => v ? this.CallAction(Acts.StartAnim, 0) : this.CallAction(Acts.StopAnim)\n                    }, {\n                        name: prefix + ".speed",\n                        value: this._currentAnimationSpeed,\n                        onedit: v => this.CallAction(Acts.SetAnimSpeed, v)\n                    }, {\n                        name: prefix + ".repeats",\n                        value: this._animationRepeats,\n                        onedit: v => this._animationRepeats = v\n                    }]\n                }]\n            }\n            SaveToJson() {\n                const o = {\n                    "a": this._currentAnimation.GetSID()\n                };\n                if (this._frameStartTime !== 0)\n                    o["fs"] = this._frameStartTime;\n                const animTime = this.GetAnimationTime();\n                if (animTime !== 0)\n                    o["at"] = animTime;\n                if (this._currentFrameIndex !== 0)\n                    o["f"] = this._currentFrameIndex;\n                if (this._currentAnimationSpeed !== 0)\n                    o["cas"] = this._currentAnimationSpeed;\n                if (this._animationRepeats !== 1)\n                    o["ar"] = this._animationRepeats;\n                if (this._currentAnimationRepeatTo !== 0)\n                    o["rt"] = this._currentAnimationRepeatTo;\n                if (!this.IsAnimationPlaying())\n                    o["ap"] = this.IsAnimationPlaying();\n                if (!this.IsPlayingForwards())\n                    o["af"] = this.IsPlayingForwards();\n                const wi = this.GetWorldInfo();\n                if (wi.IsCollisionEnabled())\n                    o["ce"] = wi.IsCollisionEnabled();\n                return o\n            }\n            LoadFromJson(o) {\n                const anim = this.GetObjectClass().GetAnimationBySID(o["a"]);\n                if (anim)\n                    this._currentAnimation = anim;\n                this._frameStartTime = o.hasOwnProperty("fs") ? o["fs"] : 0;\n                this._animationTimer.Set(o.hasOwnProperty("at") ? o["at"] : 0);\n                const frameIndex = o.hasOwnProperty("f") ? o["f"] : 0;\n                this._currentFrameIndex = C3.clamp(frameIndex, 0, this._currentAnimation.GetFrameCount() - 1);\n                this._currentAnimationSpeed = o.hasOwnProperty("cas") ? o["cas"] : 0;\n                this._animationRepeats = o.hasOwnProperty("ar") ? o["ar"] : 1;\n                const repeatToIndex = o.hasOwnProperty("rt") ? o["rt"] : 0;\n                this._currentAnimationRepeatTo = C3.clamp(repeatToIndex, 0, this._currentAnimation.GetFrameCount() - 1);\n                this.SetAnimationPlaying(o.hasOwnProperty("ap") ? !!o["ap"] : true);\n                this.SetPlayingForwards(o.hasOwnProperty("af") ? !!o["af"] : true);\n                const nextFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);\n                this._currentAnimationFrame = nextFrame;\n                this._UpdateCurrentTexture();\n                const wi = this.GetWorldInfo();\n                wi.SetOriginX(nextFrame.GetOriginX());\n                wi.SetOriginY(nextFrame.GetOriginY());\n                wi.SetSourceCollisionPoly(nextFrame.GetCollisionPoly());\n                wi.SetCollisionEnabled(!!o["ce"])\n            }\n            GetPropertyValueByIndex(index) {\n                const wi = this.GetWorldInfo();\n                switch (index) {\n                case ENABLE_COLLISIONS:\n                    return wi.IsCollisionEnabled();\n                case INITIAL_FRAME:\n                    return C3.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1)\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                const wi = this.GetWorldInfo();\n                switch (index) {\n                case ENABLE_COLLISIONS:\n                    wi.SetCollisionEnabled(!!value);\n                    break;\n                case INITIAL_FRAME:\n                    this.SetAnimationPlaying(false);\n                    const totalFrames = this._currentAnimation.GetFrameCount() - 1;\n                    const nextIndex = value = C3.clamp(value, 0, totalFrames);\n                    const prevFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);\n                    const nextFrame = this._currentAnimation.GetFrameAt(nextIndex);\n                    this._OnFrameChanged(prevFrame, nextFrame);\n                    this._currentFrameIndex = C3.clamp(nextIndex, 0, totalFrames);\n                    break\n                }\n            }\n            GetScriptInterfaceClass() {\n                return self.ISpriteInstance\n            }\n        }\n        ;\n        const map = new WeakMap;\n        const ANIM_FROM_MODES = new Map([["current-frame", 0], ["beginning", 1]]);\n        self.ISpriteInstance = class ISpriteInstance extends self.IWorldInstance {\n            constructor() {\n                super();\n                map.set(this, self.IInstance._GetInitInst().GetSdkInstance())\n            }\n            getImagePointCount() {\n                return map.get(this).GetImagePointCount()\n            }\n            getImagePointX(nameOrIndex) {\n                if (typeof nameOrIndex !== "string" && typeof nameOrIndex !== "number")\n                    throw new TypeError("expected string or number");\n                return map.get(this).GetImagePoint(nameOrIndex)[0]\n            }\n            getImagePointY(nameOrIndex) {\n                if (typeof nameOrIndex !== "string" && typeof nameOrIndex !== "number")\n                    throw new TypeError("expected string or number");\n                return map.get(this).GetImagePoint(nameOrIndex)[1]\n            }\n            getImagePoint(nameOrIndex) {\n                if (typeof nameOrIndex !== "string" && typeof nameOrIndex !== "number")\n                    throw new TypeError("expected string or number");\n                return map.get(this).GetImagePoint(nameOrIndex)\n            }\n            getPolyPointCount() {\n                return map.get(this).GetCollisionPolyPointCount()\n            }\n            getPolyPointX(index) {\n                C3X.RequireFiniteNumber(index);\n                return map.get(this).GetCollisionPolyPoint(index)[0]\n            }\n            getPolyPointY(index) {\n                C3X.RequireFiniteNumber(index);\n                return map.get(this).GetCollisionPolyPoint(index)[1]\n            }\n            getPolyPoint(index) {\n                C3X.RequireFiniteNumber(index);\n                return map.get(this).GetCollisionPolyPoint(index)\n            }\n            stopAnimation() {\n                map.get(this).SetAnimationPlaying(false)\n            }\n            startAnimation(from="current-frame") {\n                C3X.RequireString(from);\n                const f = ANIM_FROM_MODES.get(from);\n                if (typeof f === "undefined")\n                    throw new Error("invalid mode");\n                map.get(this)._StartAnim(f)\n            }\n            setAnimation(name, from="beginning") {\n                C3X.RequireString(name);\n                C3X.RequireString(from);\n                const f = ANIM_FROM_MODES.get(from);\n                if (typeof f === "undefined")\n                    throw new Error("invalid mode");\n                const inst = map.get(this);\n                if (!inst.GetObjectClass().GetAnimationByName(name))\n                    throw new Error(`animation name "${name}" does not exist`);\n                inst._SetAnim(name, f)\n            }\n            getAnimation(name) {\n                C3X.RequireString(name);\n                const a = map.get(this).GetObjectClass().GetAnimationByName(name);\n                return a ? a.GetIAnimation() : null\n            }\n            get animation() {\n                return map.get(this)._GetCurrentAnimation().GetIAnimation()\n            }\n            get animationName() {\n                return map.get(this)._GetCurrentAnimationName()\n            }\n            set animationFrame(frameIndex) {\n                C3X.RequireFiniteNumber(frameIndex);\n                map.get(this)._SetAnimFrame(frameIndex)\n            }\n            get animationFrame() {\n                return map.get(this)._GetAnimFrame()\n            }\n            set animationSpeed(s) {\n                C3X.RequireFiniteNumber(s);\n                map.get(this)._SetAnimSpeed(s)\n            }\n            get animationSpeed() {\n                return map.get(this)._GetAnimSpeed()\n            }\n            set animationRepeatToFrame(f) {\n                C3X.RequireFiniteNumber(f);\n                map.get(this)._SetAnimRepeatToFrame(f)\n            }\n            get animationRepeatToFrame() {\n                return map.get(this)._GetAnimRepeatToFrame()\n            }\n            get imageWidth() {\n                return map.get(this).GetCurrentImageInfo().GetWidth()\n            }\n            get imageHeight() {\n                return map.get(this).GetCurrentImageInfo().GetHeight()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Sprite.Cnds = {\n            IsAnimPlaying(animName) {\n                return C3.equalsNoCase(this._GetCurrentAnimationName(), animName)\n            },\n            CompareFrame(cmp, frameNum) {\n                return C3.compare(this._currentFrameIndex, cmp, frameNum)\n            },\n            CompareAnimSpeed(cmp, x) {\n                return C3.compare(this._GetAnimSpeed(), cmp, x)\n            },\n            OnAnimFinished(animName) {\n                return C3.equalsNoCase(this._animTriggerName, animName)\n            },\n            OnAnyAnimFinished() {\n                return true\n            },\n            OnFrameChanged() {\n                return true\n            },\n            IsMirrored() {\n                return this.GetWorldInfo().GetWidth() < 0\n            },\n            IsFlipped() {\n                return this.GetWorldInfo().GetHeight() < 0\n            },\n            OnURLLoaded() {\n                return true\n            },\n            OnURLFailed() {\n                return true\n            },\n            IsCollisionEnabled() {\n                return this.GetWorldInfo().IsCollisionEnabled()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Sprite.Acts = {\n            Spawn(objectClass, layer, imgPt, createHierarchy) {\n                if (!objectClass || !layer)\n                    return;\n                const [imgPtX,imgPtY] = this.GetImagePoint(imgPt);\n                const inst = this._runtime.CreateInstance(objectClass, layer, imgPtX, imgPtY, createHierarchy);\n                if (!inst)\n                    return;\n                if (createHierarchy)\n                    layer.SortAndAddInstancesByZIndex(inst);\n                if (objectClass.GetPlugin().IsRotatable()) {\n                    const instWi = inst.GetWorldInfo();\n                    instWi.SetAngle(this.GetWorldInfo().GetAngle());\n                    instWi.SetBboxChanged()\n                }\n                const eventSheetManager = this._runtime.GetEventSheetManager();\n                eventSheetManager.BlockFlushingInstances(true);\n                inst._TriggerOnCreatedOnSelfAndRelated();\n                eventSheetManager.BlockFlushingInstances(false);\n                if (objectClass !== this.GetObjectClass())\n                    this._sdkType._SpawnPickInstance(objectClass, inst, createHierarchy)\n            },\n            StopAnim() {\n                this.SetAnimationPlaying(false)\n            },\n            StartAnim(from) {\n                this._StartAnim(from)\n            },\n            SetAnim(animName, from) {\n                this._SetAnim(animName, from)\n            },\n            SetAnimFrame(frameNum) {\n                this._SetAnimFrame(frameNum)\n            },\n            SetAnimSpeed(s) {\n                this._SetAnimSpeed(s)\n            },\n            SetAnimRepeatToFrame(f) {\n                this._SetAnimRepeatToFrame(f)\n            },\n            SetMirrored(m) {\n                const wi = this.GetWorldInfo();\n                const oldW = wi.GetWidth();\n                const newW = Math.abs(oldW) * (m === 0 ? -1 : 1);\n                if (oldW === newW)\n                    return;\n                wi.SetWidth(newW);\n                wi.SetBboxChanged()\n            },\n            SetFlipped(f) {\n                const wi = this.GetWorldInfo();\n                const oldH = wi.GetHeight();\n                const newH = Math.abs(oldH) * (f === 0 ? -1 : 1);\n                if (oldH === newH)\n                    return;\n                wi.SetHeight(newH);\n                wi.SetBboxChanged()\n            },\n            SetScale(s) {\n                const frame = this._currentAnimationFrame;\n                const imageInfo = frame.GetImageInfo();\n                const wi = this.GetWorldInfo();\n                const mirrorFactor = wi.GetWidth() < 0 ? -1 : 1;\n                const flipFactor = wi.GetHeight() < 0 ? -1 : 1;\n                const newWidth = imageInfo.GetWidth() * s * mirrorFactor;\n                const newHeight = imageInfo.GetHeight() * s * flipFactor;\n                if (wi.GetWidth() !== newWidth || wi.GetHeight() !== newHeight) {\n                    wi.SetSize(newWidth, newHeight);\n                    wi.SetBboxChanged()\n                }\n            },\n            async LoadURL(url, resize, crossOrigin) {\n                const curAnimFrame = this._currentAnimationFrame;\n                const curImageInfo = curAnimFrame.GetImageInfo();\n                const wi = this.GetWorldInfo();\n                const runtime = this._runtime;\n                if (curImageInfo.GetURL() === url) {\n                    if (resize === 0) {\n                        wi.SetSize(curImageInfo.GetWidth(), curImageInfo.GetHeight());\n                        wi.SetBboxChanged()\n                    }\n                    this.Trigger(C3.Plugins.Sprite.Cnds.OnURLLoaded);\n                    return\n                }\n                const imageInfo = C3.New(C3.ImageInfo);\n                try {\n                    await imageInfo.LoadDynamicAsset(runtime, url);\n                    if (!imageInfo.IsLoaded())\n                        throw new Error("image failed to load");\n                    await imageInfo.LoadStaticTexture(runtime.GetRenderer(), {\n                        sampling: this._runtime.GetSampling()\n                    })\n                } catch (err) {\n                    console.error("Load image from URL failed: ", err);\n                    this.Trigger(C3.Plugins.Sprite.Cnds.OnURLFailed);\n                    return\n                }\n                curImageInfo.ReplaceWith(imageInfo);\n                this._sdkType._UpdateAllCurrentTexture();\n                if (!this.WasReleased() && resize === 0) {\n                    wi.SetSize(curImageInfo.GetWidth(), curImageInfo.GetHeight());\n                    wi.SetBboxChanged()\n                }\n                runtime.UpdateRender();\n                if (!this.WasReleased())\n                    await this.TriggerAsync(C3.Plugins.Sprite.Cnds.OnURLLoaded)\n            },\n            SetCollisions(e) {\n                this.GetWorldInfo().SetCollisionEnabled(e)\n            },\n            SetSolidCollisionFilter(mode, tags) {\n                this.GetWorldInfo().SetSolidCollisionFilter(mode === 0, tags)\n            },\n            SetEffect(effect) {\n                this.GetWorldInfo().SetBlendMode(effect);\n                this._runtime.UpdateRender()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Sprite.Exps = {\n            AnimationFrame() {\n                return this._currentFrameIndex\n            },\n            AnimationFrameCount() {\n                return this._currentAnimation.GetFrameCount()\n            },\n            AnimationName() {\n                return this._currentAnimation.GetName()\n            },\n            AnimationSpeed() {\n                return this._GetAnimSpeed()\n            },\n            OriginalAnimationSpeed() {\n                return this._currentAnimation.GetSpeed()\n            },\n            ImagePointX(imgpt) {\n                return this.GetImagePoint(imgpt)[0]\n            },\n            ImagePointY(imgpt) {\n                return this.GetImagePoint(imgpt)[1]\n            },\n            ImagePointCount() {\n                return this.GetImagePointCount()\n            },\n            ImageWidth() {\n                return this.GetCurrentImageInfo().GetWidth()\n            },\n            ImageHeight() {\n                return this.GetCurrentImageInfo().GetHeight()\n            },\n            PolyPointXAt(i) {\n                return this.GetCollisionPolyPoint(i)[0]\n            },\n            PolyPointYAt(i) {\n                return this.GetCollisionPolyPoint(i)[1]\n            },\n            PolyPointCount() {\n                return this.GetCollisionPolyPointCount()\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Plugins.Dictionary = class DictionaryPlugin extends C3.SDKPluginBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Dictionary.Type = class DictionaryType extends C3.SDKTypeBase {\n            constructor(objectClass) {\n                super(objectClass)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        const IInstance = self.IInstance;\n        C3.Plugins.Dictionary.Instance = class DictionaryInstance extends C3.SDKInstanceBase {\n            constructor(inst, properties) {\n                super(inst);\n                this._data = new Map;\n                this._curKey = ""\n            }\n            Release() {\n                this._data.clear();\n                super.Release()\n            }\n            GetAsJsonString() {\n                return JSON.stringify({\n                    "c2dictionary": true,\n                    "data": C3.MapToObject(this._data)\n                })\n            }\n            GetDataMap() {\n                return this._data\n            }\n            SaveToJson() {\n                return C3.MapToObject(this._data)\n            }\n            LoadFromJson(o) {\n                C3.ObjectToMap(o, this._data)\n            }\n            GetDebuggerProperties() {\n                const prefix = "plugins.dictionary";\n                return [{\n                    title: prefix + ".name",\n                    properties: [{\n                        name: prefix + ".debugger.key-count",\n                        value: this._data.size\n                    }, ...[...this._data].map(entry => ({\n                        name: "$" + entry[0],\n                        value: entry[1],\n                        onedit: v => this._data.set(entry[0], v)\n                    }))]\n                }]\n            }\n            GetScriptInterfaceClass() {\n                return self.IDictionaryInstance\n            }\n        }\n        ;\n        const map = new WeakMap;\n        self.IDictionaryInstance = class IDictionaryInstance extends IInstance {\n            constructor() {\n                super();\n                map.set(this, IInstance._GetInitInst().GetSdkInstance())\n            }\n            getDataMap() {\n                return map.get(this).GetDataMap()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Dictionary.Cnds = {\n            CompareValue(key, cmp, val) {\n                const x = this._data.get(key);\n                if (typeof x === "undefined")\n                    return false;\n                return C3.compare(x, cmp, val)\n            },\n            ForEachKey() {\n                const runtime = this._runtime;\n                const eventSheetManager = runtime.GetEventSheetManager();\n                const currentEvent = runtime.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiers();\n                const eventStack = runtime.GetEventStack();\n                const oldFrame = eventStack.GetCurrentStackFrame();\n                const newFrame = eventStack.Push(currentEvent);\n                runtime.SetDebuggingEnabled(false);\n                for (const key of this._data.keys()) {\n                    this._curKey = key;\n                    eventSheetManager.PushCopySol(solModifiers);\n                    currentEvent.Retrigger(oldFrame, newFrame);\n                    eventSheetManager.PopSol(solModifiers)\n                }\n                runtime.SetDebuggingEnabled(true);\n                this._curKey = "";\n                eventStack.Pop();\n                return false\n            },\n            CompareCurrentValue(cmp, val) {\n                const x = this._data.get(this._curKey);\n                if (typeof x === "undefined")\n                    return false;\n                return C3.compare(x, cmp, val)\n            },\n            HasKey(key) {\n                return this._data.has(key)\n            },\n            IsEmpty() {\n                return this._data.size === 0\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Dictionary.Acts = {\n            AddKey(key, value) {\n                this._data.set(key, value)\n            },\n            SetKey(key, value) {\n                if (this._data.has(key))\n                    this._data.set(key, value)\n            },\n            DeleteKey(key) {\n                this._data.delete(key)\n            },\n            Clear() {\n                this._data.clear()\n            },\n            JSONLoad(json) {\n                let o = null;\n                try {\n                    o = JSON.parse(json)\n                } catch (err) {\n                    console.error("[Construct] Error parsing JSON: ", err);\n                    return\n                }\n                if (!o["c2dictionary"])\n                    return;\n                C3.ObjectToMap(o["data"], this._data)\n            },\n            JSONDownload(filename) {\n                const url = URL.createObjectURL(new Blob([this.GetAsJsonString()],{\n                    type: "application\/json"\n                }));\n                this._runtime.InvokeDownload(url, filename)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Dictionary.Exps = {\n            Get(key) {\n                const ret = this._data.get(key);\n                if (typeof ret === "undefined")\n                    return 0;\n                else\n                    return ret\n            },\n            GetDefault(key, defaultValue) {\n                const ret = this._data.get(key);\n                if (typeof ret === "undefined")\n                    return defaultValue;\n                else\n                    return ret\n            },\n            KeyCount() {\n                return this._data.size\n            },\n            CurrentKey() {\n                return this._curKey\n            },\n            CurrentValue() {\n                return this._data.get(this._curKey) || 0\n            },\n            AsJSON() {\n                return this.GetAsJsonString()\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Plugins.Particles = class ParticlesPlugin extends C3.SDKPluginBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Particles.Type = class ParticlesType extends C3.SDKTypeBase {\n            constructor(objectClass) {\n                super(objectClass)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {\n                this.GetImageInfo().LoadAsset(this._runtime)\n            }\n            LoadTextures(renderer) {\n                return this.GetImageInfo().LoadStaticTexture(renderer, {\n                    sampling: this._runtime.GetSampling()\n                })\n            }\n            ReleaseTextures() {\n                this.GetImageInfo().ReleaseTexture()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const RATE = 0;\n        const SPRAY_CONE = 1;\n        const TYPE = 2;\n        const SPAWNOBJECTCLASS = 3;\n        const SPEED = 4;\n        const SIZE = 5;\n        const OPACITY = 6;\n        const GROW_RATE = 7;\n        const X_RANDOMISER = 8;\n        const Y_RANDOMISER = 9;\n        const INITIAL_SPEED_RANDOMISER = 10;\n        const SIZE_RANDOMISER = 11;\n        const GROW_RATE_RANDOMISER = 12;\n        const ACCELERATION = 13;\n        const GRAVITY = 14;\n        const ANGLE_RANDOMISER = 15;\n        const LIFE_SPEED_RANDOMISER = 16;\n        const OPACITY_RANDOMISER = 17;\n        const DESTROY_MODE = 18;\n        const TIMEOUT = 19;\n        const CONTINUOUS = 0;\n        const ONE_SHOT = 1;\n        const tempRect = C3.New(C3.Rect);\n        C3.Plugins.Particles.Instance = class ParticlesInstance extends C3.SDKWorldInstanceBase {\n            constructor(inst, properties) {\n                super(inst);\n                this._isFirstTick = true;\n                const pe = C3.New(self.ParticleEngine);\n                this._particleEngine = pe;\n                pe.ononeshotfinish = () => this._OnOneShotFinish();\n                this._spawnObjectClass = null;\n                this._particleUpdateCallback = (inst, dx, dy, dSize, dAngle, dOpacity) => this._OnParticleUpdate(inst, dx, dy, dSize, dAngle, dOpacity);\n                this._particleDestroyCallback = inst => this._OnParticleDestroy(inst);\n                this._hasAnyDefaultParticle = true;\n                if (properties) {\n                    pe.SetRate(properties[RATE]);\n                    pe.SetSprayCone(C3.toRadians(properties[SPRAY_CONE]));\n                    pe.SetSprayType(properties[TYPE] ? "one-shot" : "continuous-spray");\n                    this._SetParticleObjectClass(this._runtime.GetObjectClassBySID(properties[SPAWNOBJECTCLASS]));\n                    pe.SetInitSpeed(properties[SPEED]);\n                    pe.SetInitSize(properties[SIZE]);\n                    pe.SetInitOpacity(properties[OPACITY] \/ 100);\n                    pe.SetGrowRate(properties[GROW_RATE]);\n                    pe.SetInitXRandom(properties[X_RANDOMISER]);\n                    pe.SetInitYRandom(properties[Y_RANDOMISER]);\n                    pe.SetInitSpeedRandom(properties[INITIAL_SPEED_RANDOMISER]);\n                    pe.SetInitSizeRandom(properties[SIZE_RANDOMISER]);\n                    pe.SetGrowRandom(properties[GROW_RATE_RANDOMISER]);\n                    pe.SetAcceleration(properties[ACCELERATION]);\n                    pe.SetGravity(properties[GRAVITY]);\n                    pe.SetLifeAngleRandom(properties[ANGLE_RANDOMISER]);\n                    pe.SetLifeSpeedRandom(properties[LIFE_SPEED_RANDOMISER]);\n                    pe.SetLifeOpacityRandom(properties[OPACITY_RANDOMISER]);\n                    pe.SetDestroyModeIndex(properties[DESTROY_MODE]);\n                    pe.SetTimeout(properties[TIMEOUT])\n                }\n                this._UpdateEngineParameters();\n                if (this._spawnObjectClass)\n                    this._hasAnyDefaultParticle = false;\n                if (pe.GetSprayType() === "one-shot")\n                    pe.CreateOneShotSpray();\n                else\n                    pe.SetSpraying(true);\n                const wi = this.GetWorldInfo();\n                wi.SetBboxChangeEventEnabled(true);\n                this._inst.Dispatcher().addEventListener("bboxchange", () => {\n                    wi.OverwriteBoundingBox(this._particleEngine.GetBoundingBox())\n                }\n                );\n                if (this.GetRuntime().GetRenderer().IsWebGPU())\n                    wi.SetUsePointsShaderProgram();\n                this._afterLoad = e => this._OnAfterLoad(e);\n                this.GetRuntime().Dispatcher().addEventListener("afterload", this._afterLoad);\n                this._StartTicking()\n            }\n            Release() {\n                this.GetRuntime().Dispatcher().removeEventListener("afterload", this._afterLoad);\n                this._afterLoad = null;\n                this._particleEngine.Release();\n                this._particleEngine = null;\n                this._particleUpdateCallback = null;\n                this._particleDestroyCallback = null;\n                super.Release()\n            }\n            _SetParticleObjectClass(objectClass) {\n                if (objectClass === this.GetObjectClass())\n                    objectClass = null;\n                this._spawnObjectClass = objectClass;\n                this._particleEngine.onparticlecreate = objectClass ? p => this._OnParticleCreate(p) : null;\n                if (!this._spawnObjectClass)\n                    this._hasAnyDefaultParticle = true\n            }\n            _UpdateEngineParameters() {\n                const pe = this._particleEngine;\n                const wi = this.GetWorldInfo();\n                pe.SetMasterOpacity(wi.GetOpacity());\n                pe.SetPixelRounding(this._runtime.IsPixelRoundingEnabled());\n                pe.SetSpawnX(wi.GetX());\n                pe.SetSpawnY(wi.GetY());\n                pe.SetSpawnAngle(wi.GetAngle());\n                pe.SetInitSizeScale(wi.GetSceneGraphScale())\n            }\n            _OnOneShotFinish() {\n                this._runtime.DestroyInstance(this._inst)\n            }\n            Draw(renderer) {\n                if (!this._hasAnyDefaultParticle)\n                    return;\n                const imageInfo = this._objectClass.GetImageInfo();\n                const texture = imageInfo.GetTexture();\n                if (!texture)\n                    return;\n                const wi = this.GetWorldInfo();\n                const layer = wi.GetLayer();\n                const viewport = tempRect;\n                if (this._runtime.GetCanvasManager().IsPastingToDrawingCanvas())\n                    viewport.set(-Infinity, -Infinity, Infinity, Infinity);\n                else if (layer.Has3DCamera())\n                    layer.CalculateViewport3D(wi.GetTotalZElevation(), viewport);\n                else\n                    layer.GetViewportForZ(wi.GetTotalZElevation(), viewport);\n                renderer.SetTexture(texture);\n                const zScaleFactor = layer.Get2DScaleFactorToZ(wi.GetTotalZElevation());\n                this._particleEngine.SetParticleScale(layer.GetRenderScale() * zScaleFactor);\n                this._particleEngine.Draw(renderer, imageInfo.GetTexRect(), viewport, layer.Has3DCamera())\n            }\n            SaveToJson() {\n                const pe = this._particleEngine;\n                return {\n                    "r": pe.GetRate(),\n                    "sc": pe.GetSprayCone(),\n                    "st": pe.GetSprayType(),\n                    "isp": pe.GetInitSpeed(),\n                    "isz": pe.GetInitSize(),\n                    "io": pe.GetInitOpacity(),\n                    "gr": pe.GetGrowRate(),\n                    "xr": pe.GetInitXRandom(),\n                    "yr": pe.GetInitYRandom(),\n                    "spr": pe.GetInitSpeedRandom(),\n                    "szr": pe.GetInitSizeRandom(),\n                    "grnd": pe.GetGrowRandom(),\n                    "acc": pe.GetAcceleration(),\n                    "g": pe.GetGravity(),\n                    "lar": pe.GetLifeAngleRandom(),\n                    "lsr": pe.GetLifeSpeedRandom(),\n                    "lor": pe.GetLifeOpacityRandom(),\n                    "dm": pe.GetDestroyModeIndex(),\n                    "to": pe.GetTimeout(),\n                    "s": pe.IsSpraying(),\n                    "pcc": pe._GetCreateCounter(),\n                    "ft": this._isFirstTick,\n                    "p": pe.GetParticles().map(p => p.toJSON())\n                }\n            }\n            LoadFromJson(o) {\n                const pe = this._particleEngine;\n                pe.SetRate(o["r"]);\n                pe.SetSprayCone(o["sc"]);\n                pe.SetSprayType(o["st"]);\n                pe.SetInitSpeed(o["isp"]);\n                pe.SetInitSize(o["isz"]);\n                pe.SetInitOpacity(o["io"]);\n                pe.SetGrowRate(o["gr"]);\n                pe.SetInitXRandom(o["xr"]);\n                pe.SetInitYRandom(o["yr"]);\n                pe.SetInitSpeedRandom(o["spr"]);\n                pe.SetInitSizeRandom(o["szr"]);\n                pe.SetGrowRandom(o["grnd"]);\n                pe.SetAcceleration(o["acc"]);\n                pe.SetGravity(o["g"]);\n                pe.SetLifeAngleRandom(o["lar"]);\n                pe.SetLifeSpeedRandom(o["lsr"]);\n                pe.SetLifeOpacityRandom(o["lor"]);\n                pe.SetDestroyModeIndex(o["dm"]);\n                pe.SetTimeout(o["to"]);\n                pe.SetSpraying(o["s"]);\n                pe._SetCreateCounter(o["pcc"]);\n                this._isFirstTick = o["ft"];\n                const particlesData = o["p"];\n                pe.SetParticleCount(particlesData.length);\n                const particles = pe.GetParticles();\n                for (let i = 0, len = particles.length; i < len; ++i)\n                    particles[i].setFromJSON(particlesData[i])\n            }\n            _OnAfterLoad() {\n                const pe = this._particleEngine;\n                pe.UpdateAllParticlesUserData();\n                pe.ApplyParticleDataToUserData(this);\n                if (pe.GetSprayType() !== "one-shot")\n                    return;\n                const particles = pe.GetParticles();\n                for (let i = 0, len = particles.length; i < len; ++i) {\n                    const particle = particles[i];\n                    const currentUserData = particle.GetUserData();\n                    if (!currentUserData)\n                        continue;\n                    const worldInfo = currentUserData.GetWorldInfo();\n                    if (!worldInfo)\n                        continue;\n                    const instance = worldInfo.GetInstance();\n                    if (!instance)\n                        continue;\n                    const savedUid = particle.GetUserDataUID();\n                    const currentUid = instance.GetUID();\n                    if (typeof savedUid === "number" && typeof currentUid === "number" && savedUid === currentUid)\n                        continue;\n                    const runtime = this.GetRuntime();\n                    const inst = runtime.GetInstanceByUID(savedUid);\n                    if (inst)\n                        runtime.DestroyInstance(inst)\n                }\n            }\n            Tick() {\n                const dt = this._runtime.GetDt(this._inst);\n                this._UpdateEngineParameters();\n                if (this._isFirstTick && this._particleEngine.GetSprayType() === "one-shot")\n                    this._particleEngine.ReInitAllParticles();\n                this._particleEngine.Tick(dt);\n                if (this._particleEngine.IsSpraying())\n                    this._runtime.UpdateRender();\n                this.GetWorldInfo().SetBboxChanged();\n                this._isFirstTick = false\n            }\n            _OnParticleCreate(p) {\n                const inst = this._runtime.CreateInstance(this._spawnObjectClass, this.GetWorldInfo().GetLayer(), p.GetX(), p.GetY());\n                const wi = inst.GetWorldInfo();\n                wi.SetSize(p.GetSize(), p.GetSize());\n                wi.SetAngle(p.GetAngle());\n                wi.SetOpacity(p.GetOpacity());\n                wi.SetUnpremultipliedColor(this.GetWorldInfo().GetUnpremultipliedColor());\n                wi.SetBboxChanged();\n                wi.ZOrderMoveAdjacentToInstance(this.GetInstance(), true);\n                inst._TriggerOnCreated();\n                p.SetUpdateCallback(this._particleUpdateCallback);\n                p.SetDestroyCallback(this._particleDestroyCallback);\n                return inst\n            }\n            _OnParticleUpdate(inst, dx, dy, dSize, dAngle, dOpacity) {\n                if (inst.IsDestroyed())\n                    return;\n                const wi = inst.GetWorldInfo();\n                wi.OffsetXY(dx, dy);\n                wi.SetSize(wi.GetWidth() + dSize, wi.GetHeight() + dSize);\n                wi.SetAngle(wi.GetAngle() + dAngle);\n                wi.SetOpacity(wi.GetOpacity() + dOpacity);\n                wi.SetBboxChanged()\n            }\n            _OnParticleDestroy(inst) {\n                if (inst.IsDestroyed())\n                    return;\n                this._runtime.DestroyInstance(inst)\n            }\n            GetPropertyValueByIndex(index) {\n                const pe = this._particleEngine;\n                switch (index) {\n                case RATE:\n                    return pe.GetRate();\n                case SPRAY_CONE:\n                    return C3.toDegrees(pe.GetSprayCone());\n                case TYPE:\n                    return pe.GetSprayType() === "one-shot" ? ONE_SHOT : CONTINUOUS;\n                case SPEED:\n                    return pe.GetInitSpeed();\n                case SIZE:\n                    return pe.GetInitSize();\n                case OPACITY:\n                    return pe.GetInitOpacity() * 100;\n                case GROW_RATE:\n                    return pe.GetGrowRate();\n                case X_RANDOMISER:\n                    return pe.GetInitXRandom();\n                case Y_RANDOMISER:\n                    return pe.GetInitYRandom();\n                case INITIAL_SPEED_RANDOMISER:\n                    return pe.GetInitSpeedRandom();\n                case SIZE_RANDOMISER:\n                    return pe.GetInitSizeRandom();\n                case GROW_RATE_RANDOMISER:\n                    return pe.GetGrowRandom();\n                case ACCELERATION:\n                    return pe.GetAcceleration();\n                case GRAVITY:\n                    return pe.GetGravity();\n                case ANGLE_RANDOMISER:\n                    return pe.GetLifeAngleRandom();\n                case LIFE_SPEED_RANDOMISER:\n                    return pe.GetLifeSpeedRandom();\n                case OPACITY_RANDOMISER:\n                    return pe.GetLifeOpacityRandom();\n                case DESTROY_MODE:\n                    return pe.GetDestroyModeIndex();\n                case TIMEOUT:\n                    return pe.GetTimeout()\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                const pe = this._particleEngine;\n                switch (index) {\n                case RATE:\n                    pe.SetRate(value);\n                    break;\n                case SPRAY_CONE:\n                    pe.SetSprayCone(C3.toRadians(value));\n                    break;\n                case TYPE:\n                    pe.SetSprayType(value ? "one-shot" : "continuous-spray");\n                    break;\n                case SPEED:\n                    pe.SetInitSpeed(value);\n                    break;\n                case SIZE:\n                    pe.SetInitSize(value);\n                    break;\n                case OPACITY:\n                    pe.SetInitOpacity(value \/ 100);\n                    break;\n                case GROW_RATE:\n                    pe.SetGrowRate(value);\n                    break;\n                case X_RANDOMISER:\n                    pe.SetInitXRandom(value);\n                    break;\n                case Y_RANDOMISER:\n                    pe.SetInitYRandom(value);\n                    break;\n                case INITIAL_SPEED_RANDOMISER:\n                    pe.SetInitSpeedRandom(value);\n                    break;\n                case SIZE_RANDOMISER:\n                    pe.SetInitSizeRandom(value);\n                    break;\n                case GROW_RATE_RANDOMISER:\n                    pe.SetGrowRandom(value);\n                    break;\n                case ACCELERATION:\n                    pe.SetAcceleration(value);\n                    break;\n                case GRAVITY:\n                    pe.SetGravity(value);\n                    break;\n                case ANGLE_RANDOMISER:\n                    pe.SetLifeAngleRandom(value);\n                    break;\n                case LIFE_SPEED_RANDOMISER:\n                    pe.SetLifeSpeedRandom(value);\n                    break;\n                case OPACITY_RANDOMISER:\n                    pe.SetLifeOpacityRandom(value);\n                    break;\n                case DESTROY_MODE:\n                    pe.SetDestroyModeIndex(value);\n                    break;\n                case TIMEOUT:\n                    pe.SetTimeout(value);\n                    break\n                }\n            }\n            GetDebuggerProperties() {\n                const prefix = "plugins.particles";\n                const propPrefix = prefix + ".properties";\n                const dbgPrefix = prefix + ".debugger";\n                const pe = this._particleEngine;\n                return [{\n                    title: prefix + ".name",\n                    properties: [{\n                        name: dbgPrefix + ".particle-count",\n                        value: pe.GetParticleCount()\n                    }, {\n                        name: propPrefix + ".type.name",\n                        value: [propPrefix + ".type.items." + pe.GetSprayType()]\n                    }, {\n                        name: dbgPrefix + ".is-spraying",\n                        value: pe.IsSpraying(),\n                        onedit: v => pe.SetSpraying(v)\n                    }, {\n                        name: propPrefix + ".rate.name",\n                        value: pe.GetRate(),\n                        onedit: v => pe.SetRate(v)\n                    }, {\n                        name: propPrefix + ".spray-cone.name",\n                        value: C3.toDegrees(pe.GetSprayCone()),\n                        onedit: v => pe.SetSprayCone(C3.toRadians(v))\n                    }, {\n                        name: propPrefix + ".speed.name",\n                        value: pe.GetInitSpeed(),\n                        onedit: v => pe.SetInitSpeed(v)\n                    }, {\n                        name: propPrefix + ".size.name",\n                        value: pe.GetInitSize(),\n                        onedit: v => pe.SetInitSize(v)\n                    }, {\n                        name: propPrefix + ".opacity.name",\n                        value: pe.GetInitOpacity(),\n                        onedit: v => pe.SetInitOpacity(v)\n                    }, {\n                        name: propPrefix + ".grow-rate.name",\n                        value: pe.GetGrowRate(),\n                        onedit: v => pe.SetGrowRate(v)\n                    }, {\n                        name: propPrefix + ".x-randomiser.name",\n                        value: pe.GetInitXRandom(),\n                        onedit: v => pe.SetInitXRandom(v)\n                    }, {\n                        name: propPrefix + ".y-randomiser.name",\n                        value: pe.GetInitYRandom(),\n                        onedit: v => pe.SetInitYRandom(v)\n                    }, {\n                        name: propPrefix + ".initial-speed-randomiser.name",\n                        value: pe.GetInitSpeedRandom(),\n                        onedit: v => pe.SetInitSpeedRandom(v)\n                    }, {\n                        name: propPrefix + ".size-randomiser.name",\n                        value: pe.GetInitSizeRandom(),\n                        onedit: v => pe.SetInitSizeRandom(v)\n                    }, {\n                        name: propPrefix + ".grow-rate-randomiser.name",\n                        value: pe.GetGrowRandom(),\n                        onedit: v => pe.SetGrowRandom(v)\n                    }, {\n                        name: propPrefix + ".acceleration.name",\n                        value: pe.GetAcceleration(),\n                        onedit: v => pe.SetAcceleration(v)\n                    }, {\n                        name: propPrefix + ".gravity.name",\n                        value: pe.GetGravity(),\n                        onedit: v => pe.SetGravity(v)\n                    }, {\n                        name: propPrefix + ".angle-randomiser.name",\n                        value: pe.GetLifeAngleRandom(),\n                        onedit: v => pe.SetLifeAngleRandom(v)\n                    }, {\n                        name: propPrefix + ".life-speed-randomiser.name",\n                        value: pe.GetLifeSpeedRandom(),\n                        onedit: v => pe.SetLifeSpeedRandom(v)\n                    }, {\n                        name: propPrefix + ".opacity-randomiser.name",\n                        value: pe.GetLifeOpacityRandom(),\n                        onedit: v => pe.SetLifeOpacityRandom(v)\n                    }, {\n                        name: propPrefix + ".timeout.name",\n                        value: pe.GetTimeout(),\n                        onedit: v => pe.SetTimeout(v)\n                    }]\n                }]\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Particles.Cnds = {\n            IsSpraying() {\n                return this._particleEngine.IsSpraying()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Particles.Acts = {\n            SetSpraying(s) {\n                this._particleEngine.SetSpraying(s !== 0)\n            },\n            SetRate(r) {\n                this._particleEngine.SetRate(r);\n                if (this._particleEngine.GetSprayType() === "one-shot" && this._isFirstTick)\n                    this._particleEngine.SetParticleCount(r)\n            },\n            SetParticleObject(objectClass) {\n                this._SetParticleObjectClass(objectClass)\n            },\n            UnsetParticleObject() {\n                this._SetParticleObjectClass(null)\n            },\n            SetSprayCone(c) {\n                this._particleEngine.SetSprayCone(C3.toRadians(c))\n            },\n            SetInitSpeed(x) {\n                this._particleEngine.SetInitSpeed(x)\n            },\n            SetInitSize(x) {\n                this._particleEngine.SetInitSize(x)\n            },\n            SetInitOpacity(x) {\n                this._particleEngine.SetInitOpacity(x \/ 100)\n            },\n            SetGrowRate(x) {\n                this._particleEngine.SetGrowRate(x)\n            },\n            SetXRandomiser(x) {\n                this._particleEngine.SetInitXRandom(x)\n            },\n            SetYRandomiser(x) {\n                this._particleEngine.SetInitYRandom(x)\n            },\n            SetSpeedRandomiser(x) {\n                this._particleEngine.SetInitSpeedRandom(x)\n            },\n            SetSizeRandomiser(x) {\n                this._particleEngine.SetInitSizeRandom(x)\n            },\n            SetGrowRateRandomiser(x) {\n                this._particleEngine.SetGrowRandom(x)\n            },\n            SetParticleAcc(x) {\n                this._particleEngine.SetAcceleration(x)\n            },\n            SetGravity(x) {\n                this._particleEngine.SetGravity(x)\n            },\n            SetAngleRandomiser(x) {\n                this._particleEngine.SetLifeAngleRandom(x)\n            },\n            SetLifeSpeedRandomiser(x) {\n                this._particleEngine.SetLifeSpeedRandom(x)\n            },\n            SetOpacityRandomiser(x) {\n                this._particleEngine.SetLifeOpacityRandom(x)\n            },\n            SetTimeout(x) {\n                this._particleEngine.SetTimeout(x)\n            },\n            SetEffect(effect) {\n                this.GetWorldInfo().SetBlendMode(effect);\n                this._runtime.UpdateRender()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Particles.Exps = {\n            ParticleCount() {\n                return this._particleEngine.GetParticleCount()\n            },\n            Rate() {\n                return this._particleEngine.GetRate()\n            },\n            SprayCone() {\n                return C3.toDegrees(this._particleEngine.GetSprayCone())\n            },\n            InitSpeed() {\n                return this._particleEngine.GetInitSpeed()\n            },\n            InitSize() {\n                return this._particleEngine.GetInitSize()\n            },\n            InitOpacity() {\n                return this._particleEngine.GetInitOpacity() * 100\n            },\n            InitGrowRate() {\n                return this._particleEngine.GetGrowRate()\n            },\n            XRandom() {\n                return this._particleEngine.GetInitXRandom()\n            },\n            YRandom() {\n                return this._particleEngine.GetInitYRandom()\n            },\n            InitSizeRandom() {\n                return this._particleEngine.GetInitSizeRandom()\n            },\n            InitSpeedRandom() {\n                return this._particleEngine.GetInitSpeedRandom()\n            },\n            InitGrowRandom() {\n                return this._particleEngine.GetGrowRandom()\n            },\n            ParticleAcceleration() {\n                return this._particleEngine.GetAcceleration()\n            },\n            Gravity() {\n                return this._particleEngine.GetGravity()\n            },\n            ParticleAngleRandom() {\n                return this._particleEngine.GetLifeAngleRandom()\n            },\n            ParticleSpeedRandom() {\n                return this._particleEngine.GetLifeSpeedRandom()\n            },\n            ParticleOpacityRandom() {\n                return this._particleEngine.GetLifeOpacityRandom()\n            },\n            Timeout() {\n                return this._particleEngine.GetTimeout()\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const inactiveParticles = [];\n    const MAX_RECYCLE_PARTICLES = 1E3;\n    const VALID_SPRAY_TYPES = new Set(["continuous-spray", "one-shot"]);\n    const DESTROY_MODES = ["fade-to-invisible", "timeout-expired", "particle-stopped"];\n    self.ParticleEngine = class ParticleEngine {\n        constructor() {\n            this._rate = 0;\n            this._sprayCone = 0;\n            this._sprayType = "continuous-spray";\n            this._isSpraying = false;\n            this._masterOpacity = 0;\n            this._isPixelRounding = false;\n            this._spawnX = 0;\n            this._spawnY = 0;\n            this._spawnAngle = 0;\n            this._initSpeed = 0;\n            this._initSize = 0;\n            this._initSizeScale = 1;\n            this._initOpacity = 0;\n            this._growRate = 0;\n            this._xRandom = 0;\n            this._yRandom = 0;\n            this._initSpeedRandom = 0;\n            this._initSizeRandom = 0;\n            this._growRandom = 0;\n            this._acceleration = 0;\n            this._gravity = 0;\n            this._lifeAngleRandom = 0;\n            this._lifeSpeedRandom = 0;\n            this._lifeOpacityRandom = 0;\n            this._destroyMode = 0;\n            this._timeout = 0;\n            this._createCounter = 0;\n            this._particleScale = 1;\n            this.ononeshotfinish = null;\n            this.onparticlecreate = null;\n            this._particles = [];\n            this._boundingBox = new C3.Rect;\n            this._color = new C3.Color\n        }\n        Release() {\n            this.Cancel();\n            C3.clearArray(this._particles);\n            this._particles = null;\n            this.ononeshotfinish = null;\n            this.onparticlecreate = null;\n            this._boundingBox = null;\n            this._boundingBox = null;\n            this._color = null\n        }\n        Cancel() {\n            const particles = this._particles;\n            for (let i = 0, len = particles.length; i < len; ++i)\n                particles[i].Destroy();\n            C3.appendArray(inactiveParticles, particles);\n            C3.clearArray(particles);\n            if (inactiveParticles.length > MAX_RECYCLE_PARTICLES)\n                C3.truncateArray(inactiveParticles, MAX_RECYCLE_PARTICLES);\n            this._isSpraying = false\n        }\n        CreateOneShotSpray() {\n            for (let i = 0, len = this._rate; i < len; ++i)\n                this._CreateParticle();\n            if (this._particles.length)\n                this._isSpraying = true\n        }\n        _CreateParticle() {\n            let ret = null;\n            if (inactiveParticles.length) {\n                ret = inactiveParticles.pop();\n                ret.SetEngine(this)\n            } else\n                ret = C3.New(self.Particle, this);\n            this._particles.push(ret);\n            ret.Init(this.onparticlecreate);\n            return ret\n        }\n        ReInitAllParticles() {\n            const particles = this._particles;\n            const onparticlecreate = this.onparticlecreate;\n            for (let i = 0, len = particles.length; i < len; ++i)\n                particles[i].Init(onparticlecreate)\n        }\n        UpdateAllParticlesUserData() {\n            const particles = this._particles;\n            const onparticlecreate = this.onparticlecreate;\n            for (let i = 0, len = particles.length; i < len; ++i)\n                particles[i].UpdateUserData(onparticlecreate)\n        }\n        ApplyParticleDataToUserData(inst) {\n            const particles = this._particles;\n            for (let i = 0, len = particles.length; i < len; ++i) {\n                const particle = particles[i];\n                const userData = particle.GetUserData();\n                if (userData) {\n                    const wi = userData.GetWorldInfo();\n                    wi.SetX(particle.GetX());\n                    wi.SetY(particle.GetY());\n                    wi.SetSize(particle.GetSize(), particle.GetSize());\n                    wi.SetOpacity(particle.GetOpacity());\n                    wi.SetAngle(particle.GetAngle());\n                    wi.SetUnpremultipliedColor(inst.GetWorldInfo().GetUnpremultipliedColor());\n                    wi.SetBboxChanged()\n                }\n            }\n        }\n        SetParticleCount(c) {\n            const particles = this._particles;\n            if (c < particles.length) {\n                const diff = particles.length - c;\n                for (let i = 0; i < diff; ++i) {\n                    const p = particles.pop();\n                    p.Destroy();\n                    inactiveParticles.push(p)\n                }\n                if (inactiveParticles.length > MAX_RECYCLE_PARTICLES)\n                    C3.truncateArray(inactiveParticles, MAX_RECYCLE_PARTICLES)\n            } else if (c > particles.length) {\n                const diff = c - particles.length;\n                for (let i = 0; i < diff; ++i)\n                    this._CreateParticle()\n            }\n        }\n        GetParticles() {\n            return this._particles\n        }\n        GetParticleCount() {\n            return this._particles.length\n        }\n        Tick(dt) {\n            this._SpawnContinuous(dt);\n            this._TickParticles(dt);\n            this._MaybeFinishOneShot()\n        }\n        _SpawnContinuous(dt) {\n            if (this._sprayType === "continuous-spray" && this._isSpraying) {\n                this._createCounter += dt * this._rate;\n                const n = Math.floor(this._createCounter);\n                this._createCounter -= n;\n                for (let i = 0; i < n; ++i)\n                    this._CreateParticle()\n            }\n        }\n        _SetCreateCounter(c) {\n            this._createCounter = c\n        }\n        _GetCreateCounter() {\n            return this._createCounter\n        }\n        _TickParticles(dt) {\n            const bbox = this._boundingBox;\n            bbox.set(this._spawnX, this._spawnY, this._spawnX, this._spawnY);\n            const particles = this._particles;\n            let j = 0;\n            for (let i = 0, len = particles.length; i < len; ++i) {\n                const p = particles[i];\n                particles[j] = p;\n                p.Tick(dt);\n                if (p.IsActive()) {\n                    ++j;\n                    bbox.expandToContain(p.GetBoundingBox())\n                } else {\n                    p.Destroy();\n                    inactiveParticles.push(p)\n                }\n            }\n            C3.truncateArray(particles, j);\n            if (inactiveParticles.length > MAX_RECYCLE_PARTICLES)\n                C3.truncateArray(inactiveParticles, MAX_RECYCLE_PARTICLES)\n        }\n        _MaybeFinishOneShot() {\n            if (this._sprayType === "one-shot" && this._particles.length === 0 && this._isSpraying) {\n                if (this.ononeshotfinish)\n                    this.ononeshotfinish();\n                this._isSpraying = false\n            }\n        }\n        Draw(renderer, texRect, viewport, forceQuads) {\n            renderer.StartRenderingPoints(texRect);\n            this._color.copy(renderer.GetColor());\n            const particles = this._particles;\n            for (let i = 0, len = particles.length; i < len; ++i) {\n                const p = particles[i];\n                if (viewport.intersectsRect(p.GetBoundingBox()))\n                    p.Draw(renderer, texRect, forceQuads)\n            }\n            renderer.FinishRenderingPoints()\n        }\n        GetColor() {\n            return this._color\n        }\n        SetRate(r) {\n            this._rate = +r\n        }\n        GetRate() {\n            return this._rate\n        }\n        SetSprayCone(c) {\n            this._sprayCone = +c\n        }\n        GetSprayCone() {\n            return this._sprayCone\n        }\n        SetSprayType(type) {\n            if (!VALID_SPRAY_TYPES.has(type))\n                throw new Error("invalid spray type");\n            this._sprayType = type\n        }\n        GetSprayType() {\n            return this._sprayType\n        }\n        SetSpraying(s) {\n            this._isSpraying = !!s\n        }\n        IsSpraying() {\n            return this._isSpraying\n        }\n        SetMasterOpacity(o) {\n            this._masterOpacity = +o\n        }\n        GetMasterOpacity() {\n            return this._masterOpacity\n        }\n        SetPixelRounding(r) {\n            this._isPixelRounding = !!r\n        }\n        IsPixelRounding() {\n            return this._isPixelRounding\n        }\n        SetSpawnX(x) {\n            this._spawnX = +x\n        }\n        GetSpawnX() {\n            return this._spawnX\n        }\n        SetSpawnY(y) {\n            this._spawnY = +y\n        }\n        GetSpawnY() {\n            return this._spawnY\n        }\n        SetSpawnAngle(a) {\n            this._spawnAngle = +a\n        }\n        GetInitAngle() {\n            return this._spawnAngle\n        }\n        SetInitSpeed(s) {\n            this._initSpeed = +s\n        }\n        GetInitSpeed() {\n            return this._initSpeed\n        }\n        SetInitSize(s) {\n            this._initSize = +s\n        }\n        GetInitSize() {\n            return this._initSize\n        }\n        SetInitSizeScale(s) {\n            this._initSizeScale = +s\n        }\n        GetInitSizeScale() {\n            return this._initSizeScale\n        }\n        SetInitOpacity(o) {\n            this._initOpacity = +o\n        }\n        GetInitOpacity() {\n            return this._initOpacity\n        }\n        SetGrowRate(g) {\n            this._growRate = +g\n        }\n        GetGrowRate() {\n            return this._growRate\n        }\n        SetInitXRandom(x) {\n            this._xRandom = +x\n        }\n        GetInitXRandom() {\n            return this._xRandom\n        }\n        SetInitYRandom(y) {\n            this._yRandom = +y\n        }\n        GetInitYRandom() {\n            return this._yRandom\n        }\n        SetInitSpeedRandom(s) {\n            this._initSpeedRandom = +s\n        }\n        GetInitSpeedRandom() {\n            return this._initSpeedRandom\n        }\n        SetInitSizeRandom(s) {\n            this._initSizeRandom = +s\n        }\n        GetInitSizeRandom() {\n            return this._initSizeRandom\n        }\n        SetGrowRandom(g) {\n            this._growRandom = +g\n        }\n        GetGrowRandom() {\n            return this._growRandom\n        }\n        SetAcceleration(a) {\n            this._acceleration = +a\n        }\n        GetAcceleration() {\n            return this._acceleration\n        }\n        SetGravity(g) {\n            this._gravity = +g\n        }\n        GetGravity() {\n            return this._gravity\n        }\n        SetLifeAngleRandom(a) {\n            this._lifeAngleRandom = +a\n        }\n        GetLifeAngleRandom() {\n            return this._lifeAngleRandom\n        }\n        SetLifeSpeedRandom(s) {\n            this._lifeSpeedRandom = +s\n        }\n        GetLifeSpeedRandom() {\n            return this._lifeSpeedRandom\n        }\n        SetLifeOpacityRandom(o) {\n            this._lifeOpacityRandom = +o\n        }\n        GetLifeOpacityRandom() {\n            return this._lifeOpacityRandom\n        }\n        SetDestroyMode(m) {\n            let i = DESTROY_MODES.indexOf(m);\n            if (i === -1)\n                throw new Error("invalid destroy mode");\n            this._destroyMode = i\n        }\n        SetDestroyModeIndex(i) {\n            this.SetDestroyMode(DESTROY_MODES[i])\n        }\n        GetDestroyMode() {\n            return DESTROY_MODES[this._destroyMode]\n        }\n        GetDestroyModeIndex() {\n            return this._destroyMode\n        }\n        SetTimeout(t) {\n            this._timeout = +t\n        }\n        GetTimeout() {\n            return this._timeout\n        }\n        SetParticleScale(s) {\n            this._particleScale = +s\n        }\n        GetParticleScale() {\n            return this._particleScale\n        }\n        GetBoundingBox() {\n            return this._boundingBox\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const ParticleEngine = self.ParticleEngine;\n    function randomOffset(x) {\n        return Math.random() * x - x \/ 2\n    }\n    const tmpQuad = new C3.Quad;\n    const tmpColor = new C3.Color;\n    const DPR = self.devicePixelRatio || 1;\n    let didChangeColor = false;\n    self.Particle = class Particle {\n        constructor(engine) {\n            this._engine = engine;\n            this._isActive = false;\n            this._x = 0;\n            this._y = 0;\n            this._speed = 0;\n            this._angle = 0;\n            this._opacity = 1;\n            this._lastOpacity = 0;\n            this._grow = 0;\n            this._size = 0;\n            this._halfSize = 0;\n            this._gs = 0;\n            this._age = 0;\n            this._bbox = new C3.Rect;\n            this._userData = null;\n            this._userDataUid = NaN;\n            this._updateCallback = null;\n            this._destroyCallback = null\n        }\n        SetEngine(engine) {\n            this._engine = engine\n        }\n        Init(particleCreateCallback) {\n            const engine = this._engine;\n            this._isActive = true;\n            this._x = engine.GetSpawnX() + randomOffset(engine.GetInitXRandom());\n            this._y = engine.GetSpawnY() + randomOffset(engine.GetInitYRandom());\n            this._speed = engine.GetInitSpeed() + randomOffset(engine.GetInitSpeedRandom());\n            this._angle = engine.GetInitAngle() + randomOffset(engine.GetSprayCone());\n            this._opacity = engine.GetInitOpacity();\n            this._lastOpacity = this._opacity;\n            this._size = (engine.GetInitSize() + randomOffset(engine.GetInitSizeRandom())) * engine.GetInitSizeScale();\n            this._halfSize = this._size \/ 2;\n            this._grow = engine.GetGrowRate() + randomOffset(engine.GetGrowRandom());\n            this._gs = 0;\n            this._age = 0;\n            this._UpdateBoundingBox();\n            if (particleCreateCallback) {\n                if (!this._userData)\n                    this._userData = particleCreateCallback(this)\n            } else {\n                this._userData = null;\n                this._updateCallback = null;\n                this._destroyCallback = null\n            }\n        }\n        UpdateUserData(particleCreateCallback) {\n            if (particleCreateCallback) {\n                if (!this._userData || this._userData.IsDestroyed())\n                    this._userData = particleCreateCallback(this)\n            } else {\n                this._userData = null;\n                this._updateCallback = null;\n                this._destroyCallback = null\n            }\n        }\n        SetUpdateCallback(f) {\n            this._updateCallback = f\n        }\n        SetDestroyCallback(f) {\n            this._destroyCallback = f\n        }\n        Destroy() {\n            const particleDestroyCallback = this._destroyCallback;\n            if (particleDestroyCallback)\n                particleDestroyCallback(this._userData);\n            this._userData = null;\n            this._updateCallback = null;\n            this._destroyCallback = null\n        }\n        toJSON() {\n            let uid;\n            if (this._userData)\n                uid = this._userData.GetWorldInfo().GetInstance().GetUID();\n            return [this._x, this._y, this._speed, this._angle, this._opacity, this._grow, this._size, this._gs, this._age, uid]\n        }\n        setFromJSON(o) {\n            this._x = o[0];\n            this._y = o[1];\n            this._speed = o[2];\n            this._angle = o[3];\n            this._opacity = o[4];\n            this._grow = o[5];\n            this._size = o[6];\n            this._gs = o[7];\n            this._age = o[8];\n            this._userDataUid = o[9];\n            this._halfSize = this._size \/ 2;\n            this._UpdateBoundingBox()\n        }\n        Tick(dt) {\n            const engine = this._engine;\n            const dist = this._speed * dt;\n            const a = this._angle;\n            const dx = Math.cos(a) * dist;\n            const dy = Math.sin(a) * dist + this._gs * dt;\n            this._x += dx;\n            this._y += dy;\n            const dSize = this._grow * dt;\n            this._size += dSize;\n            this._halfSize = this._size \/ 2;\n            this._speed += engine.GetAcceleration() * dt;\n            this._gs += engine.GetGravity() * dt;\n            this._age += dt;\n            this._UpdateBoundingBox();\n            const lifeAngleRandom = engine.GetLifeAngleRandom();\n            const lifeSpeedRandom = engine.GetLifeSpeedRandom();\n            const lifeOpacityRandom = engine.GetLifeOpacityRandom();\n            let dAngle = 0;\n            if (lifeAngleRandom !== 0) {\n                dAngle = randomOffset(lifeAngleRandom * dt);\n                this._angle += dAngle\n            }\n            if (lifeSpeedRandom !== 0)\n                this._speed += randomOffset(lifeSpeedRandom * dt);\n            if (lifeOpacityRandom !== 0)\n                this._opacity = C3.clamp(this._opacity + randomOffset(lifeOpacityRandom * dt), 0, 1);\n            const isActive = this._size >= 1 && (engine.GetDestroyModeIndex() === 2 ? this._speed > 0 : this._age < engine.GetTimeout());\n            const particleUpdateCallback = this._updateCallback;\n            if (particleUpdateCallback && isActive) {\n                let curOpacity = engine.GetMasterOpacity() * this._opacity;\n                if (engine.GetDestroyModeIndex() === 0)\n                    curOpacity *= 1 - this._age \/ engine.GetTimeout();\n                const dOpacity = curOpacity - this._lastOpacity;\n                this._lastOpacity = curOpacity;\n                particleUpdateCallback(this._userData, dx, dy, dSize, dAngle, dOpacity)\n            }\n            this._isActive = isActive\n        }\n        IsActive() {\n            return this._isActive\n        }\n        GetBoundingBox() {\n            return this._bbox\n        }\n        _UpdateBoundingBox() {\n            const x = this._x;\n            const y = this._y;\n            const halfSize = this._halfSize;\n            this._bbox.set(x - halfSize, y - halfSize, x + halfSize, y + halfSize)\n        }\n        Draw(renderer, texRect, forceQuads) {\n            if (this._userData)\n                return;\n            const engine = this._engine;\n            let opacity = engine.GetMasterOpacity() * this._opacity;\n            if (engine.GetDestroyModeIndex() === 0)\n                opacity *= 1 - this._age \/ engine.GetTimeout();\n            if (opacity <= 0)\n                return;\n            const size = this._size;\n            const scaledSize = size * engine.GetParticleScale() * DPR;\n            if (scaledSize < 1)\n                return;\n            let x = this._x;\n            let y = this._y;\n            if (engine.IsPixelRounding()) {\n                x = x + .5 | 0;\n                y = y + .5 | 0\n            }\n            if (renderer.IsWebGPU())\n                renderer.Point(x, y, size, opacity);\n            else if (forceQuads || scaledSize > renderer.GetMaxPointSize() || scaledSize < renderer.GetMinPointSize()) {\n                tmpColor.copy(engine.GetColor());\n                tmpColor.multiplyAlpha(opacity);\n                renderer.SetColor(tmpColor);\n                didChangeColor = true;\n                tmpQuad.setFromRect(this._bbox);\n                renderer.Quad3(tmpQuad, texRect)\n            } else {\n                if (didChangeColor) {\n                    renderer.SetColor(engine.GetColor());\n                    didChangeColor = false\n                }\n                renderer.Point(x, y, scaledSize, opacity)\n            }\n        }\n        GetUserData() {\n            return this._userData\n        }\n        GetUserDataUID() {\n            return this._userDataUid\n        }\n        GetX() {\n            return this._x\n        }\n        GetY() {\n            return this._y\n        }\n        GetSize() {\n            return this._size\n        }\n        GetAngle() {\n            return this._angle\n        }\n        GetOpacity() {\n            return this._opacity\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Plugins.Arr = class ArrayPlugin extends C3.SDKPluginBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Arr.Type = class ArrayType extends C3.SDKTypeBase {\n            constructor(objectClass) {\n                super(objectClass)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        const IInstance = self.IInstance;\n        function ResizeArray(arr, len, data) {\n            if (len < arr.length)\n                C3.truncateArray(arr, len);\n            else if (len > arr.length)\n                if (typeof data === "function")\n                    for (let i = arr.length; i < len; ++i)\n                        arr.push(data());\n                else\n                    for (let i = arr.length; i < len; ++i)\n                        arr.push(data)\n        }\n        C3.Plugins.Arr.Instance = class ArrayInstance extends C3.SDKInstanceBase {\n            constructor(inst, properties) {\n                super(inst);\n                this._cx = 10;\n                this._cy = 1;\n                this._cz = 1;\n                this._arr = null;\n                this._forX = [];\n                this._forY = [];\n                this._forZ = [];\n                this._forDepth = -1;\n                if (properties) {\n                    this._cx = properties[0];\n                    this._cy = properties[1];\n                    this._cz = properties[2]\n                }\n                this._arr = C3.MakeFilledArray(this._cx, () => C3.MakeFilledArray(this._cy, () => C3.MakeFilledArray(this._cz, 0)))\n            }\n            Release() {\n                this._arr = null;\n                super.Release()\n            }\n            At(x, y, z) {\n                x = Math.floor(x);\n                y = Math.floor(y);\n                z = Math.floor(z);\n                if (x >= 0 && x < this._cx && y >= 0 && y < this._cy && z >= 0 && z < this._cz)\n                    return this._arr[x][y][z];\n                else\n                    return 0\n            }\n            Set(x, y, z, val) {\n                x = Math.floor(x);\n                y = Math.floor(y);\n                z = Math.floor(z);\n                if (x >= 0 && x < this._cx && y >= 0 && y < this._cy && z >= 0 && z < this._cz)\n                    this._arr[x][y][z] = val\n            }\n            SetSize(w, h, d) {\n                w = Math.floor(w);\n                h = Math.floor(h);\n                d = Math.floor(d);\n                if (w < 0)\n                    w = 0;\n                if (h < 0)\n                    h = 0;\n                if (d < 0)\n                    d = 0;\n                if (this._cx === w && this._cy === h && this._cz === d)\n                    return;\n                this._cx = w;\n                this._cy = h;\n                this._cz = d;\n                const arr = this._arr;\n                ResizeArray(arr, w, () => C3.MakeFilledArray(h, () => C3.MakeFilledArray(d, 0)));\n                for (let x = 0; x < w; ++x) {\n                    ResizeArray(arr[x], h, () => C3.MakeFilledArray(d, 0));\n                    for (let y = 0; y < h; ++y)\n                        ResizeArray(arr[x][y], d, 0)\n                }\n            }\n            GetWidth() {\n                return this._cx\n            }\n            GetHeight() {\n                return this._cy\n            }\n            GetDepth() {\n                return this._cz\n            }\n            GetDebuggerProperties() {\n                const prefix = "plugins.arr.debugger";\n                const propsPrefix = "plugins.arr.properties";\n                const ret = [{\n                    title: prefix + ".array-properties.title",\n                    properties: [{\n                        name: propsPrefix + ".width.name",\n                        value: this._cx,\n                        onedit: v => this.SetSize(v, this._cy, this._cz)\n                    }, {\n                        name: propsPrefix + ".height.name",\n                        value: this._cy,\n                        onedit: v => this.SetSize(this._cx, v, this._cz)\n                    }, {\n                        name: propsPrefix + ".depth.name",\n                        value: this._cz,\n                        onedit: v => this.SetSize(this._cx, this._cy, v)\n                    }, {\n                        name: propsPrefix + ".elements.name",\n                        value: this._cx * this._cy * this._cz\n                    }]\n                }];\n                const dataProps = [];\n                if (this._cy === 1 && this._cz === 1)\n                    for (let x = 0; x < this._cx; ++x)\n                        dataProps.push({\n                            name: "$" + x,\n                            value: this._arr[x][0][0],\n                            onedit: v => this._arr[x][0][0] = v\n                        });\n                else\n                    for (let x = 0; x < this._cx; ++x)\n                        dataProps.push({\n                            name: "$" + x,\n                            value: this._arr[x].toString()\n                        });\n                if (dataProps.length)\n                    ret.push({\n                        title: prefix + ".array-data.title",\n                        properties: dataProps\n                    });\n                return ret\n            }\n            GetAsJsonString() {\n                return JSON.stringify({\n                    "c2array": true,\n                    "size": [this._cx, this._cy, this._cz],\n                    "data": this._arr\n                })\n            }\n            SaveToJson() {\n                return {\n                    "size": [this._cx, this._cy, this._cz],\n                    "data": this._arr\n                }\n            }\n            LoadFromJson(o) {\n                const sz = o["size"];\n                this._cx = sz[0];\n                this._cy = sz[1];\n                this._cz = sz[2];\n                this._arr = o["data"]\n            }\n            _GetForX() {\n                if (this._forDepth >= 0 && this._forDepth < this._forX.length)\n                    return this._forX[this._forDepth];\n                else\n                    return 0\n            }\n            _GetForY() {\n                if (this._forDepth >= 0 && this._forDepth < this._forY.length)\n                    return this._forY[this._forDepth];\n                else\n                    return 0\n            }\n            _GetForZ() {\n                if (this._forDepth >= 0 && this._forDepth < this._forZ.length)\n                    return this._forZ[this._forDepth];\n                else\n                    return 0\n            }\n            GetScriptInterfaceClass() {\n                return self.IArrayInstance\n            }\n        }\n        ;\n        const map = new WeakMap;\n        self.IArrayInstance = class IArrayInstance extends IInstance {\n            constructor() {\n                super();\n                map.set(this, IInstance._GetInitInst().GetSdkInstance())\n            }\n            get width() {\n                return map.get(this).GetWidth()\n            }\n            get height() {\n                return map.get(this).GetHeight()\n            }\n            get depth() {\n                return map.get(this).GetDepth()\n            }\n            setSize(w, h=1, d=1) {\n                C3X.RequireFiniteNumber(w);\n                C3X.RequireFiniteNumber(h);\n                C3X.RequireFiniteNumber(d);\n                map.get(this).SetSize(w, h, d)\n            }\n            getAt(x, y=0, z=0) {\n                C3X.RequireFiniteNumber(x);\n                C3X.RequireFiniteNumber(y);\n                C3X.RequireFiniteNumber(z);\n                return map.get(this).At(x, y, z)\n            }\n            setAt(val, x, y=0, z=0) {\n                C3X.RequireFiniteNumber(x);\n                C3X.RequireFiniteNumber(y);\n                C3X.RequireFiniteNumber(z);\n                if (typeof val !== "number" && typeof val !== "string")\n                    throw new TypeError("invalid type");\n                map.get(this).Set(x, y, z, val)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        function DoForEachTrigger(eventSheetManager, currentEvent, solModifiers, oldFrame, newFrame) {\n            eventSheetManager.PushCopySol(solModifiers);\n            currentEvent.Retrigger(oldFrame, newFrame);\n            eventSheetManager.PopSol(solModifiers)\n        }\n        C3.Plugins.Arr.Cnds = {\n            CompareX(x, cmp, val) {\n                return C3.compare(this.At(x, 0, 0), cmp, val)\n            },\n            CompareXY(x, y, cmp, val) {\n                return C3.compare(this.At(x, y, 0), cmp, val)\n            },\n            CompareXYZ(x, y, z, cmp, val) {\n                return C3.compare(this.At(x, y, z), cmp, val)\n            },\n            ArrForEach(dims) {\n                const runtime = this._runtime;\n                const eventSheetManager = runtime.GetEventSheetManager();\n                const currentEvent = runtime.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiers();\n                const eventStack = runtime.GetEventStack();\n                const oldFrame = eventStack.GetCurrentStackFrame();\n                const newFrame = eventStack.Push(currentEvent);\n                const forDepth = ++this._forDepth;\n                const forX = this._forX;\n                const forY = this._forY;\n                const forZ = this._forZ;\n                const cx = this._cx;\n                const cy = this._cy;\n                const cz = this._cz;\n                if (forDepth === this._forX.length) {\n                    forX.push(0);\n                    forY.push(0);\n                    forZ.push(0)\n                } else {\n                    forX[forDepth] = 0;\n                    forY[forDepth] = 0;\n                    forZ[forDepth] = 0\n                }\n                runtime.SetDebuggingEnabled(false);\n                if (dims === 0)\n                    for (let x = 0; x < cx; ++x)\n                        for (let y = 0; y < cy; ++y)\n                            for (let z = 0; z < cz; ++z) {\n                                forX[forDepth] = x;\n                                forY[forDepth] = y;\n                                forZ[forDepth] = z;\n                                DoForEachTrigger(eventSheetManager, currentEvent, solModifiers, oldFrame, newFrame)\n                            }\n                else if (dims === 1)\n                    for (let x = 0; x < cx; ++x)\n                        for (let y = 0; y < cy; ++y) {\n                            forX[forDepth] = x;\n                            forY[forDepth] = y;\n                            DoForEachTrigger(eventSheetManager, currentEvent, solModifiers, oldFrame, newFrame)\n                        }\n                else\n                    for (let x = 0; x < cx; ++x) {\n                        forX[forDepth] = x;\n                        DoForEachTrigger(eventSheetManager, currentEvent, solModifiers, oldFrame, newFrame)\n                    }\n                runtime.SetDebuggingEnabled(true);\n                this._forDepth--;\n                eventStack.Pop();\n                return false\n            },\n            CompareCurrent(cmp, val) {\n                return C3.compare(this.At(this._GetForX(), this._GetForY(), this._GetForZ()), cmp, val)\n            },\n            Contains(val) {\n                const cx = this._cx;\n                const cy = this._cy;\n                const cz = this._cz;\n                const arr = this._arr;\n                for (let x = 0; x < cx; ++x)\n                    for (let y = 0; y < cy; ++y)\n                        for (let z = 0; z < cz; ++z)\n                            if (arr[x][y][z] === val)\n                                return true;\n                return false\n            },\n            IsEmpty() {\n                return this._cx === 0 || this._cy === 0 || this._cz === 0\n            },\n            CompareSize(axis, cmp, val) {\n                let s = 0;\n                switch (axis) {\n                case 0:\n                    s = this._cx;\n                    break;\n                case 1:\n                    s = this._cy;\n                    break;\n                case 2:\n                    s = this._cz;\n                    break\n                }\n                return C3.compare(s, cmp, val)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        function CompareValues(va, vb) {\n            if (typeof va === "number" && typeof vb === "number")\n                return va - vb;\n            else {\n                const sa = va.toString();\n                const sb = vb.toString();\n                if (sa < sb)\n                    return -1;\n                else if (sa > sb)\n                    return 1;\n                else\n                    return 0\n            }\n        }\n        C3.Plugins.Arr.Acts = {\n            Clear(v) {\n                const cx = this._cx;\n                const cy = this._cy;\n                const cz = this._cz;\n                const arr = this._arr;\n                for (let x = 0; x < cx; ++x)\n                    for (let y = 0; y < cy; ++y)\n                        for (let z = 0; z < cz; ++z)\n                            arr[x][y][z] = v\n            },\n            SetSize(w, h, d) {\n                this.SetSize(w, h, d)\n            },\n            SetX(x, val) {\n                this.Set(x, 0, 0, val)\n            },\n            SetXY(x, y, val) {\n                this.Set(x, y, 0, val)\n            },\n            SetXYZ(x, y, z, val) {\n                this.Set(x, y, z, val)\n            },\n            Push(where, value, axis) {\n                const cx = this._cx;\n                const cy = this._cy;\n                const cz = this._cz;\n                const arr = this._arr;\n                if (axis === 0) {\n                    const add = C3.MakeFilledArray(cy, () => C3.MakeFilledArray(cz, value));\n                    if (where === 0)\n                        arr.push(add);\n                    else\n                        arr.unshift(add);\n                    this._cx++\n                } else if (axis === 1) {\n                    for (let x = 0; x < cx; ++x) {\n                        const add = C3.MakeFilledArray(cz, value);\n                        if (where === 0)\n                            arr[x].push(add);\n                        else\n                            arr[x].unshift(add)\n                    }\n                    this._cy++\n                } else {\n                    for (let x = 0; x < cx; ++x)\n                        for (let y = 0; y < cy; ++y)\n                            if (where === 0)\n                                arr[x][y].push(value);\n                            else\n                                arr[x][y].unshift(value);\n                    this._cz++\n                }\n            },\n            Pop(where, axis) {\n                const cx = this._cx;\n                const cy = this._cy;\n                const cz = this._cz;\n                const arr = this._arr;\n                if (axis === 0) {\n                    if (cx === 0)\n                        return;\n                    if (where === 0)\n                        arr.pop();\n                    else\n                        arr.shift();\n                    this._cx--\n                } else if (axis === 1) {\n                    if (cy === 0)\n                        return;\n                    for (let x = 0; x < cx; ++x)\n                        if (where === 0)\n                            arr[x].pop();\n                        else\n                            arr[x].shift();\n                    this._cy--\n                } else {\n                    if (cz === 0)\n                        return;\n                    for (let x = 0; x < cx; ++x)\n                        for (let y = 0; y < cy; ++y)\n                            if (where === 0)\n                                arr[x][y].pop();\n                            else\n                                arr[x][y].shift();\n                    this._cz--\n                }\n            },\n            Reverse(axis) {\n                const cx = this._cx;\n                const cy = this._cy;\n                const cz = this._cz;\n                const arr = this._arr;\n                if (cx === 0 || cy === 0 || cz === 0)\n                    return;\n                if (axis === 0)\n                    arr.reverse();\n                else if (axis === 1)\n                    for (let x = 0; x < cx; ++x)\n                        arr[x].reverse();\n                else\n                    for (let x = 0; x < cx; ++x)\n                        for (let y = 0; y < cy; ++y)\n                            arr[x][y].reverse()\n            },\n            Sort(axis) {\n                const cx = this._cx;\n                const cy = this._cy;\n                const cz = this._cz;\n                const arr = this._arr;\n                if (cx === 0 || cy === 0 || cz === 0)\n                    return;\n                if (axis === 0)\n                    arr.sort( (a, b) => CompareValues(a[0][0], b[0][0]));\n                else if (axis === 1)\n                    for (let x = 0; x < cx; ++x)\n                        arr[x].sort( (a, b) => CompareValues(a[0], b[0]));\n                else\n                    for (let x = 0; x < cx; ++x)\n                        for (let y = 0; y < cy; ++y)\n                            arr[x][y].sort(CompareValues)\n            },\n            Delete(index, axis) {\n                index = Math.floor(index);\n                if (index < 0)\n                    return;\n                const cx = this._cx;\n                const cy = this._cy;\n                const cz = this._cz;\n                const arr = this._arr;\n                if (axis === 0) {\n                    if (index >= cx)\n                        return;\n                    arr.splice(index, 1);\n                    this._cx--\n                } else if (axis === 1) {\n                    if (index >= cy)\n                        return;\n                    for (let x = 0; x < cx; ++x)\n                        arr[x].splice(index, 1);\n                    this._cy--\n                } else {\n                    if (index >= cz)\n                        return;\n                    for (let x = 0; x < cx; ++x)\n                        for (let y = 0; y < cy; ++y)\n                            arr[x][y].splice(index, 1);\n                    this._cz--\n                }\n            },\n            Insert(value, index, axis) {\n                index = Math.floor(index);\n                if (index < 0)\n                    return;\n                const cx = this._cx;\n                const cy = this._cy;\n                const cz = this._cz;\n                const arr = this._arr;\n                if (axis === 0) {\n                    if (index > cx)\n                        return;\n                    arr.splice(index, 0, C3.MakeFilledArray(cy, () => C3.MakeFilledArray(cz, value)));\n                    this._cx++\n                } else if (axis === 1) {\n                    if (index > cy)\n                        return;\n                    for (let x = 0; x < cx; ++x)\n                        arr[x].splice(index, 0, C3.MakeFilledArray(cz, value));\n                    this._cy++\n                } else {\n                    if (index > cz)\n                        return;\n                    for (let x = 0; x < cx; ++x)\n                        for (let y = 0; y < cy; ++y)\n                            arr[x][y].splice(index, 0, value);\n                    this._cz++\n                }\n            },\n            JSONLoad(json) {\n                let o = null;\n                try {\n                    o = JSON.parse(json)\n                } catch (err) {\n                    console.error("[Construct] Failed to parse JSON: ", err);\n                    return\n                }\n                if (!o["c2array"])\n                    return;\n                const sz = o["size"];\n                this._cx = sz[0];\n                this._cy = sz[1];\n                this._cz = sz[2];\n                this._arr = o["data"]\n            },\n            JSONDownload(filename) {\n                const url = URL.createObjectURL(new Blob([this.GetAsJsonString()],{\n                    type: "application\/json"\n                }));\n                this._runtime.InvokeDownload(url, filename)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Arr.Exps = {\n            At(x, y, z) {\n                return this.At(x, y || 0, z || 0)\n            },\n            Width() {\n                return this._cx\n            },\n            Height() {\n                return this._cy\n            },\n            Depth() {\n                return this._cz\n            },\n            CurX() {\n                return this._GetForX()\n            },\n            CurY() {\n                return this._GetForY()\n            },\n            CurZ() {\n                return this._GetForZ()\n            },\n            CurValue() {\n                return this.At(this._GetForX(), this._GetForY(), this._GetForZ())\n            },\n            Front() {\n                return this.At(0, 0, 0)\n            },\n            Back() {\n                return this.At(this._cx - 1, 0, 0)\n            },\n            IndexOf(v) {\n                const arr = this._arr;\n                for (let x = 0, len = this._cx; x < len; ++x)\n                    if (arr[x][0][0] === v)\n                        return x;\n                return -1\n            },\n            LastIndexOf(v) {\n                const arr = this._arr;\n                for (let x = this._cx - 1; x >= 0; --x)\n                    if (arr[x][0][0] === v)\n                        return x;\n                return -1\n            },\n            AsJSON() {\n                return this.GetAsJsonString()\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Plugins.Touch = class TouchPlugin extends C3.SDKPluginBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        C3.Plugins.Touch.Type = class TouchType extends C3.SDKTypeBase {\n            constructor(objectClass) {\n                super(objectClass)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n            GetScriptInterfaceClass() {\n                return self.ITouchObjectType\n            }\n        }\n        ;\n        let touchObjectType = null;\n        function GetTouchSdkInstance() {\n            return touchObjectType.GetSingleGlobalInstance().GetSdkInstance()\n        }\n        self.ITouchObjectType = class ITouchObjectType extends self.IObjectClass {\n            constructor(objectType) {\n                super(objectType);\n                touchObjectType = objectType;\n                objectType.GetRuntime()._GetCommonScriptInterfaces().touch = this\n            }\n            requestPermission(type) {\n                C3X.RequireString(type);\n                const touchInst = GetTouchSdkInstance();\n                if (type === "orientation")\n                    return touchInst._RequestPermission(0);\n                else if (type === "motion")\n                    return touchInst._RequestPermission(1);\n                else\n                    throw new Error("invalid type");\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const DOM_COMPONENT_ID = "touch";\n        C3.Plugins.Touch.Instance = class TouchInstance extends C3.SDKInstanceBase {\n            constructor(inst, properties) {\n                super(inst, DOM_COMPONENT_ID);\n                this._touches = new Map;\n                this._useMouseInput = false;\n                this._isMouseDown = false;\n                this._orientCompassHeading = 0;\n                this._orientAlpha = 0;\n                this._orientBeta = 0;\n                this._orientGamma = 0;\n                this._accX = 0;\n                this._accY = 0;\n                this._accZ = 0;\n                this._accWithGX = 0;\n                this._accWithGY = 0;\n                this._accWithGZ = 0;\n                this._triggerIndex = 0;\n                this._triggerId = 0;\n                this._triggerPermission = 0;\n                this._curTouchX = 0;\n                this._curTouchY = 0;\n                this._getTouchIndex = 0;\n                this._permissionPromises = [];\n                if (properties)\n                    this._useMouseInput = properties[0];\n                this.AddDOMMessageHandler("permission-result", e => this._OnPermissionResult(e));\n                const rt = this.GetRuntime().Dispatcher();\n                this._disposables = new C3.CompositeDisposable(C3.Disposable.From(rt, "pointerdown", e => this._OnPointerDown(e.data)),C3.Disposable.From(rt, "pointermove", e => this._OnPointerMove(e.data)),C3.Disposable.From(rt, "pointerup", e => this._OnPointerUp(e.data, false)),C3.Disposable.From(rt, "pointercancel", e => this._OnPointerUp(e.data, true)),C3.Disposable.From(rt, "deviceorientation", e => this._OnDeviceOrientation(e.data)),C3.Disposable.From(rt, "deviceorientationabsolute", e => this._OnDeviceOrientationAbsolute(e.data)),C3.Disposable.From(rt, "devicemotion", e => this._OnDeviceMotion(e.data)),C3.Disposable.From(rt, "tick2", e => this._OnTick2()))\n            }\n            Release() {\n                this._touches.clear();\n                super.Release()\n            }\n            _OnPointerDown(e) {\n                if (e["pointerType"] === "mouse")\n                    if (this._useMouseInput)\n                        this._isMouseDown = true;\n                    else\n                        return;\n                const pointerId = e["pointerId"];\n                if (this._touches.has(pointerId))\n                    return;\n                const x = e["pageX"] - this._runtime.GetCanvasClientX();\n                const y = e["pageY"] - this._runtime.GetCanvasClientY();\n                const nowTime = performance.now();\n                const index = this._touches.size;\n                this._triggerIndex = index;\n                this._triggerId = pointerId;\n                const touchInfo = C3.New(C3.Plugins.Touch.TouchInfo);\n                touchInfo.Init(nowTime, x, y, pointerId, index);\n                this._touches.set(pointerId, touchInfo);\n                this.Trigger(C3.Plugins.Touch.Cnds.OnNthTouchStart);\n                this.Trigger(C3.Plugins.Touch.Cnds.OnTouchStart);\n                this._curTouchX = x;\n                this._curTouchY = y;\n                this.Trigger(C3.Plugins.Touch.Cnds.OnTouchObject)\n            }\n            _OnPointerMove(e) {\n                if (e["pointerType"] === "mouse" && !this._isMouseDown)\n                    return;\n                const touchInfo = this._touches.get(e["pointerId"]);\n                if (!touchInfo)\n                    return;\n                const nowTime = performance.now();\n                if (nowTime - touchInfo.GetTime() < 2)\n                    return;\n                const x = e["pageX"] - this._runtime.GetCanvasClientX();\n                const y = e["pageY"] - this._runtime.GetCanvasClientY();\n                touchInfo.Update(nowTime, x, y, e["width"], e["height"], e["pressure"])\n            }\n            _OnPointerUp(e, isCancel) {\n                if (e["pointerType"] === "mouse")\n                    if (this._isMouseDown)\n                        this._isMouseDown = false;\n                    else\n                        return;\n                const nowTime = performance.now();\n                const pointerId = e["pointerId"];\n                const touchInfo = this._touches.get(pointerId);\n                if (!touchInfo)\n                    return;\n                this._triggerIndex = touchInfo.GetStartIndex();\n                this._triggerId = touchInfo.GetId();\n                this.Trigger(C3.Plugins.Touch.Cnds.OnNthTouchEnd);\n                this.Trigger(C3.Plugins.Touch.Cnds.OnTouchEnd);\n                if (!isCancel) {\n                    const tap = touchInfo.ShouldTriggerTap(nowTime);\n                    if (tap === "single-tap") {\n                        this.Trigger(C3.Plugins.Touch.Cnds.OnTapGesture);\n                        this._curTouchX = touchInfo.GetX();\n                        this._curTouchY = touchInfo.GetY();\n                        this.Trigger(C3.Plugins.Touch.Cnds.OnTapGestureObject)\n                    } else if (tap === "double-tap") {\n                        this.Trigger(C3.Plugins.Touch.Cnds.OnDoubleTapGesture);\n                        this._curTouchX = touchInfo.GetX();\n                        this._curTouchY = touchInfo.GetY();\n                        this.Trigger(C3.Plugins.Touch.Cnds.OnDoubleTapGestureObject)\n                    }\n                }\n                touchInfo.Release();\n                this._touches.delete(pointerId)\n            }\n            _RequestPermission(type) {\n                this._PostToDOMMaybeSync("request-permission", {\n                    "type": type\n                });\n                return new Promise( (resolve, reject) => {\n                    this._permissionPromises.push({\n                        type,\n                        resolve,\n                        reject\n                    })\n                }\n                )\n            }\n            _OnPermissionResult(e) {\n                const isGranted = e["result"];\n                const type = e["type"];\n                this._triggerPermission = type;\n                const toResolve = this._permissionPromises.filter(o => o.type === type);\n                for (const o of toResolve)\n                    o.resolve(isGranted ? "granted" : "denied");\n                this._permissionPromises = this._permissionPromises.filter(o => o.type !== type);\n                if (isGranted) {\n                    this.Trigger(C3.Plugins.Touch.Cnds.OnPermissionGranted);\n                    if (type === 0)\n                        this._runtime.RequestDeviceOrientationEvent();\n                    else\n                        this._runtime.RequestDeviceMotionEvent()\n                } else\n                    this.Trigger(C3.Plugins.Touch.Cnds.OnPermissionDenied)\n            }\n            _OnDeviceOrientation(e) {\n                if (typeof e["webkitCompassHeading"] === "number")\n                    this._orientCompassHeading = e["webkitCompassHeading"];\n                else if (e["absolute"])\n                    this._orientCompassHeading = e["alpha"];\n                this._orientAlpha = e["alpha"];\n                this._orientBeta = e["beta"];\n                this._orientGamma = e["gamma"]\n            }\n            _OnDeviceOrientationAbsolute(e) {\n                this._orientCompassHeading = e["alpha"]\n            }\n            _OnDeviceMotion(e) {\n                const acc = e["acceleration"];\n                if (acc) {\n                    this._accX = acc["x"];\n                    this._accY = acc["y"];\n                    this._accZ = acc["z"]\n                }\n                const withG = e["accelerationIncludingGravity"];\n                if (withG) {\n                    this._accWithGX = withG["x"];\n                    this._accWithGY = withG["y"];\n                    this._accWithGZ = withG["z"]\n                }\n            }\n            _OnTick2() {\n                const nowTime = performance.now();\n                let index = 0;\n                for (const touchInfo of this._touches.values()) {\n                    if (touchInfo.GetTime() <= nowTime - 50)\n                        touchInfo._SetLastTime(nowTime);\n                    if (touchInfo.ShouldTriggerHold(nowTime)) {\n                        this._triggerIndex = touchInfo.GetStartIndex();\n                        this._triggerId = touchInfo.GetId();\n                        this._getTouchIndex = index;\n                        this.Trigger(C3.Plugins.Touch.Cnds.OnHoldGesture);\n                        this._curTouchX = touchInfo.GetX();\n                        this._curTouchY = touchInfo.GetY();\n                        this.Trigger(C3.Plugins.Touch.Cnds.OnHoldGestureObject);\n                        this._getTouchIndex = 0\n                    }\n                    ++index\n                }\n            }\n            _GetTouchByIndex(index) {\n                index = Math.floor(index);\n                for (const touchInfo of this._touches.values()) {\n                    if (index === 0)\n                        return touchInfo;\n                    --index\n                }\n                return null\n            }\n            _IsClientPosOnCanvas(touchX, touchY) {\n                return touchX >= 0 && touchY >= 0 && touchX < this._runtime.GetCanvasCssWidth() && touchY < this._runtime.GetCanvasCssHeight()\n            }\n            GetDebuggerProperties() {\n                const prefix = "plugins.touch.debugger";\n                return [{\n                    title: prefix + ".touches",\n                    properties: [...this._touches.values()].map(ti => ({\n                        name: "$" + ti.GetId(),\n                        value: ti.GetX() + ", " + ti.GetY()\n                    }))\n                }]\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const tempArr = [];\n        C3.Plugins.Touch.Cnds = {\n            OnTouchStart() {\n                return true\n            },\n            OnTouchEnd() {\n                return true\n            },\n            IsInTouch() {\n                return this._touches.size > 0\n            },\n            OnTouchObject(objectClass) {\n                if (!objectClass)\n                    return false;\n                if (!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY))\n                    return false;\n                return this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(objectClass, this._curTouchX, this._curTouchY, false)\n            },\n            IsTouchingObject(objectClass) {\n                if (!objectClass)\n                    return false;\n                const sol = objectClass.GetCurrentSol();\n                const instances = sol.GetInstances();\n                for (const inst of instances) {\n                    const wi = inst.GetWorldInfo();\n                    const layer = wi.GetLayer();\n                    for (const touchInfo of this._touches.values()) {\n                        if (!this._IsClientPosOnCanvas(touchInfo.GetX(), touchInfo.GetY()))\n                            continue;\n                        const [px,py] = layer.CanvasCssToLayer(touchInfo.GetX(), touchInfo.GetY(), wi.GetTotalZElevation());\n                        if (layer.IsSelfAndParentsInteractive() && wi.ContainsPoint(px, py)) {\n                            tempArr.push(inst);\n                            break\n                        }\n                    }\n                }\n                if (tempArr.length) {\n                    sol.SetArrayPicked(tempArr);\n                    objectClass.ApplySolToContainer();\n                    C3.clearArray(tempArr);\n                    return true\n                } else\n                    return false\n            },\n            CompareTouchSpeed(index, cmp, s) {\n                const touchInfo = this._GetTouchByIndex(index);\n                if (!touchInfo)\n                    return false;\n                return C3.compare(touchInfo.GetSpeed(), cmp, s)\n            },\n            OrientationSupported() {\n                return true\n            },\n            MotionSupported() {\n                return true\n            },\n            CompareOrientation(orientation, cmp, a) {\n                this._runtime.RequestDeviceOrientationEvent();\n                let v = 0;\n                if (orientation === 0)\n                    v = this._orientAlpha;\n                else if (orientation === 1)\n                    v = this._orientBeta;\n                else\n                    v = this._orientGamma;\n                return C3.compare(v, cmp, a)\n            },\n            CompareAcceleration(a, cmp, x) {\n                this._runtime.RequestDeviceMotionEvent();\n                let v = 0;\n                if (a === 0)\n                    v = this._accWithGX;\n                else if (a === 1)\n                    v = this._accWithGY;\n                else if (a === 2)\n                    v = this._accWithGZ;\n                else if (a === 3)\n                    v = this._accX;\n                else if (a === 4)\n                    v = this._accY;\n                else\n                    v = this._accZ;\n                return C3.compare(v, cmp, x)\n            },\n            OnNthTouchStart(index) {\n                index = Math.floor(index);\n                return index === this._triggerIndex\n            },\n            OnNthTouchEnd(index) {\n                index = Math.floor(index);\n                return index === this._triggerIndex\n            },\n            HasNthTouch(index) {\n                index = Math.floor(index);\n                return this._touches.size >= index + 1\n            },\n            OnHoldGesture() {\n                return true\n            },\n            OnTapGesture() {\n                return true\n            },\n            OnDoubleTapGesture() {\n                return true\n            },\n            OnHoldGestureObject(objectClass) {\n                if (!objectClass)\n                    return false;\n                if (!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY))\n                    return false;\n                return this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(objectClass, this._curTouchX, this._curTouchY, false)\n            },\n            OnTapGestureObject(objectClass) {\n                if (!objectClass)\n                    return false;\n                if (!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY))\n                    return false;\n                return this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(objectClass, this._curTouchX, this._curTouchY, false)\n            },\n            OnDoubleTapGestureObject(objectClass) {\n                if (!objectClass)\n                    return false;\n                if (!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY))\n                    return false;\n                return this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(objectClass, this._curTouchX, this._curTouchY, false)\n            },\n            OnPermissionGranted(type) {\n                return this._triggerPermission === type\n            },\n            OnPermissionDenied(type) {\n                return this._triggerPermission === type\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Touch.Acts = {\n            RequestPermission(type) {\n                this._RequestPermission(type)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Touch.Exps = {\n            TouchCount() {\n                return this._touches.size\n            },\n            X(layerParam) {\n                const touchInfo = this._GetTouchByIndex(this._getTouchIndex);\n                if (!touchInfo)\n                    return 0;\n                return touchInfo.GetPositionForLayer(this._runtime.GetCurrentLayout(), layerParam, true)\n            },\n            Y(layerParam) {\n                const touchInfo = this._GetTouchByIndex(this._getTouchIndex);\n                if (!touchInfo)\n                    return 0;\n                return touchInfo.GetPositionForLayer(this._runtime.GetCurrentLayout(), layerParam, false)\n            },\n            XAt(index, layerParam) {\n                const touchInfo = this._GetTouchByIndex(index);\n                if (!touchInfo)\n                    return 0;\n                return touchInfo.GetPositionForLayer(this._runtime.GetCurrentLayout(), layerParam, true)\n            },\n            YAt(index, layerParam) {\n                const touchInfo = this._GetTouchByIndex(index);\n                if (!touchInfo)\n                    return 0;\n                return touchInfo.GetPositionForLayer(this._runtime.GetCurrentLayout(), layerParam, false)\n            },\n            XForID(id, layerParam) {\n                const touchInfo = this._touches.get(id);\n                if (!touchInfo)\n                    return 0;\n                return touchInfo.GetPositionForLayer(this._runtime.GetCurrentLayout(), layerParam, true)\n            },\n            YForID(id, layerParam) {\n                const touchInfo = this._touches.get(id);\n                if (!touchInfo)\n                    return 0;\n                return touchInfo.GetPositionForLayer(this._runtime.GetCurrentLayout(), layerParam, false)\n            },\n            AbsoluteX() {\n                const touchInfo = this._GetTouchByIndex(0);\n                if (touchInfo)\n                    return touchInfo.GetX();\n                else\n                    return 0\n            },\n            AbsoluteY() {\n                const touchInfo = this._GetTouchByIndex(0);\n                if (touchInfo)\n                    return touchInfo.GetY();\n                else\n                    return 0\n            },\n            AbsoluteXAt(index) {\n                const touchInfo = this._GetTouchByIndex(index);\n                if (touchInfo)\n                    return touchInfo.GetX();\n                else\n                    return 0\n            },\n            AbsoluteYAt(index) {\n                const touchInfo = this._GetTouchByIndex(index);\n                if (touchInfo)\n                    return touchInfo.GetY();\n                else\n                    return 0\n            },\n            AbsoluteXForID(id) {\n                const touchInfo = this._touches.get(id);\n                if (touchInfo)\n                    return touchInfo.GetX();\n                else\n                    return 0\n            },\n            AbsoluteYForID(id) {\n                const touchInfo = this._touches.get(id);\n                if (touchInfo)\n                    return touchInfo.GetY();\n                else\n                    return 0\n            },\n            SpeedAt(index) {\n                const touchInfo = this._GetTouchByIndex(index);\n                if (touchInfo)\n                    return touchInfo.GetSpeed();\n                else\n                    return 0\n            },\n            SpeedForID(id) {\n                const touchInfo = this._touches.get(id);\n                if (touchInfo)\n                    return touchInfo.GetSpeed();\n                else\n                    return 0\n            },\n            AngleAt(index) {\n                const touchInfo = this._GetTouchByIndex(index);\n                if (touchInfo)\n                    return C3.toDegrees(touchInfo.GetAngle());\n                else\n                    return 0\n            },\n            AngleForID(id) {\n                const touchInfo = this._touches.get(id);\n                if (touchInfo)\n                    return C3.toDegrees(touchInfo.GetAngle());\n                else\n                    return 0\n            },\n            CompassHeading() {\n                this._runtime.RequestDeviceOrientationEvent();\n                return this._orientCompassHeading\n            },\n            Alpha() {\n                this._runtime.RequestDeviceOrientationEvent();\n                return this._orientAlpha\n            },\n            Beta() {\n                this._runtime.RequestDeviceOrientationEvent();\n                return this._orientBeta\n            },\n            Gamma() {\n                this._runtime.RequestDeviceOrientationEvent();\n                return this._orientGamma\n            },\n            AccelerationXWithG() {\n                this._runtime.RequestDeviceMotionEvent();\n                return this._accWithGX\n            },\n            AccelerationYWithG() {\n                this._runtime.RequestDeviceMotionEvent();\n                return this._accWithGY\n            },\n            AccelerationZWithG() {\n                this._runtime.RequestDeviceMotionEvent();\n                return this._accWithGZ\n            },\n            AccelerationX() {\n                this._runtime.RequestDeviceMotionEvent();\n                return this._accX\n            },\n            AccelerationY() {\n                this._runtime.RequestDeviceMotionEvent();\n                return this._accY\n            },\n            AccelerationZ() {\n                this._runtime.RequestDeviceMotionEvent();\n                return this._accZ\n            },\n            TouchIndex() {\n                return this._triggerIndex\n            },\n            TouchID() {\n                return this._triggerId\n            },\n            WidthForID(id) {\n                const touchInfo = this._touches.get(id);\n                if (touchInfo)\n                    return touchInfo.GetWidth();\n                else\n                    return 0\n            },\n            HeightForID(id) {\n                const touchInfo = this._touches.get(id);\n                if (touchInfo)\n                    return touchInfo.GetHeight();\n                else\n                    return 0\n            },\n            PressureForID(id) {\n                const touchInfo = this._touches.get(id);\n                if (touchInfo)\n                    return touchInfo.GetPressure();\n                else\n                    return 0\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const GESTURE_HOLD_THRESHOLD = 15;\n    const GESTURE_HOLD_TIMEOUT = 500;\n    const GESTURE_TAP_TIMEOUT = 333;\n    const GESTURE_DOUBLETAP_THRESHOLD = 25;\n    let lastTapX = -1E3;\n    let lastTapY = -1E3;\n    let lastTapTime = -1E4;\n    C3.Plugins.Touch.TouchInfo = class TouchInfo extends C3.DefendedBase {\n        constructor() {\n            super();\n            this._pointerId = 0;\n            this._startIndex = 0;\n            this._startTime = 0;\n            this._time = 0;\n            this._lastTime = 0;\n            this._startX = 0;\n            this._startY = 0;\n            this._x = 0;\n            this._y = 0;\n            this._lastX = 0;\n            this._lastY = 0;\n            this._width = 0;\n            this._height = 0;\n            this._pressure = 0;\n            this._hasTriggeredHold = false;\n            this._isTooFarForHold = false\n        }\n        Release() {}\n        Init(nowTime, x, y, id, index) {\n            this._pointerId = id;\n            this._startIndex = index;\n            this._time = nowTime;\n            this._lastTime = nowTime;\n            this._startTime = nowTime;\n            this._startX = x;\n            this._startY = y;\n            this._x = x;\n            this._y = y;\n            this._lastX = x;\n            this._lastY = y\n        }\n        Update(nowTime, x, y, width, height, pressure) {\n            this._lastTime = this._time;\n            this._time = nowTime;\n            this._lastX = this._x;\n            this._lastY = this._y;\n            this._x = x;\n            this._y = y;\n            this._width = width;\n            this._height = height;\n            this._pressure = pressure;\n            if (!this._isTooFarForHold && C3.distanceTo(this._startX, this._startY, this._x, this._y) >= GESTURE_HOLD_THRESHOLD)\n                this._isTooFarForHold = true\n        }\n        GetId() {\n            return this._pointerId\n        }\n        GetStartIndex() {\n            return this._startIndex\n        }\n        GetTime() {\n            return this._time\n        }\n        _SetLastTime(t) {\n            this._lastTime = t\n        }\n        GetX() {\n            return this._x\n        }\n        GetY() {\n            return this._y\n        }\n        GetSpeed() {\n            const dist = C3.distanceTo(this._x, this._y, this._lastX, this._lastY);\n            const dt = (this._time - this._lastTime) \/ 1E3;\n            if (dt > 0)\n                return dist \/ dt;\n            else\n                return 0\n        }\n        GetAngle() {\n            return C3.angleTo(this._lastX, this._lastY, this._x, this._y)\n        }\n        GetWidth() {\n            return this._width\n        }\n        GetHeight() {\n            return this._height\n        }\n        GetPressure() {\n            return this._pressure\n        }\n        ShouldTriggerHold(nowTime) {\n            if (this._hasTriggeredHold)\n                return false;\n            if (nowTime - this._startTime >= GESTURE_HOLD_TIMEOUT && !this._isTooFarForHold && C3.distanceTo(this._startX, this._startY, this._x, this._y) < GESTURE_HOLD_THRESHOLD) {\n                this._hasTriggeredHold = true;\n                return true\n            }\n            return false\n        }\n        ShouldTriggerTap(nowTime) {\n            if (this._hasTriggeredHold)\n                return "";\n            if (nowTime - this._startTime <= GESTURE_TAP_TIMEOUT && !this._isTooFarForHold && C3.distanceTo(this._startX, this._startY, this._x, this._y) < GESTURE_HOLD_THRESHOLD)\n                if (nowTime - lastTapTime <= GESTURE_TAP_TIMEOUT * 2 && C3.distanceTo(lastTapX, lastTapY, this._x, this._y) < GESTURE_DOUBLETAP_THRESHOLD) {\n                    lastTapX = -1E3;\n                    lastTapY = -1E3;\n                    lastTapTime = -1E4;\n                    return "double-tap"\n                } else {\n                    lastTapX = this._x;\n                    lastTapY = this._y;\n                    lastTapTime = nowTime;\n                    return "single-tap"\n                }\n            return ""\n        }\n        GetPositionForLayer(layout, layerNameOrNumber, getx) {\n            if (typeof layerNameOrNumber === "undefined") {\n                const layer = layout.GetLayerByIndex(0);\n                return layer.CanvasCssToLayer_DefaultTransform(this._x, this._y)[getx ? 0 : 1]\n            } else {\n                const layer = layout.GetLayer(layerNameOrNumber);\n                if (layer)\n                    return layer.CanvasCssToLayer(this._x, this._y)[getx ? 0 : 1];\n                else\n                    return 0\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        const actionPromises = [];\n        C3.Plugins.Audio = class AudioPlugin extends C3.SDKPluginBase {\n            constructor(opts) {\n                super(opts)\n            }\n            _AddActionPromise(promise) {\n                actionPromises.push(promise)\n            }\n            static async WaitForAllActionPromises() {\n                await Promise.all(actionPromises);\n                C3.clearArray(actionPromises)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        C3.Plugins.Audio.Type = class AudioType extends C3.SDKTypeBase {\n            constructor(objectClass) {\n                super(objectClass)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n            GetScriptInterfaceClass() {\n                return self.IAudioObjectType\n            }\n        }\n        ;\n        function GetAudioDOMInterface() {\n            if (self["C3Audio_DOMInterface"])\n                return self["C3Audio_DOMInterface"];\n            else\n                throw new Error("audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode");\n        }\n        self.IAudioObjectType = class IAudioObjectType extends self.IObjectClass {\n            constructor(objectType) {\n                super(objectType)\n            }\n            get audioContext() {\n                return GetAudioDOMInterface().GetAudioContext()\n            }\n            get destinationNode() {\n                return GetAudioDOMInterface().GetDestinationNode()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const DOM_COMPONENT_ID = "audio";\n        const LATENCY_HINTS = ["interactive", "balanced", "playback"];\n        C3.Plugins.Audio.Instance = class AudioInstance extends C3.SDKInstanceBase {\n            constructor(inst, properties) {\n                super(inst, DOM_COMPONENT_ID);\n                this._nextPlayTime = 0;\n                this._triggerTag = "";\n                this._timeScaleMode = 0;\n                this._saveLoadMode = 0;\n                this._playInBackground = false;\n                this._panningModel = 1;\n                this._distanceModel = 1;\n                this._listenerX = this._runtime.GetViewportWidth() \/ 2;\n                this._listenerY = this._runtime.GetViewportHeight() \/ 2;\n                this._listenerZ = -600;\n                this._referenceDistance = 600;\n                this._maxDistance = 1E4;\n                this._rolloffFactor = 1;\n                this._listenerInst = null;\n                this._loadListenerUid = -1;\n                this._masterVolume = 1;\n                this._isSilent = false;\n                this._sampleRate = 0;\n                this._audioContextState = "suspended";\n                this._effectCount = new Map;\n                this._preloadTotal = 0;\n                this._preloadCount = 0;\n                this._remoteUrls = new Map;\n                let latencyHint = "interactive";\n                if (properties) {\n                    this._timeScaleMode = properties[0];\n                    this._saveLoadMode = properties[1];\n                    this._playInBackground = properties[2];\n                    latencyHint = LATENCY_HINTS[properties[3]];\n                    this._panningModel = properties[4];\n                    this._distanceModel = properties[5];\n                    this._listenerZ = -properties[6];\n                    this._referenceDistance = properties[7];\n                    this._maxDistance = properties[8];\n                    this._rolloffFactor = properties[9]\n                }\n                this._lastAIState = [];\n                this._lastFxState = [];\n                this._lastAnalysersData = [];\n                this.AddDOMMessageHandlers([["state", e => this._OnUpdateState(e)], ["audiocontext-state", e => this._OnAudioContextStateChanged(e)], ["fxstate", e => this._OnUpdateFxState(e)], ["trigger", e => this._OnTrigger(e)]]);\n                const rt = this.GetRuntime().Dispatcher();\n                this._disposables = new C3.CompositeDisposable(C3.Disposable.From(rt, "instancedestroy", e => this._OnInstanceDestroyed(e.instance)),C3.Disposable.From(rt, "afterload", () => this._OnAfterLoad()),C3.Disposable.From(rt, "suspend", () => this._OnSuspend()),C3.Disposable.From(rt, "resume", () => this._OnResume()));\n                this._runtime.AddLoadPromise(this.PostToDOMAsync("create-audio-context", {\n                    "preloadList": this._runtime.GetAssetManager().GetAudioToPreload().map(o => ({\n                        "originalUrl": o.originalUrl,\n                        "url": o.url,\n                        "type": o.type,\n                        "fileSize": o.fileSize\n                    })),\n                    "isiOSCordova": this._runtime.IsiOSCordova(),\n                    "timeScaleMode": this._timeScaleMode,\n                    "latencyHint": latencyHint,\n                    "panningModel": this._panningModel,\n                    "distanceModel": this._distanceModel,\n                    "refDistance": this._referenceDistance,\n                    "maxDistance": this._maxDistance,\n                    "rolloffFactor": this._rolloffFactor,\n                    "listenerPos": [this._listenerX, this._listenerY, this._listenerZ]\n                }).then(info => {\n                    this._sampleRate = info["sampleRate"];\n                    this._audioContextState = info["audioContextState"]\n                }\n                ));\n                this._StartTicking()\n            }\n            Release() {\n                this._listenerInst = null;\n                super.Release()\n            }\n            _AddActionPromise(promise) {\n                this.GetPlugin()._AddActionPromise(promise)\n            }\n            _OnInstanceDestroyed(inst) {\n                if (this._listenerInst === inst)\n                    this._listenerInst = null\n            }\n            DbToLinearNoCap(x) {\n                return Math.pow(10, x \/ 20)\n            }\n            DbToLinear(x) {\n                const v = this.DbToLinearNoCap(x);\n                if (!isFinite(v))\n                    return 0;\n                return Math.max(Math.min(v, 1), 0)\n            }\n            LinearToDbNoCap(x) {\n                return Math.log(x) \/ Math.log(10) * 20\n            }\n            LinearToDb(x) {\n                return this.LinearToDbNoCap(Math.max(Math.min(x, 1), 0))\n            }\n            _OnSuspend() {\n                if (this._playInBackground)\n                    return;\n                this.PostToDOM("set-suspended", {\n                    "isSuspended": true\n                })\n            }\n            _OnResume() {\n                if (this._playInBackground)\n                    return;\n                this.PostToDOM("set-suspended", {\n                    "isSuspended": false\n                })\n            }\n            _OnUpdateState(e) {\n                const tickCount = e["tickCount"];\n                const preservePlaceholders = this._lastAIState.filter(ai => ai.hasOwnProperty("placeholder") && (ai["placeholder"] > tickCount || ai["placeholder"] === -1));\n                this._lastAIState = e["audioInstances"];\n                this._lastAnalysersData = e["analysers"];\n                if (preservePlaceholders.length > 0)\n                    C3.appendArray(this._lastAIState, preservePlaceholders)\n            }\n            _OnAudioContextStateChanged(e) {\n                this._audioContextState = e["audioContextState"]\n            }\n            GetAudioContextState() {\n                if (this._runtime.IsExportToVideo())\n                    return "running";\n                else\n                    return this._audioContextState\n            }\n            _OnUpdateFxState(e) {\n                this._lastFxState = e["fxstate"]\n            }\n            _GetFirstAudioStateByTag(tag) {\n                for (const a of this._lastAIState)\n                    if (C3.equalsNoCase(a["tag"], tag))\n                        return a;\n                return null\n            }\n            _IsTagPlaying(tag) {\n                return this._lastAIState.some(ai => C3.equalsNoCase(tag, ai["tag"]) && ai["isPlaying"])\n            }\n            _MaybeMarkAsPlaying(tag, isMusic, isLooping, vol) {\n                if (this._IsTagPlaying(tag))\n                    return null;\n                const state = {\n                    "tag": tag,\n                    "duration": 0,\n                    "volume": vol,\n                    "isPlaying": true,\n                    "playbackTime": 0,\n                    "playbackRate": 1,\n                    "uid": -1,\n                    "bufferOriginalUrl": "",\n                    "bufferUrl": "",\n                    "bufferType": "",\n                    "isMusic": isMusic,\n                    "isLooping": isLooping,\n                    "isMuted": false,\n                    "resumePosition": 0,\n                    "pan": null,\n                    "placeholder": -1\n                };\n                this._lastAIState.push(state);\n                return state\n            }\n            async _OnTrigger(e) {\n                const type = e["type"];\n                this._triggerTag = e["tag"];\n                const aiId = e["aiid"];\n                if (type === "ended") {\n                    for (const aiState of this._lastAIState)\n                        if (aiState["aiid"] === aiId) {\n                            aiState["isPlaying"] = false;\n                            break\n                        }\n                    await this.TriggerAsync(C3.Plugins.Audio.Cnds.OnEnded)\n                } else if (type === "fade-ended")\n                    await this.TriggerAsync(C3.Plugins.Audio.Cnds.OnFadeEnded)\n            }\n            Tick() {\n                const o = {\n                    "timeScale": this._runtime.GetTimeScale(),\n                    "gameTime": this._runtime.GetGameTimeRaw(),\n                    "instPans": this.GetInstancePans(),\n                    "tickCount": this._runtime.GetTickCountNoSave()\n                };\n                if (this._listenerInst) {\n                    const wi = this._listenerInst.GetWorldInfo();\n                    this._listenerX = wi.GetX();\n                    this._listenerY = wi.GetY();\n                    o["listenerPos"] = [this._listenerX, this._listenerY, this._listenerZ]\n                }\n                this.PostToDOM("tick", o)\n            }\n            rotatePtAround(px, py, a, ox, oy) {\n                if (a === 0)\n                    return [px, py];\n                const sin_a = Math.sin(a);\n                const cos_a = Math.cos(a);\n                px -= ox;\n                py -= oy;\n                const left_sin_a = px * sin_a;\n                const top_sin_a = py * sin_a;\n                const left_cos_a = px * cos_a;\n                const top_cos_a = py * cos_a;\n                px = left_cos_a - top_sin_a;\n                py = top_cos_a + left_sin_a;\n                px += ox;\n                py += oy;\n                return [px, py]\n            }\n            GetInstancePans() {\n                return this._lastAIState.filter(ai => ai["uid"] !== -1).map(ai => this._runtime.GetInstanceByUID(ai["uid"])).filter(inst => inst).map(inst => {\n                    const wi = inst.GetWorldInfo();\n                    const layerAngle = wi.GetLayer().GetAngle();\n                    const [x,y] = this.rotatePtAround(wi.GetX(), wi.GetY(), -layerAngle, this._listenerX, this._listenerY);\n                    return {\n                        "uid": inst.GetUID(),\n                        "x": x,\n                        "y": y,\n                        "angle": wi.GetAngle() - layerAngle\n                    }\n                }\n                )\n            }\n            GetAnalyserData(tag, index) {\n                for (const o of this._lastAnalysersData)\n                    if (o.index === index && C3.equalsNoCase(o.tag, tag))\n                        return o;\n                return null\n            }\n            _IncrementEffectCount(tag) {\n                this._effectCount.set(tag, (this._effectCount.get(tag) || 0) + 1)\n            }\n            _ShouldSave(ai) {\n                if (ai.hasOwnProperty("placeholder"))\n                    return false;\n                if (this._saveLoadMode === 3)\n                    return false;\n                else if (ai["isMusic"] && this._saveLoadMode === 1)\n                    return false;\n                else if (!ai["isMusic"] && this._saveLoadMode === 2)\n                    return false;\n                else\n                    return true\n            }\n            SaveToJson() {\n                return {\n                    "isSilent": this._isSilent,\n                    "masterVolume": this._masterVolume,\n                    "listenerZ": this._listenerZ,\n                    "listenerUid": this._listenerInst ? this._listenerInst.GetUID() : -1,\n                    "remoteUrls": [...this._remoteUrls.entries()],\n                    "playing": this._lastAIState.filter(ai => this._ShouldSave(ai)),\n                    "effects": this._lastFxState,\n                    "analysers": this._lastAnalysersData\n                }\n            }\n            LoadFromJson(o) {\n                this._isSilent = o["isSilent"];\n                this._masterVolume = o["masterVolume"];\n                this._listenerZ = o["listenerZ"];\n                this._listenerInst = null;\n                this._loadListenerUid = o["listenerUid"];\n                this._remoteUrls.clear();\n                if (o["remoteUrls"])\n                    for (const [k,v] of o["remoteUrls"])\n                        this._remoteUrls.set(k, v);\n                this._lastAIState = o["playing"];\n                this._lastFxState = o["effects"];\n                this._lastAnalysersData = o["analysers"]\n            }\n            _OnAfterLoad() {\n                if (this._loadListenerUid !== -1) {\n                    this._listenerInst = this._runtime.GetInstanceByUID(this._loadListenerUid);\n                    this._loadListenerUid = -1;\n                    if (this._listenerInst) {\n                        const wi = this._listenerInst.GetWorldInfo();\n                        this._listenerX = wi.GetX();\n                        this._listenerY = wi.GetY()\n                    }\n                }\n                for (const ai of this._lastAIState) {\n                    const info = this._runtime.GetAssetManager().GetProjectAudioFileUrl(ai["bufferOriginalUrl"]);\n                    if (info) {\n                        ai["bufferUrl"] = info.url;\n                        ai["bufferType"] = info.type\n                    } else\n                        ai["bufferUrl"] = null\n                }\n                for (const fxChainData of Object.values(this._lastFxState))\n                    for (const fxData of fxChainData)\n                        if (fxData.hasOwnProperty("bufferOriginalUrl")) {\n                            const info = this._runtime.GetAssetManager().GetProjectAudioFileUrl(fxData["bufferOriginalUrl"]);\n                            if (info) {\n                                fxData["bufferUrl"] = info.url;\n                                fxData["bufferType"] = info.type\n                            }\n                        }\n                this.PostToDOM("load-state", {\n                    "saveLoadMode": this._saveLoadMode,\n                    "timeScale": this._runtime.GetTimeScale(),\n                    "gameTime": this._runtime.GetGameTimeRaw(),\n                    "listenerPos": [this._listenerX, this._listenerY, this._listenerZ],\n                    "isSilent": this._isSilent,\n                    "masterVolume": this._masterVolume,\n                    "playing": this._lastAIState.filter(ai => ai["bufferUrl"] !== null),\n                    "effects": this._lastFxState\n                })\n            }\n            GetDebuggerProperties() {\n                const fxProps = [];\n                for (const [tag,fxChainData] of Object.entries(this._lastFxState))\n                    fxProps.push({\n                        name: "$" + tag,\n                        value: fxChainData.map(d => d["type"]).join(", ")\n                    });\n                const prefix = "plugins.audio.debugger";\n                return [{\n                    title: prefix + ".tag-effects",\n                    properties: fxProps\n                }, {\n                    title: prefix + ".currently-playing",\n                    properties: [{\n                        name: prefix + ".currently-playing-count",\n                        value: this._lastAIState.length\n                    }, ...this._lastAIState.map( (s, index) => ({\n                        name: "$#" + index,\n                        value: `${s["bufferOriginalUrl"]} ("${s["tag"]}") ${Math.round(s["playbackTime"] * 10) \/ 10} \/ ${Math.round(s["duration"] * 10) \/ 10}`\n                    }))]\n                }]\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Audio.Cnds = {\n            OnEnded(tag) {\n                return C3.equalsNoCase(this._triggerTag, tag)\n            },\n            OnFadeEnded(tag) {\n                return C3.equalsNoCase(this._triggerTag, tag)\n            },\n            PreloadsComplete() {\n                return this._preloadCount === this._preloadTotal\n            },\n            AdvancedAudioSupported() {\n                return true\n            },\n            IsSilent() {\n                return this._isSilent\n            },\n            IsAnyPlaying() {\n                for (const ai of this._lastAIState)\n                    if (ai["isPlaying"])\n                        return true;\n                return false\n            },\n            IsTagPlaying(tag) {\n                return this._IsTagPlaying(tag)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const FILTER_TYPES = ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "peaking", "notch", "allpass"];\n        C3.Plugins.Audio.Acts = {\n            Play(file, looping, vol, tag, startOffset) {\n                const ret = C3.Plugins.Audio.Acts._DoPlay.call(this, file, looping, vol, tag, startOffset);\n                this._AddActionPromise(ret);\n                return ret\n            },\n            async _DoPlay(file, looping, vol, tag, startOffset) {\n                if (this._isSilent)\n                    return;\n                const isMusic = file[1];\n                const info = this._runtime.GetAssetManager().GetProjectAudioFileUrl(file[0]);\n                if (!info)\n                    return;\n                startOffset = startOffset ? startOffset : 0;\n                const nextPlayTime = this._nextPlayTime;\n                this._nextPlayTime = 0;\n                const state = this._MaybeMarkAsPlaying(tag.toLowerCase(), isMusic, looping !== 0, this.DbToLinear(vol));\n                try {\n                    await this.PostToDOMAsync("play", {\n                        "originalUrl": file[0],\n                        "url": info.url,\n                        "type": info.type,\n                        "isMusic": isMusic,\n                        "tag": tag.toLowerCase(),\n                        "isLooping": looping !== 0,\n                        "vol": this.DbToLinear(vol),\n                        "pos": startOffset,\n                        "off": nextPlayTime,\n                        "trueClock": !!self["C3_GetAudioContextCurrentTime"]\n                    })\n                } finally {\n                    if (state)\n                        state["placeholder"] = this._runtime.GetTickCountNoSave()\n                }\n            },\n            async PlayAtPosition(file, looping, vol, x, y, angle, innerAngle, outerAngle, outerGain, tag) {\n                if (this._isSilent)\n                    return;\n                const isMusic = file[1];\n                const info = this._runtime.GetAssetManager().GetProjectAudioFileUrl(file[0]);\n                if (!info)\n                    return;\n                const nextPlayTime = this._nextPlayTime;\n                this._nextPlayTime = 0;\n                const state = this._MaybeMarkAsPlaying(tag.toLowerCase(), isMusic, looping !== 0, this.DbToLinear(vol));\n                try {\n                    await this.PostToDOMAsync("play", {\n                        "originalUrl": file[0],\n                        "url": info.url,\n                        "type": info.type,\n                        "isMusic": isMusic,\n                        "tag": tag.toLowerCase(),\n                        "isLooping": looping !== 0,\n                        "vol": this.DbToLinear(vol),\n                        "pos": 0,\n                        "off": nextPlayTime,\n                        "trueClock": !!self["C3_GetAudioContextCurrentTime"],\n                        "panning": {\n                            "x": x,\n                            "y": y,\n                            "angle": C3.toRadians(angle),\n                            "innerAngle": C3.toRadians(innerAngle),\n                            "outerAngle": C3.toRadians(outerAngle),\n                            "outerGain": this.DbToLinear(outerGain)\n                        }\n                    })\n                } finally {\n                    if (state)\n                        state["placeholder"] = this._runtime.GetTickCountNoSave()\n                }\n            },\n            async PlayAtObject(file, looping, vol, objectClass, innerAngle, outerAngle, outerGain, tag) {\n                if (this._isSilent)\n                    return;\n                if (!objectClass)\n                    return;\n                const inst = objectClass.GetFirstPicked();\n                if (!inst || !inst.GetWorldInfo())\n                    return;\n                const wi = inst.GetWorldInfo();\n                const layerAngle = wi.GetLayer().GetAngle();\n                const [x,y] = this.rotatePtAround(wi.GetX(), wi.GetY(), -layerAngle, this._listenerX, this._listenerY);\n                const isMusic = file[1];\n                const info = this._runtime.GetAssetManager().GetProjectAudioFileUrl(file[0]);\n                if (!info)\n                    return;\n                const nextPlayTime = this._nextPlayTime;\n                this._nextPlayTime = 0;\n                const state = this._MaybeMarkAsPlaying(tag.toLowerCase(), isMusic, looping !== 0, this.DbToLinear(vol));\n                try {\n                    await this.PostToDOMAsync("play", {\n                        "originalUrl": file[0],\n                        "url": info.url,\n                        "type": info.type,\n                        "isMusic": isMusic,\n                        "tag": tag.toLowerCase(),\n                        "isLooping": looping !== 0,\n                        "vol": this.DbToLinear(vol),\n                        "pos": 0,\n                        "off": nextPlayTime,\n                        "trueClock": !!self["C3_GetAudioContextCurrentTime"],\n                        "panning": {\n                            "x": x,\n                            "y": y,\n                            "angle": wi.GetAngle() - layerAngle,\n                            "innerAngle": C3.toRadians(innerAngle),\n                            "outerAngle": C3.toRadians(outerAngle),\n                            "outerGain": this.DbToLinear(outerGain),\n                            "uid": inst.GetUID()\n                        }\n                    })\n                } finally {\n                    if (state)\n                        state["placeholder"] = this._runtime.GetTickCountNoSave()\n                }\n            },\n            async PlayByName(folder, filename, looping, vol, tag) {\n                if (this._isSilent)\n                    return;\n                const isMusic = folder === 1;\n                const info = this._runtime.GetAssetManager().GetProjectAudioFileUrl(filename) || this._remoteUrls.get(filename.toLowerCase());\n                if (!info)\n                    return;\n                const nextPlayTime = this._nextPlayTime;\n                this._nextPlayTime = 0;\n                const state = this._MaybeMarkAsPlaying(tag.toLowerCase(), isMusic, looping !== 0, this.DbToLinear(vol));\n                try {\n                    await this.PostToDOMAsync("play", {\n                        "originalUrl": filename,\n                        "url": info.url,\n                        "type": info.type,\n                        "isMusic": isMusic,\n                        "tag": tag.toLowerCase(),\n                        "isLooping": looping !== 0,\n                        "vol": this.DbToLinear(vol),\n                        "pos": 0,\n                        "off": nextPlayTime,\n                        "trueClock": !!self["C3_GetAudioContextCurrentTime"]\n                    })\n                } finally {\n                    if (state)\n                        state["placeholder"] = this._runtime.GetTickCountNoSave()\n                }\n            },\n            async PlayAtPositionByName(folder, filename, looping, vol, x, y, angle, innerAngle, outerAngle, outerGain, tag) {\n                if (this._isSilent)\n                    return;\n                const isMusic = folder === 1;\n                const info = this._runtime.GetAssetManager().GetProjectAudioFileUrl(filename) || this._remoteUrls.get(filename.toLowerCase());\n                if (!info)\n                    return;\n                const nextPlayTime = this._nextPlayTime;\n                this._nextPlayTime = 0;\n                const state = this._MaybeMarkAsPlaying(tag.toLowerCase(), isMusic, looping !== 0, this.DbToLinear(vol));\n                try {\n                    await this.PostToDOMAsync("play", {\n                        "originalUrl": filename,\n                        "url": info.url,\n                        "type": info.type,\n                        "isMusic": isMusic,\n                        "tag": tag.toLowerCase(),\n                        "isLooping": looping !== 0,\n                        "vol": this.DbToLinear(vol),\n                        "pos": 0,\n                        "off": nextPlayTime,\n                        "trueClock": !!self["C3_GetAudioContextCurrentTime"],\n                        "panning": {\n                            "x": x,\n                            "y": y,\n                            "angle": C3.toRadians(angle),\n                            "innerAngle": C3.toRadians(innerAngle),\n                            "outerAngle": C3.toRadians(outerAngle),\n                            "outerGain": this.DbToLinear(outerGain)\n                        }\n                    })\n                } finally {\n                    if (state)\n                        state["placeholder"] = this._runtime.GetTickCountNoSave()\n                }\n            },\n            async PlayAtObjectByName(folder, filename, looping, vol, objectClass, innerAngle, outerAngle, outerGain, tag) {\n                if (this._isSilent)\n                    return;\n                if (this._isSilent)\n                    return;\n                if (!objectClass)\n                    return;\n                const inst = objectClass.GetFirstPicked();\n                if (!inst || !inst.GetWorldInfo())\n                    return;\n                const wi = inst.GetWorldInfo();\n                const layerAngle = wi.GetLayer().GetAngle();\n                const [x,y] = this.rotatePtAround(wi.GetX(), wi.GetY(), -layerAngle, this._listenerX, this._listenerY);\n                const isMusic = folder === 1;\n                const info = this._runtime.GetAssetManager().GetProjectAudioFileUrl(filename) || this._remoteUrls.get(filename.toLowerCase());\n                if (!info)\n                    return;\n                const nextPlayTime = this._nextPlayTime;\n                this._nextPlayTime = 0;\n                const state = this._MaybeMarkAsPlaying(tag.toLowerCase(), isMusic, looping !== 0, this.DbToLinear(vol));\n                try {\n                    await this.PostToDOMAsync("play", {\n                        "originalUrl": filename,\n                        "url": info.url,\n                        "type": info.type,\n                        "isMusic": isMusic,\n                        "tag": tag.toLowerCase(),\n                        "isLooping": looping !== 0,\n                        "vol": this.DbToLinear(vol),\n                        "pos": 0,\n                        "off": nextPlayTime,\n                        "trueClock": !!self["C3_GetAudioContextCurrentTime"],\n                        "panning": {\n                            "x": x,\n                            "y": y,\n                            "angle": wi.GetAngle() - layerAngle,\n                            "innerAngle": C3.toRadians(innerAngle),\n                            "outerAngle": C3.toRadians(outerAngle),\n                            "outerGain": this.DbToLinear(outerGain),\n                            "uid": inst.GetUID()\n                        }\n                    })\n                } finally {\n                    if (state)\n                        state["placeholder"] = this._runtime.GetTickCountNoSave()\n                }\n            },\n            SetLooping(tag, looping) {\n                this.PostToDOM("set-looping", {\n                    "tag": tag.toLowerCase(),\n                    "isLooping": looping === 0\n                })\n            },\n            SetMuted(tag, muted) {\n                this.PostToDOM("set-muted", {\n                    "tag": tag.toLowerCase(),\n                    "isMuted": muted === 0\n                })\n            },\n            SetVolume(tag, vol) {\n                this.PostToDOM("set-volume", {\n                    "tag": tag.toLowerCase(),\n                    "vol": this.DbToLinear(vol)\n                })\n            },\n            FadeVolume(tag, vol, duration, ending) {\n                this.PostToDOM("fade-volume", {\n                    "tag": tag.toLowerCase(),\n                    "vol": this.DbToLinear(vol),\n                    "duration": duration,\n                    "stopOnEnd": ending === 0\n                })\n            },\n            async Preload(file) {\n                const isMusic = file[1];\n                const info = this._runtime.GetAssetManager().GetProjectAudioFileUrl(file[0]);\n                if (!info)\n                    return;\n                this._preloadTotal++;\n                await this.PostToDOMAsync("preload", {\n                    "originalUrl": file[0],\n                    "url": info.url,\n                    "type": info.type,\n                    "isMusic": isMusic\n                });\n                this._preloadCount++\n            },\n            async PreloadByName(folder, filename) {\n                const isMusic = folder === 1;\n                const info = this._runtime.GetAssetManager().GetProjectAudioFileUrl(filename) || this._remoteUrls.get(filename.toLowerCase());\n                if (!info)\n                    return;\n                this._preloadTotal++;\n                await this.PostToDOMAsync("preload", {\n                    "originalUrl": filename,\n                    "url": info.url,\n                    "type": info.type,\n                    "isMusic": isMusic\n                });\n                this._preloadCount++\n            },\n            SetPlaybackRate(tag, rate) {\n                this.PostToDOM("set-playback-rate", {\n                    "tag": tag.toLowerCase(),\n                    "rate": Math.max(rate, 0)\n                })\n            },\n            Stop(tag) {\n                this.PostToDOM("stop", {\n                    "tag": tag.toLowerCase()\n                })\n            },\n            StopAll() {\n                this.PostToDOM("stop-all")\n            },\n            SetPaused(tag, state) {\n                this.PostToDOM("set-paused", {\n                    "tag": tag.toLowerCase(),\n                    "paused": state === 0\n                })\n            },\n            Seek(tag, pos) {\n                this.PostToDOM("seek", {\n                    "tag": tag.toLowerCase(),\n                    "pos": pos\n                })\n            },\n            SetSilent(s) {\n                if (s === 2)\n                    s = this._isSilent ? 1 : 0;\n                s = s === 0;\n                if (this._isSilent === s)\n                    return;\n                this._isSilent = s;\n                this.PostToDOM("set-silent", {\n                    "isSilent": s\n                })\n            },\n            SetMasterVolume(vol) {\n                const mv = this.DbToLinear(vol);\n                if (this._masterVolume === mv)\n                    return;\n                this._masterVolume = mv;\n                this.PostToDOM("set-master-volume", {\n                    "vol": mv\n                })\n            },\n            AddFilterEffect(tag, type, freq, detune, q, gain, mix) {\n                tag = tag.toLowerCase();\n                const typeStr = FILTER_TYPES[type];\n                this._IncrementEffectCount(tag);\n                this.PostToDOM("add-effect", {\n                    "type": "filter",\n                    "tag": tag,\n                    "params": [typeStr, freq, detune, q, gain, C3.clamp(mix \/ 100, 0, 1)]\n                })\n            },\n            AddDelayEffect(tag, delay, gain, mix) {\n                tag = tag.toLowerCase();\n                this._IncrementEffectCount(tag);\n                this.PostToDOM("add-effect", {\n                    "type": "delay",\n                    "tag": tag,\n                    "params": [delay, this.DbToLinear(gain), C3.clamp(mix \/ 100, 0, 1)]\n                })\n            },\n            AddFlangerEffect(tag, delay, modulation, freq, feedback, mix) {\n                tag = tag.toLowerCase();\n                this._IncrementEffectCount(tag);\n                this.PostToDOM("add-effect", {\n                    "type": "flanger",\n                    "tag": tag,\n                    "params": [delay \/ 1E3, modulation \/ 1E3, freq, feedback \/ 100, C3.clamp(mix \/ 100, 0, 1)]\n                })\n            },\n            AddPhaserEffect(tag, freq, detune, q, mod, modfreq, mix) {\n                tag = tag.toLowerCase();\n                this._IncrementEffectCount(tag);\n                this.PostToDOM("add-effect", {\n                    "type": "phaser",\n                    "tag": tag,\n                    "params": [freq, detune, q, mod, modfreq, C3.clamp(mix \/ 100, 0, 1)]\n                })\n            },\n            AddConvolutionEffect(tag, file, norm, mix) {\n                tag = tag.toLowerCase();\n                const info = this._runtime.GetAssetManager().GetProjectAudioFileUrl(file[0]);\n                if (!info)\n                    return;\n                this._IncrementEffectCount(tag);\n                this.PostToDOM("add-effect", {\n                    "type": "convolution",\n                    "tag": tag,\n                    "bufferOriginalUrl": file[0],\n                    "bufferUrl": info.url,\n                    "bufferType": info.type,\n                    "params": [norm === 0, C3.clamp(mix \/ 100, 0, 1)]\n                })\n            },\n            AddGainEffect(tag, g) {\n                tag = tag.toLowerCase();\n                this._IncrementEffectCount(tag);\n                this.PostToDOM("add-effect", {\n                    "type": "gain",\n                    "tag": tag,\n                    "params": [this.DbToLinear(g)]\n                })\n            },\n            AddMuteEffect(tag) {\n                tag = tag.toLowerCase();\n                this._IncrementEffectCount(tag);\n                this.PostToDOM("add-effect", {\n                    "type": "gain",\n                    "tag": tag,\n                    "params": [0]\n                })\n            },\n            AddTremoloEffect(tag, freq, mix) {\n                tag = tag.toLowerCase();\n                this._IncrementEffectCount(tag);\n                this.PostToDOM("add-effect", {\n                    "type": "tremolo",\n                    "tag": tag,\n                    "params": [freq, C3.clamp(mix \/ 100, 0, 1)]\n                })\n            },\n            AddRingModEffect(tag, freq, mix) {\n                tag = tag.toLowerCase();\n                this._IncrementEffectCount(tag);\n                this.PostToDOM("add-effect", {\n                    "type": "ringmod",\n                    "tag": tag,\n                    "params": [freq, C3.clamp(mix \/ 100, 0, 1)]\n                })\n            },\n            AddDistortionEffect(tag, threshold, headroom, drive, makeupgain, mix) {\n                tag = tag.toLowerCase();\n                this._IncrementEffectCount(tag);\n                this.PostToDOM("add-effect", {\n                    "type": "distortion",\n                    "tag": tag,\n                    "params": [this.DbToLinearNoCap(threshold), this.DbToLinearNoCap(headroom), drive, this.DbToLinearNoCap(makeupgain), C3.clamp(mix \/ 100, 0, 1)]\n                })\n            },\n            AddCompressorEffect(tag, threshold, knee, ratio, attack, release) {\n                tag = tag.toLowerCase();\n                this._IncrementEffectCount(tag);\n                this.PostToDOM("add-effect", {\n                    "type": "compressor",\n                    "tag": tag,\n                    "params": [threshold, knee, ratio, attack \/ 1E3, release \/ 1E3]\n                })\n            },\n            AddAnalyserEffect(tag, fftSize, smoothing) {\n                tag = tag.toLowerCase();\n                this._IncrementEffectCount(tag);\n                this.PostToDOM("add-effect", {\n                    "type": "analyser",\n                    "tag": tag,\n                    "params": [fftSize, smoothing]\n                })\n            },\n            RemoveEffects(tag) {\n                tag = tag.toLowerCase();\n                this._effectCount.set(tag, 0);\n                this.PostToDOM("remove-effects", {\n                    "tag": tag\n                });\n                this._lastFxState = {}\n            },\n            SetEffectParameter(tag, index, param, value, ramp, time) {\n                this.PostToDOM("set-effect-param", {\n                    "tag": tag.toLowerCase(),\n                    "index": Math.floor(index),\n                    "param": param,\n                    "value": value,\n                    "ramp": ramp,\n                    "time": time\n                })\n            },\n            SetListenerObject(objectClass) {\n                if (!objectClass)\n                    return;\n                const inst = objectClass.GetFirstPicked();\n                if (!inst || !inst.GetWorldInfo())\n                    return;\n                this._listenerInst = inst\n            },\n            SetListenerZ(z) {\n                this._listenerZ = z\n            },\n            ScheduleNextPlay(t) {\n                this._nextPlayTime = Math.max(t, 0)\n            },\n            UnloadAudio(file) {\n                const isMusic = file[1];\n                const info = this._runtime.GetAssetManager().GetProjectAudioFileUrl(file[0]);\n                if (!info)\n                    return;\n                this.PostToDOM("unload", {\n                    "url": info.url,\n                    "type": info.type,\n                    "isMusic": isMusic\n                })\n            },\n            UnloadAudioByName(folder, filename) {\n                const isMusic = folder === 1;\n                const info = this._runtime.GetAssetManager().GetProjectAudioFileUrl(filename) || this._remoteUrls.get(filename.toLowerCase());\n                if (!info)\n                    return;\n                this.PostToDOM("unload", {\n                    "url": info.url,\n                    "type": info.type,\n                    "isMusic": isMusic\n                })\n            },\n            UnloadAll() {\n                this.PostToDOM("unload-all")\n            },\n            AddRemoteURL(url, type, name) {\n                this._remoteUrls.set(name.toLowerCase(), {\n                    url,\n                    type\n                })\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Audio.Exps = {\n            Duration(tag) {\n                const a = this._GetFirstAudioStateByTag(tag);\n                return a ? a["duration"] : 0\n            },\n            PlaybackTime(tag) {\n                const a = this._GetFirstAudioStateByTag(tag);\n                return a ? a["playbackTime"] : 0\n            },\n            PlaybackRate(tag) {\n                const a = this._GetFirstAudioStateByTag(tag);\n                return a ? a["playbackRate"] : 0\n            },\n            Volume(tag) {\n                const a = this._GetFirstAudioStateByTag(tag);\n                return a ? this.LinearToDb(a["volume"]) : 0\n            },\n            MasterVolume() {\n                return this.LinearToDb(this._masterVolume)\n            },\n            EffectCount(tag) {\n                return this._effectCount.get(tag.toLowerCase()) || 0\n            },\n            AnalyserFreqBinCount(tag, index) {\n                const o = this.GetAnalyserData(tag, Math.floor(index));\n                return o ? o["binCount"] : 0\n            },\n            AnalyserFreqBinAt(tag, index, bin) {\n                const o = this.GetAnalyserData(tag, Math.floor(index));\n                if (!o)\n                    return 0;\n                bin = Math.floor(bin);\n                if (bin < 0 || bin >= o["binCount"])\n                    return 0;\n                return o["freqBins"][bin]\n            },\n            AnalyserPeakLevel(tag, index) {\n                const o = this.GetAnalyserData(tag, Math.floor(index));\n                return o ? o["peak"] : 0\n            },\n            AnalyserRMSLevel(tag, index) {\n                const o = this.GetAnalyserData(tag, Math.floor(index));\n                return o ? o["rms"] : 0\n            },\n            SampleRate() {\n                return this._sampleRate\n            },\n            CurrentTime() {\n                if (self["C3_GetAudioContextCurrentTime"])\n                    return self["C3_GetAudioContextCurrentTime"]();\n                else\n                    return performance.now() \/ 1E3\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Plugins.Browser = class BrowserPlugin extends C3.SDKPluginBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Browser.Type = class BrowserType extends C3.SDKTypeBase {\n            constructor(objectClass) {\n                super(objectClass)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const DOM_COMPONENT_ID = "browser";\n        C3.Plugins.Browser.Instance = class BrowserInstance extends C3.SDKInstanceBase {\n            constructor(inst, properties) {\n                super(inst, DOM_COMPONENT_ID);\n                this._initLocationStr = "";\n                this._isOnline = false;\n                this._referrer = "";\n                this._docTitle = "";\n                this._isCookieEnabled = false;\n                this._screenWidth = 0;\n                this._screenHeight = 0;\n                this._windowOuterWidth = 0;\n                this._windowOuterHeight = 0;\n                this._isConstructArcade = false;\n                this.AddDOMMessageHandlers([["online-state", e => this._OnOnlineStateChanged(e)], ["backbutton", () => this._OnBackButton()], ["sw-message", e => this._OnSWMessage(e)], ["hashchange", e => this._OnHashChange(e)]]);\n                const rt = this.GetRuntime().Dispatcher();\n                this._disposables = new C3.CompositeDisposable(C3.Disposable.From(rt, "afterfirstlayoutstart", () => this._OnAfterFirstLayoutStart()),C3.Disposable.From(rt, "window-resize", () => this._OnWindowResize()),C3.Disposable.From(rt, "suspend", () => this._OnSuspend()),C3.Disposable.From(rt, "resume", () => this._OnResume()));\n                this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state", {\n                    "exportType": this._runtime.GetExportType()\n                }).then(data => {\n                    this._initLocationStr = data["location"];\n                    this._isOnline = data["isOnline"];\n                    this._referrer = data["referrer"];\n                    this._docTitle = data["title"];\n                    this._isCookieEnabled = data["isCookieEnabled"];\n                    this._screenWidth = data["screenWidth"];\n                    this._screenHeight = data["screenHeight"];\n                    this._windowOuterWidth = data["windowOuterWidth"];\n                    this._windowOuterHeight = data["windowOuterHeight"];\n                    this._isConstructArcade = data["isConstructArcade"]\n                }\n                ))\n            }\n            Release() {\n                super.Release()\n            }\n            _OnAfterFirstLayoutStart() {\n                this.PostToDOM("ready-for-sw-messages")\n            }\n            async _OnOnlineStateChanged(e) {\n                const isOnline = !!e["isOnline"];\n                if (this._isOnline === isOnline)\n                    return;\n                this._isOnline = isOnline;\n                if (this._isOnline)\n                    await this.TriggerAsync(C3.Plugins.Browser.Cnds.OnOnline);\n                else\n                    await this.TriggerAsync(C3.Plugins.Browser.Cnds.OnOffline)\n            }\n            async _OnWindowResize() {\n                await this.TriggerAsync(C3.Plugins.Browser.Cnds.OnResize)\n            }\n            _OnSuspend() {\n                this.Trigger(C3.Plugins.Browser.Cnds.OnPageHidden)\n            }\n            _OnResume() {\n                this.Trigger(C3.Plugins.Browser.Cnds.OnPageVisible)\n            }\n            async _OnBackButton() {\n                await this.TriggerAsync(C3.Plugins.Browser.Cnds.OnBackButton)\n            }\n            _OnSWMessage(e) {\n                const messageType = e["type"];\n                if (messageType === "downloading-update")\n                    this.Trigger(C3.Plugins.Browser.Cnds.OnUpdateFound);\n                else if (messageType === "update-ready" || messageType === "update-pending")\n                    this.Trigger(C3.Plugins.Browser.Cnds.OnUpdateReady);\n                else if (messageType === "offline-ready")\n                    this.Trigger(C3.Plugins.Browser.Cnds.OnOfflineReady)\n            }\n            _OnHashChange(e) {\n                this._initLocationStr = e["location"];\n                this.Trigger(C3.Plugins.Browser.Cnds.OnHashChange)\n            }\n            GetDebuggerProperties() {\n                const prefix = "plugins.browser.debugger";\n                return [{\n                    title: "plugins.browser.name",\n                    properties: [{\n                        name: prefix + ".user-agent",\n                        value: navigator.userAgent\n                    }, {\n                        name: prefix + ".is-online",\n                        value: this._isOnline\n                    }, {\n                        name: prefix + ".is-fullscreen",\n                        value: this._runtime.GetCanvasManager().IsDocumentFullscreen()\n                    }]\n                }]\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Browser.Cnds = {\n            IsOnline() {\n                return this._isOnline\n            },\n            OnOnline() {\n                return true\n            },\n            OnOffline() {\n                return true\n            },\n            OnResize() {\n                return true\n            },\n            CookiesEnabled() {\n                return this._isCookieEnabled\n            },\n            IsFullscreen() {\n                return this._runtime.GetCanvasManager().IsDocumentFullscreen()\n            },\n            OnBackButton() {\n                return true\n            },\n            IsPortraitLandscape(p) {\n                const lastInnerWidth = this._runtime.GetCanvasManager().GetLastWidth();\n                const lastInnerHeight = this._runtime.GetCanvasManager().GetLastHeight();\n                const current = lastInnerWidth <= lastInnerHeight ? 0 : 1;\n                return current === p\n            },\n            OnUpdateFound() {\n                return true\n            },\n            OnUpdateReady() {\n                return true\n            },\n            OnOfflineReady() {\n                return true\n            },\n            OnHashChange() {\n                return true\n            },\n            PageVisible() {\n                return !this._runtime.IsSuspended()\n            },\n            OnPageHidden() {\n                return true\n            },\n            OnPageVisible() {\n                return true\n            },\n            HasJava() {\n                return false\n            },\n            IsDownloadingUpdate() {\n                return false\n            },\n            OnMenuButton() {\n                return false\n            },\n            OnSearchButton() {\n                return false\n            },\n            IsMetered() {\n                return false\n            },\n            IsCharging() {\n                return true\n            },\n            SupportsFullscreen() {\n                return true\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const ORIENTATIONS = ["portrait", "landscape", "portrait-primary", "portrait-secondary", "landscape-primary", "landscape-secondary"];\n        C3.Plugins.Browser.Acts = {\n            Alert(message) {\n                this.PostToDOM("alert", {\n                    "message": message.toString()\n                })\n            },\n            Close() {\n                if (this._isConstructArcade)\n                    return;\n                if (this._runtime.IsDebug())\n                    self.C3Debugger.CloseWindow();\n                else\n                    this.PostToDOM("close")\n            },\n            Focus() {\n                this.PostToDOM("set-focus", {\n                    "isFocus": true\n                })\n            },\n            Blur() {\n                this.PostToDOM("set-focus", {\n                    "isFocus": false\n                })\n            },\n            GoBack() {\n                if (this._isConstructArcade)\n                    return;\n                this.PostToDOM("navigate", {\n                    "type": "back"\n                })\n            },\n            GoForward() {\n                if (this._isConstructArcade)\n                    return;\n                this.PostToDOM("navigate", {\n                    "type": "forward"\n                })\n            },\n            GoHome() {},\n            Reload() {\n                if (this._isConstructArcade)\n                    return;\n                if (this._runtime.IsDebug())\n                    this._runtime.PostToDebugger({\n                        "type": "reload"\n                    });\n                else\n                    this.PostToDOM("navigate", {\n                        "type": "reload"\n                    })\n            },\n            GoToURL(url, target) {\n                this._PostToDOMMaybeSync("navigate", {\n                    "type": "url",\n                    "url": url,\n                    "target": target,\n                    "exportType": this._runtime.GetExportType()\n                })\n            },\n            GoToURLWindow(url, tag) {\n                this._PostToDOMMaybeSync("navigate", {\n                    "type": "new-window",\n                    "url": url,\n                    "tag": tag,\n                    "exportType": this._runtime.GetExportType()\n                })\n            },\n            RequestFullScreen(mode, navUi) {\n                if (mode >= 2)\n                    mode += 1;\n                if (mode === 6)\n                    mode = 2;\n                if (mode === 1)\n                    mode = 0;\n                const modeStr = C3.CanvasManager._FullscreenModeNumberToString(mode);\n                this._runtime.GetCanvasManager().SetDocumentFullscreenMode(modeStr);\n                this._PostToDOMMaybeSync("request-fullscreen", {\n                    "navUI": navUi\n                })\n            },\n            CancelFullScreen() {\n                this._PostToDOMMaybeSync("exit-fullscreen")\n            },\n            Vibrate(pattern) {\n                const arr = pattern.split(",");\n                for (let i = 0, len = arr.length; i < len; ++i)\n                    arr[i] = parseInt(arr[i], 10);\n                this._PostToDOMMaybeSync("vibrate", {\n                    "pattern": arr\n                })\n            },\n            async InvokeDownload(url, filename) {\n                if (!url || !filename)\n                    return;\n                const urlToDownload = await this._runtime.GetAssetManager().GetProjectFileUrl(url);\n                this._runtime.InvokeDownload(urlToDownload, filename)\n            },\n            InvokeDownloadString(str, mimeType, filename) {\n                if (!filename)\n                    return;\n                const dataUri = `data:${mimeType},${encodeURIComponent(str)}`;\n                this._runtime.InvokeDownload(dataUri, filename)\n            },\n            ConsoleLog(type, msg) {\n                msg = msg.toString();\n                if (type === 0)\n                    console.log(msg);\n                else if (type === 1)\n                    console.warn(msg);\n                else if (type === 2)\n                    console.error(msg)\n            },\n            ConsoleGroup(name) {\n                console.group(name)\n            },\n            ConsoleGroupEnd() {\n                console.groupEnd()\n            },\n            ExecJs(jsStr) {\n                try {\n                    eval(jsStr)\n                } catch (err) {\n                    console.error("Error executing JavaScript: ", err)\n                }\n            },\n            LockOrientation(o) {\n                o = Math.floor(o);\n                if (o < 0 || o >= ORIENTATIONS.length)\n                    return;\n                const orientation = ORIENTATIONS[o];\n                this._PostToDOMMaybeSync("lock-orientation", {\n                    "orientation": orientation\n                })\n            },\n            UnlockOrientation() {\n                this._PostToDOMMaybeSync("unlock-orientation")\n            },\n            LoadStyleSheet(url) {\n                this._runtime.GetAssetManager().LoadStyleSheet(url)\n            },\n            SetHash(h) {\n                this.PostToDOM("set-hash", {\n                    "hash": h\n                })\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Browser.Exps = {\n            URL() {\n                if (this._runtime.IsInWorker())\n                    return this._initLocationStr;\n                else\n                    return location.toString()\n            },\n            Protocol() {\n                if (this._runtime.IsInWorker())\n                    return (new URL(this._initLocationStr)).protocol;\n                else\n                    return location.protocol\n            },\n            Domain() {\n                if (this._runtime.IsInWorker())\n                    return (new URL(this._initLocationStr)).hostname;\n                else\n                    return location.hostname\n            },\n            Port() {\n                if (this._runtime.IsInWorker())\n                    return (new URL(this._initLocationStr)).port;\n                else\n                    return location.port\n            },\n            PathName() {\n                if (this._runtime.IsInWorker())\n                    return (new URL(this._initLocationStr)).pathname;\n                else\n                    return location.pathname\n            },\n            Hash() {\n                if (this._runtime.IsInWorker())\n                    return (new URL(this._initLocationStr)).hash;\n                else\n                    return location.hash\n            },\n            QueryString() {\n                if (this._runtime.IsInWorker())\n                    return (new URL(this._initLocationStr)).search;\n                else\n                    return location.search\n            },\n            QueryParam(param) {\n                const search = this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).search : location.search;\n                const match = RegExp("[?&]" + param + "=([^&]*)").exec(search);\n                if (match)\n                    return decodeURIComponent(match[1].replace(\/\\+\/g, " "));\n                else\n                    return ""\n            },\n            Referrer() {\n                return this._referrer\n            },\n            Title() {\n                return this._docTitle\n            },\n            Language() {\n                return navigator.language\n            },\n            Platform() {\n                return navigator.platform\n            },\n            UserAgent() {\n                return navigator.userAgent\n            },\n            ExecJS(jsStr) {\n                let result = 0;\n                try {\n                    result = eval(jsStr)\n                } catch (err) {\n                    console.error("Error executing JavaScript: ", err)\n                }\n                if (typeof result === "number" || typeof result === "string")\n                    return result;\n                if (typeof result === "boolean")\n                    return result ? 1 : 0;\n                else\n                    return 0\n            },\n            Name() {\n                return navigator.appName\n            },\n            Version() {\n                return navigator.appVersion\n            },\n            Product() {\n                return navigator.product\n            },\n            Vendor() {\n                return navigator.vendor\n            },\n            BatteryLevel() {\n                return 1\n            },\n            BatteryTimeLeft() {\n                return Infinity\n            },\n            Bandwidth() {\n                const connection = navigator["connection"];\n                if (connection)\n                    return connection["downlink"] || connection["downlinkMax"] || connection["bandwidth"] || Infinity;\n                else\n                    return Infinity\n            },\n            ConnectionType() {\n                const connection = navigator["connection"];\n                if (connection)\n                    return connection["type"] || "unknown";\n                else\n                    return "unknown"\n            },\n            DevicePixelRatio() {\n                return self.devicePixelRatio\n            },\n            ScreenWidth() {\n                return this._screenWidth\n            },\n            ScreenHeight() {\n                return this._screenHeight\n            },\n            WindowInnerWidth() {\n                return this._runtime.GetCanvasManager().GetLastWidth()\n            },\n            WindowInnerHeight() {\n                return this._runtime.GetCanvasManager().GetLastHeight()\n            },\n            WindowOuterWidth() {\n                return this._windowOuterWidth\n            },\n            WindowOuterHeight() {\n                return this._windowOuterWidth\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Plugins.AJAX = class AJAXPlugin extends C3.SDKPluginBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.AJAX.Type = class AJAXType extends C3.SDKTypeBase {\n            constructor(objectClass) {\n                super(objectClass)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.AJAX.Instance = class AJAXInstance extends C3.SDKInstanceBase {\n            constructor(inst, properties) {\n                super(inst);\n                this._lastData = "";\n                this._curTag = "";\n                this._progress = 0;\n                this._timeout = -1;\n                this._nextRequestHeaders = new Map;\n                this._nextReponseBinaryData = null;\n                this._nextRequestOverrideMimeType = "";\n                this._nwjsFs = null;\n                this._nwjsPath = null;\n                this._nwjsAppFolder = null;\n                this._isNWjs = this._runtime.GetExportType() === "nwjs";\n                if (this._isNWjs) {\n                    this._nwjsFs = require("fs");\n                    this._nwjsPath = require("path");\n                    const process = self["process"] || nw["process"];\n                    this._nwjsAppFolder = this._nwjsPath["dirname"](process["execPath"]) + "\\\\"\n                }\n            }\n            Release() {\n                super.Release()\n            }\n            async _TriggerError(tag, url, err) {\n                console.error(`[Construct] AJAX request to \'${url}\' (tag \'${tag}\') failed: `, err);\n                this._curTag = tag;\n                await this.TriggerAsync(C3.Plugins.AJAX.Cnds.OnAnyError);\n                await this.TriggerAsync(C3.Plugins.AJAX.Cnds.OnError)\n            }\n            async _TriggerComplete(tag) {\n                this._curTag = tag;\n                await this.TriggerAsync(C3.Plugins.AJAX.Cnds.OnAnyComplete);\n                await this.TriggerAsync(C3.Plugins.AJAX.Cnds.OnComplete)\n            }\n            async _OnProgress(tag, e) {\n                if (!e["lengthComputable"])\n                    return;\n                this._progress = e["loaded"] \/ e["total"];\n                this._curTag = tag;\n                await this.TriggerAsync(C3.Plugins.AJAX.Cnds.OnProgress)\n            }\n            _OnError(tag, url, err) {\n                if (!this._isNWjs) {\n                    this._TriggerError(tag, url, err);\n                    return\n                }\n                const fs = this._nwjsFs;\n                const filePath = this._nwjsAppFolder + url;\n                if (fs["existsSync"](filePath))\n                    fs["readFile"](filePath, {\n                        "encoding": "utf8"\n                    }, (err2, data) => {\n                        if (err2)\n                            this._TriggerError(tag, url, err2);\n                        else {\n                            this._lastData = data.replace(\/\\r\\n\/g, "\\n");\n                            this._TriggerComplete(tag)\n                        }\n                    }\n                    );\n                else\n                    this._TriggerError(tag, url, err)\n            }\n            async _DoCordovaRequest(tag, file) {\n                const assetManager = this._runtime.GetAssetManager();\n                const binaryData = this._nextReponseBinaryData;\n                this._nextReponseBinaryData = null;\n                try {\n                    if (binaryData) {\n                        const buffer = await assetManager.CordovaFetchLocalFileAsArrayBuffer(file);\n                        binaryData.SetArrayBufferTransfer(buffer);\n                        this._lastData = "";\n                        this._TriggerComplete(tag)\n                    } else {\n                        const data = await assetManager.CordovaFetchLocalFileAsText(file);\n                        this._lastData = data.replace(\/\\r\\n\/g, "\\n");\n                        this._TriggerComplete(tag)\n                    }\n                } catch (err) {\n                    this._TriggerError(tag, file, err)\n                }\n            }\n            _DoRequest(tag, url, method, data) {\n                return new Promise(resolve => {\n                    const errorFunc = err => {\n                        this._OnError(tag, url, err);\n                        resolve()\n                    }\n                    ;\n                    const binaryData = this._nextReponseBinaryData;\n                    this._nextReponseBinaryData = null;\n                    try {\n                        const request = new XMLHttpRequest;\n                        request.onreadystatechange = () => {\n                            if (request.readyState === 4) {\n                                if (binaryData)\n                                    this._lastData = "";\n                                else\n                                    this._lastData = (request.responseText || "").replace(\/\\r\\n\/g, "\\n");\n                                if (request.status >= 400)\n                                    this._TriggerError(tag, url, request.status + request.statusText);\n                                else {\n                                    const hasData = this._lastData.length || binaryData && request.response instanceof ArrayBuffer;\n                                    if ((!this._isNWjs || hasData) && !(!this._isNWjs && request.status === 0 && !hasData)) {\n                                        if (binaryData)\n                                            binaryData.SetArrayBufferTransfer(request.response);\n                                        this._TriggerComplete(tag)\n                                    }\n                                }\n                                resolve()\n                            }\n                        }\n                        ;\n                        request.onerror = errorFunc;\n                        request.ontimeout = errorFunc;\n                        request.onabort = errorFunc;\n                        request["onprogress"] = e => this._OnProgress(tag, e);\n                        request.open(method, url);\n                        if (this._timeout >= 0 && typeof request["timeout"] !== "undefined")\n                            request["timeout"] = this._timeout;\n                        request.responseType = binaryData ? "arraybuffer" : "text";\n                        if (data && !this._nextRequestHeaders.has("Content-Type"))\n                            if (typeof data !== "string")\n                                request["setRequestHeader"]("Content-Type", "application\/octet-stream");\n                            else\n                                request["setRequestHeader"]("Content-Type", "application\/x-www-form-urlencoded");\n                        for (const [header,value] of this._nextRequestHeaders)\n                            try {\n                                request["setRequestHeader"](header, value)\n                            } catch (err) {\n                                console.error(`[Construct] AJAX: Failed to set header \'${header}: ${value}\': `, err)\n                            }\n                        this._nextRequestHeaders.clear();\n                        if (this._nextRequestOverrideMimeType) {\n                            try {\n                                request["overrideMimeType"](this._nextRequestOverrideMimeType)\n                            } catch (err) {\n                                console.error(`[Construct] AJAX: failed to override MIME type: `, err)\n                            }\n                            this._nextRequestOverrideMimeType = ""\n                        }\n                        if (data)\n                            request.send(data);\n                        else\n                            request.send()\n                    } catch (err) {\n                        errorFunc(err)\n                    }\n                }\n                )\n            }\n            GetDebuggerProperties() {\n                const prefix = "plugins.ajax.debugger";\n                return [{\n                    title: prefix + ".title",\n                    properties: [{\n                        name: prefix + ".last-data",\n                        value: this._lastData\n                    }]\n                }]\n            }\n            SaveToJson() {\n                return {\n                    "lastData": this._lastData\n                }\n            }\n            LoadFromJson(o) {\n                this._lastData = o["lastData"];\n                this._curTag = "";\n                this._progress = 0\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.AJAX.Cnds = {\n            OnComplete(tag) {\n                return C3.equalsNoCase(this._curTag, tag)\n            },\n            OnAnyComplete() {\n                return true\n            },\n            OnError(tag) {\n                return C3.equalsNoCase(this._curTag, tag)\n            },\n            OnAnyError() {\n                return true\n            },\n            OnProgress(tag) {\n                return C3.equalsNoCase(this._curTag, tag)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.AJAX.Acts = {\n            async Request(tag, url) {\n                if (this._runtime.IsCordova() && C3.IsRelativeURL(url) && this._runtime.GetAssetManager().IsFileProtocol())\n                    await this._DoCordovaRequest(tag, url);\n                else if (this._runtime.IsPreview() && C3.IsRelativeURL(url)) {\n                    const localurl = this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(url.toLowerCase());\n                    await this._DoRequest(tag, localurl, "GET", null)\n                } else\n                    await this._DoRequest(tag, url, "GET", null)\n            },\n            async RequestFile(tag, file) {\n                if (this._runtime.IsCordova() && this._runtime.GetAssetManager().IsFileProtocol())\n                    await this._DoCordovaRequest(tag, file);\n                else\n                    await this._DoRequest(tag, this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(file), "GET", null)\n            },\n            async Post(tag, url, data, method) {\n                await this._DoRequest(tag, url, method, data)\n            },\n            async PostBinary(tag, url, objectClass, method) {\n                if (!objectClass)\n                    return;\n                const target = objectClass.GetFirstPicked(this._inst);\n                if (!target)\n                    return;\n                const sdkInst = target.GetSdkInstance();\n                const buffer = sdkInst.GetArrayBufferReadOnly();\n                await this._DoRequest(tag, url, method, buffer)\n            },\n            SetTimeout(t) {\n                this._timeout = t * 1E3\n            },\n            SetHeader(n, v) {\n                this._nextRequestHeaders.set(n, v)\n            },\n            SetResponseBinary(objectClass) {\n                if (!objectClass)\n                    return;\n                const inst = objectClass.GetFirstPicked(this._inst);\n                if (!inst)\n                    return;\n                this._nextReponseBinaryData = inst.GetSdkInstance()\n            },\n            OverrideMIMEType(m) {\n                this._nextRequestOverrideMimeType = m\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.AJAX.Exps = {\n            LastData() {\n                return this._lastData\n            },\n            Progress() {\n                return this._progress\n            },\n            Tag() {\n                return this._curTag\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Plugins.LocalStorage = class LocalStoragePlugin extends C3.SDKPluginBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.LocalStorage.Type = class LocalStorageType extends C3.SDKTypeBase {\n            constructor(objectClass) {\n                super(objectClass)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.LocalStorage.Instance = class LocalStorageInstance extends C3.SDKInstanceBase {\n            constructor(inst, properties) {\n                super(inst);\n                this._currentKey = "";\n                this._lastValue = "";\n                this._keyNamesList = [];\n                this._errorMessage = "";\n                this._pendingGets = 0;\n                this._pendingSets = 0;\n                this._storage = this._runtime._GetProjectStorage();\n                this._debugCache = new Map;\n                this._isLoadingDebugCache = false\n            }\n            Release() {\n                super.Release()\n            }\n            async _TriggerStorageError(err) {\n                this._errorMessage = this._GetErrorString(err);\n                await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnError)\n            }\n            _GetErrorString(err) {\n                if (!err)\n                    return "unknown error";\n                else if (typeof err === "string")\n                    return err;\n                else if (typeof err.message === "string")\n                    return err.message;\n                else if (typeof err.name === "string")\n                    return err.name;\n                else if (typeof err.data === "string")\n                    return err.data;\n                else\n                    return "unknown error"\n            }\n            GetDebuggerProperties() {\n                if (!this._isLoadingDebugCache)\n                    this._DebugCacheStorage();\n                return [{\n                    title: "plugins.localstorage.name",\n                    properties: [...this._debugCache.entries()].map(entry => ({\n                        name: "$" + entry[0],\n                        value: entry[1],\n                        onedit: v => this._storage.setItem(entry[0], v)\n                    }))\n                }]\n            }\n            async _DebugCacheStorage() {\n                this._isLoadingDebugCache = true;\n                try {\n                    const keyList = await this._storage.keys();\n                    keyList.sort( (a, b) => {\n                        const la = a.toLowerCase();\n                        const lb = b.toLowerCase();\n                        if (la < lb)\n                            return -1;\n                        else if (lb < la)\n                            return 1;\n                        else\n                            return 0\n                    }\n                    );\n                    const values = await Promise.all(keyList.map(key => this._storage.getItem(key)));\n                    this._debugCache.clear();\n                    for (let i = 0, len = keyList.length; i < len; ++i)\n                        this._debugCache.set(keyList[i], values[i])\n                } catch (err) {\n                    console.warn("[C3 debugger] Error displaying local storage: ", err)\n                } finally {\n                    this._isLoadingDebugCache = false\n                }\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.LocalStorage.Cnds = {\n            OnItemSet(key) {\n                return this._currentKey === key\n            },\n            OnAnyItemSet() {\n                return true\n            },\n            OnItemGet(key) {\n                return this._currentKey === key\n            },\n            OnAnyItemGet() {\n                return true\n            },\n            OnItemRemoved(key) {\n                return this._currentKey === key\n            },\n            OnAnyItemRemoved() {\n                return true\n            },\n            OnCleared() {\n                return true\n            },\n            OnAllKeyNamesLoaded() {\n                return true\n            },\n            OnError() {\n                return true\n            },\n            OnItemExists(key) {\n                return this._currentKey === key\n            },\n            OnItemMissing(key) {\n                return this._currentKey === key\n            },\n            CompareKey(cmp, key) {\n                return C3.compare(this._currentKey, cmp, key)\n            },\n            CompareValue(cmp, v) {\n                return C3.compare(this._lastValue, cmp, v)\n            },\n            IsProcessingSets() {\n                return this._pendingSets > 0\n            },\n            IsProcessingGets() {\n                return this._pendingGets > 0\n            },\n            OnAllSetsComplete() {\n                return true\n            },\n            OnAllGetsComplete() {\n                return true\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        function IsExpressionType(x) {\n            return typeof x === "string" || typeof x === "number"\n        }\n        C3.Plugins.LocalStorage.Acts = {\n            async SetItem(key, value) {\n                this._pendingSets++;\n                try {\n                    const valueSet = await this._storage.setItem(key, value);\n                    await this.ScheduleTriggers(async () => {\n                        this._currentKey = key;\n                        this._lastValue = valueSet;\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAnyItemSet);\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnItemSet)\n                    }\n                    )\n                } catch (err) {\n                    await this._TriggerStorageError(err)\n                } finally {\n                    this._pendingSets--;\n                    if (this._pendingSets === 0)\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAllSetsComplete)\n                }\n            },\n            async SetBinaryItem(key, objectClass) {\n                if (!objectClass)\n                    return;\n                const inst = objectClass.GetFirstPicked(this._inst);\n                if (!inst)\n                    return;\n                const sdkInst = inst.GetSdkInstance();\n                if (!sdkInst)\n                    return;\n                const buffer = sdkInst.GetArrayBufferReadOnly();\n                this._pendingSets++;\n                try {\n                    await this._storage.setItem(key, buffer);\n                    await this.ScheduleTriggers(async () => {\n                        this._currentKey = key;\n                        this._lastValue = "";\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAnyItemSet);\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnItemSet)\n                    }\n                    )\n                } catch (err) {\n                    await this._TriggerStorageError(err)\n                } finally {\n                    this._pendingSets--;\n                    if (this._pendingSets === 0)\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAllSetsComplete)\n                }\n            },\n            async GetItem(key) {\n                this._pendingGets++;\n                try {\n                    const value = await this._storage.getItem(key);\n                    await this.ScheduleTriggers(async () => {\n                        this._currentKey = key;\n                        this._lastValue = IsExpressionType(value) ? value : "";\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAnyItemGet);\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnItemGet)\n                    }\n                    )\n                } catch (err) {\n                    await this._TriggerStorageError(err)\n                } finally {\n                    this._pendingGets--;\n                    if (this._pendingGets === 0)\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAllGetsComplete)\n                }\n            },\n            async GetBinaryItem(key, objectClass) {\n                if (!objectClass)\n                    return;\n                const inst = objectClass.GetFirstPicked(this._inst);\n                if (!inst)\n                    return;\n                const sdkInst = inst.GetSdkInstance();\n                this._pendingGets++;\n                try {\n                    let value = await this._storage.getItem(key);\n                    value = value instanceof ArrayBuffer ? value : new ArrayBuffer(0);\n                    await this.ScheduleTriggers(async () => {\n                        this._lastValue = "";\n                        this._currentKey = key;\n                        sdkInst.SetArrayBufferTransfer(value);\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAnyItemGet);\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnItemGet)\n                    }\n                    )\n                } catch (err) {\n                    await this._TriggerStorageError(err)\n                } finally {\n                    this._pendingGets--;\n                    if (this._pendingGets === 0)\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAllGetsComplete)\n                }\n            },\n            async CheckItemExists(key) {\n                try {\n                    const value = await this._storage.getItem(key);\n                    await this.ScheduleTriggers(async () => {\n                        this._currentKey = key;\n                        if (typeof value === "undefined" || value === null) {\n                            this._lastValue = "";\n                            await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnItemMissing)\n                        } else {\n                            this._lastValue = IsExpressionType(value) ? value : "";\n                            await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnItemExists)\n                        }\n                    }\n                    )\n                } catch (err) {\n                    await this._TriggerStorageError(err)\n                }\n            },\n            async RemoveItem(key) {\n                try {\n                    await this._storage.removeItem(key);\n                    await this.ScheduleTriggers(async () => {\n                        this._currentKey = key;\n                        this._lastValue = "";\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAnyItemRemoved);\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnItemRemoved)\n                    }\n                    )\n                } catch (err) {\n                    await this._TriggerStorageError(err)\n                }\n            },\n            async ClearStorage() {\n                try {\n                    await this._storage.clear();\n                    await this.ScheduleTriggers(async () => {\n                        this._currentKey = "";\n                        this._lastValue = "";\n                        C3.clearArray(this._keyNamesList);\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnCleared)\n                    }\n                    )\n                } catch (err) {\n                    await this._TriggerStorageError(err)\n                }\n            },\n            async GetAllKeyNames() {\n                try {\n                    const keyList = await this._storage.keys();\n                    await this.ScheduleTriggers(async () => {\n                        this._keyNamesList = keyList;\n                        await this.TriggerAsync(C3.Plugins.LocalStorage.Cnds.OnAllKeyNamesLoaded)\n                    }\n                    )\n                } catch (err) {\n                    await this._TriggerStorageError(err)\n                }\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.LocalStorage.Exps = {\n            ItemValue() {\n                return this._lastValue\n            },\n            Key() {\n                return this._currentKey\n            },\n            KeyCount() {\n                return this._keyNamesList.length\n            },\n            KeyAt(i) {\n                i = Math.floor(i);\n                if (i < 0 || i >= this._keyNamesList.length)\n                    return "";\n                return this._keyNamesList[i]\n            },\n            ErrorMessage() {\n                return this._errorMessage\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Plugins.PlatformInfo = class PlatformInfoPlugin extends C3.SDKPluginBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.PlatformInfo.Type = class PlatformInfoType extends C3.SDKTypeBase {\n            constructor(objectClass) {\n                super(objectClass)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const DOM_COMPONENT_ID = "platform-info";\n        C3.Plugins.PlatformInfo.Instance = class PlatformInfoInstance extends C3.SDKInstanceBase {\n            constructor(inst, properties) {\n                super(inst, DOM_COMPONENT_ID);\n                this._screenWidth = 0;\n                this._screenHeight = 0;\n                this._windowOuterWidth = 0;\n                this._windowOuterHeight = 0;\n                this._safeAreaInset = [0, 0, 0, 0];\n                this._supportsWakeLock = false;\n                this._isWakeLockActive = false;\n                this.AddDOMMessageHandlers([["window-resize", e => this._OnWindowResize(e)], ["wake-lock-acquired", e => this._OnWakeLockAcquired(e)], ["wake-lock-error", e => this._OnWakeLockError(e)], ["wake-lock-released", e => this._OnWakeLockReleased(e)]]);\n                if (navigator.connection)\n                    navigator.connection.addEventListener("change", () => this._OnNetworkChange());\n                this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state").then(data => {\n                    this._screenWidth = data["screenWidth"];\n                    this._screenHeight = data["screenHeight"];\n                    this._windowOuterWidth = data["windowOuterWidth"];\n                    this._windowOuterHeight = data["windowOuterHeight"];\n                    this._safeAreaInset = data["safeAreaInset"];\n                    this._supportsWakeLock = data["supportsWakeLock"]\n                }\n                ))\n            }\n            Release() {\n                super.Release()\n            }\n            _OnWindowResize(e) {\n                this._windowOuterWidth = e["windowOuterWidth"];\n                this._windowOuterHeight = e["windowOuterHeight"];\n                this._safeAreaInset = e["safeAreaInset"]\n            }\n            async _OnNetworkChange() {\n                await this.TriggerAsync(C3.Plugins.PlatformInfo.Cnds.OnNetworkChange)\n            }\n            async _OnWakeLockAcquired() {\n                this._isWakeLockActive = true;\n                await this.TriggerAsync(C3.Plugins.PlatformInfo.Cnds.OnWakeLockAcquired)\n            }\n            async _OnWakeLockError() {\n                this._isWakeLockActive = false;\n                await this.TriggerAsync(C3.Plugins.PlatformInfo.Cnds.OnWakeLockError)\n            }\n            async _OnWakeLockReleased() {\n                this._isWakeLockActive = false;\n                await this.TriggerAsync(C3.Plugins.PlatformInfo.Cnds.OnWakeLockReleased)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.PlatformInfo.Cnds = {\n            IsOnMobile() {\n                return C3.Platform.IsMobile\n            },\n            IsOnWindows() {\n                return C3.Platform.OS === "Windows"\n            },\n            IsOnMacOS() {\n                return C3.Platform.OS === "macOS"\n            },\n            IsOnLinux() {\n                return C3.Platform.OS === "Linux"\n            },\n            IsOnChromeOS() {\n                return C3.Platform.OS === "Chrome OS"\n            },\n            IsOnAndroid() {\n                return C3.Platform.OS === "Android"\n            },\n            IsOniOS() {\n                return C3.Platform.OS === "iOS"\n            },\n            IsWebExport() {\n                const exportType = this._runtime.GetExportType();\n                return exportType === "html5" || exportType === "scirra-arcade" || exportType === "preview" || exportType === "instant-games"\n            },\n            IsCordovaExport() {\n                return this._runtime.IsCordova()\n            },\n            IsNWjsExport() {\n                return this._runtime.GetExportType() === "nwjs"\n            },\n            IsWindowsUWPExport() {\n                return this._runtime.GetExportType() === "windows-uwp"\n            },\n            IsWindowsWebView2Export() {\n                return this._runtime.GetExportType() === "windows-webview2"\n            },\n            IsMacOSWKWebView2Export() {\n                return this._runtime.GetExportType() === "macos-wkwebview"\n            },\n            OnNetworkChange() {\n                return true\n            },\n            OnWakeLockAcquired() {\n                return true\n            },\n            OnWakeLockError() {\n                return true\n            },\n            OnWakeLockReleased() {\n                return true\n            },\n            IsWakeLockActive() {\n                return this._isWakeLockActive\n            },\n            IsWakeLockSupported() {\n                return this._supportsWakeLock\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.PlatformInfo.Acts = {\n            RequestWakeLock() {\n                if (!this._supportsWakeLock)\n                    return;\n                this._PostToDOMMaybeSync("request-wake-lock")\n            },\n            ReleaseWakeLock() {\n                if (!this._supportsWakeLock)\n                    return;\n                this._isWakeLockActive = false;\n                this.PostToDOM("release-wake-lock")\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.PlatformInfo.Exps = {\n            Renderer() {\n                let ret = "";\n                if (this._runtime.GetWebGPURenderer())\n                    ret = "webgpu";\n                else\n                    ret = "webgl" + this._runtime.GetWebGLRenderer().GetWebGLVersionNumber();\n                if (this._runtime.GetRenderer().HasMajorPerformanceCaveat())\n                    ret += "-software";\n                return ret\n            },\n            RendererDetail() {\n                return this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()\n            },\n            DevicePixelRatio() {\n                return self.devicePixelRatio\n            },\n            ScreenWidth() {\n                return this._screenWidth\n            },\n            ScreenHeight() {\n                return this._screenHeight\n            },\n            WindowInnerWidth() {\n                return this._runtime.GetCanvasManager().GetLastWidth()\n            },\n            WindowInnerHeight() {\n                return this._runtime.GetCanvasManager().GetLastHeight()\n            },\n            WindowOuterWidth() {\n                return this._windowOuterWidth\n            },\n            WindowOuterHeight() {\n                return this._windowOuterHeight\n            },\n            CanvasCssWidth() {\n                return this._runtime.GetCanvasManager().GetCssWidth()\n            },\n            CanvasCssHeight() {\n                return this._runtime.GetCanvasManager().GetCssHeight()\n            },\n            CanvasDeviceWidth() {\n                return this._runtime.GetCanvasManager().GetDeviceWidth()\n            },\n            CanvasDeviceHeight() {\n                return this._runtime.GetCanvasManager().GetDeviceHeight()\n            },\n            Downlink() {\n                if (navigator.connection)\n                    return navigator.connection["downlink"] || 0;\n                else\n                    return 0\n            },\n            DownlinkMax() {\n                if (navigator.connection)\n                    return navigator.connection["downlinkMax"] || 0;\n                else\n                    return 0\n            },\n            ConnectionType() {\n                if (navigator.connection)\n                    return navigator.connection["type"] || "unknown";\n                else\n                    return "unknown"\n            },\n            ConnectionEffectiveType() {\n                if (navigator.connection)\n                    return navigator.connection["effectiveType"] || "unknown";\n                else\n                    return "unknown"\n            },\n            ConnectionRTT() {\n                if (navigator.connection)\n                    return navigator.connection["rtt"] || 0;\n                else\n                    return 0\n            },\n            HardwareConcurrency() {\n                return navigator.hardwareConcurrency || 0\n            },\n            DeviceMemory() {\n                return navigator.deviceMemory || 0\n            },\n            SafeAreaInsetTop() {\n                return this._safeAreaInset[0]\n            },\n            SafeAreaInsetRight() {\n                return this._safeAreaInset[1]\n            },\n            SafeAreaInsetBottom() {\n                return this._safeAreaInset[2]\n            },\n            SafeAreaInsetLeft() {\n                return this._safeAreaInset[3]\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Plugins.Json = class JSONPlugin extends C3.SDKPluginBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Json.Type = class JSONType extends C3.SDKTypeBase {\n            constructor(objectClass) {\n                super(objectClass)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        const IInstance = self.IInstance;\n        C3.Plugins.Json.Instance = class JSONInstance extends C3.SDKInstanceBase {\n            constructor(inst, properties) {\n                super(inst);\n                this._valueCache = [null, null];\n                this._locationCache = [null, null];\n                this._data = {};\n                this._path = [];\n                this._currentKey = "";\n                this._currentValue = 0\n            }\n            Release() {\n                super.Release()\n            }\n            _InvalidateValueCache() {\n                this._valueCache[0] = null;\n                this._valueCache[1] = null\n            }\n            _HasValueCache(arr, isMutate) {\n                const cacheArr = this._valueCache[0];\n                if (arr === null || cacheArr === null)\n                    return false;\n                if (cacheArr === arr || C3.arraysEqual(cacheArr, arr))\n                    return true;\n                if (isMutate && cacheArr.length > 0) {\n                    for (let i = 0, len = Math.min(arr.length, cacheArr.length); i < len; ++i)\n                        if (arr[i] !== cacheArr[i])\n                            return false;\n                    return true\n                } else\n                    return false\n            }\n            _GetValueCache() {\n                return this._valueCache[1]\n            }\n            _UpdateValueCache(arr, value) {\n                this._valueCache[0] = arr;\n                this._valueCache[1] = value\n            }\n            _InvalidateLocationCache() {\n                this._locationCache[0] = null;\n                this._locationCache[1] = null\n            }\n            _HasLocationCache(str) {\n                return this._locationCache[0] === str\n            }\n            _GetLocationCache() {\n                return this._locationCache[1]\n            }\n            _UpdateLocationCache(str, value) {\n                this._locationCache[0] = str;\n                this._locationCache[1] = value\n            }\n            _SetData(obj) {\n                this._data = obj;\n                this._InvalidateValueCache()\n            }\n            _GetData() {\n                return this._data\n            }\n            _SetPath(str) {\n                this._path = this._ParsePathUnsafe(str);\n                this._InvalidateLocationCache()\n            }\n            _ParsePath(str) {\n                return C3.cloneArray(this._ParsePathUnsafe(str))\n            }\n            _ParsePathUnsafe(str) {\n                const buffer = [];\n                let escaped = false;\n                let parts;\n                if (this._HasLocationCache(str))\n                    return this._GetLocationCache();\n                if (str[0] === ".") {\n                    parts = C3.cloneArray(this._path);\n                    str = str.slice(1)\n                } else\n                    parts = [];\n                for (const c of str)\n                    if (escaped) {\n                        buffer.push(c);\n                        escaped = false\n                    } else if (c === "\\\\")\n                        escaped = true;\n                    else if (c === ".") {\n                        parts.push(buffer.join(""));\n                        C3.clearArray(buffer)\n                    } else\n                        buffer.push(c);\n                if (buffer.length !== 0)\n                    parts.push(buffer.join(""));\n                this._UpdateLocationCache(str, parts);\n                return parts\n            }\n            _GetValueAtFullPath(path, lazyCreate) {\n                if (this._HasValueCache(path, false))\n                    return this._GetValueCache();\n                let result = this._data;\n                for (const part of path)\n                    if (Array.isArray(result)) {\n                        const index = parseInt(part, 10);\n                        if (index < 0 || index >= result.length || !isFinite(index)) {\n                            result = null;\n                            break\n                        }\n                        result = result[index]\n                    } else if (typeof result === "object" && result !== null)\n                        if (result.hasOwnProperty(part))\n                            result = result[part];\n                        else if (lazyCreate) {\n                            const o = {};\n                            result[part] = o;\n                            result = o\n                        } else {\n                            result = null;\n                            break\n                        }\n                    else {\n                        result = null;\n                        break\n                    }\n                this._UpdateValueCache(path, result);\n                return result\n            }\n            _GetValue(str) {\n                const path = this._ParsePath(str);\n                if (!path.length)\n                    return this._data;\n                const key = path.pop();\n                const obj = this._GetValueAtFullPath(path, false);\n                if (Array.isArray(obj)) {\n                    const index = parseInt(key, 10);\n                    return index >= 0 && index < obj.length ? obj[index] : null\n                } else if (typeof obj === "object" && obj !== null)\n                    return obj.hasOwnProperty(key) ? obj[key] : null;\n                else\n                    return null\n            }\n            _JSONTypeOf(val) {\n                if (val === null)\n                    return "null";\n                else if (Array.isArray(val))\n                    return "array";\n                else\n                    return typeof val\n            }\n            _GetTypeOf(str) {\n                const val = this._GetValue(str);\n                return this._JSONTypeOf(val)\n            }\n            _ToSafeValue(value) {\n                const type = typeof value;\n                if (type === "number" || type === "string")\n                    return value;\n                else if (type === "boolean")\n                    return value ? 1 : 0;\n                else\n                    return 0\n            }\n            _GetSafeValue(str) {\n                return this._ToSafeValue(this._GetValue(str))\n            }\n            _HasKey(str) {\n                const path = this._ParsePath(str);\n                if (!path.length)\n                    return false;\n                const key = path.pop();\n                const obj = this._GetValueAtFullPath(path, false);\n                if (Array.isArray(obj)) {\n                    const index = parseInt(key, 10);\n                    return index >= 0 && index < obj.length\n                } else if (typeof obj === "object" && obj !== null)\n                    return obj.hasOwnProperty(key);\n                else\n                    return false\n            }\n            _SetValue(str, value) {\n                const path = this._ParsePath(str);\n                if (!path.length)\n                    return false;\n                if (this._HasValueCache(path, true))\n                    this._InvalidateValueCache();\n                const key = path.pop();\n                const obj = this._GetValueAtFullPath(path, true);\n                if (Array.isArray(obj)) {\n                    const index = parseInt(key, 10);\n                    if (!isFinite(index) || index < 0 || index >= obj.length)\n                        return false;\n                    obj[index] = value;\n                    return true\n                } else if (typeof obj === "object" && obj !== null) {\n                    obj[key] = value;\n                    return true\n                }\n                return false\n            }\n            _DeleteKey(str) {\n                const path = this._ParsePath(str);\n                if (!path.length)\n                    return false;\n                if (this._HasValueCache(path, true))\n                    this._InvalidateValueCache();\n                const key = path.pop();\n                const obj = this._GetValueAtFullPath(path, false);\n                if (Array.isArray(obj))\n                    return false;\n                else if (typeof obj === "object" && obj !== null) {\n                    delete obj[key];\n                    return true\n                } else\n                    return false\n            }\n            SaveToJson() {\n                return {\n                    "path": this._path,\n                    "data": this._data\n                }\n            }\n            LoadFromJson(o) {\n                this._InvalidateValueCache();\n                this._InvalidateLocationCache();\n                this._path = o["path"];\n                this._data = o["data"]\n            }\n            _SanitizeValue(val) {\n                const type = typeof val;\n                if (type === "number") {\n                    if (!isFinite(val))\n                        return 0;\n                    return val\n                }\n                if (typeof val == "object")\n                    return JSON.stringify(val);\n                return val + ""\n            }\n            GetDebuggerProperties() {\n                const prefix = "plugins.json.debugger";\n                let topLevelData;\n                try {\n                    topLevelData = this._SanitizeValue(this._data)\n                } catch (e) {\n                    topLevelData = \'"invalid"\'\n                }\n                return [{\n                    title: prefix + ".title",\n                    properties: [{\n                        name: prefix + ".data",\n                        value: topLevelData,\n                        onedit: v => {\n                            try {\n                                const n = JSON.parse(v);\n                                this._SetData(n)\n                            } catch (e) {}\n                        }\n                    }, {\n                        name: prefix + ".path",\n                        value: this._path.map(seg => seg.replace(\/\\.\/g, "\\\\.")).join(".")\n                    }]\n                }]\n            }\n            GetScriptInterfaceClass() {\n                return self.IJSONInstance\n            }\n        }\n        ;\n        const map = new WeakMap;\n        self.IJSONInstance = class IJSONInstance extends IInstance {\n            constructor() {\n                super();\n                map.set(this, IInstance._GetInitInst().GetSdkInstance())\n            }\n            getJsonDataCopy() {\n                const data = map.get(this)._GetData();\n                return JSON.parse(JSON.stringify(data))\n            }\n            setJsonDataCopy(o) {\n                try {\n                    const o2 = JSON.parse(JSON.stringify(o));\n                    map.get(this)._SetData(o2)\n                } catch (err) {\n                    console.error("[JSON plugin] setJsonData: object is not valid JSON: ", err);\n                    throw err;\n                }\n            }\n            setJsonString(str) {\n                C3X.RequireString(str);\n                try {\n                    const o = JSON.parse(str);\n                    map.get(this)._SetData(o)\n                } catch (err) {\n                    console.error("[JSON plugin] setJsonString: string is not valid JSON: ", err);\n                    throw err;\n                }\n            }\n            toCompactString() {\n                return JSON.stringify(map.get(this)._GetData())\n            }\n            toBeautifiedString() {\n                return JSON.stringify(map.get(this)._GetData(), null, 4)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const JSON_TYPES = ["null", "boolean", "number", "string", "object", "array"];\n        C3.Plugins.Json.Cnds = {\n            HasKey(str) {\n                return this._HasKey(str)\n            },\n            CompareType(str, typeIndex) {\n                return this._GetTypeOf(str) === JSON_TYPES[typeIndex]\n            },\n            CompareValue(str, cmp, value) {\n                return C3.compare(this._GetSafeValue(str), cmp, value)\n            },\n            IsBooleanSet(str) {\n                return this._GetValue(str) === true\n            },\n            ForEach(str) {\n                const value = this._GetValue(str);\n                if (typeof value !== "object" || value === null)\n                    return false;\n                const runtime = this._runtime;\n                const eventSheetManager = runtime.GetEventSheetManager();\n                const currentEvent = runtime.GetCurrentEvent();\n                const solModifiers = currentEvent.GetSolModifiers();\n                const eventStack = runtime.GetEventStack();\n                const oldFrame = eventStack.GetCurrentStackFrame();\n                const newFrame = eventStack.Push(currentEvent);\n                const oldPath = this._path;\n                const oldKey = this._currentKey;\n                const oldValue = this._currentValue;\n                const subPath = this._ParsePathUnsafe(str);\n                runtime.SetDebuggingEnabled(false);\n                for (const [k,v] of Object.entries(value)) {\n                    this._path = C3.cloneArray(subPath);\n                    this._path.push(k);\n                    this._currentKey = k;\n                    this._currentValue = v;\n                    eventSheetManager.PushCopySol(solModifiers);\n                    currentEvent.Retrigger(oldFrame, newFrame);\n                    eventSheetManager.PopSol(solModifiers)\n                }\n                runtime.SetDebuggingEnabled(true);\n                this._path = oldPath;\n                this._InvalidateLocationCache();\n                this._currentKey = oldKey;\n                this._currentValue = oldValue;\n                eventStack.Pop();\n                return false\n            },\n            OnParseError() {\n                return true\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Json.Acts = {\n            Parse(str) {\n                try {\n                    this._SetData(JSON.parse(str))\n                } catch (err) {\n                    console.warn("[JSON plugin] Failed to parse JSON data: ", err);\n                    this._SetData({});\n                    this.Trigger(C3.Plugins.Json.Cnds.OnParseError)\n                }\n            },\n            SetPath(str) {\n                this._SetPath(str)\n            },\n            SetValue(str, value) {\n                this._SetValue(str, value)\n            },\n            SetArray(str, size) {\n                let value = this._GetValue(str);\n                if (Array.isArray(value))\n                    C3.resizeArray(value, size, 0);\n                else {\n                    value = [];\n                    C3.extendArray(value, size, 0);\n                    this._SetValue(str, value)\n                }\n            },\n            SetObject(str) {\n                this._SetValue(str, {})\n            },\n            SetJSON(location, value) {\n                let obj = null;\n                try {\n                    obj = JSON.parse(value)\n                } catch (err) {\n                    console.warn("[JSON plugin] Failed to parse JSON data: ", err);\n                    this.Trigger(C3.Plugins.Json.Cnds.OnParseError)\n                }\n                this._SetValue(location, obj)\n            },\n            SetNull(str) {\n                this._SetValue(str, null)\n            },\n            SetBoolean(str, value) {\n                this._SetValue(str, value !== 0)\n            },\n            ToggleBoolean(str) {\n                const value = this._GetValue(str);\n                if (typeof value === "boolean")\n                    this._SetValue(str, !value)\n            },\n            AddTo(str, inc) {\n                const value = this._GetValue(str);\n                if (typeof value === "number")\n                    this._SetValue(str, value + inc)\n            },\n            SubtractFrom(str, dec) {\n                const value = this._GetValue(str);\n                if (typeof value === "number")\n                    this._SetValue(str, value - dec)\n            },\n            DeleteKey(str) {\n                this._DeleteKey(str)\n            },\n            PushValue(side, str, value) {\n                const parent = this._GetValue(str);\n                if (Array.isArray(parent))\n                    side === 0 ? parent.push(value) : parent.unshift(value)\n            },\n            PopValue(side, str) {\n                const parent = this._GetValue(str);\n                if (Array.isArray(parent))\n                    side === 0 ? parent.pop() : parent.shift()\n            },\n            InsertValue(value, str, index) {\n                const parent = this._GetValue(str);\n                if (Array.isArray(parent))\n                    parent.splice(index, 0, value)\n            },\n            RemoveValues(count, str, index) {\n                const parent = this._GetValue(str);\n                if (Array.isArray(parent))\n                    parent.splice(index, count)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Plugins.Json.Exps = {\n            ToCompactString() {\n                try {\n                    return JSON.stringify(this._data)\n                } catch (err) {\n                    return ""\n                }\n            },\n            ToBeautifiedString() {\n                try {\n                    return JSON.stringify(this._data, null, 4)\n                } catch (err) {\n                    return ""\n                }\n            },\n            Get(str) {\n                return this._GetSafeValue(str)\n            },\n            GetAsCompactString(str) {\n                const value = this._GetValue(str);\n                return JSON.stringify(value)\n            },\n            GetAsBeautifiedString(str) {\n                const value = this._GetValue(str);\n                return JSON.stringify(value, null, 4)\n            },\n            Front(str) {\n                const parent = this._GetValue(str);\n                if (Array.isArray(parent)) {\n                    const value = parent[0];\n                    return this._ToSafeValue(value)\n                } else\n                    return -1\n            },\n            Back(str) {\n                const parent = this._GetValue(str);\n                if (Array.isArray(parent)) {\n                    const value = parent.at(-1);\n                    return this._ToSafeValue(value)\n                } else\n                    return -1\n            },\n            Type(str) {\n                return this._GetTypeOf(str)\n            },\n            ArraySize(str) {\n                const value = this._GetValue(str);\n                if (Array.isArray(value))\n                    return value.length;\n                else\n                    return -1\n            },\n            Path() {\n                return this._path.map(seg => seg.replace(\/\\.\/g, "\\\\.")).join(".")\n            },\n            CurrentKey() {\n                return this._currentKey\n            },\n            CurrentValue() {\n                return this._ToSafeValue(this._currentValue)\n            },\n            CurrentType() {\n                return this._JSONTypeOf(this._currentValue)\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Sin = class SinBehavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Sin.Type = class SinType extends C3.SDKBehaviorTypeBase {\n            constructor(behaviorType) {\n                super(behaviorType)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        const IBehaviorInstance = self.IBehaviorInstance;\n        const MOVEMENT = 0;\n        const WAVE = 1;\n        const PERIOD = 2;\n        const PERIOD_RANDOM = 3;\n        const PERIOD_OFFSET = 4;\n        const PERIOD_OFFSET_RANDOM = 5;\n        const MAGNITUDE = 6;\n        const MAGNITUDE_RANDOM = 7;\n        const ENABLE = 8;\n        const HORIZONTAL = 0;\n        const VERTICAL = 1;\n        const SIZE = 2;\n        const WIDTH = 3;\n        const HEIGHT = 4;\n        const ANGLE = 5;\n        const OPACITY = 6;\n        const VALUE = 7;\n        const FORWARDS_BACKWARDS = 8;\n        const ZELEVATION = 9;\n        const SINE = 0;\n        const TRIANGLE = 1;\n        const SAWTOOTH = 2;\n        const REVERSE_SAWTOOTH = 3;\n        const SQUARE = 4;\n        const _2pi = 2 * Math.PI;\n        const _pi_2 = Math.PI \/ 2;\n        const _3pi_2 = 3 * Math.PI \/ 2;\n        const MOVEMENT_LOOKUP = [0, 1, 8, 3, 4, 2, 5, 6, 9, 7];\n        C3.Behaviors.Sin.Instance = class SinInstance extends C3.SDKBehaviorInstanceBase {\n            constructor(behInst, properties) {\n                super(behInst);\n                this._i = 0;\n                this._movement = 0;\n                this._wave = 0;\n                this._period = 0;\n                this._mag = 0;\n                this._isEnabled = true;\n                this._basePeriod = 0;\n                this._basePeriodOffset = 0;\n                this._baseMag = 0;\n                this._periodRandom = 0;\n                this._periodOffsetRandom = 0;\n                this._magnitudeRandom = 0;\n                this._initialValue = 0;\n                this._initialValue2 = 0;\n                this._lastKnownValue = 0;\n                this._lastKnownValue2 = 0;\n                this._ratio = 0;\n                if (properties) {\n                    this._movement = MOVEMENT_LOOKUP[properties[MOVEMENT]];\n                    this._wave = properties[WAVE];\n                    this._periodRandom = this._runtime.Random() * properties[PERIOD_RANDOM];\n                    this._basePeriod = properties[PERIOD];\n                    this._period = properties[PERIOD];\n                    this._period += this._periodRandom;\n                    this._basePeriodOffset = properties[PERIOD_OFFSET];\n                    if (this._period !== 0) {\n                        this._periodOffsetRandom = this._runtime.Random() * properties[PERIOD_OFFSET_RANDOM];\n                        this._i = properties[PERIOD_OFFSET] \/ this._period * _2pi;\n                        this._i += this._periodOffsetRandom \/ this._period * _2pi\n                    }\n                    this._magnitudeRandom = this._runtime.Random() * properties[MAGNITUDE_RANDOM];\n                    this._baseMag = properties[MAGNITUDE];\n                    this._mag = properties[MAGNITUDE];\n                    this._mag += this._magnitudeRandom;\n                    this._isEnabled = !!properties[ENABLE]\n                }\n                if (this._movement === ANGLE)\n                    this._mag = C3.toRadians(this._mag);\n                this.Init();\n                if (this._isEnabled)\n                    this._StartTicking()\n            }\n            Release() {\n                super.Release()\n            }\n            SaveToJson() {\n                return {\n                    "i": this._i,\n                    "e": this._isEnabled,\n                    "mv": this._movement,\n                    "w": this._wave,\n                    "p": this._period,\n                    "mag": this._mag,\n                    "iv": this._initialValue,\n                    "iv2": this._initialValue2,\n                    "r": this._ratio,\n                    "lkv": this._lastKnownValue,\n                    "lkv2": this._lastKnownValue2\n                }\n            }\n            LoadFromJson(o) {\n                this._i = o["i"];\n                this._SetEnabled(o["e"]);\n                this._movement = o["mv"];\n                this._wave = o["w"];\n                this._period = o["p"];\n                this._mag = o["mag"];\n                this._initialValue = o["iv"];\n                this._initialValue2 = o["iv2"];\n                this._ratio = o["r"];\n                this._lastKnownValue = o["lkv"];\n                this._lastKnownValue2 = o["lkv2"]\n            }\n            Init() {\n                const wi = this._inst.GetWorldInfo();\n                switch (this._movement) {\n                case HORIZONTAL:\n                    this._initialValue = wi.GetX();\n                    break;\n                case VERTICAL:\n                    this._initialValue = wi.GetY();\n                    break;\n                case SIZE:\n                    this._initialValue = wi.GetWidth();\n                    this._ratio = wi.GetHeight() \/ wi.GetWidth();\n                    break;\n                case WIDTH:\n                    this._initialValue = wi.GetWidth();\n                    break;\n                case HEIGHT:\n                    this._initialValue = wi.GetHeight();\n                    break;\n                case ANGLE:\n                    this._initialValue = wi.GetAngle();\n                    break;\n                case OPACITY:\n                    this._initialValue = wi.GetOpacity();\n                    break;\n                case VALUE:\n                    this._initialValue = 0;\n                    break;\n                case FORWARDS_BACKWARDS:\n                    this._initialValue = wi.GetX();\n                    this._initialValue2 = wi.GetY();\n                    break;\n                case ZELEVATION:\n                    this._initialValue = wi.GetZElevation();\n                    break;\n                default:\n                }\n                this._lastKnownValue = this._initialValue;\n                this._lastKnownValue2 = this._initialValue2\n            }\n            WaveFunc(x) {\n                x = x % _2pi;\n                switch (this._wave) {\n                case SINE:\n                    return Math.sin(x);\n                case TRIANGLE:\n                    if (x <= _pi_2)\n                        return x \/ _pi_2;\n                    else if (x <= _3pi_2)\n                        return 1 - 2 * (x - _pi_2) \/ Math.PI;\n                    else\n                        return (x - _3pi_2) \/ _pi_2 - 1;\n                case SAWTOOTH:\n                    return 2 * x \/ _2pi - 1;\n                case REVERSE_SAWTOOTH:\n                    return -2 * x \/ _2pi + 1;\n                case SQUARE:\n                    return x < Math.PI ? -1 : 1\n                }\n                return 0\n            }\n            Tick() {\n                const dt = this._runtime.GetDt(this._inst);\n                if (!this._isEnabled || dt === 0)\n                    return;\n                if (this._period === 0)\n                    this._i = 0;\n                else\n                    this._i = (this._i + dt \/ this._period * _2pi) % _2pi;\n                this._UpdateFromPhase()\n            }\n            _UpdateFromPhase() {\n                const wi = this._inst.GetWorldInfo();\n                switch (this._movement) {\n                case HORIZONTAL:\n                    if (wi.GetX() !== this._lastKnownValue)\n                        this._initialValue += wi.GetX() - this._lastKnownValue;\n                    wi.SetX(this._initialValue + this.WaveFunc(this._i) * this._mag);\n                    this._lastKnownValue = wi.GetX();\n                    break;\n                case VERTICAL:\n                    if (wi.GetY() !== this._lastKnownValue)\n                        this._initialValue += wi.GetY() - this._lastKnownValue;\n                    wi.SetY(this._initialValue + this.WaveFunc(this._i) * this._mag);\n                    this._lastKnownValue = wi.GetY();\n                    break;\n                case SIZE:\n                    wi.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);\n                    wi.SetHeight(wi.GetWidth() * this._ratio);\n                    break;\n                case WIDTH:\n                    wi.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);\n                    break;\n                case HEIGHT:\n                    wi.SetHeight(this._initialValue + this.WaveFunc(this._i) * this._mag);\n                    break;\n                case ANGLE:\n                    if (wi.GetAngle() !== this._lastKnownValue)\n                        this._initialValue = C3.clampAngle(this._initialValue + (wi.GetAngle() - this._lastKnownValue));\n                    wi.SetAngle(this._initialValue + this.WaveFunc(this._i) * this._mag);\n                    this._lastKnownValue = wi.GetAngle();\n                    break;\n                case OPACITY:\n                    wi.SetOpacity(this._initialValue + this.WaveFunc(this._i) * this._mag \/ 100);\n                    break;\n                case FORWARDS_BACKWARDS:\n                    if (wi.GetX() !== this._lastKnownValue)\n                        this._initialValue += wi.GetX() - this._lastKnownValue;\n                    if (wi.GetY() !== this._lastKnownValue2)\n                        this._initialValue2 += wi.GetY() - this._lastKnownValue2;\n                    wi.SetX(this._initialValue + Math.cos(wi.GetAngle()) * this.WaveFunc(this._i) * this._mag);\n                    wi.SetY(this._initialValue2 + Math.sin(wi.GetAngle()) * this.WaveFunc(this._i) * this._mag);\n                    this._lastKnownValue = wi.GetX();\n                    this._lastKnownValue2 = wi.GetY();\n                    break;\n                case ZELEVATION:\n                    wi.SetZElevation(this._initialValue + this.WaveFunc(this._i) * this._mag);\n                    break\n                }\n                wi.SetBboxChanged()\n            }\n            _OnSpriteFrameChanged(prevFrame, nextFrame) {}\n            _SetPeriod(x) {\n                this._period = x\n            }\n            _GetPeriod() {\n                return this._period\n            }\n            _SetMagnitude(x) {\n                this._mag = x\n            }\n            _SetMagnitude_ConvertAngle(x) {\n                if (this._movement === 5)\n                    x = C3.toRadians(x);\n                this._SetMagnitude(x)\n            }\n            _GetMagnitude() {\n                return this._mag\n            }\n            _GetMagnitude_ConvertAngle() {\n                let m = this._GetMagnitude();\n                if (this._movement === 5)\n                    m = C3.toDegrees(m);\n                return m\n            }\n            _SetMovement(m) {\n                if (this._movement === 5 && m !== 5)\n                    this._mag = C3.toDegrees(this._mag);\n                this._movement = m;\n                this.Init()\n            }\n            _GetMovement() {\n                return this._movement\n            }\n            _SetWave(w) {\n                this._wave = w\n            }\n            _GetWave() {\n                return this._wave\n            }\n            _SetPhase(x) {\n                this._i = C3.clamp(x, 0, Math.PI * 2);\n                this._UpdateFromPhase()\n            }\n            _GetPhase() {\n                return this._i\n            }\n            _SetEnabled(e) {\n                this._isEnabled = !!e;\n                if (this._isEnabled)\n                    this._StartTicking();\n                else\n                    this._StopTicking()\n            }\n            _IsEnabled() {\n                return this._isEnabled\n            }\n            GetPropertyValueByIndex(index) {\n                switch (index) {\n                case MOVEMENT:\n                    return this._movement;\n                case WAVE:\n                    return this._wave;\n                case PERIOD:\n                    return this._basePeriod;\n                case MAGNITUDE:\n                    return this._baseMag;\n                case ENABLE:\n                    return this._isEnabled\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                switch (index) {\n                case MOVEMENT:\n                    this._movement = MOVEMENT_LOOKUP[value];\n                    this.Init();\n                    break;\n                case WAVE:\n                    this._wave = value;\n                    break;\n                case PERIOD:\n                    this._basePeriod = value;\n                    this._period = this._basePeriod + this._periodRandom;\n                    if (!this._isEnabled)\n                        if (this._period !== 0) {\n                            this._i = this._basePeriodOffset \/ this._period * _2pi;\n                            this._i += this._periodOffsetRandom \/ this._period * _2pi\n                        } else\n                            this._i = 0;\n                    break;\n                case MAGNITUDE:\n                    this._baseMag = value;\n                    this._mag = this._baseMag + this._magnitudeRandom;\n                    if (this._movement === ANGLE)\n                        this._mag = C3.toRadians(this._mag);\n                    break;\n                case ENABLE:\n                    this._isEnabled = !!value;\n                    break\n                }\n            }\n            GetDebuggerProperties() {\n                const prefix = "behaviors.sin";\n                return [{\n                    title: "$" + this.GetBehaviorType().GetName(),\n                    properties: [{\n                        name: prefix + ".properties.enabled.name",\n                        value: this._IsEnabled(),\n                        onedit: v => this._SetEnabled(v)\n                    }, {\n                        name: prefix + ".properties.period.name",\n                        value: this._GetPeriod(),\n                        onedit: v => this._SetPeriod(v)\n                    }, {\n                        name: prefix + ".properties.magnitude.name",\n                        value: this._GetMagnitude_ConvertAngle(),\n                        onedit: v => this._SetMagnitude_ConvertAngle(v)\n                    }, {\n                        name: prefix + ".debugger.value",\n                        value: this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle()\n                    }]\n                }]\n            }\n            GetScriptInterfaceClass() {\n                return self.ISineBehaviorInstance\n            }\n        }\n        ;\n        const map = new WeakMap;\n        const VALID_MOVEMENTS = ["horizontal", "vertical", "size", "width", "height", "angle", "opacity", "value-only", "forwards-backwards", "z-elevation"];\n        const VALID_WAVES = ["sine", "triangle", "sawtooth", "reverse-sawtooth", "square"];\n        self.ISineBehaviorInstance = class ISineBehaviorInstance extends IBehaviorInstance {\n            constructor() {\n                super();\n                map.set(this, IBehaviorInstance._GetInitInst().GetSdkInstance())\n            }\n            set period(x) {\n                C3X.RequireFiniteNumber(x);\n                map.get(this)._SetPeriod(x)\n            }\n            get period() {\n                return map.get(this)._GetPeriod()\n            }\n            set magnitude(m) {\n                C3X.RequireFiniteNumber(m);\n                map.get(this)._SetMagnitude(m)\n            }\n            get magnitude() {\n                return map.get(this)._GetMagnitude()\n            }\n            set phase(p) {\n                map.get(this)._SetPhase(p)\n            }\n            get phase() {\n                return map.get(this)._GetPhase()\n            }\n            set movement(m) {\n                C3X.RequireString(m);\n                const i = VALID_MOVEMENTS.indexOf(m);\n                if (i === -1)\n                    throw new Error("invalid movement");\n                map.get(this)._SetMovement(i)\n            }\n            get movement() {\n                return VALID_MOVEMENTS[map.get(this)._GetMovement()]\n            }\n            set wave(w) {\n                C3X.RequireString(w);\n                const i = VALID_WAVES.indexOf(w);\n                if (i === -1)\n                    throw new Error("invalid wave");\n                map.get(this)._SetWave(i)\n            }\n            get wave() {\n                return VALID_WAVES[map.get(this)._GetWave()]\n            }\n            get value() {\n                const inst = map.get(this);\n                return inst.WaveFunc(inst._GetPhase()) * inst._GetMagnitude()\n            }\n            updateInitialState() {\n                map.get(this).Init()\n            }\n            set isEnabled(e) {\n                map.get(this)._SetEnabled(!!e)\n            }\n            get isEnabled() {\n                return map.get(this)._IsEnabled()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Sin.Cnds = {\n            IsEnabled() {\n                return this._IsEnabled()\n            },\n            CompareMovement(m) {\n                return this._GetMovement() === m\n            },\n            ComparePeriod(cmp, v) {\n                return C3.compare(this._GetPeriod(), cmp, v)\n            },\n            CompareMagnitude(cmp, v) {\n                return C3.compare(this._GetMagnitude_ConvertAngle(), cmp, v)\n            },\n            CompareWave(w) {\n                return this._GetWave() === w\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Sin.Acts = {\n            SetEnabled(e) {\n                this._SetEnabled(e !== 0)\n            },\n            SetPeriod(x) {\n                this._SetPeriod(x)\n            },\n            SetMagnitude(x) {\n                this._SetMagnitude_ConvertAngle(x)\n            },\n            SetMovement(m) {\n                this._SetMovement(m)\n            },\n            SetWave(w) {\n                this._wave = w\n            },\n            SetPhase(x) {\n                const _2pi = Math.PI * 2;\n                this._SetPhase(x * _2pi % _2pi)\n            },\n            UpdateInitialState() {\n                this.Init()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Sin.Exps = {\n            CyclePosition() {\n                return this._GetPhase() \/ (2 * Math.PI)\n            },\n            Period() {\n                return this._GetPeriod()\n            },\n            Magnitude() {\n                return this._GetMagnitude_ConvertAngle()\n            },\n            Value() {\n                return this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle()\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Behaviors.DragnDrop = class DragnDropBehavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                super(opts);\n                const rt = this._runtime.Dispatcher();\n                this._disposables = new C3.CompositeDisposable(C3.Disposable.From(rt, "pointerdown", e => this._OnPointerDown(e.data)),C3.Disposable.From(rt, "pointermove", e => this._OnPointerMove(e.data)),C3.Disposable.From(rt, "pointerup", e => this._OnPointerUp(e.data, false)),C3.Disposable.From(rt, "pointercancel", e => this._OnPointerUp(e.data, true)))\n            }\n            Release() {\n                this._disposables.Release();\n                this._disposables = null;\n                super.Release()\n            }\n            _OnPointerDown(e) {\n                if (e["pointerType"] === "mouse" && e["button"] !== 0)\n                    return;\n                this._OnInputDown(e["pointerId"].toString(), e["pageX"] - this._runtime.GetCanvasClientX(), e["pageY"] - this._runtime.GetCanvasClientY())\n            }\n            _OnPointerMove(e) {\n                if ((e["lastButtons"] & 1) !== 0 && (e["buttons"] & 1) === 0)\n                    this._OnInputUp(e["pointerId"].toString());\n                else\n                    this._OnInputMove(e["pointerId"].toString(), e["pageX"] - this._runtime.GetCanvasClientX(), e["pageY"] - this._runtime.GetCanvasClientY())\n            }\n            _OnPointerUp(e, isCancel) {\n                if (e["pointerType"] === "mouse" && e["button"] !== 0)\n                    return;\n                this._OnInputUp(e["pointerId"].toString())\n            }\n            async _OnInputDown(src, clientX, clientY) {\n                const myInstances = this.GetInstances();\n                let topMost = null;\n                let topBehInst = null;\n                let topX = 0;\n                let topY = 0;\n                for (const inst of myInstances) {\n                    const behInst = inst.GetBehaviorSdkInstanceFromCtor(C3.Behaviors.DragnDrop);\n                    if (!behInst.IsEnabled() || behInst.IsDragging() || inst.IsDestroyed())\n                        continue;\n                    const wi = inst.GetWorldInfo();\n                    const layer = wi.GetLayer();\n                    const [lx,ly] = layer.CanvasCssToLayer(clientX, clientY, wi.GetTotalZElevation());\n                    if (!layer.IsSelfAndParentsInteractive() || !wi.ContainsPoint(lx, ly))\n                        continue;\n                    if (!topMost) {\n                        topMost = inst;\n                        topBehInst = behInst;\n                        topX = lx;\n                        topY = ly;\n                        continue\n                    }\n                    const topWi = topMost.GetWorldInfo();\n                    if (layer.GetIndex() > topWi.GetLayer().GetIndex() || layer.GetIndex() === topWi.GetLayer().GetIndex() && wi.GetZIndex() > topWi.GetZIndex()) {\n                        topMost = inst;\n                        topBehInst = behInst;\n                        topX = lx;\n                        topY = ly\n                    }\n                }\n                if (topMost)\n                    await topBehInst._OnDown(src, topX, topY)\n            }\n            _OnInputMove(src, clientX, clientY) {\n                const myInstances = this.GetInstances();\n                for (const inst of myInstances) {\n                    const behInst = inst.GetBehaviorSdkInstanceFromCtor(C3.Behaviors.DragnDrop);\n                    if (!behInst.IsEnabled() || !behInst.IsDragging() || behInst.IsDragging() && behInst.GetDragSource() !== src)\n                        continue;\n                    const wi = inst.GetWorldInfo();\n                    const layer = wi.GetLayer();\n                    const [lx,ly] = layer.CanvasCssToLayer(clientX, clientY, wi.GetTotalZElevation());\n                    behInst._OnMove(lx, ly)\n                }\n            }\n            async _OnInputUp(src) {\n                const myInstances = this.GetInstances();\n                for (const inst of myInstances) {\n                    const behInst = inst.GetBehaviorSdkInstanceFromCtor(C3.Behaviors.DragnDrop);\n                    if (behInst.IsDragging() && behInst.GetDragSource() === src)\n                        await behInst._OnUp()\n                }\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.DragnDrop.Type = class DragnDropType extends C3.SDKBehaviorTypeBase {\n            constructor(behaviorType) {\n                super(behaviorType)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const AXES = 0;\n        const ENABLE = 1;\n        C3.Behaviors.DragnDrop.Instance = class DragnDropInstance extends C3.SDKBehaviorInstanceBase {\n            constructor(behInst, properties) {\n                super(behInst);\n                this._isDragging = false;\n                this._dx = 0;\n                this._dy = 0;\n                this._dragSource = "<none>";\n                this._axes = 0;\n                this._isEnabled = true;\n                if (properties) {\n                    this._axes = properties[AXES];\n                    this._isEnabled = properties[ENABLE]\n                }\n            }\n            Release() {\n                super.Release()\n            }\n            SaveToJson() {\n                return {\n                    "a": this._axes,\n                    "e": this._isEnabled\n                }\n            }\n            LoadFromJson(o) {\n                this._axes = o["a"];\n                this._isEnabled = o["e"];\n                this._isDragging = false\n            }\n            IsEnabled() {\n                return this._isEnabled\n            }\n            IsDragging() {\n                return this._isDragging\n            }\n            GetDragSource() {\n                return this._dragSource\n            }\n            async _OnDown(src, x, y) {\n                const wi = this.GetWorldInfo();\n                this._dx = x - wi.GetX();\n                this._dy = y - wi.GetY();\n                this._isDragging = true;\n                this._dragSource = src;\n                await this.TriggerAsync(C3.Behaviors.DragnDrop.Cnds.OnDragStart)\n            }\n            _OnMove(x, y) {\n                const wi = this.GetWorldInfo();\n                const newX = x - this._dx;\n                const newY = y - this._dy;\n                if (this._axes === 0) {\n                    if (wi.GetX() !== newX || wi.GetY() !== newY) {\n                        wi.SetXY(newX, newY);\n                        wi.SetBboxChanged()\n                    }\n                } else if (this._axes === 1) {\n                    if (wi.GetX() !== newX) {\n                        wi.SetX(newX);\n                        wi.SetBboxChanged()\n                    }\n                } else if (this._axes === 2)\n                    if (wi.GetY() !== newY) {\n                        wi.SetY(newY);\n                        wi.SetBboxChanged()\n                    }\n            }\n            async _OnUp() {\n                this._isDragging = false;\n                await this.TriggerAsync(C3.Behaviors.DragnDrop.Cnds.OnDrop)\n            }\n            GetPropertyValueByIndex(index) {\n                switch (index) {\n                case AXES:\n                    return this._axes;\n                case ENABLE:\n                    return this._isEnabled\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                switch (index) {\n                case AXES:\n                    this._axes = value;\n                    break;\n                case ENABLE:\n                    this._isEnabled = !!value;\n                    break\n                }\n            }\n            GetDebuggerProperties() {\n                const prefix = "behaviors.dragndrop";\n                return [{\n                    title: "$" + this.GetBehaviorType().GetName(),\n                    properties: [{\n                        name: prefix + ".debugger.is-dragging",\n                        value: this._isDragging\n                    }, {\n                        name: prefix + ".properties.enabled.name",\n                        value: this._isEnabled,\n                        onedit: v => this._isEnabled = v\n                    }]\n                }]\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.DragnDrop.Cnds = {\n            IsDragging() {\n                return this._isDragging\n            },\n            OnDragStart() {\n                return true\n            },\n            OnDrop() {\n                return true\n            },\n            IsEnabled() {\n                return this._isEnabled\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.DragnDrop.Acts = {\n            SetEnabled(e) {\n                this._isEnabled = !!e;\n                if (!this._isEnabled)\n                    this._isDragging = false\n            },\n            SetAxes(a) {\n                this._axes = a\n            },\n            Drop() {\n                if (this._isDragging)\n                    this._OnUp()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.DragnDrop.Exps = {}\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Pin = class PinBehavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Pin.Type = class PinType extends C3.SDKBehaviorTypeBase {\n            constructor(behaviorType) {\n                super(behaviorType)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Pin.Instance = class PinInstance extends C3.SDKBehaviorInstanceBase {\n            constructor(behInst, properties) {\n                super(behInst);\n                this._pinInst = null;\n                this._pinUid = -1;\n                this._mode = "";\n                this._propSet = new Set;\n                this._pinDist = 0;\n                this._pinAngle = 0;\n                this._pinImagePoint = 0;\n                this._dx = 0;\n                this._dy = 0;\n                this._dWidth = 0;\n                this._dHeight = 0;\n                this._dAngle = 0;\n                this._dz = 0;\n                this._lastKnownAngle = 0;\n                this._destroy = false;\n                if (properties)\n                    this._destroy = properties[0];\n                const rt = this._runtime.Dispatcher();\n                this._disposables = new C3.CompositeDisposable(C3.Disposable.From(rt, "instancedestroy", e => this._OnInstanceDestroyed(e.instance)),C3.Disposable.From(rt, "afterload", e => this._OnAfterLoad()))\n            }\n            Release() {\n                this._pinInst = null;\n                super.Release()\n            }\n            _SetPinInst(inst) {\n                if (inst) {\n                    this._pinInst = inst;\n                    this._StartTicking2()\n                } else {\n                    this._pinInst = null;\n                    this._StopTicking2()\n                }\n            }\n            _Pin(objectClass, mode, propList) {\n                if (!objectClass)\n                    return;\n                const otherInst = objectClass.GetFirstPicked(this._inst);\n                if (!otherInst)\n                    return;\n                this._mode = mode;\n                this._SetPinInst(otherInst);\n                const myWi = this._inst.GetWorldInfo();\n                const otherWi = otherInst.GetWorldInfo();\n                if (this._mode === "properties") {\n                    const propSet = this._propSet;\n                    propSet.clear();\n                    for (const p of propList)\n                        propSet.add(p);\n                    this._dx = myWi.GetX() - otherWi.GetX();\n                    this._dy = myWi.GetY() - otherWi.GetY();\n                    this._dAngle = myWi.GetAngle() - otherWi.GetAngle();\n                    this._lastKnownAngle = myWi.GetAngle();\n                    this._dz = myWi.GetZElevation() - otherWi.GetZElevation();\n                    if (propSet.has("x") && propSet.has("y")) {\n                        this._pinAngle = C3.angleTo(otherWi.GetX(), otherWi.GetY(), myWi.GetX(), myWi.GetY()) - otherWi.GetAngle();\n                        this._pinDist = C3.distanceTo(otherWi.GetX(), otherWi.GetY(), myWi.GetX(), myWi.GetY())\n                    }\n                    if (propSet.has("width-abs"))\n                        this._dWidth = myWi.GetWidth() - otherWi.GetWidth();\n                    else if (propSet.has("width-scale"))\n                        this._dWidth = myWi.GetWidth() \/ otherWi.GetWidth();\n                    if (propSet.has("height-abs"))\n                        this._dHeight = myWi.GetHeight() - otherWi.GetHeight();\n                    else if (propSet.has("height-scale"))\n                        this._dHeight = myWi.GetHeight() \/ otherWi.GetHeight()\n                } else\n                    this._pinDist = C3.distanceTo(otherWi.GetX(), otherWi.GetY(), myWi.GetX(), myWi.GetY())\n            }\n            SaveToJson() {\n                const propSet = this._propSet;\n                const mode = this._mode;\n                const ret = {\n                    "uid": this._pinInst ? this._pinInst.GetUID() : -1,\n                    "m": mode,\n                    "d": this._destroy\n                };\n                if (mode === "rope" || mode === "bar")\n                    ret["pd"] = this._pinDist;\n                else if (mode === "properties") {\n                    ret["ps"] = [...this._propSet];\n                    if (propSet.has("imagepoint"))\n                        ret["ip"] = this._pinImagePoint;\n                    else if (propSet.has("x") && propSet.has("y")) {\n                        ret["pa"] = this._pinAngle;\n                        ret["pd"] = this._pinDist\n                    } else {\n                        if (propSet.has("x"))\n                            ret["dx"] = this._dx;\n                        if (propSet.has("y"))\n                            ret["dy"] = this._dy\n                    }\n                    if (propSet.has("angle")) {\n                        ret["da"] = this._dAngle;\n                        ret["lka"] = this._lastKnownAngle\n                    }\n                    if (propSet.has("width-abs") || propSet.has("width-scale"))\n                        ret["dw"] = this._dWidth;\n                    if (propSet.has("height-abs") || propSet.has("height-scale"))\n                        ret["dh"] = this._dHeight;\n                    if (propSet.has("z"))\n                        ret["dz"] = this._dz\n                }\n                return ret\n            }\n            LoadFromJson(o) {\n                const mode = o["m"];\n                const propSet = this._propSet;\n                propSet.clear();\n                this._pinUid = o["uid"];\n                if (typeof mode === "number") {\n                    this._LoadFromJson_Legacy(o);\n                    return\n                }\n                this._mode = mode;\n                if (o.hasOwnProperty("d"))\n                    this._destroy = !!o["d"];\n                if (mode === "rope" || mode === "bar")\n                    this._pinDist = o["pd"];\n                else if (mode === "properties") {\n                    for (const p of o["ps"])\n                        propSet.add(p);\n                    if (propSet.has("imagepoint"))\n                        this._pinImagePoint = o["ip"];\n                    else if (propSet.has("x") && propSet.has("y")) {\n                        this._pinAngle = o["pa"];\n                        this._pinDist = o["pd"]\n                    } else {\n                        if (propSet.has("x"))\n                            this._dx = o["dx"];\n                        if (propSet.has("y"))\n                            this._dy = o["dy"]\n                    }\n                    if (propSet.has("angle")) {\n                        this._dAngle = o["da"];\n                        this._lastKnownAngle = o["lka"] || 0\n                    }\n                    if (propSet.has("width-abs") || propSet.has("width-scale"))\n                        this._dWidth = o["dw"];\n                    if (propSet.has("height-abs") || propSet.has("height-scale"))\n                        this._dHeight = o["dh"];\n                    if (propSet.has("z"))\n                        this._dz = o["dz"]\n                }\n            }\n            _LoadFromJson_Legacy(o) {\n                const propSet = this._propSet;\n                const myStartAngle = o["msa"];\n                const theirStartAngle = o["tsa"];\n                const pinAngle = o["pa"];\n                const pinDist = o["pd"];\n                const mode = o["m"];\n                switch (mode) {\n                case 0:\n                    this._mode = "properties";\n                    propSet.add("x").add("y").add("angle");\n                    this._pinAngle = pinAngle;\n                    this._pinDist = pinDist;\n                    this._dAngle = myStartAngle - theirStartAngle;\n                    this._lastKnownAngle = o["lka"];\n                    break;\n                case 1:\n                    this._mode = "properties";\n                    propSet.add("x").add("y");\n                    this._pinAngle = pinAngle;\n                    this._pinDist = pinDist;\n                    break;\n                case 2:\n                    this._mode = "properties";\n                    propSet.add("angle");\n                    this._dAngle = myStartAngle - theirStartAngle;\n                    this._lastKnownAngle = o["lka"];\n                    break;\n                case 3:\n                    this._mode = "rope";\n                    this._pinDist = o["pd"];\n                    break;\n                case 4:\n                    this._mode = "bar";\n                    this._pinDist = o["pd"];\n                    break\n                }\n            }\n            _OnAfterLoad() {\n                if (this._pinUid === -1)\n                    this._SetPinInst(null);\n                else {\n                    this._SetPinInst(this._runtime.GetInstanceByUID(this._pinUid));\n                    this._pinUid = -1\n                }\n            }\n            _OnInstanceDestroyed(inst) {\n                if (this._pinInst === inst) {\n                    this._SetPinInst(null);\n                    if (this._destroy)\n                        this._runtime.DestroyInstance(this._inst)\n                }\n            }\n            Tick2() {\n                const pinInst = this._pinInst;\n                if (!pinInst)\n                    return;\n                const pinWi = pinInst.GetWorldInfo();\n                const myInst = this._inst;\n                const myWi = myInst.GetWorldInfo();\n                const mode = this._mode;\n                let bboxChanged = false;\n                if (mode === "rope" || mode === "bar") {\n                    const dist = C3.distanceTo(myWi.GetX(), myWi.GetY(), pinWi.GetX(), pinWi.GetY());\n                    if (dist > this._pinDist || mode === "bar" && dist < this._pinDist) {\n                        const a = C3.angleTo(pinWi.GetX(), pinWi.GetY(), myWi.GetX(), myWi.GetY());\n                        myWi.SetXY(pinWi.GetX() + Math.cos(a) * this._pinDist, pinWi.GetY() + Math.sin(a) * this._pinDist);\n                        bboxChanged = true\n                    }\n                } else {\n                    const propSet = this._propSet;\n                    let v = 0;\n                    if (propSet.has("imagepoint")) {\n                        const [newX,newY] = pinInst.GetImagePoint(this._pinImagePoint);\n                        if (!myWi.EqualsXY(newX, newY)) {\n                            myWi.SetXY(newX, newY);\n                            bboxChanged = true\n                        }\n                    } else if (propSet.has("x") && propSet.has("y")) {\n                        const newX = pinWi.GetX() + Math.cos(pinWi.GetAngle() + this._pinAngle) * this._pinDist;\n                        const newY = pinWi.GetY() + Math.sin(pinWi.GetAngle() + this._pinAngle) * this._pinDist;\n                        if (!myWi.EqualsXY(newX, newY)) {\n                            myWi.SetXY(newX, newY);\n                            bboxChanged = true\n                        }\n                    } else {\n                        v = pinWi.GetX() + this._dx;\n                        if (propSet.has("x") && v !== myWi.GetX()) {\n                            myWi.SetX(v);\n                            bboxChanged = true\n                        }\n                        v = pinWi.GetY() + this._dy;\n                        if (propSet.has("y") && v !== myWi.GetY()) {\n                            myWi.SetY(v);\n                            bboxChanged = true\n                        }\n                    }\n                    if (propSet.has("angle")) {\n                        if (this._lastKnownAngle !== myWi.GetAngle())\n                            this._dAngle = C3.clampAngle(this._dAngle + (myWi.GetAngle() - this._lastKnownAngle));\n                        v = C3.clampAngle(pinWi.GetAngle() + this._dAngle);\n                        if (v !== myWi.GetAngle()) {\n                            myWi.SetAngle(v);\n                            bboxChanged = true\n                        }\n                        this._lastKnownAngle = myWi.GetAngle()\n                    }\n                    if (propSet.has("width-abs")) {\n                        v = pinWi.GetWidth() + this._dWidth;\n                        if (v !== myWi.GetWidth()) {\n                            myWi.SetWidth(v);\n                            bboxChanged = true\n                        }\n                    }\n                    if (propSet.has("width-scale")) {\n                        v = pinWi.GetWidth() * this._dWidth;\n                        if (v !== myWi.GetWidth()) {\n                            myWi.SetWidth(v);\n                            bboxChanged = true\n                        }\n                    }\n                    if (propSet.has("height-abs")) {\n                        v = pinWi.GetHeight() + this._dHeight;\n                        if (v !== myWi.GetHeight()) {\n                            myWi.SetHeight(v);\n                            bboxChanged = true\n                        }\n                    }\n                    if (propSet.has("height-scale")) {\n                        v = pinWi.GetHeight() * this._dHeight;\n                        if (v !== myWi.GetHeight()) {\n                            myWi.SetHeight(v);\n                            bboxChanged = true\n                        }\n                    }\n                    if (propSet.has("z")) {\n                        v = pinWi.GetZElevation() + this._dz;\n                        if (v !== myWi.GetZElevation()) {\n                            myWi.SetZElevation(v);\n                            this._runtime.UpdateRender()\n                        }\n                    }\n                }\n                if (bboxChanged)\n                    myWi.SetBboxChanged()\n            }\n            GetDebuggerProperties() {\n                const prefix = "behaviors.pin.debugger";\n                return [{\n                    title: "$" + this.GetBehaviorType().GetName(),\n                    properties: [{\n                        name: prefix + ".is-pinned",\n                        value: !!this._pinInst\n                    }, {\n                        name: prefix + ".pinned-uid",\n                        value: this._pinInst ? this._pinInst.GetUID() : 0\n                    }]\n                }]\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Pin.Cnds = {\n            IsPinned() {\n                return !!this._pinInst\n            },\n            WillDestroy() {\n                return this._destroy\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Pin.Acts = {\n            PinByDistance(objectClass, mode) {\n                this._Pin(objectClass, mode === 0 ? "rope" : "bar")\n            },\n            PinByProperties(objectClass, ex, ey, ea, ew, eh, ez) {\n                const propList = [];\n                if (ex)\n                    propList.push("x");\n                if (ey)\n                    propList.push("y");\n                if (ea)\n                    propList.push("angle");\n                if (ez)\n                    propList.push("z");\n                if (ew === 1)\n                    propList.push("width-abs");\n                else if (ew === 2)\n                    propList.push("width-scale");\n                if (eh === 1)\n                    propList.push("height-abs");\n                else if (eh === 2)\n                    propList.push("height-scale");\n                if (propList.length === 0)\n                    return;\n                this._Pin(objectClass, "properties", propList)\n            },\n            PinByImagePoint(objectClass, imgPt, ea, ew, eh, ez) {\n                const propList = ["imagepoint"];\n                if (ea)\n                    propList.push("angle");\n                if (ez)\n                    propList.push("z");\n                if (ew === 1)\n                    propList.push("width-abs");\n                else if (ew === 2)\n                    propList.push("width-scale");\n                if (eh === 1)\n                    propList.push("height-abs");\n                else if (eh === 2)\n                    propList.push("height-scale");\n                this._pinImagePoint = imgPt;\n                this._Pin(objectClass, "properties", propList)\n            },\n            SetPinDistance(d) {\n                if (this._mode === "rope" || this._mode === "bar")\n                    this._pinDist = Math.max(d, 0)\n            },\n            SetDestroy(d) {\n                this._destroy = d\n            },\n            Unpin() {\n                this._SetPinInst(null);\n                this._mode = "";\n                this._propSet.clear();\n                this._pinImagePoint = ""\n            },\n            Pin(objectClass, mode) {\n                switch (mode) {\n                case 0:\n                    this._Pin(objectClass, "properties", ["x", "y", "angle"]);\n                    break;\n                case 1:\n                    this._Pin(objectClass, "properties", ["x", "y"]);\n                    break;\n                case 2:\n                    this._Pin(objectClass, "properties", ["angle"]);\n                    break;\n                case 3:\n                    this._Pin(objectClass, "rope");\n                    break;\n                case 4:\n                    this._Pin(objectClass, "bar");\n                    break\n                }\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Pin.Exps = {\n            PinnedUID() {\n                return this._pinInst ? this._pinInst.GetUID() : -1\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Tween = class TweenBehavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Tween.Type = class TweenType extends C3.SDKBehaviorTypeBase {\n            constructor(behaviorType) {\n                super(behaviorType)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const NAMESPACE = C3.Behaviors.Tween;\n        const ENABLED = 0;\n        NAMESPACE.Instance = class TweenInstance extends C3.SDKBehaviorInstanceBase {\n            constructor(behInst, properties) {\n                super(behInst);\n                this._allowMultiple = false;\n                this._enabled = true;\n                if (properties) {\n                    this._allowMultiple = false;\n                    this._enabled = !!properties[ENABLED]\n                }\n                this._activeTweens = new Map;\n                this._disabledTweens = [];\n                this._waitingForReleaseTweens = new Map;\n                this._finishingTween = null;\n                this._activeTweensJson = null;\n                this._disabledTweensJson = null;\n                this._waitingForReleaseTweensJson = null;\n                this._finishingTweenName = "";\n                if (this._enabled)\n                    this._StartTicking2();\n                this._afterLoad = e => this._OnAfterLoad(e);\n                this.GetRuntime().Dispatcher().addEventListener("afterload", this._afterLoad);\n                this._tweenReleased = e => this._OnTweenReleased(e);\n                this.GetRuntime().Dispatcher().addEventListener("tweenstatereleased", this._tweenReleased)\n            }\n            Release() {\n                this.GetRuntime().Dispatcher().removeEventListener("afterload", this._afterLoad);\n                this._afterLoad = null;\n                this.GetRuntime().Dispatcher().addEventListener("tweenstatereleased", this._tweenReleased);\n                this._tweenReleased = null;\n                if (this._finishingTween) {\n                    this.ReleaseAndCompleteTween(this._finishingTween);\n                    this._finishingTween = null\n                }\n                this.ReleaseAndCompleteTweens();\n                this._tweens = null;\n                this.ClearDisabledList();\n                this._disabledTweens = null;\n                this._ReleaseWaitingTweens();\n                this._waitingForReleaseTweens = null;\n                super.Release()\n            }\n            SetEnabled(e) {\n                this._enabled = e;\n                if (this._enabled)\n                    this._StartTicking2();\n                else\n                    this._StopTicking2()\n            }\n            GetEnabled() {\n                return this._enabled\n            }\n            AddToDisabledList(tween) {\n                this._disabledTweens.push(tween)\n            }\n            IsInDisabledList(tween) {\n                return this._disabledTweens.includes(tween)\n            }\n            ClearDisabledList() {\n                C3.clearArray(this._disabledTweens)\n            }\n            GetFinishingTween() {\n                return this._finishingTween\n            }\n            IsInstanceValid() {\n                const inst = this.GetObjectInstance();\n                if (!inst)\n                    return false;\n                return !inst.IsDestroyed()\n            }\n            GetTween(tags, property, includeWaitingForRelease=false) {\n                const tweens = property ? this.PropertyTweens(property, includeWaitingForRelease) : this.AllTweens(includeWaitingForRelease);\n                if (!tweens || !tweens.length)\n                    return;\n                for (const tween of tweens)\n                    if (tween.HasTags(tags))\n                        return tween\n            }\n            GetTweenIncludingWaitingForRelease(tags, property) {\n                return this.GetTween(tags, property, true)\n            }\n            *GetTweens(tags, property, includeWaitingForRelease=false) {\n                const tweens = property ? this.PropertyTweens(property, includeWaitingForRelease) : this.AllTweens(includeWaitingForRelease);\n                if (tweens && tweens.length)\n                    for (const tween of tweens)\n                        if (tween.HasTags(tags))\n                            yield tween\n            }\n            *GetTweensIncludingWaitingForRelease(tags, property) {\n                yield*this.GetTweens(tags, property, true)\n            }\n            PropertyTweens(property, includeWaitingForRelease) {\n                if (includeWaitingForRelease) {\n                    let active = this._activeTweens.get(property);\n                    let waitingForRelease = this._waitingForReleaseTweens.get(property);\n                    if (!active)\n                        active = [];\n                    if (!waitingForRelease)\n                        waitingForRelease = [];\n                    return active.concat(waitingForRelease).filter(t => t).filter(t => !t.IsReleased())\n                } else {\n                    let active = this._activeTweens.get(property);\n                    if (!active)\n                        active = [];\n                    return active.filter(t => t).filter(t => !t.IsReleased())\n                }\n            }\n            AllTweens(includeWaitingForRelease) {\n                if (includeWaitingForRelease) {\n                    const active = [...this._activeTweens.values()].flat();\n                    const waitingForRelease = [...this._waitingForReleaseTweens.values()].flat();\n                    return active.concat(waitingForRelease).filter(t => t).filter(t => !t.IsReleased())\n                } else {\n                    const active = [...this._activeTweens.values()].flat();\n                    return active.filter(t => t).filter(t => !t.IsReleased())\n                }\n            }\n            AllTweensIncludingWaitingForRelease() {\n                return this.AllTweens(true)\n            }\n            SaveToJson() {\n                return {\n                    "s": false,\n                    "e": !!this._enabled,\n                    "at": this._SaveActiveTweensToJson(),\n                    "dt": this._SaveDisabledTweensToJson(),\n                    "wt": this._SaveWaitingForReleaseTweensToJson(),\n                    "ft": this._SaveFinishingTweenToJson()\n                }\n            }\n            LoadFromJson(o) {\n                if (!o)\n                    return;\n                this._activeTweensJson = o["at"];\n                this._disabledTweensJson = o["dt"];\n                this._waitingForReleaseTweensJson = o["wt"];\n                this._finishingTweenName = o["ft"];\n                this._allowMultiple = false;\n                this._enabled = !!o["e"]\n            }\n            _OnAfterLoad(e) {\n                const timelineManager = this.GetRuntime().GetTimelineManager();\n                this._PopulateTweenMap(this._activeTweensJson, this._activeTweens, timelineManager);\n                if (this._disabledTweensJson) {\n                    C3.clearArray(this._disabledTweens);\n                    for (const tweenName of this._disabledTweensJson)\n                        this._PopulateTweenArray(this._disabledTweens, tweenName, timelineManager)\n                }\n                this._PopulateTweenMap(this._waitingForReleaseTweensJson, this._waitingForReleaseTweens, timelineManager);\n                this._finishingTween = this._GetTween(this._finishingTweenName, timelineManager);\n                this._enabled ? this._StartTicking2() : this._StopTicking2()\n            }\n            _OnTweenReleased(e) {\n                const tween = e.tweenState;\n                if (!tween)\n                    return;\n                if (!tween.IsReleased())\n                    return;\n                this._MaybeRemoveFromActiveTweenMap(tween)\n            }\n            _PopulateTweenMap(restoreJson, map, timelineManager) {\n                if (!restoreJson)\n                    return;\n                for (const property in restoreJson) {\n                    let tweens = map.get(property);\n                    tweens ? C3.clearArray(tweens) : tweens = [];\n                    const tweensJson = restoreJson[property];\n                    for (const tweenJson of tweensJson) {\n                        const success = this._PopulateTweenArray(tweens, tweenJson["name"], timelineManager);\n                        if (!success) {\n                            const tween = C3.TweenState.Build({\n                                runtime: this.GetRuntime(),\n                                json: tweenJson\n                            });\n                            tween.AddCompletedCallback(tween => this._FinishTriggers(tween));\n                            timelineManager.AddScheduledTimeline(tween);\n                            this._PopulateTweenArray(tweens, tween, timelineManager)\n                        } else\n                            this._LoadTweenFromJson(tweenJson["name"], tweenJson, timelineManager)\n                    }\n                    map.set(property, tweens)\n                }\n            }\n            _GetTween(name, timelineManager) {\n                return timelineManager.GetScheduledOrPlayingTimelineByName(name)\n            }\n            _PopulateTweenArray(collection, tweenOrName, timelineManager) {\n                if (typeof tweenOrName === "string") {\n                    const tween = this._GetTween(tweenOrName, timelineManager);\n                    if (tween)\n                        return !!collection.push(tween)\n                } else\n                    return !!collection.push(tweenOrName);\n                return false\n            }\n            _LoadTweenFromJson(tweenOrName, tweenJson, timelineManager) {\n                if (typeof tweenOrName === "string") {\n                    const tween = this._GetTween(tweenOrName, timelineManager);\n                    if (tween)\n                        tween._LoadFromJson(tweenJson)\n                } else\n                    tweenOrName._LoadFromJson(tweenJson)\n            }\n            _SaveActiveTweensToJson() {\n                const ret = {};\n                for (const [property,tweens] of this._activeTweens)\n                    ret[property] = tweens.filter(t => !t.IsReleased()).map(t => t._SaveToJson());\n                return ret\n            }\n            _SaveDisabledTweensToJson() {\n                return this._disabledTweens.filter(t => !t.IsReleased()).map(t => t.GetName())\n            }\n            _SaveWaitingForReleaseTweensToJson() {\n                const ret = {};\n                for (const [property,tweens] of this._waitingForReleaseTweens)\n                    ret[property] = tweens.map(tween => tween._SaveToJson());\n                return ret\n            }\n            _SaveFinishingTweenToJson() {\n                return this._finishingTween ? this._finishingTween.GetName() : ""\n            }\n            Tick2() {\n                this._ReleaseWaitingTweens()\n            }\n            CreateTween(args) {\n                const propertyTracksConfig = NAMESPACE.Config.GetPropertyTracksConfig(args.property, args.startValue, args.endValue, args.ease, args.resultMode, this.GetObjectInstance());\n                const tweenId = NAMESPACE.Maps.GetPropertyFromIndex(args.property);\n                if (!NAMESPACE.Maps.IsValueId(tweenId))\n                    this.ReleaseTweens(args.property);\n                const tween = C3.TweenState.Build({\n                    runtime: this.GetRuntime(),\n                    id: tweenId,\n                    tags: args.tags,\n                    time: args.time,\n                    instance: this.GetObjectInstance(),\n                    releaseOnComplete: !!args.releaseOnComplete,\n                    loop: !!args.loop,\n                    pingPong: !!args.pingPong,\n                    initialValueMode: args.initialValueMode,\n                    propertyTracksConfig: propertyTracksConfig\n                });\n                tween.AddCompletedCallback(tween => this._FinishTriggers(tween));\n                this._AddTween(tween, args.property);\n                return tween\n            }\n            _MaybeRemoveFromActiveTweenMap(tween) {\n                const id = tween.GetId();\n                if (this._activeTweens.has(id)) {\n                    const tweenArray = this._activeTweens.get(id);\n                    if (tweenArray) {\n                        const index = tweenArray.indexOf(tween);\n                        if (index !== -1)\n                            tweenArray.splice(index, 1)\n                    }\n                }\n            }\n            ReleaseTween(tween, complete=false) {\n                this._MaybeRemoveFromActiveTweenMap(tween);\n                if (tween.IsReleased())\n                    return;\n                if (this._IsInWaitingList(tween))\n                    return;\n                tween.Stop(complete);\n                this._AddToWaitingList(tween)\n            }\n            ReleaseTweens(indexProperty, complete=false) {\n                if (C3.IsFiniteNumber(indexProperty)) {\n                    const stringProperty = NAMESPACE.Maps.GetPropertyFromIndex(indexProperty);\n                    if (!this._activeTweens.has(stringProperty))\n                        return;\n                    const tweenArray = this._activeTweens.get(stringProperty);\n                    const finishingTween = this.GetFinishingTween();\n                    for (const tween of tweenArray) {\n                        if (tween === finishingTween)\n                            continue;\n                        if (tween.IsReleased())\n                            continue;\n                        if (this._IsInWaitingList(tween))\n                            continue;\n                        tween.Stop(complete);\n                        tween.Release()\n                    }\n                    C3.clearArray(tweenArray)\n                } else {\n                    const finishingTween = this.GetFinishingTween();\n                    for (const tween of this.AllTweens()) {\n                        if (tween === finishingTween)\n                            continue;\n                        if (tween.IsReleased())\n                            continue;\n                        if (this._IsInWaitingList(tween))\n                            continue;\n                        tween.Stop(complete);\n                        tween.Release()\n                    }\n                    for (const property of this._activeTweens.keys()) {\n                        C3.clearArray(this._activeTweens.get(property));\n                        this._activeTweens.delete(property)\n                    }\n                    this._activeTweens.clear()\n                }\n            }\n            ReleaseAndCompleteTween(tween) {\n                this.ReleaseTween(tween, true)\n            }\n            ReleaseAndCompleteTweens() {\n                this.ReleaseTweens(NaN, true)\n            }\n            GetPropertyValueByIndex(index) {\n                switch (index) {\n                case ENABLED:\n                    return this._enabled\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                switch (index) {\n                case ENABLED:\n                    this._enabled = !!value;\n                    break\n                }\n            }\n            _GetBehaviorType(tween) {\n                const instance = tween.GetInstance();\n                const behaviorInstances = instance.GetBehaviorInstances();\n                for (const behaviorInstance of behaviorInstances) {\n                    const behaviorType = behaviorInstance.GetBehaviorType();\n                    if (behaviorType.GetInstanceSdkCtor() === this.constructor)\n                        return behaviorType\n                }\n            }\n            Trigger(method, runtime, inst, behaviorType) {\n                if (this._runtime)\n                    return super.Trigger(method);\n                else\n                    return runtime.Trigger(method, inst, behaviorType)\n            }\n            _FinishTriggers(tween) {\n                this._finishingTween = tween;\n                NAMESPACE.Cnds.SetFinishingTween(tween);\n                let instance;\n                let runtime;\n                if (!this.GetRuntime()) {\n                    instance = tween.GetInstance();\n                    if (!instance)\n                        return;\n                    if (instance && instance.IsDestroyed())\n                        return;\n                    runtime = instance.GetRuntime();\n                    const behaviorType = this._GetBehaviorType(tween);\n                    this.Trigger(NAMESPACE.Cnds.OnTweensFinished, runtime, instance, behaviorType);\n                    this.Trigger(NAMESPACE.Cnds.OnAnyTweensFinished, runtime, instance, behaviorType);\n                    tween.Stop()\n                } else {\n                    instance = this._inst;\n                    runtime = this._runtime;\n                    this.Trigger(NAMESPACE.Cnds.OnTweensFinished);\n                    this.Trigger(NAMESPACE.Cnds.OnAnyTweensFinished);\n                    this.ReleaseTween(tween)\n                }\n                this._finishingTween = null;\n                NAMESPACE.Cnds.SetFinishingTween(null);\n                if (tween.GetDestroyInstanceOnComplete())\n                    runtime.DestroyInstance(instance)\n            }\n            _AddTween(tween, indexProperty) {\n                const stringProperty = NAMESPACE.Maps.GetPropertyFromIndex(indexProperty);\n                if (!this._activeTweens.has(stringProperty))\n                    this._activeTweens.set(stringProperty, []);\n                const tweenArray = this._activeTweens.get(stringProperty);\n                tweenArray.push(tween)\n            }\n            _AddToWaitingList(tween) {\n                const id = tween.GetId();\n                if (!this._waitingForReleaseTweens.has(id))\n                    this._waitingForReleaseTweens.set(id, []);\n                this._waitingForReleaseTweens.get(id).push(tween)\n            }\n            _IsInWaitingList(tween) {\n                const id = tween.GetId();\n                if (!this._waitingForReleaseTweens.has(id))\n                    return false;\n                return this._waitingForReleaseTweens.get(id).includes(tween)\n            }\n            _ReleaseWaitingTweens() {\n                if (!this._waitingForReleaseTweens.size)\n                    return;\n                for (const tweenArray of this._waitingForReleaseTweens.values()) {\n                    for (const tween of tweenArray) {\n                        if (tween.IsReleased())\n                            continue;\n                        tween.Release()\n                    }\n                    C3.clearArray(tweenArray)\n                }\n                this._waitingForReleaseTweens.clear()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        let finishingTween = null;\n        C3.Behaviors.Tween.Cnds = {\n            SetFinishingTween(tween) {\n                finishingTween = tween\n            },\n            OnTweensFinished(tags) {\n                return finishingTween.HasTags(tags)\n            },\n            OnAnyTweensFinished() {\n                return true\n            },\n            IsPlaying(tags) {\n                const tweens = [...this.GetTweensIncludingWaitingForRelease(tags)];\n                if (!tweens)\n                    return false;\n                if (!tweens.length)\n                    return false;\n                return tweens.some(C3.TweenState.IsPlaying)\n            },\n            IsAnyPlaying() {\n                const tweens = [...this.AllTweensIncludingWaitingForRelease()];\n                if (!tweens)\n                    return false;\n                if (!tweens.length)\n                    return false;\n                return tweens.some(C3.TweenState.IsPlaying)\n            },\n            IsPaused(tags) {\n                const tweens = [...this.GetTweensIncludingWaitingForRelease(tags)];\n                if (!tweens)\n                    return false;\n                if (!tweens.length)\n                    return false;\n                return tweens.some(C3.TweenState.IsPaused)\n            },\n            IsAnyPaused() {\n                const tweens = [...this.AllTweensIncludingWaitingForRelease()];\n                if (!tweens)\n                    return false;\n                if (!tweens.length)\n                    return false;\n                return tweens.some(C3.TweenState.IsPaused)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const Ease = self.Ease;\n        const NAMESPACE = C3.Behaviors.Tween;\n        NAMESPACE.Acts = {\n            SetEnabled(enable) {\n                this.SetEnabled(!!enable);\n                for (const tween of this.AllTweens())\n                    if (!!enable) {\n                        if (this.IsInDisabledList(tween))\n                            tween.Resume()\n                    } else {\n                        if (tween.IsPlaying() || tween.IsScheduled())\n                            this.AddToDisabledList(tween);\n                        tween.Stop()\n                    }\n                if (enable)\n                    this.ClearDisabledList()\n            },\n            async TweenOneProperty(...args) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                const tween = this.CreateTween(NAMESPACE.TweenArguments.OneProperty(this, ...args));\n                if (tween.Play())\n                    await tween.GetPlayPromise()\n            },\n            async TweenTwoProperties(...args) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                const tween = this.CreateTween(NAMESPACE.TweenArguments.TwoProperties(this, ...args));\n                if (tween.Play())\n                    await tween.GetPlayPromise()\n            },\n            async TweenValue(...args) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                const tween = this.CreateTween(NAMESPACE.TweenArguments.ValueProperty(this, ...args));\n                if (tween.Play())\n                    await tween.GetPlayPromise()\n            },\n            PauseTweens(tags) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                for (const tween of this.GetTweens(tags))\n                    tween.Stop()\n            },\n            PauseAllTweens() {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                for (const tween of this.AllTweens())\n                    tween.Stop()\n            },\n            ResumeTweens(tags) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                for (const tween of this.GetTweens(tags))\n                    tween.Resume()\n            },\n            ResumeAllTweens() {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                for (const tween of this.AllTweens())\n                    tween.Resume()\n            },\n            StopTweens(tags) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                for (const tween of this.GetTweens(tags))\n                    this.ReleaseTween(tween)\n            },\n            StopAllTweens() {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                for (const tween of this.AllTweens())\n                    this.ReleaseTween(tween)\n            },\n            SetOnePropertyTweensEndValue(tags, property, endValue) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                const propertyName = C3.Behaviors.Tween.Maps.GetSinglePropertyFromIndex(property);\n                for (const tween of this.GetTweens(tags)) {\n                    tween.BeforeSetEndValues([propertyName]);\n                    tween.SetEndValue(endValue, propertyName)\n                }\n            },\n            SetTwoPropertiesTweensEndValue(tags, property, endValueX, endValueY) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                const properties = C3.Behaviors.Tween.Maps.GetRealProperties(property);\n                for (const tween of this.GetTweens(tags)) {\n                    tween.BeforeSetEndValues(properties);\n                    tween.SetEndValue(endValueX, properties[0]);\n                    tween.SetEndValue(endValueY, properties[1])\n                }\n            },\n            SetValuePropertyTweensStartValue(tags, startValue) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                for (const tween of this.GetTweens(tags, "value"))\n                    tween.SetStartValue(startValue, "value")\n            },\n            SetValuePropertyTweensEndValue(tags, endValue) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                for (const tween of this.GetTweens(tags, "value")) {\n                    tween.BeforeSetEndValues(["value"]);\n                    tween.SetEndValue(endValue, "value")\n                }\n            },\n            SetTweensEase(tags, easeIndex) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                const ease = Ease.GetEaseFromIndex(easeIndex);\n                for (const tween of this.GetTweens(tags))\n                    tween.SetEase(ease)\n            },\n            SetAllTweensEase(easeIndex) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                const ease = Ease.GetEaseFromIndex(easeIndex);\n                for (const tween of this.AllTweens())\n                    tween.SetEase(ease)\n            },\n            SetTweensTime(tags, time) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                for (const tween of this.GetTweens(tags))\n                    tween.SetTime(time)\n            },\n            SetAllTweensTime(time) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                for (const tween of this.AllTweens())\n                    tween.SetTime(time)\n            },\n            SetTweensPlaybackRate(tags, rate) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                for (const tween of this.GetTweens(tags))\n                    tween.SetPlaybackRate(rate)\n            },\n            SetAllTweensPlaybackRate(rate) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                for (const tween of this.AllTweens())\n                    tween.SetPlaybackRate(rate)\n            },\n            SetTweensDestroyOnComplete(tags, destroyOnComplete) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                for (const tween of this.GetTweens(tags))\n                    tween.SetDestroyInstanceOnComplete(!!destroyOnComplete)\n            },\n            SetAllTweensDestroyOnComplete(destroyOnComplete) {\n                if (!this.GetEnabled() || !this.IsInstanceValid())\n                    return;\n                for (const tween of this.AllTweens())\n                    tween.SetDestroyInstanceOnComplete(!!destroyOnComplete)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Tween.Exps = {\n            Time(tags) {\n                const tween = this.GetTweenIncludingWaitingForRelease(tags);\n                if (!tween)\n                    return 0;\n                return tween.GetTime()\n            },\n            Progress(tags) {\n                const tween = this.GetTweenIncludingWaitingForRelease(tags);\n                if (!tween)\n                    return 0;\n                return tween.GetTime() \/ tween.GetTotalTime()\n            },\n            Value(tags) {\n                const tween = this.GetTweenIncludingWaitingForRelease(tags, "value");\n                if (!tween)\n                    return 0;\n                return tween.GetPropertyTrack("value").GetSourceAdapterValue()\n            },\n            Tags() {\n                if (!this.GetFinishingTween())\n                    return "";\n                return this.GetFinishingTween().GetStringTags()\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const Ease = self.Ease;\n    const PAIR_PROPERTIES = ["position", "size", "scale"];\n    const SINGLE_PROPERTIES = ["offsetX", "offsetY", "offsetWidth", "offsetHeight", "offsetAngle", "offsetOpacity", "offsetColor", "offsetZElevation", "offsetScaleX", "offsetScaleY"];\n    const VALUE_PROPERTIES = ["value"];\n    const PROPERTY_INDEX_TO_NAME = [].concat(PAIR_PROPERTIES).concat(SINGLE_PROPERTIES).concat(VALUE_PROPERTIES);\n    const PROPERTY_PAIR_TO_REAL_PROPERTIES = {\n        "position": ["offsetX", "offsetY"],\n        "size": ["offsetWidth", "offsetHeight"],\n        "scale": ["offsetScaleX", "offsetScaleY"]\n    };\n    const ALL_REAL_PROPERTIES = Object.assign({}, PROPERTY_INDEX_TO_NAME.reduce( (o, key) => Object.assign({}, o, {\n        [key]: [key]\n    }), {}), PROPERTY_PAIR_TO_REAL_PROPERTIES);\n    C3.Behaviors.Tween.Maps = class Maps {\n        constructor() {}\n        static GetEases() {\n            return [...Ease.GetRuntimeEaseNames()]\n        }\n        static GetEaseFromIndex(index) {\n            return [...Ease.GetRuntimeEaseNames()][index]\n        }\n        static GetPropertyFromIndex(index) {\n            return PROPERTY_INDEX_TO_NAME[index]\n        }\n        static GetPropertyIndexFromName(name) {\n            return PROPERTY_INDEX_TO_NAME.indexOf(name)\n        }\n        static GetPairPropertyFromIndex(index) {\n            return PAIR_PROPERTIES[index]\n        }\n        static GetSinglePropertyFromIndex(index) {\n            return SINGLE_PROPERTIES[index]\n        }\n        static GetValuePropertyFromIndex(index) {\n            return VALUE_PROPERTIES[index]\n        }\n        static GetPairProperties(pairId) {\n            return PROPERTY_PAIR_TO_REAL_PROPERTIES[pairId]\n        }\n        static GetRealProperties(id) {\n            if (C3.IsString(id))\n                return ALL_REAL_PROPERTIES[id];\n            else\n                return ALL_REAL_PROPERTIES[PROPERTY_INDEX_TO_NAME[id]]\n        }\n        static IsPairId(id) {\n            return !!PROPERTY_PAIR_TO_REAL_PROPERTIES[id]\n        }\n        static IsColorId(id) {\n            return id === "offsetColor"\n        }\n        static IsAngleId(id) {\n            return id === "offsetAngle"\n        }\n        static IsOpacityId(id) {\n            return id === "offsetOpacity"\n        }\n        static IsValueId(id) {\n            return id === "value"\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const NAMESPACE = C3.Behaviors.Tween;\n    const TWEEN_CONFIGURATIONS = new Map;\n    NAMESPACE.Config = class Config {\n        constructor() {}\n        static GetPropertyTracksConfig(property, startValue, endValue, ease, resultMode, instance) {\n            if (TWEEN_CONFIGURATIONS.size === 0)\n                this._CreateConfigObjects();\n            const propertyType = NAMESPACE.PropertyTypes.Pick(property);\n            let config = TWEEN_CONFIGURATIONS.get(propertyType);\n            if (C3.IsFiniteNumber(property))\n                property = NAMESPACE.Maps.GetPropertyFromIndex(property);\n            return this._GetConfig(config, property, startValue, endValue, ease, resultMode, instance)\n        }\n        static TransformValue(property, value) {\n            const configFunctionObject = C3.Behaviors.Tween.GetPropertyTracksConfig(property);\n            return configFunctionObject.valueGetter(value)\n        }\n        static _CreateConfigObjects() {\n            const types = NAMESPACE.PropertyTypes;\n            const getters = NAMESPACE.ValueGetters;\n            this._AddConfigObject(types.PAIR, this._GetPairConfig, getters._GetPropertyValue);\n            this._AddConfigObject(types.COLOR, this._GetColorConfig, getters._GetColorPropertyValue);\n            this._AddConfigObject(types.ANGLE, this._GetAngleConfig, getters._GetPropertyAngleValue);\n            this._AddConfigObject(types.VALUE, this._GetValueConfig, getters._GetPropertyValue);\n            this._AddConfigObject(types.OTHER, this._GetCommonConfig, getters._GetPropertyValue)\n        }\n        static _AddConfigObject(name, configGetter, valueGetter) {\n            TWEEN_CONFIGURATIONS.set(name, this._CreateConfigObject(name, configGetter, valueGetter))\n        }\n        static _CreateConfigObject(name, configFunc, valueGetter) {\n            return {\n                name: name,\n                configFunc: configFunc,\n                valueGetter: valueGetter\n            }\n        }\n        static _GetConfig(config, property, startValue, endValue, ease, resultMode, instance) {\n            return config.configFunc(property, config.valueGetter(startValue), config.valueGetter(endValue), ease, resultMode, instance)\n        }\n        static _GetPairConfig(property, startValues, endValues, ease, resultMode, instance) {\n            const properties = NAMESPACE.Maps.GetPairProperties(property);\n            return properties.map( (property, index) => {\n                return {\n                    sourceId: "world-instance",\n                    property: property,\n                    type: "float",\n                    valueType: "numeric",\n                    startValue: startValues[index],\n                    endValue: endValues[index],\n                    ease: NAMESPACE.Maps.GetEaseFromIndex(ease),\n                    resultMode: resultMode\n                }\n            }\n            )\n        }\n        static _GetColorConfig(property, startValue, endValue, ease, resultMode, instance) {\n            if (C3.Plugins.Text && instance.GetPlugin()instanceof C3.Plugins.Text)\n                return {\n                    sourceId: "plugin",\n                    sourceArgs: [7],\n                    property: "color",\n                    type: "color",\n                    valueType: "color",\n                    startValue: startValue,\n                    endValue: endValue,\n                    ease: NAMESPACE.Maps.GetEaseFromIndex(ease),\n                    resultMode: resultMode\n                };\n            else\n                return {\n                    sourceId: "world-instance",\n                    property: property,\n                    type: "color",\n                    valueType: "color",\n                    startValue: startValue,\n                    endValue: endValue,\n                    ease: NAMESPACE.Maps.GetEaseFromIndex(ease),\n                    resultMode: resultMode\n                }\n        }\n        static _GetAngleConfig(property, startValue, endValue, ease, resultMode, instance) {\n            return {\n                sourceId: "world-instance",\n                property: property,\n                type: "angle",\n                valueType: "angle",\n                startValue: startValue,\n                endValue: endValue,\n                ease: NAMESPACE.Maps.GetEaseFromIndex(ease),\n                resultMode: resultMode\n            }\n        }\n        static _GetCommonConfig(property, startValue, endValue, ease, resultMode, instance) {\n            return {\n                sourceId: "world-instance",\n                property: property,\n                type: "float",\n                valueType: "numeric",\n                startValue: startValue,\n                endValue: endValue,\n                ease: NAMESPACE.Maps.GetEaseFromIndex(ease),\n                resultMode: resultMode\n            }\n        }\n        static _GetValueConfig(property, startValue, endValue, ease, resultMode, instance) {\n            return {\n                sourceId: "value",\n                property: property,\n                type: "float",\n                valueType: "numeric",\n                startValue: startValue,\n                endValue: endValue,\n                ease: NAMESPACE.Maps.GetEaseFromIndex(ease),\n                resultMode: resultMode\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const NAMESPACE = C3.Behaviors.Tween;\n    const COMMON_FIXED_ARGS = {\n        resultMode: "absolute"\n    };\n    const COMMON_VARIABLE_ARGS = Object.assign({}, COMMON_FIXED_ARGS, {\n        tags: "",\n        property: "",\n        time: 0,\n        ease: 0,\n        releaseOnComplete: 0,\n        loop: false,\n        pingPong: false\n    });\n    const ONE_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, {\n        initialValueMode: "current-state",\n        startValue: 0,\n        endValue: 0\n    });\n    const TWO_PROPERTIES_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, {\n        initialValueMode: "current-state",\n        startValue: [0, 0],\n        endValue: [0, 0]\n    });\n    const COLOR_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, {\n        initialValueMode: "current-state",\n        startValue: [0, 0, 0],\n        endValue: [0, 0, 0]\n    });\n    const VALUE_PROPERTY_ARGS = Object.assign({}, ONE_PROPERTY_ARGS, {\n        initialValueMode: "start-value"\n    });\n    const X = 0;\n    const Y = 1;\n    const R = 0;\n    const G = 1;\n    const B = 2;\n    NAMESPACE.TweenArguments = class TweenArguments {\n        constructor() {}\n        static _SetCommonProperties(argsObject, tags, time, ease, destroyOnComplete, loop, pingPong) {\n            argsObject.tags = tags;\n            argsObject.time = time;\n            argsObject.ease = ease;\n            argsObject.releaseOnComplete = destroyOnComplete;\n            argsObject.loop = loop;\n            argsObject.pingPong = pingPong\n        }\n        static OneProperty(inst, tags, property, endValue, time, ease, destroyOnComplete, loop, pingPong) {\n            const propertyName = NAMESPACE.Maps.GetSinglePropertyFromIndex(property);\n            const args = NAMESPACE.Maps.IsColorId(propertyName) ? COLOR_PROPERTY_ARGS : ONE_PROPERTY_ARGS;\n            this._SetCommonProperties(args, tags, time, ease, destroyOnComplete, loop, pingPong);\n            if (NAMESPACE.Maps.IsColorId(propertyName)) {\n                COLOR_PROPERTY_ARGS.endValue[R] = C3.GetRValue(endValue);\n                COLOR_PROPERTY_ARGS.endValue[G] = C3.GetGValue(endValue);\n                COLOR_PROPERTY_ARGS.endValue[B] = C3.GetBValue(endValue);\n                COLOR_PROPERTY_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName(propertyName)\n            } else if (NAMESPACE.Maps.IsOpacityId(propertyName))\n                ONE_PROPERTY_ARGS.endValue = endValue \/ 100;\n            else\n                ONE_PROPERTY_ARGS.endValue = endValue;\n            args.property = NAMESPACE.Maps.GetPropertyIndexFromName(propertyName);\n            return args\n        }\n        static TwoProperties(inst, tags, property, endValueX, endValueY, time, ease, destroyOnComplete, loop, pingPong) {\n            this._SetCommonProperties(TWO_PROPERTIES_ARGS, tags, time, ease, destroyOnComplete, loop, pingPong);\n            const pairName = NAMESPACE.Maps.GetPairPropertyFromIndex(property);\n            TWO_PROPERTIES_ARGS.endValue[X] = endValueX;\n            TWO_PROPERTIES_ARGS.endValue[Y] = endValueY;\n            TWO_PROPERTIES_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName(pairName);\n            return TWO_PROPERTIES_ARGS\n        }\n        static ValueProperty(inst, tags, startValue, endValue, time, ease, destroyOnComplete, loop, pingPong) {\n            this._SetCommonProperties(VALUE_PROPERTY_ARGS, tags, time, ease, destroyOnComplete, loop, pingPong);\n            VALUE_PROPERTY_ARGS.startValue = startValue;\n            VALUE_PROPERTY_ARGS.endValue = endValue;\n            VALUE_PROPERTY_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName("value");\n            return VALUE_PROPERTY_ARGS\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const NAMESPACE = C3.Behaviors.Tween;\n    const TYPE_CHECK_OBJECTS = [];\n    NAMESPACE.PropertyTypes = class PropertyTypes {\n        constructor() {}\n        static Pick(property) {\n            if (TYPE_CHECK_OBJECTS.length === 0) {\n                const arr = TYPE_CHECK_OBJECTS;\n                arr.push({\n                    checkFunc: NAMESPACE.Maps.IsPairId,\n                    result: this.PAIR\n                });\n                arr.push({\n                    checkFunc: NAMESPACE.Maps.IsColorId,\n                    result: this.COLOR\n                });\n                arr.push({\n                    checkFunc: NAMESPACE.Maps.IsAngleId,\n                    result: this.ANGLE\n                });\n                arr.push({\n                    checkFunc: NAMESPACE.Maps.IsValueId,\n                    result: this.VALUE\n                });\n                arr.push({\n                    checkFunc: () => true,\n                    result: this.OTHER\n                })\n            }\n            if (C3.IsFiniteNumber(property))\n                property = C3.Behaviors.Tween.Maps.GetPropertyFromIndex(property);\n            for (const propertyTypeFunctionObject of TYPE_CHECK_OBJECTS)\n                if (propertyTypeFunctionObject.checkFunc(property))\n                    return propertyTypeFunctionObject.result\n        }\n        static get PAIR() {\n            return "pair"\n        }\n        static get COLOR() {\n            return "color"\n        }\n        static get ANGLE() {\n            return "angle"\n        }\n        static get VALUE() {\n            return "value"\n        }\n        static get OTHER() {\n            return "other"\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const NAMESPACE = C3.Behaviors.Tween;\n    NAMESPACE.ValueGetters = class ValueGetters {\n        constructor() {}\n        static _GetPropertyAngleValue(value) {\n            const r = C3.toRadians(parseFloat(value));\n            return C3.clampAngle(r)\n        }\n        static _GetColorPropertyValue(value) {\n            return value.slice(0)\n        }\n        static _GetPropertyValue(value) {\n            return value\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Behaviors.bound = class BoundBehavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.bound.Type = class BoundType extends C3.SDKBehaviorTypeBase {\n            constructor(behaviorType) {\n                super(behaviorType)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const MODE = 0;\n        C3.Behaviors.bound.Instance = class BoundInstance extends C3.SDKBehaviorInstanceBase {\n            constructor(behInst, properties) {\n                super(behInst);\n                this._mode = 0;\n                if (properties)\n                    this._mode = properties[MODE];\n                this._StartTicking2()\n            }\n            Release() {\n                super.Release()\n            }\n            SaveToJson() {\n                return {\n                    "m": this._mode\n                }\n            }\n            LoadFromJson(o) {\n                this._mode = o["m"]\n            }\n            Tick2() {\n                const wi = this._inst.GetWorldInfo();\n                const bbox = wi.GetBoundingBox();\n                const layout = wi.GetLayout();\n                let isChanged = false;\n                if (this._mode === 0) {\n                    if (wi.GetX() < 0) {\n                        wi.SetX(0);\n                        isChanged = true\n                    }\n                    if (wi.GetY() < 0) {\n                        wi.SetY(0);\n                        isChanged = true\n                    }\n                    if (wi.GetX() > layout.GetWidth()) {\n                        wi.SetX(layout.GetWidth());\n                        isChanged = true\n                    }\n                    if (wi.GetY() > layout.GetHeight()) {\n                        wi.SetY(layout.GetHeight());\n                        isChanged = true\n                    }\n                } else {\n                    if (bbox.getLeft() < 0) {\n                        wi.OffsetX(-bbox.getLeft());\n                        isChanged = true\n                    }\n                    if (bbox.getTop() < 0) {\n                        wi.OffsetY(-bbox.getTop());\n                        isChanged = true\n                    }\n                    if (bbox.getRight() > layout.GetWidth()) {\n                        wi.OffsetX(-(bbox.getRight() - layout.GetWidth()));\n                        isChanged = true\n                    }\n                    if (bbox.getBottom() > layout.GetHeight()) {\n                        wi.OffsetY(-(bbox.getBottom() - layout.GetHeight()));\n                        isChanged = true\n                    }\n                }\n                if (isChanged)\n                    wi.SetBboxChanged()\n            }\n            GetPropertyValueByIndex(index) {\n                switch (index) {\n                case MODE:\n                    return this._mode\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                switch (index) {\n                case MODE:\n                    this._mode = value;\n                    break\n                }\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.bound.Cnds = {}\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.bound.Acts = {}\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.bound.Exps = {}\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Behaviors.MoveTo = class MoveToBehavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.MoveTo.Type = class MoveToType extends C3.SDKBehaviorTypeBase {\n            constructor(behaviorType) {\n                super(behaviorType)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        const IBehaviorInstance = self.IBehaviorInstance;\n        const PROP_MAX_SPEED = 0;\n        const PROP_ACCELERATION = 1;\n        const PROP_DECELERATION = 2;\n        const PROP_ROTATE_SPEED = 3;\n        const PROP_SET_ANGLE = 4;\n        const PROP_STOP_ON_SOLIDS = 5;\n        const PROP_ENABLED = 6;\n        C3.Behaviors.MoveTo.Instance = class MoveToInstance extends C3.SDKBehaviorInstanceBase {\n            constructor(behInst, properties) {\n                super(behInst);\n                this._maxSpeed = 200;\n                this._acc = 600;\n                this._dec = 600;\n                this._rotateSpeed = 0;\n                this._setAngle = true;\n                this._stopOnSolids = false;\n                this._isEnabled = true;\n                this._speed = 0;\n                this._movingAngle = this.GetWorldInfo().GetAngle();\n                this._waypoints = [];\n                if (properties) {\n                    this._maxSpeed = properties[PROP_MAX_SPEED];\n                    this._acc = properties[PROP_ACCELERATION];\n                    this._dec = properties[PROP_DECELERATION];\n                    this._rotateSpeed = C3.toRadians(properties[PROP_ROTATE_SPEED]);\n                    this._setAngle = properties[PROP_SET_ANGLE];\n                    this._stopOnSolids = properties[PROP_STOP_ON_SOLIDS];\n                    this._isEnabled = properties[PROP_ENABLED]\n                }\n            }\n            Release() {\n                super.Release()\n            }\n            SaveToJson() {\n                return {\n                    "ms": this._maxSpeed,\n                    "acc": this._acc,\n                    "dec": this._dec,\n                    "rs": this._rotateSpeed,\n                    "sa": this._setAngle,\n                    "sos": this._stopOnSolids,\n                    "s": this._speed,\n                    "ma": this._movingAngle,\n                    "wp": this._waypoints.map(p => ({\n                        "x": p.x,\n                        "y": p.y\n                    })),\n                    "e": this._isEnabled\n                }\n            }\n            LoadFromJson(o) {\n                this._maxSpeed = o["ms"];\n                this._acc = o["acc"];\n                this._dec = o["dec"];\n                this._rotateSpeed = o["rs"];\n                this._setAngle = o["sa"];\n                this._stopOnSolids = o["sos"];\n                this._speed = o["s"];\n                this._movingAngle = o["ma"];\n                this._waypoints = o["wp"].map(p => ({\n                    x: p["x"],\n                    y: p["y"]\n                }));\n                this._SetEnabled(o["e"]);\n                if (this._isEnabled && this._waypoints.length > 0)\n                    this._StartTicking()\n            }\n            _AddWaypoint(x, y, isDirect) {\n                if (isDirect)\n                    C3.clearArray(this._waypoints);\n                this._waypoints.push({\n                    x,\n                    y\n                });\n                if (this._isEnabled)\n                    this._StartTicking()\n            }\n            _GetWaypointCount() {\n                return this._waypoints.length\n            }\n            _GetWaypointXAt(i) {\n                i = Math.floor(i);\n                if (i < 0 || i >= this._waypoints.length)\n                    return 0;\n                return this._waypoints[i].x\n            }\n            _GetWaypointYAt(i) {\n                i = Math.floor(i);\n                if (i < 0 || i >= this._waypoints.length)\n                    return 0;\n                return this._waypoints[i].y\n            }\n            _IsMoving() {\n                return this._waypoints.length > 0\n            }\n            _Stop() {\n                C3.clearArray(this._waypoints);\n                this._speed = 0;\n                this._StopTicking()\n            }\n            _GetTargetX() {\n                if (this._waypoints.length > 0)\n                    return this._waypoints[0].x;\n                else\n                    return 0\n            }\n            _GetTargetY() {\n                if (this._waypoints.length > 0)\n                    return this._waypoints[0].y;\n                else\n                    return 0\n            }\n            _SetSpeed(s) {\n                if (!this._IsMoving())\n                    return;\n                this._speed = Math.min(s, this._maxSpeed)\n            }\n            _GetSpeed() {\n                return this._speed\n            }\n            _SetMaxSpeed(ms) {\n                this._maxSpeed = Math.max(ms, 0);\n                this._SetSpeed(this._speed)\n            }\n            _GetMaxSpeed() {\n                return this._maxSpeed\n            }\n            _IsRotationEnabled() {\n                return this._rotateSpeed !== 0\n            }\n            Tick() {\n                if (!this._isEnabled || !this._IsMoving())\n                    return;\n                const dt = this._runtime.GetDt(this._inst);\n                const wi = this._inst.GetWorldInfo();\n                const startX = wi.GetX();\n                const startY = wi.GetY();\n                const startAngle = wi.GetAngle();\n                let curSpeed = this._speed;\n                let maxSpeed = this._maxSpeed;\n                const acc = this._acc;\n                const dec = this._dec;\n                const targetX = this._GetTargetX();\n                const targetY = this._GetTargetY();\n                const angleToTarget = C3.angleTo(startX, startY, targetX, targetY);\n                let isWithinStoppingDistance = false;\n                if (dec > 0 && this._waypoints.length === 1) {\n                    const stoppingDist = .5 * curSpeed * curSpeed \/ dec * 1.0001;\n                    isWithinStoppingDistance = C3.distanceSquared(startX, startY, targetX, targetY) <= stoppingDist * stoppingDist;\n                    if (isWithinStoppingDistance) {\n                        const remainingDist = C3.distanceTo(startX, startY, targetX, targetY);\n                        curSpeed = Math.sqrt(2 * dec * remainingDist);\n                        maxSpeed = curSpeed;\n                        this._speed = curSpeed\n                    }\n                }\n                if (this._IsRotationEnabled()) {\n                    const da = C3.angleDiff(this._movingAngle, angleToTarget);\n                    if (da > Number.EPSILON) {\n                        const t = da \/ this._rotateSpeed;\n                        const dist = C3.distanceTo(wi.GetX(), wi.GetY(), targetX, targetY);\n                        const r = dist \/ (2 * Math.sin(da));\n                        const curveDist = r * da;\n                        maxSpeed = Math.min(maxSpeed, C3.clamp(curveDist \/ t, 0, this._maxSpeed))\n                    }\n                }\n                let curAcc = isWithinStoppingDistance ? -dec : acc;\n                const stepDist = Math.min(curSpeed * dt + .5 * curAcc * dt * dt, maxSpeed * dt);\n                if (isWithinStoppingDistance) {\n                    if (dec > 0) {\n                        this._speed = Math.max(this._speed - dec * dt, 0);\n                        if (this._speed === 0) {\n                            this._OnArrived(wi, targetX, targetY);\n                            return\n                        }\n                    }\n                } else if (acc === 0)\n                    this._speed = maxSpeed;\n                else\n                    this._speed = Math.min(this._speed + acc * dt, maxSpeed);\n                if (C3.distanceSquared(wi.GetX(), wi.GetY(), targetX, targetY) <= stepDist * stepDist) {\n                    this._OnArrived(wi, targetX, targetY);\n                    return\n                }\n                if (this._IsRotationEnabled())\n                    this._movingAngle = C3.angleRotate(this._movingAngle, angleToTarget, this._rotateSpeed * dt);\n                else\n                    this._movingAngle = angleToTarget;\n                wi.OffsetXY(Math.cos(this._movingAngle) * stepDist, Math.sin(this._movingAngle) * stepDist);\n                if (this._setAngle)\n                    wi.SetAngle(this._movingAngle);\n                wi.SetBboxChanged();\n                this._CheckSolidCollision(startX, startY, startAngle)\n            }\n            _OnArrived(wi, targetX, targetY) {\n                wi.SetXY(targetX, targetY);\n                wi.SetBboxChanged();\n                this._waypoints.shift();\n                if (this._waypoints.length === 0) {\n                    this._speed = 0;\n                    this._StopTicking()\n                }\n                this.DispatchScriptEvent("arrived");\n                this.Trigger(C3.Behaviors.MoveTo.Cnds.OnArrived)\n            }\n            _CheckSolidCollision(startX, startY, startAngle) {\n                const collisionEngine = this._runtime.GetCollisionEngine();\n                if (this._stopOnSolids && collisionEngine.TestOverlapSolid(this._inst)) {\n                    this._Stop();\n                    const wi = this._inst.GetWorldInfo();\n                    const x = wi.GetX();\n                    const y = wi.GetY();\n                    const a = C3.angleTo(x, y, startX, startY);\n                    const dist = C3.distanceTo(x, y, startX, startY);\n                    if (!collisionEngine.PushOutSolid(this._inst, Math.cos(a), Math.sin(a), Math.max(dist, 1))) {\n                        wi.SetXY(startX, startY);\n                        wi.SetAngle(startAngle);\n                        wi.SetBboxChanged()\n                    }\n                    this.DispatchScriptEvent("hitsolid");\n                    this.Trigger(C3.Behaviors.MoveTo.Cnds.OnHitSolid)\n                }\n            }\n            _IsSetAngle() {\n                return this._setAngle\n            }\n            _SetSetAngle(a) {\n                this._setAngle = !!a\n            }\n            _SetAngleOfMotion(a) {\n                this._movingAngle = a;\n                if (this._isEnabled && this._setAngle && !this._IsMoving()) {\n                    const wi = this.GetWorldInfo();\n                    wi.SetAngle(this._movingAngle);\n                    wi.SetBboxChanged()\n                }\n            }\n            _GetAngleOfMotion() {\n                return this._movingAngle\n            }\n            _SetAcceleration(a) {\n                this._acc = Math.max(a, 0)\n            }\n            _GetAcceleration() {\n                return this._acc\n            }\n            _SetDeceleration(d) {\n                this._dec = Math.max(d, 0)\n            }\n            _GetDeceleration() {\n                return this._dec\n            }\n            _SetRotateSpeed(r) {\n                this._rotateSpeed = Math.max(r, 0)\n            }\n            _GetRotateSpeed() {\n                return this._rotateSpeed\n            }\n            _SetStopOnSolids(e) {\n                this._stopOnSolids = !!e\n            }\n            _IsStopOnSolids() {\n                return this._stopOnSolids\n            }\n            _SetEnabled(e) {\n                e = !!e;\n                if (this._isEnabled === e)\n                    return;\n                this._isEnabled = e;\n                if (this._isEnabled && this._IsMoving())\n                    this._StartTicking();\n                else\n                    this._StopTicking()\n            }\n            _IsEnabled() {\n                return this._isEnabled\n            }\n            GetPropertyValueByIndex(index) {\n                switch (index) {\n                case PROP_MAX_SPEED:\n                    return this._GetMaxSpeed();\n                case PROP_ACCELERATION:\n                    return this._GetAcceleration();\n                case PROP_DECELERATION:\n                    return this._GetDeceleration();\n                case PROP_ROTATE_SPEED:\n                    return C3.toDegrees(this._GetRotateSpeed());\n                case PROP_SET_ANGLE:\n                    return this._IsSetAngle();\n                case PROP_STOP_ON_SOLIDS:\n                    return this._IsStopOnSolids();\n                case PROP_ENABLED:\n                    return this._IsEnabled()\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                switch (index) {\n                case PROP_MAX_SPEED:\n                    this._SetMaxSpeed(value);\n                    break;\n                case PROP_ACCELERATION:\n                    this._SetAcceleration(value);\n                    break;\n                case PROP_DECELERATION:\n                    this._SetDeceleration(value);\n                    break;\n                case PROP_ROTATE_SPEED:\n                    this._SetRotateSpeed(C3.toRadians(value));\n                    break;\n                case PROP_SET_ANGLE:\n                    this._SetSetAngle(value);\n                    break;\n                case PROP_STOP_ON_SOLIDS:\n                    this._SetStopOnSolids(value);\n                    break;\n                case PROP_ENABLED:\n                    this._SetEnabled(value);\n                    break\n                }\n            }\n            GetDebuggerProperties() {\n                const prefix = "behaviors.moveto";\n                return [{\n                    title: "$" + this.GetBehaviorType().GetName(),\n                    properties: [{\n                        name: prefix + ".debugger.speed",\n                        value: this._GetSpeed(),\n                        onedit: v => this._SetSpeed(v)\n                    }, {\n                        name: prefix + ".debugger.angle-of-motion",\n                        value: C3.toDegrees(this._GetAngleOfMotion()),\n                        onedit: v => this._movingAngle = C3.toRadians(v)\n                    }, {\n                        name: prefix + ".debugger.target-x",\n                        value: this._GetTargetX()\n                    }, {\n                        name: prefix + ".debugger.target-y",\n                        value: this._GetTargetY()\n                    }, {\n                        name: prefix + ".debugger.waypoint-count",\n                        value: this._GetWaypointCount()\n                    }, {\n                        name: prefix + ".properties.max-speed.name",\n                        value: this._GetMaxSpeed(),\n                        onedit: v => this._SetMaxSpeed(v)\n                    }, {\n                        name: prefix + ".properties.acceleration.name",\n                        value: this._GetAcceleration(),\n                        onedit: v => this._SetAcceleration(v)\n                    }, {\n                        name: prefix + ".properties.deceleration.name",\n                        value: this._GetDeceleration(),\n                        onedit: v => this._SetDeceleration(v)\n                    }, {\n                        name: prefix + ".properties.rotate-speed.name",\n                        value: C3.toDegrees(this._GetRotateSpeed()),\n                        onedit: v => this._SetRotateSpeed(C3.toRadians(v))\n                    }, {\n                        name: prefix + ".properties.enabled.name",\n                        value: this._IsEnabled(),\n                        onedit: v => this._SetEnabled(v)\n                    }]\n                }]\n            }\n            GetScriptInterfaceClass() {\n                return self.IMoveToBehaviorInstance\n            }\n        }\n        ;\n        const map = new WeakMap;\n        self.IMoveToBehaviorInstance = class IMoveToBehaviorInstance extends IBehaviorInstance {\n            constructor() {\n                super();\n                map.set(this, IBehaviorInstance._GetInitInst().GetSdkInstance())\n            }\n            moveToPosition(x, y, isDirect=true) {\n                C3X.RequireFiniteNumber(x);\n                C3X.RequireFiniteNumber(y);\n                map.get(this)._AddWaypoint(x, y, !!isDirect)\n            }\n            getTargetX() {\n                return map.get(this)._GetTargetX()\n            }\n            getTargetY() {\n                return map.get(this)._GetTargetY()\n            }\n            getTargetPosition() {\n                const b = map.get(this);\n                return [b._GetTargetX(), b._GetTargetY()]\n            }\n            getWaypointCount() {\n                return map.get(this)._GetWaypointCount()\n            }\n            getWaypointX(i) {\n                C3X.RequireFiniteNumber(i);\n                return map.get(this)._GetWaypointXAt(i)\n            }\n            getWaypointY(i) {\n                C3X.RequireFiniteNumber(i);\n                return map.get(this)._GetWaypointYAt(i)\n            }\n            getWaypoint(i) {\n                C3X.RequireFiniteNumber(i);\n                const b = map.get(this);\n                return [b._GetWaypointXAt(i), b._GetWaypointYAt(i)]\n            }\n            stop() {\n                map.get(this)._Stop()\n            }\n            get isMoving() {\n                return map.get(this)._IsMoving()\n            }\n            get speed() {\n                return map.get(this)._GetSpeed()\n            }\n            set speed(s) {\n                C3X.RequireFiniteNumber(s);\n                map.get(this)._SetSpeed(s)\n            }\n            get maxSpeed() {\n                return map.get(this)._GetMaxSpeed()\n            }\n            set maxSpeed(ms) {\n                C3X.RequireFiniteNumber(ms);\n                map.get(this)._SetMaxSpeed(ms)\n            }\n            get acceleration() {\n                return map.get(this)._GetAcceleration()\n            }\n            set acceleration(a) {\n                C3X.RequireFiniteNumber(a);\n                map.get(this)._SetAcceleration(a)\n            }\n            get deceleration() {\n                return map.get(this)._GetDeceleration()\n            }\n            set deceleration(d) {\n                C3X.RequireFiniteNumber(d);\n                map.get(this)._SetDeceleration(d)\n            }\n            get angleOfMotion() {\n                return map.get(this)._GetAngleOfMotion()\n            }\n            set angleOfMotion(a) {\n                C3X.RequireFiniteNumber(a);\n                map.get(this)._SetAngleOfMotion(a)\n            }\n            get rotateSpeed() {\n                return map.get(this)._GetRotateSpeed()\n            }\n            set rotateSpeed(r) {\n                C3X.RequireFiniteNumber(r);\n                map.get(this)._SetRotateSpeed(r)\n            }\n            get isStopOnSolids() {\n                return map.get(this)._IsStopOnSolids()\n            }\n            set isStopOnSolids(e) {\n                map.get(this)._SetStopOnSolids(e)\n            }\n            get isEnabled() {\n                return map.get(this)._IsEnabled()\n            }\n            set isEnabled(e) {\n                map.get(this)._SetEnabled(e)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.MoveTo.Cnds = {\n            IsMoving() {\n                return this._IsMoving()\n            },\n            CompareSpeed(cmp, s) {\n                return C3.compare(this._GetSpeed(), cmp, s)\n            },\n            IsEnabled() {\n                return this._IsEnabled()\n            },\n            OnArrived() {\n                return true\n            },\n            OnHitSolid() {\n                return true\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.MoveTo.Acts = {\n            MoveToPosition(x, y, mode) {\n                this._AddWaypoint(x, y, mode === 0)\n            },\n            MoveToObject(objectClass, imgPt, mode) {\n                if (!objectClass)\n                    return;\n                const inst = objectClass.GetPairedInstance(this._inst);\n                if (!inst || !inst.GetWorldInfo())\n                    return;\n                const [x,y] = inst.GetImagePoint(imgPt);\n                this._AddWaypoint(x, y, mode === 0)\n            },\n            MoveAlongPathfindingPath(mode) {\n                const behInst = this._inst.GetBehaviorSdkInstanceFromCtor(C3.Behaviors.Pathfinding);\n                if (!behInst)\n                    return;\n                const path = behInst._GetPath();\n                if (path.length === 0)\n                    return;\n                for (let i = 0, len = path.length; i < len; ++i) {\n                    const n = path[i];\n                    this._AddWaypoint(n.x, n.y, i === 0 && mode === 0)\n                }\n            },\n            MoveAlongTimeline(timeline, trackId, mode) {\n                let trackState = null;\n                if (trackId)\n                    trackState = timeline.GetTrackById(trackId);\n                else\n                    trackState = C3.first(timeline.GetTracks());\n                if (!trackState)\n                    return;\n                const xTrack = trackState.GetPropertyTrack("offsetX");\n                const yTrack = trackState.GetPropertyTrack("offsetY");\n                if (!xTrack || !yTrack)\n                    return;\n                const xPositions = [...xTrack.GetPropertyKeyframeValues()];\n                const yPositions = [...yTrack.GetPropertyKeyframeValues()];\n                if (xPositions.length === 0 || yPositions.length === 0)\n                    return;\n                let xOrigin = 0;\n                let yOrigin = 0;\n                const wi = this._inst.GetWorldInfo();\n                if (xTrack.GetResultMode() === "relative")\n                    xOrigin = wi.GetX();\n                if (yTrack.GetResultMode() === "relative")\n                    yOrigin = wi.GetY();\n                for (let i = 0, len = Math.min(xPositions.length, yPositions.length); i < len; ++i) {\n                    const x = xPositions[i] + xOrigin;\n                    const y = yPositions[i] + yOrigin;\n                    this._AddWaypoint(x, y, i === 0 && mode === 0)\n                }\n            },\n            MoveAlongTimelineByName(timelineName, trackId, mode) {\n                const timeline = this._runtime.GetTimelineManager().GetTimelineByName(timelineName);\n                if (!timeline)\n                    return;\n                C3.Behaviors.MoveTo.Acts.MoveAlongTimeline.call(this, timeline, trackId, mode)\n            },\n            Stop() {\n                this._Stop()\n            },\n            SetMovingAngle(a) {\n                this._SetAngleOfMotion(C3.toRadians(a))\n            },\n            SetSpeed(s) {\n                this._SetSpeed(s)\n            },\n            SetMaxSpeed(ms) {\n                this._SetMaxSpeed(ms)\n            },\n            SetAcceleration(a) {\n                this._SetAcceleration(a)\n            },\n            SetDeceleration(d) {\n                this._SetDeceleration(d)\n            },\n            SetRotateSpeed(r) {\n                this._SetRotateSpeed(C3.toRadians(r))\n            },\n            SetStopOnSolids(e) {\n                this._SetStopOnSolids(e)\n            },\n            SetEnabled(e) {\n                this._SetEnabled(e)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.MoveTo.Exps = {\n            Speed() {\n                return this._GetSpeed()\n            },\n            MaxSpeed() {\n                return this._GetMaxSpeed()\n            },\n            Acceleration() {\n                return this._GetAcceleration()\n            },\n            Deceleration() {\n                return this._GetDeceleration()\n            },\n            MovingAngle() {\n                return C3.toDegrees(this._GetAngleOfMotion())\n            },\n            RotateSpeed() {\n                return C3.toDegrees(this._GetRotateSpeed())\n            },\n            TargetX() {\n                return this._GetTargetX()\n            },\n            TargetY() {\n                return this._GetTargetY()\n            },\n            WaypointCount() {\n                return this._GetWaypointCount()\n            },\n            WaypointXAt(i) {\n                return this._GetWaypointXAt(i)\n            },\n            WaypointYAt(i) {\n                return this._GetWaypointYAt(i)\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Bullet = class BulletBehavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Bullet.Type = class BulletType extends C3.SDKBehaviorTypeBase {\n            constructor(behaviorType) {\n                super(behaviorType)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        const IBehaviorInstance = self.IBehaviorInstance;\n        const SPEED = 0;\n        const ACCELERATION = 1;\n        const GRAVITY = 2;\n        const BOUNCE_OFF_SOLIDS = 3;\n        const SET_ANGLE = 4;\n        const STEPPING = 5;\n        const ENABLE = 6;\n        C3.Behaviors.Bullet.Instance = class BulletInstance extends C3.SDKBehaviorInstanceBase {\n            constructor(behInst, properties) {\n                super(behInst);\n                const wi = this.GetWorldInfo();\n                this._speed = 0;\n                this._acc = 0;\n                this._g = 0;\n                this._bounceOffSolid = false;\n                this._setAngle = false;\n                this._isStepping = false;\n                this._isEnabled = true;\n                this._dx = 0;\n                this._dy = 0;\n                this._lastX = wi.GetX();\n                this._lastY = wi.GetY();\n                this._lastKnownAngle = wi.GetAngle();\n                this._travelled = 0;\n                this._stepSize = Math.min(Math.abs(wi.GetWidth()), Math.abs(wi.GetHeight()) \/ 2);\n                this._stopStepping = false;\n                if (properties) {\n                    this._speed = properties[SPEED];\n                    this._acc = properties[ACCELERATION];\n                    this._g = properties[GRAVITY];\n                    this._bounceOffSolid = !!properties[BOUNCE_OFF_SOLIDS];\n                    this._setAngle = !!properties[SET_ANGLE];\n                    this._isStepping = !!properties[STEPPING];\n                    this._isEnabled = !!properties[ENABLE]\n                }\n                const a = wi.GetAngle();\n                this._dx = Math.cos(a) * this._speed;\n                this._dy = Math.sin(a) * this._speed;\n                if (this._isEnabled) {\n                    this._StartTicking();\n                    if (this._bounceOffSolid)\n                        this._StartPostTicking()\n                }\n            }\n            Release() {\n                super.Release()\n            }\n            SaveToJson() {\n                const o = {\n                    "dx": this._dx,\n                    "dy": this._dy,\n                    "lx": this._lastX,\n                    "ly": this._lastY,\n                    "lka": this._lastKnownAngle,\n                    "t": this._travelled\n                };\n                if (this._acc !== 0)\n                    o["acc"] = this._acc;\n                if (this._g !== 0)\n                    o["g"] = this._g;\n                if (this._isStepping)\n                    o["st"] = this._isStepping;\n                if (!this._isEnabled)\n                    o["e"] = this._isEnabled;\n                if (this._bounceOffSolid)\n                    o["bos"] = this._bounceOffSolid;\n                if (this._setAngle)\n                    o["sa"] = this._setAngle;\n                return o\n            }\n            LoadFromJson(o) {\n                this._dx = o["dx"];\n                this._dy = o["dy"];\n                this._lastX = o["lx"];\n                this._lastY = o["ly"];\n                this._lastKnownAngle = o["lka"];\n                this._travelled = o["t"];\n                this._acc = o.hasOwnProperty("acc") ? o["acc"] : 0;\n                this._g = o.hasOwnProperty("g") ? o["g"] : 0;\n                this._isStepping = o.hasOwnProperty("st") ? o["st"] : false;\n                this._bounceOffSolid = o.hasOwnProperty("bos") ? o["bos"] : false;\n                this._setAngle = o.hasOwnProperty("sa") ? o["sa"] : false;\n                this._SetEnabled(o.hasOwnProperty("e") ? o["e"] : true)\n            }\n            Tick() {\n                if (!this._isEnabled)\n                    return;\n                const dt = this._runtime.GetDt(this._inst);\n                const wi = this._inst.GetWorldInfo();\n                if (wi.GetAngle() !== this._lastKnownAngle) {\n                    const angle = wi.GetAngle();\n                    if (this._setAngle) {\n                        const s = C3.distanceTo(0, 0, this._dx, this._dy);\n                        this._dx = Math.cos(angle) * s;\n                        this._dy = Math.sin(angle) * s\n                    }\n                    this._lastKnownAngle = angle\n                }\n                let xacc = 0;\n                let yacc = 0;\n                if (this._acc !== 0) {\n                    let s = C3.distanceTo(0, 0, this._dx, this._dy);\n                    let a = 0;\n                    if (this._dx === 0 && this._dy === 0)\n                        a = wi.GetAngle();\n                    else\n                        a = C3.angleTo(0, 0, this._dx, this._dy);\n                    s += this._acc * dt;\n                    xacc = Math.cos(a) * this._acc;\n                    yacc = Math.sin(a) * this._acc;\n                    if (s < 0) {\n                        s = 0;\n                        xacc = 0;\n                        yacc = 0\n                    }\n                    this._dx = Math.cos(a) * s;\n                    this._dy = Math.sin(a) * s\n                }\n                if (this._g !== 0) {\n                    this._dy += this._g * dt;\n                    yacc += this._g\n                }\n                this._lastX = wi.GetX();\n                this._lastY = wi.GetY();\n                if (this._dx !== 0 || this._dy !== 0) {\n                    const mx = this._dx * dt + .5 * xacc * dt * dt;\n                    const my = this._dy * dt + .5 * yacc * dt * dt;\n                    const stepDist = C3.distanceTo(0, 0, mx, my);\n                    this._MoveBy(mx, my, stepDist);\n                    this._travelled += stepDist;\n                    if (this._setAngle && (mx !== 0 || my !== 0)) {\n                        const a = C3.angleTo(0, 0, mx, my);\n                        wi.SetAngle(a);\n                        this._lastKnownAngle = wi.GetAngle()\n                    }\n                    wi.SetBboxChanged()\n                }\n            }\n            _MoveBy(mx, my, stepDist) {\n                const wi = this.GetWorldInfo();\n                if (!this._isStepping || stepDist <= this._stepSize) {\n                    wi.OffsetXY(mx, my);\n                    wi.SetBboxChanged();\n                    if (this._isStepping)\n                        this.Trigger(C3.Behaviors.Bullet.Cnds.OnStep);\n                    return\n                }\n                this._stopStepping = false;\n                const startX = wi.GetX();\n                const startY = wi.GetY();\n                const endX = startX + mx;\n                const endY = startY + my;\n                const a = C3.angleTo(0, 0, mx, my);\n                const stepX = Math.cos(a) * this._stepSize;\n                const stepY = Math.sin(a) * this._stepSize;\n                const stepCount = Math.floor(stepDist \/ this._stepSize);\n                for (let i = 1; i <= stepCount; ++i) {\n                    wi.SetXY(startX + stepX * i, startY + stepY * i);\n                    wi.SetBboxChanged();\n                    this.Trigger(C3.Behaviors.Bullet.Cnds.OnStep);\n                    if (this._inst.IsDestroyed() || this._stopStepping)\n                        return\n                }\n                wi.SetXY(endX, endY);\n                wi.SetBboxChanged();\n                this.Trigger(C3.Behaviors.Bullet.Cnds.OnStep)\n            }\n            PostTick() {\n                if (!this._isEnabled || !this._bounceOffSolid || this._dx === 0 && this._dy === 0)\n                    return;\n                const dt = this._runtime.GetDt(this._inst);\n                const wi = this._inst.GetWorldInfo();\n                const collisionEngine = this._runtime.GetCollisionEngine();\n                const bounceSolid = collisionEngine.TestOverlapSolid(this._inst);\n                if (bounceSolid) {\n                    collisionEngine.RegisterCollision(this._inst, bounceSolid);\n                    const s = C3.distanceTo(0, 0, this._dx, this._dy);\n                    const bounceAngle = collisionEngine.CalculateBounceAngle(this._inst, this._lastX, this._lastY);\n                    this._dx = Math.cos(bounceAngle) * s;\n                    this._dy = Math.sin(bounceAngle) * s;\n                    wi.OffsetXY(this._dx * dt, this._dy * dt);\n                    wi.SetBboxChanged();\n                    if (this._setAngle) {\n                        wi.SetAngle(bounceAngle);\n                        this._lastKnownAngle = wi.GetAngle();\n                        wi.SetBboxChanged()\n                    }\n                    if (!collisionEngine.PushOutSolid(this._inst, this._dx \/ s, this._dy \/ s, Math.max(s * 2.5 * dt, 30)))\n                        collisionEngine.PushOutSolidNearest(this._inst, 100)\n                }\n            }\n            GetPropertyValueByIndex(index) {\n                switch (index) {\n                case SPEED:\n                    return this._GetSpeed();\n                case ACCELERATION:\n                    return this._GetAcceleration();\n                case GRAVITY:\n                    return this._GetGravity();\n                case SET_ANGLE:\n                    return this._setAngle;\n                case STEPPING:\n                    return this._isStepping;\n                case ENABLE:\n                    return this._IsEnabled()\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                switch (index) {\n                case SPEED:\n                    this._SetSpeed(value);\n                    break;\n                case ACCELERATION:\n                    this._acc = value;\n                    break;\n                case GRAVITY:\n                    this._g = value;\n                    break;\n                case SET_ANGLE:\n                    this._setAngle = !!value;\n                    break;\n                case STEPPING:\n                    this._isStepping = !!value;\n                    break;\n                case ENABLE:\n                    this._SetEnabled(!!value);\n                    break\n                }\n            }\n            _SetSpeed(s) {\n                const a = C3.angleTo(0, 0, this._dx, this._dy);\n                this._dx = Math.cos(a) * s;\n                this._dy = Math.sin(a) * s\n            }\n            _GetSpeed() {\n                return C3.round6dp(C3.distanceTo(0, 0, this._dx, this._dy))\n            }\n            _SetAcceleration(a) {\n                this._acc = a\n            }\n            _GetAcceleration() {\n                return this._acc\n            }\n            _SetGravity(g) {\n                this._g = g\n            }\n            _GetGravity() {\n                return this._g\n            }\n            _SetAngleOfMotion(a) {\n                const s = C3.distanceTo(0, 0, this._dx, this._dy);\n                this._dx = Math.cos(a) * s;\n                this._dy = Math.sin(a) * s\n            }\n            _GetAngleOfMotion() {\n                return C3.angleTo(0, 0, this._dx, this._dy)\n            }\n            _SetBounceOffSolids(b) {\n                b = !!b;\n                if (this._bounceOffSolid === b)\n                    return;\n                this._bounceOffSolid = b;\n                if (this._isEnabled)\n                    if (this._bounceOffSolid)\n                        this._StartPostTicking();\n                    else\n                        this._StopPostTicking()\n            }\n            _IsBounceOffSolids() {\n                return this._bounceOffSolid\n            }\n            _SetDistanceTravelled(d) {\n                this._travelled = d\n            }\n            _GetDistanceTravelled() {\n                return this._travelled\n            }\n            _SetEnabled(e) {\n                this._isEnabled = !!e;\n                if (this._isEnabled) {\n                    this._StartTicking();\n                    if (this._bounceOffSolid)\n                        this._StartPostTicking()\n                } else {\n                    this._StopTicking();\n                    this._StopPostTicking()\n                }\n            }\n            _IsEnabled() {\n                return this._isEnabled\n            }\n            GetDebuggerProperties() {\n                const prefix = "behaviors.bullet";\n                return [{\n                    title: "$" + this.GetBehaviorType().GetName(),\n                    properties: [{\n                        name: prefix + ".debugger.vector-x",\n                        value: this._dx,\n                        onedit: v => this._dx = v\n                    }, {\n                        name: prefix + ".debugger.vector-y",\n                        value: this._dy,\n                        onedit: v => this._dy = v\n                    }, {\n                        name: prefix + ".properties.speed.name",\n                        value: this._GetSpeed(),\n                        onedit: v => this._SetSpeed(v)\n                    }, {\n                        name: prefix + ".debugger.angle-of-motion",\n                        value: C3.toDegrees(this._GetAngleOfMotion())\n                    }, {\n                        name: prefix + ".properties.gravity.name",\n                        value: this._GetGravity(),\n                        onedit: v => this._SetGravity(v)\n                    }, {\n                        name: prefix + ".properties.acceleration.name",\n                        value: this._GetAcceleration(),\n                        onedit: v => this._SetAcceleration(v)\n                    }, {\n                        name: prefix + ".debugger.distance-travelled",\n                        value: this._GetDistanceTravelled()\n                    }, {\n                        name: prefix + ".properties.enabled.name",\n                        value: this._IsEnabled(),\n                        onedit: v => this._SetEnabled(v)\n                    }]\n                }]\n            }\n            GetScriptInterfaceClass() {\n                return self.IBulletBehaviorInstance\n            }\n        }\n        ;\n        const map = new WeakMap;\n        self.IBulletBehaviorInstance = class IBulletBehaviorInstance extends IBehaviorInstance {\n            constructor() {\n                super();\n                map.set(this, IBehaviorInstance._GetInitInst().GetSdkInstance())\n            }\n            get speed() {\n                return map.get(this)._GetSpeed()\n            }\n            set speed(s) {\n                C3X.RequireFiniteNumber(s);\n                map.get(this)._SetSpeed(s)\n            }\n            get acceleration() {\n                return map.get(this)._GetAcceleration()\n            }\n            set acceleration(a) {\n                C3X.RequireFiniteNumber(a);\n                map.get(this)._SetAcceleration(a)\n            }\n            get gravity() {\n                return map.get(this)._GetGravity()\n            }\n            set gravity(g) {\n                C3X.RequireFiniteNumber(g);\n                map.get(this)._SetGravity(g)\n            }\n            get angleOfMotion() {\n                return map.get(this)._GetAngleOfMotion()\n            }\n            set angleOfMotion(a) {\n                C3X.RequireFiniteNumber(a);\n                map.get(this)._SetAngleOfMotion(a)\n            }\n            get bounceOffSolids() {\n                return map.get(this)._IsBounceOffSolids()\n            }\n            set bounceOffSolids(b) {\n                map.get(this)._SetBounceOffSolids(!!b)\n            }\n            get distanceTravelled() {\n                return map.get(this)._GetDistanceTravelled()\n            }\n            set distanceTravelled(d) {\n                C3X.RequireFiniteNumber(d);\n                map.get(this)._SetDistanceTravelled(d)\n            }\n            get isEnabled() {\n                return map.get(this)._IsEnabled()\n            }\n            set isEnabled(e) {\n                map.get(this)._SetEnabled(e)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Bullet.Cnds = {\n            CompareSpeed(cmp, s) {\n                const speed = Math.sqrt(this._dx * this._dx + this._dy * this._dy);\n                return C3.compare(speed, cmp, s)\n            },\n            CompareTravelled(cmp, d) {\n                return C3.compare(this._GetDistanceTravelled(), cmp, d)\n            },\n            OnStep() {\n                return true\n            },\n            IsEnabled() {\n                return this._IsEnabled()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Bullet.Acts = {\n            SetSpeed(s) {\n                this._SetSpeed(s)\n            },\n            SetAcceleration(a) {\n                this._SetAcceleration(a)\n            },\n            SetGravity(g) {\n                this._SetGravity(g)\n            },\n            SetAngleOfMotion(a) {\n                this._SetAngleOfMotion(C3.toRadians(a))\n            },\n            Bounce(objectClass) {\n                if (!objectClass)\n                    return;\n                const otherInst = objectClass.GetFirstPicked(this._inst);\n                if (!otherInst)\n                    return;\n                const wi = this._inst.GetWorldInfo();\n                const collisionEngine = this._runtime.GetCollisionEngine();\n                const dt = this._runtime.GetDt(this._inst);\n                const s = C3.distanceTo(0, 0, this._dx, this._dy);\n                const bounceAngle = collisionEngine.CalculateBounceAngle(this._inst, this._lastX, this._lastY, otherInst);\n                this._dx = Math.cos(bounceAngle) * s;\n                this._dy = Math.sin(bounceAngle) * s;\n                wi.OffsetXY(this._dx * dt, this._dy * dt);\n                wi.SetBboxChanged();\n                if (this._setAngle) {\n                    wi.SetAngle(bounceAngle);\n                    this._lastKnownAngle = wi.GetAngle();\n                    wi.SetBboxChanged()\n                }\n                if (s !== 0)\n                    if (this._bounceOffSolid) {\n                        if (!collisionEngine.PushOutSolid(this._inst, this._dx \/ s, this._dy \/ s, Math.max(s * 2.5 * dt, 30)))\n                            collisionEngine.PushOutSolidNearest(this._inst, 100)\n                    } else\n                        collisionEngine.PushOut(this._inst, this._dx \/ s, this._dy \/ s, Math.max(s * 2.5 * dt, 30), otherInst)\n            },\n            SetBounceOffSolids(b) {\n                this._SetBounceOffSolids(b)\n            },\n            SetDistanceTravelled(d) {\n                this._SetDistanceTravelled(d)\n            },\n            SetEnabled(e) {\n                this._SetEnabled(e)\n            },\n            StopStepping() {\n                this._stopStepping = true\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Bullet.Exps = {\n            Speed() {\n                return this._GetSpeed()\n            },\n            Acceleration() {\n                return this._GetAcceleration()\n            },\n            AngleOfMotion() {\n                return C3.toDegrees(this._GetAngleOfMotion())\n            },\n            DistanceTravelled() {\n                return this._GetDistanceTravelled()\n            },\n            Gravity() {\n                return this._GetGravity()\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Behaviors.solid = class SolidBehavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.solid.Type = class SolidType extends C3.SDKBehaviorTypeBase {\n            constructor(behaviorType) {\n                super(behaviorType)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const ENABLE = 0;\n        const TAGS = 1;\n        const EMPTY_SET = new Set;\n        C3.Behaviors.solid.Instance = class SolidInstance extends C3.SDKBehaviorInstanceBase {\n            constructor(behInst, properties) {\n                super(behInst);\n                this.SetEnabled(true);\n                if (properties) {\n                    this.SetEnabled(properties[ENABLE]);\n                    this.SetTags(properties[TAGS])\n                }\n            }\n            Release() {\n                super.Release()\n            }\n            SetEnabled(e) {\n                this._inst._SetSolidEnabled(!!e)\n            }\n            IsEnabled() {\n                return this._inst._IsSolidEnabled()\n            }\n            SetTags(tagList) {\n                const savedDataMap = this._inst.GetSavedDataMap();\n                if (!tagList.trim()) {\n                    savedDataMap.delete("solidTags");\n                    return\n                }\n                let solidTags = savedDataMap.get("solidTags");\n                if (!solidTags) {\n                    solidTags = new Set;\n                    savedDataMap.set("solidTags", solidTags)\n                }\n                solidTags.clear();\n                for (const tag of tagList.split(" "))\n                    if (tag)\n                        solidTags.add(tag.toLowerCase())\n            }\n            GetTags() {\n                return this._inst.GetSavedDataMap().get("solidTags") || EMPTY_SET\n            }\n            SaveToJson() {\n                return {\n                    "e": this.IsEnabled()\n                }\n            }\n            LoadFromJson(o) {\n                this.SetEnabled(o["e"])\n            }\n            GetPropertyValueByIndex(index) {\n                switch (index) {\n                case ENABLE:\n                    return this.IsEnabled()\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                switch (index) {\n                case ENABLE:\n                    this.SetEnabled(value);\n                    break\n                }\n            }\n            GetDebuggerProperties() {\n                return [{\n                    title: "$" + this.GetBehaviorType().GetName(),\n                    properties: [{\n                        name: "behaviors.solid.properties.enabled.name",\n                        value: this.IsEnabled(),\n                        onedit: v => this.SetEnabled(v)\n                    }]\n                }]\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.solid.Cnds = {\n            IsEnabled() {\n                return this.IsEnabled()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.solid.Acts = {\n            SetEnabled(e) {\n                this.SetEnabled(e)\n            },\n            SetTags(tagList) {\n                this.SetTags(tagList)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.solid.Exps = {}\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Rotate = class RotateBehavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Rotate.Type = class RotateType extends C3.SDKBehaviorTypeBase {\n            constructor(objectClass) {\n                super(objectClass)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const SPEED = 0;\n        const ACCELERATION = 1;\n        const ENABLE = 2;\n        C3.Behaviors.Rotate.Instance = class RotateInstance extends C3.SDKBehaviorInstanceBase {\n            constructor(inst, properties) {\n                super(inst);\n                this._speed = 0;\n                this._acceleration = 0;\n                this._isEnabled = true;\n                if (properties) {\n                    this._speed = C3.toRadians(properties[SPEED]);\n                    this._acceleration = C3.toRadians(properties[ACCELERATION]);\n                    this._isEnabled = properties[ENABLE]\n                }\n                if (this._isEnabled)\n                    this._StartTicking()\n            }\n            Release() {\n                super.Release()\n            }\n            SaveToJson() {\n                return {\n                    "s": this._speed,\n                    "a": this._acceleration,\n                    "e": this._isEnabled\n                }\n            }\n            LoadFromJson(o) {\n                this._speed = o["s"];\n                this._acceleration = o["a"];\n                this._SetEnabled(o["e"])\n            }\n            Tick() {\n                if (!this._isEnabled)\n                    return;\n                const dt = this._runtime.GetDt(this._inst);\n                if (dt === 0)\n                    return;\n                if (this._acceleration !== 0)\n                    this._speed += this._acceleration * dt;\n                if (this._speed !== 0) {\n                    const wi = this._inst.GetWorldInfo();\n                    wi.SetAngle(wi.GetAngle() + this._speed * dt);\n                    wi.SetBboxChanged()\n                }\n            }\n            GetPropertyValueByIndex(index) {\n                switch (index) {\n                case SPEED:\n                    return C3.toDegrees(this._speed);\n                case ACCELERATION:\n                    return C3.toDegrees(this._acceleration);\n                case ENABLE:\n                    return this._isEnabled\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                switch (index) {\n                case SPEED:\n                    this._speed = C3.toRadians(value);\n                    break;\n                case ACCELERATION:\n                    this._acceleration = C3.toRadians(value);\n                    break;\n                case ENABLE:\n                    this._SetEnabled(value);\n                    break\n                }\n            }\n            _SetEnabled(e) {\n                this._isEnabled = !!e;\n                if (this._isEnabled)\n                    this._StartTicking();\n                else\n                    this._StopTicking()\n            }\n            GetDebuggerProperties() {\n                const prefix = "behaviors.rotate";\n                return [{\n                    title: "$" + this.GetBehaviorType().GetName(),\n                    properties: [{\n                        name: prefix + ".properties.speed.name",\n                        value: C3.toDegrees(this._speed),\n                        onedit: v => this._speed = C3.toRadians(v)\n                    }, {\n                        name: prefix + ".properties.acceleration.name",\n                        value: C3.toDegrees(this._acceleration),\n                        onedit: v => this._acceleration = C3.toRadians(v)\n                    }, {\n                        name: prefix + ".properties.enabled.name",\n                        value: this._isEnabled,\n                        onedit: v => this._SetEnabled(v)\n                    }]\n                }]\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Rotate.Cnds = {\n            IsEnabled() {\n                return this._isEnabled\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Rotate.Acts = {\n            SetSpeed(s) {\n                this._speed = C3.toRadians(s)\n            },\n            SetAcceleration(a) {\n                this._acceleration = C3.toRadians(a)\n            },\n            SetEnabled(e) {\n                this._SetEnabled(e)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Rotate.Exps = {\n            Speed() {\n                return C3.toDegrees(this._speed)\n            },\n            Acceleration() {\n                return C3.toDegrees(this._acceleration)\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Behaviors.EightDir = class EightDirBehavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.EightDir.Type = class EightDirType extends C3.SDKBehaviorTypeBase {\n            constructor(behaviorType) {\n                super(behaviorType)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        const IBehaviorInstance = self.IBehaviorInstance;\n        const MAX_SPEED = 0;\n        const ACCELERATION = 1;\n        const DEACCELERATION = 2;\n        const DIRECTION = 3;\n        const ANGLE_MODE = 4;\n        const ALLOW_SLIDING = 5;\n        const DEFAULT_CONTROLS = 6;\n        const ENABLE = 7;\n        C3.Behaviors.EightDir.Instance = class EightDirInstance extends C3.SDKBehaviorInstanceBase {\n            constructor(behInst, properties) {\n                super(behInst);\n                this._upKey = false;\n                this._downKey = false;\n                this._leftKey = false;\n                this._rightKey = false;\n                this._ignoreInput = false;\n                this._simUp = false;\n                this._simDown = false;\n                this._simLeft = false;\n                this._simRight = false;\n                this._dx = 0;\n                this._dy = 0;\n                this._maxSpeed = 200;\n                this._acc = 600;\n                this._dec = 500;\n                this._directions = 3;\n                this._angleMode = 3;\n                this._allowSliding = false;\n                this._defaultControls = true;\n                this._isEnabled = true;\n                if (properties) {\n                    this._maxSpeed = properties[MAX_SPEED];\n                    this._acc = properties[ACCELERATION];\n                    this._dec = properties[DEACCELERATION];\n                    this._directions = properties[DIRECTION];\n                    this._angleMode = properties[ANGLE_MODE];\n                    this._allowSliding = !!properties[ALLOW_SLIDING];\n                    this._defaultControls = !!properties[DEFAULT_CONTROLS];\n                    this._isEnabled = !!properties[ENABLE]\n                }\n                if (this._isEnabled)\n                    this._StartTicking();\n                if (this._defaultControls)\n                    this._BindEvents()\n            }\n            _BindEvents() {\n                if (this._disposables)\n                    return;\n                const rt = this._runtime.Dispatcher();\n                this._disposables = new C3.CompositeDisposable(C3.Disposable.From(rt, "keydown", e => this._OnKeyDown(e.data)),C3.Disposable.From(rt, "keyup", e => this._OnKeyUp(e.data)),C3.Disposable.From(rt, "window-blur", () => this._OnWindowOrKeyboardBlur()),C3.Disposable.From(rt, "keyboard-blur", () => this._OnWindowOrKeyboardBlur()))\n            }\n            _UnBindEvents() {\n                if (!this._disposables)\n                    return;\n                this._disposables.Release();\n                this._disposables = null\n            }\n            Release() {\n                super.Release()\n            }\n            SaveToJson() {\n                return {\n                    "dx": this._dx,\n                    "dy": this._dy,\n                    "e": this._isEnabled,\n                    "ms": this._maxSpeed,\n                    "acc": this._acc,\n                    "dec": this._dec,\n                    "d": this._directions,\n                    "am": this._angleMode,\n                    "dc": this._defaultControls,\n                    "ii": this._ignoreInput\n                }\n            }\n            LoadFromJson(o) {\n                this._dx = o["dx"];\n                this._dy = o["dy"];\n                this._SetEnabled(o["e"]);\n                this._maxSpeed = o["ms"];\n                this._acc = o["acc"];\n                this._dec = o["dec"];\n                this._directions = o["d"];\n                this._angleMode = o["am"];\n                this._defaultControls = o["dc"];\n                this._ignoreInput = o["ii"];\n                this._upKey = false;\n                this._downKey = false;\n                this._leftKey = false;\n                this._rightKey = false;\n                this._simUp = false;\n                this._simDown = false;\n                this._simLeft = false;\n                this._simRight = false;\n                this._defaultControls ? this._BindEvents() : this._UnBindEvents()\n            }\n            _OnKeyDown(data) {\n                switch (data["key"]) {\n                case "ArrowLeft":\n                    this._leftKey = true;\n                    break;\n                case "ArrowUp":\n                    this._upKey = true;\n                    break;\n                case "ArrowRight":\n                    this._rightKey = true;\n                    break;\n                case "ArrowDown":\n                    this._downKey = true;\n                    break\n                }\n            }\n            _OnKeyUp(data) {\n                switch (data["key"]) {\n                case "ArrowLeft":\n                    this._leftKey = false;\n                    break;\n                case "ArrowUp":\n                    this._upKey = false;\n                    break;\n                case "ArrowRight":\n                    this._rightKey = false;\n                    break;\n                case "ArrowDown":\n                    this._downKey = false;\n                    break\n                }\n            }\n            _OnWindowOrKeyboardBlur() {\n                this._upKey = false;\n                this._downKey = false;\n                this._leftKey = false;\n                this._rightKey = false\n            }\n            Tick() {\n                const dt = this._runtime.GetDt(this._inst);\n                const collisionEngine = this._runtime.GetCollisionEngine();\n                let left = this._leftKey || this._simLeft;\n                let right = this._rightKey || this._simRight;\n                let up = this._upKey || this._simUp;\n                let down = this._downKey || this._simDown;\n                this._simLeft = false;\n                this._simRight = false;\n                this._simUp = false;\n                this._simDown = false;\n                if (!this._isEnabled)\n                    return;\n                let collInst = collisionEngine.TestOverlapSolid(this._inst);\n                if (collInst) {\n                    collisionEngine.RegisterCollision(this._inst, collInst);\n                    if (!collisionEngine.PushOutSolidNearest(this._inst))\n                        return\n                }\n                if (this._ignoreInput)\n                    left = right = up = down = false;\n                if (this._directions === 0)\n                    left = right = false;\n                else if (this._directions === 1)\n                    up = down = false;\n                if (this._directions === 2 && (up || down))\n                    left = right = false;\n                if (left === right)\n                    if (this._dx < 0)\n                        this._dx = Math.min(this._dx + this._dec * dt, 0);\n                    else if (this._dx > 0)\n                        this._dx = Math.max(this._dx - this._dec * dt, 0);\n                if (up === down)\n                    if (this._dy < 0)\n                        this._dy = Math.min(this._dy + this._dec * dt, 0);\n                    else if (this._dy > 0)\n                        this._dy = Math.max(this._dy - this._dec * dt, 0);\n                let xacc = 0;\n                let yacc = 0;\n                if (left && !right)\n                    if (this._dx > 0)\n                        xacc = -(this._acc + this._dec);\n                    else\n                        xacc = -this._acc;\n                if (right && !left)\n                    if (this._dx < 0)\n                        xacc = this._acc + this._dec;\n                    else\n                        xacc = this._acc;\n                if (up && !down)\n                    if (this._dy > 0)\n                        yacc = -(this._acc + this._dec);\n                    else\n                        yacc = -this._acc;\n                if (down && !up)\n                    if (this._dy < 0)\n                        yacc = this._acc + this._dec;\n                    else\n                        yacc = this._acc;\n                this._dx += xacc * dt;\n                this._dy += yacc * dt;\n                if (this._dx !== 0 || this._dy !== 0) {\n                    let speed = Math.sqrt(this._dx * this._dx + this._dy * this._dy);\n                    const a = Math.atan2(this._dy, this._dx);\n                    const maxSpeedX = this._maxSpeed * Math.cos(a);\n                    const maxSpeedY = this._maxSpeed * Math.sin(a);\n                    if (speed > this._maxSpeed) {\n                        speed = this._maxSpeed;\n                        this._dx = maxSpeedX;\n                        this._dy = maxSpeedY\n                    }\n                    const wi = this._inst.GetWorldInfo();\n                    const oldX = wi.GetX();\n                    const oldY = wi.GetY();\n                    const oldAngle = wi.GetAngle();\n                    const maxStepX = Math.abs(maxSpeedX) * dt;\n                    const maxStepY = Math.abs(maxSpeedY) * dt;\n                    const offX = C3.clamp(this._dx * dt + .5 * xacc * dt * dt, -maxStepX, maxStepX);\n                    const offY = C3.clamp(this._dy * dt + .5 * yacc * dt * dt, -maxStepY, maxStepY);\n                    if (this._allowSliding) {\n                        wi.OffsetXY(offX, offY);\n                        wi.SetBboxChanged();\n                        collInst = collisionEngine.TestOverlapSolid(this._inst);\n                        if (collInst) {\n                            collisionEngine.RegisterCollision(this._inst, collInst);\n                            const m = Math.atan2(this._dy, this._dx) + Math.PI \/ 2;\n                            let pushedOutOk = false;\n                            const minPushDist = (wi.GetWidth() + wi.GetHeight()) \/ 4;\n                            if (collisionEngine.PushOutSolidAxis(this._inst, Math.cos(m), Math.sin(m), Math.max(speed * 2.5 * dt, minPushDist))) {\n                                pushedOutOk = true;\n                                const endX = wi.GetX();\n                                const endY = wi.GetY();\n                                const maxStep = speed * dt;\n                                const distTravelled = C3.distanceTo(oldX, oldY, endX, endY);\n                                if (distTravelled > maxStep * 1.01) {\n                                    const prog = maxStep \/ distTravelled;\n                                    const targetX = C3.lerp(oldX, endX, prog);\n                                    const targetY = C3.lerp(oldY, endY, prog);\n                                    wi.SetXY(targetX, targetY);\n                                    wi.SetBboxChanged();\n                                    collInst = collisionEngine.TestOverlapSolid(this._inst);\n                                    if (collInst) {\n                                        const la = C3.angleTo(oldX, oldY, endX, endY) + Math.PI \/ 2;\n                                        const lxdir = Math.cos(la);\n                                        const lydir = Math.sin(la);\n                                        const ld = (wi.GetWidth() + wi.GetHeight()) \/ 2 \/ 10;\n                                        if (!collisionEngine.PushOutSolidAxis(this._inst, lxdir, lydir, Math.max(ld, 1))) {\n                                            wi.SetXY(oldX, oldY);\n                                            wi.SetBboxChanged();\n                                            pushedOutOk = false\n                                        }\n                                    }\n                                }\n                            }\n                            if (!pushedOutOk) {\n                                const mag = Math.hypot(offX, offY);\n                                const pushX = -offX \/ mag;\n                                const pushY = -offY \/ mag;\n                                this._dx = 0;\n                                this._dy = 0;\n                                if (!collisionEngine.PushOutSolid(this._inst, pushX, pushY, Math.max(speed * 2.5 * dt, minPushDist))) {\n                                    wi.SetXY(oldX, oldY);\n                                    wi.SetBboxChanged()\n                                }\n                            }\n                        }\n                    } else {\n                        wi.OffsetX(offX);\n                        wi.SetBboxChanged();\n                        collInst = collisionEngine.TestOverlapSolid(this._inst);\n                        if (collInst) {\n                            if (!collisionEngine.PushOutSolid(this._inst, this._dx < 0 ? 1 : -1, 0, Math.max(Math.abs(Math.floor(offX)), 1))) {\n                                wi.SetX(oldX);\n                                wi.SetBboxChanged()\n                            }\n                            this._dx = 0;\n                            collisionEngine.RegisterCollision(this._inst, collInst)\n                        }\n                        wi.OffsetY(offY);\n                        wi.SetBboxChanged();\n                        collInst = collisionEngine.TestOverlapSolid(this._inst);\n                        if (collInst) {\n                            if (!collisionEngine.PushOutSolid(this._inst, 0, this._dy < 0 ? 1 : -1, Math.max(Math.abs(Math.floor(offY)), 1))) {\n                                wi.SetY(oldY);\n                                wi.SetBboxChanged()\n                            }\n                            this._dy = 0;\n                            collisionEngine.RegisterCollision(this._inst, collInst)\n                        }\n                    }\n                    const ax = C3.round6dp(this._dx);\n                    const ay = C3.round6dp(this._dy);\n                    if ((ax !== 0 || ay !== 0) && this._inst.GetPlugin().IsRotatable())\n                        if (this._angleMode === 1)\n                            wi.SetAngle(C3.toRadians(Math.round(C3.toDegrees(Math.atan2(ay, ax)) \/ 90) * 90));\n                        else if (this._angleMode === 2)\n                            wi.SetAngle(C3.toRadians(Math.round(C3.toDegrees(Math.atan2(ay, ax)) \/ 45) * 45));\n                        else if (this._angleMode === 3)\n                            wi.SetAngle(Math.atan2(ay, ax));\n                    wi.SetBboxChanged();\n                    if (wi.GetAngle() != oldAngle) {\n                        collInst = collisionEngine.TestOverlapSolid(this._inst);\n                        if (collInst) {\n                            wi.SetAngle(oldAngle);\n                            wi.SetBboxChanged();\n                            collisionEngine.RegisterCollision(this._inst, collInst)\n                        }\n                    }\n                }\n            }\n            GetPropertyValueByIndex(index) {\n                switch (index) {\n                case MAX_SPEED:\n                    return this._GetMaxSpeed();\n                case ACCELERATION:\n                    return this._GetAcceleration();\n                case DEACCELERATION:\n                    return this._GetDeceleration();\n                case DIRECTION:\n                    return this._directions;\n                case ANGLE_MODE:\n                    return this._angleMode;\n                case ALLOW_SLIDING:\n                    return this._allowSliding;\n                case DEFAULT_CONTROLS:\n                    return this._IsDefaultControls();\n                case ENABLE:\n                    return this._IsEnabled()\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                switch (index) {\n                case MAX_SPEED:\n                    this._SetMaxSpeed(value);\n                    break;\n                case ACCELERATION:\n                    this._SetAcceleration(value);\n                    break;\n                case DEACCELERATION:\n                    this._SetDeceleration(value);\n                    break;\n                case DIRECTION:\n                    this._directions = value;\n                    break;\n                case ANGLE_MODE:\n                    this._angleMode = value;\n                    break;\n                case ALLOW_SLIDING:\n                    this._allowSliding = !!value;\n                    break;\n                case DEFAULT_CONTROLS:\n                    this._SetDefaultControls(!!value);\n                    break;\n                case ENABLE:\n                    this._SetEnabled(!!value);\n                    break\n                }\n            }\n            _Stop() {\n                this._dx = 0;\n                this._dy = 0\n            }\n            _Reverse() {\n                this._dx *= -1;\n                this._dy *= -1\n            }\n            _MaybeClampSpeed() {\n                const speed = Math.hypot(this._dx, this._dy);\n                if (speed > this._maxSpeed)\n                    this._SetSpeed(speed)\n            }\n            _SetSpeed(speed) {\n                speed = C3.clamp(speed, 0, this._maxSpeed);\n                const a = Math.atan2(this._dy, this._dx);\n                this._dx = speed * Math.cos(a);\n                this._dy = speed * Math.sin(a)\n            }\n            _GetSpeed() {\n                return Math.hypot(this._dx, this._dy)\n            }\n            _SetMaxSpeed(maxSpeed) {\n                this._maxSpeed = Math.max(maxSpeed, 0)\n            }\n            _GetMaxSpeed() {\n                return this._maxSpeed\n            }\n            _SetAcceleration(acc) {\n                this._acc = Math.max(acc, 0)\n            }\n            _GetAcceleration() {\n                return this._acc\n            }\n            _SetDeceleration(dec) {\n                this._dec = Math.max(dec, 0)\n            }\n            _GetDeceleration() {\n                return this._dec\n            }\n            _GetMovingAngle() {\n                return Math.atan2(this._dy, this._dx)\n            }\n            _SetVectorX(x) {\n                this._dx = x;\n                this._MaybeClampSpeed()\n            }\n            _GetVectorX() {\n                return this._dx\n            }\n            _SetVectorY(y) {\n                this._dy = y;\n                this._MaybeClampSpeed()\n            }\n            _GetVectorY() {\n                return this._dy\n            }\n            _SimulateControl(ctrl) {\n                if (!this._isEnabled)\n                    return;\n                switch (ctrl) {\n                case 0:\n                    this._simLeft = true;\n                    break;\n                case 1:\n                    this._simRight = true;\n                    break;\n                case 2:\n                    this._simUp = true;\n                    break;\n                case 3:\n                    this._simDown = true;\n                    break\n                }\n            }\n            _SetDefaultControls(d) {\n                d = !!d;\n                if (this._defaultControls === d)\n                    return;\n                this._defaultControls = d;\n                if (this._defaultControls)\n                    this._BindEvents();\n                else {\n                    this._UnBindEvents();\n                    this._OnWindowOrKeyboardBlur()\n                }\n            }\n            _IsDefaultControls() {\n                return this._defaultControls\n            }\n            _SetIgnoreInput(ignore) {\n                this._ignoreInput = !!ignore\n            }\n            _IsIgnoreInput() {\n                return this._ignoreInput\n            }\n            _SetEnabled(e) {\n                this._isEnabled = !!e;\n                if (this._isEnabled)\n                    this._StartTicking();\n                else {\n                    this._simLeft = false;\n                    this._simRight = false;\n                    this._simUp = false;\n                    this._simDown = false;\n                    this._StopTicking()\n                }\n            }\n            _IsEnabled() {\n                return this._isEnabled\n            }\n            _SetAllowSliding(s) {\n                this._allowSliding = !!s\n            }\n            _IsAllowSliding() {\n                return this._allowSliding\n            }\n            GetDebuggerProperties() {\n                const prefix = "behaviors.eightdir";\n                return [{\n                    title: "$" + this.GetBehaviorType().GetName(),\n                    properties: [{\n                        name: prefix + ".debugger.vector-x",\n                        value: this._GetVectorX(),\n                        onedit: v => this._SetVectorX(v)\n                    }, {\n                        name: prefix + ".debugger.vector-y",\n                        value: this._GetVectorY(),\n                        onedit: v => this._SetVectorY(v)\n                    }, {\n                        name: prefix + ".debugger.speed",\n                        value: this._GetSpeed(),\n                        onedit: v => this._SetSpeed(v)\n                    }, {\n                        name: prefix + ".debugger.angle-of-motion",\n                        value: C3.toDegrees(this._GetMovingAngle())\n                    }, {\n                        name: prefix + ".properties.max-speed.name",\n                        value: this._GetMaxSpeed(),\n                        onedit: v => this._SetMaxSpeed(v)\n                    }, {\n                        name: prefix + ".properties.acceleration.name",\n                        value: this._GetAcceleration(),\n                        onedit: v => this._SetAcceleration(v)\n                    }, {\n                        name: prefix + ".properties.deceleration.name",\n                        value: this._GetDeceleration(),\n                        onedit: v => this._SetDeceleration(v)\n                    }, {\n                        name: prefix + ".properties.allow-sliding.name",\n                        value: this._IsAllowSliding(),\n                        onedit: v => this._SetAllowSliding(v)\n                    }, {\n                        name: prefix + ".properties.enabled.name",\n                        value: this._IsEnabled(),\n                        onedit: v => this._SetEnabled(v)\n                    }]\n                }]\n            }\n            GetScriptInterfaceClass() {\n                return self.I8DirectionBehaviorInstance\n            }\n        }\n        ;\n        const map = new WeakMap;\n        const SIMULATE_CONTROL_MAP = new Map([["left", 0], ["right", 1], ["up", 2], ["down", 3]]);\n        self.I8DirectionBehaviorInstance = class I8DirectionBehaviorInstance extends IBehaviorInstance {\n            constructor() {\n                super();\n                map.set(this, IBehaviorInstance._GetInitInst().GetSdkInstance())\n            }\n            stop() {\n                map.get(this)._Stop()\n            }\n            reverse() {\n                map.get(this)._Reverse()\n            }\n            simulateControl(ctrl) {\n                C3X.RequireString(ctrl);\n                const index = SIMULATE_CONTROL_MAP.get(ctrl);\n                if (typeof index !== "number")\n                    throw new Error("invalid control");\n                map.get(this)._SimulateControl(index)\n            }\n            get speed() {\n                return map.get(this)._GetSpeed()\n            }\n            set speed(s) {\n                C3X.RequireFiniteNumber(s);\n                map.get(this)._SetSpeed(s)\n            }\n            get maxSpeed() {\n                return map.get(this)._GetMaxSpeed()\n            }\n            set maxSpeed(s) {\n                C3X.RequireFiniteNumber(s);\n                map.get(this)._SetMaxSpeed(s)\n            }\n            get acceleration() {\n                return map.get(this)._GetAcceleration()\n            }\n            set acceleration(a) {\n                C3X.RequireFiniteNumber(a);\n                map.get(this)._SetAcceleration(a)\n            }\n            get deceleration() {\n                return map.get(this)._GetDeceleration()\n            }\n            set deceleration(d) {\n                C3X.RequireFiniteNumber(d);\n                map.get(this)._SetDeceleration(d)\n            }\n            get vectorX() {\n                return map.get(this)._GetVectorX()\n            }\n            set vectorX(x) {\n                C3X.RequireFiniteNumber(x);\n                map.get(this)._SetVectorX(x)\n            }\n            get vectorY() {\n                return map.get(this)._GetVectorY()\n            }\n            set vectorY(y) {\n                C3X.RequireFiniteNumber(y);\n                map.get(this)._SetVectorY(y)\n            }\n            get isDefaultControls() {\n                return map.get(this)._IsDefaultControls()\n            }\n            set isDefaultControls(d) {\n                map.get(this)._SetDefaultControls(!!d)\n            }\n            get isIgnoringInput() {\n                return map.get(this)._IsIgnoreInput()\n            }\n            set isIgnoringInput(e) {\n                map.get(this)._SetIgnoreInput(!!e)\n            }\n            get isAllowSliding() {\n                return map.get(this)._IsAllowSliding()\n            }\n            set isAllowSliding(s) {\n                map.get(this)._SetAllowSliding(!!s)\n            }\n            get isEnabled() {\n                return map.get(this)._IsEnabled()\n            }\n            set isEnabled(e) {\n                map.get(this)._SetEnabled(!!e)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.EightDir.Cnds = {\n            IsMoving() {\n                return this._GetSpeed() > 1E-10\n            },\n            CompareSpeed(cmp, s) {\n                return C3.compare(this._GetSpeed(), cmp, s)\n            },\n            IsEnabled() {\n                return this._IsEnabled()\n            },\n            IsAllowSliding() {\n                return this._IsAllowSliding()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.EightDir.Acts = {\n            Stop() {\n                this._Stop()\n            },\n            Reverse() {\n                this._Reverse()\n            },\n            SetIgnoreInput(ignore) {\n                this._SetIgnoreInput(ignore)\n            },\n            SetSpeed(speed) {\n                this._SetSpeed(speed)\n            },\n            SetMaxSpeed(maxSpeed) {\n                this._SetMaxSpeed(maxSpeed)\n            },\n            SetAcceleration(acc) {\n                this._SetAcceleration(acc)\n            },\n            SetDeceleration(dec) {\n                this._SetDeceleration(dec)\n            },\n            SimulateControl(ctrl) {\n                this._SimulateControl(ctrl)\n            },\n            SetEnabled(e) {\n                this._SetEnabled(e)\n            },\n            SetVectorX(x) {\n                this._SetVectorX(x)\n            },\n            SetVectorY(y) {\n                this._SetVectorY(y)\n            },\n            SetDefaultControls(d) {\n                this._SetDefaultControls(!!d)\n            },\n            SetAllowSliding(s) {\n                this._SetAllowSliding(s)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.EightDir.Exps = {\n            Speed() {\n                return this._GetSpeed()\n            },\n            MaxSpeed() {\n                return this._GetMaxSpeed()\n            },\n            Acceleration() {\n                return this._GetAcceleration()\n            },\n            Deceleration() {\n                return this._GetDeceleration()\n            },\n            MovingAngle() {\n                return C3.toDegrees(this._GetMovingAngle())\n            },\n            VectorX() {\n                return this._GetVectorX()\n            },\n            VectorY() {\n                return this._GetVectorY()\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        let tempVec2a = null;\n        let tempVec2b = null;\n        let vec2RecycleCache = [];\n        let Box2D = null;\n        let physicsBehavior = null;\n        const PHYSICS_COLLISIONS_KEY = "Physics_DisabledCollisions";\n        function SetObjectTypeCollisionsEnabled(typeA, typeB, state) {\n            const savedA = typeA.GetSavedDataMap();\n            const savedB = typeB.GetSavedDataMap();\n            if (state) {\n                const setA = savedA.get(PHYSICS_COLLISIONS_KEY);\n                if (setA)\n                    setA.delete(typeB.GetSID());\n                const setB = savedB.get(PHYSICS_COLLISIONS_KEY);\n                if (setB)\n                    setB.delete(typeA.GetSID())\n            } else {\n                let setA = savedA.get(PHYSICS_COLLISIONS_KEY);\n                if (!setA) {\n                    setA = new Set;\n                    savedA.set(PHYSICS_COLLISIONS_KEY, setA)\n                }\n                let setB = savedB.get(PHYSICS_COLLISIONS_KEY);\n                if (!setB) {\n                    setB = new Set;\n                    savedB.set(PHYSICS_COLLISIONS_KEY, setB)\n                }\n                setA.add(typeB.GetSID());\n                setB.add(typeA.GetSID())\n            }\n        }\n        C3.Behaviors.Physics = class PhysicsBehavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                opts.scriptInterfaceClass = self.IPhysicsBehavior;\n                super(opts);\n                this._world = null;\n                this._worldG = 10;\n                this._worldScale = .02;\n                this._worldManifold = null;\n                this._lastUpdateTick = -1;\n                this._steppingMode = 1;\n                this._velocityIterations = 8;\n                this._positionIterations = 3;\n                this._allCollisionsEnabled = true;\n                this._runtime.AddLoadPromise(this._LoadBox2DWasm())\n            }\n            async _LoadBox2DWasm() {\n                const box2dWasmUrl = await this._runtime.GetAssetManager().GetProjectFileUrl("box2d.wasm");\n                await new Promise(resolve => {\n                    self["Box2DWasmModule"]({\n                        "wasmBinaryFile": box2dWasmUrl\n                    }).then(box2d => {\n                        Box2D = box2d;\n                        this._InitBox2DWorld();\n                        resolve()\n                    }\n                    )\n                }\n                )\n            }\n            _InitBox2DWorld() {\n                const collisionEngine = this._runtime.GetCollisionEngine();\n                tempVec2a = C3.Behaviors.Physics.GetVec2(0, 0);\n                tempVec2b = C3.Behaviors.Physics.GetVec2(0, 0);\n                this._world = new Box2D["b2World"](C3.Behaviors.Physics.GetTempVec2A(0, this._worldG),true);\n                const listener = new Box2D["JSContactListener"];\n                listener["BeginContact"] = contactPtr => {\n                    const contact = Box2D["wrapPointer"](contactPtr, Box2D["b2Contact"]);\n                    const behA = C3.Behaviors.Physics.Instance.LookupBehInstFromBody(contact["GetFixtureA"]()["GetBody"]());\n                    const behB = C3.Behaviors.Physics.Instance.LookupBehInstFromBody(contact["GetFixtureB"]()["GetBody"]());\n                    collisionEngine.RegisterCollision(behA.GetObjectInstance(), behB.GetObjectInstance())\n                }\n                ;\n                listener["EndContact"] = () => {}\n                ;\n                listener["PreSolve"] = () => {}\n                ;\n                listener["PostSolve"] = () => {}\n                ;\n                this._world["SetContactListener"](listener);\n                const filter = new Box2D["JSContactFilter"];\n                filter["ShouldCollide"] = (fixAPtr, fixBPtr) => {\n                    if (this._allCollisionsEnabled)\n                        return true;\n                    const fixtureA = Box2D["wrapPointer"](fixAPtr, Box2D["b2Fixture"]);\n                    const fixtureB = Box2D["wrapPointer"](fixBPtr, Box2D["b2Fixture"]);\n                    const behA = C3.Behaviors.Physics.Instance.LookupBehInstFromBody(fixtureA["GetBody"]());\n                    const behB = C3.Behaviors.Physics.Instance.LookupBehInstFromBody(fixtureB["GetBody"]());\n                    const typeA = behA.GetObjectInstance().GetObjectClass();\n                    const typeB = behB.GetObjectInstance().GetObjectClass();\n                    const sidA = typeA.GetSID();\n                    const sidB = typeB.GetSID();\n                    const setA = typeA.GetSavedDataMap().get(PHYSICS_COLLISIONS_KEY);\n                    if (setA && setA.has(sidB))\n                        return false;\n                    const setB = typeB.GetSavedDataMap().get(PHYSICS_COLLISIONS_KEY);\n                    if (setB && setB.has(sidA))\n                        return false;\n                    return true\n                }\n                ;\n                this._world["SetContactFilter"](filter);\n                this._worldManifold = new Box2D["b2WorldManifold"]\n            }\n            Release() {\n                super.Release()\n            }\n            GetBox2D() {\n                return Box2D\n            }\n            GetWorld() {\n                return this._world\n            }\n            GetWorldScale() {\n                return this._worldScale\n            }\n            GetSteppingMode() {\n                return this._steppingMode\n            }\n            SetSteppingMode(m) {\n                this._steppingMode = m\n            }\n            SetLastUpdateTick(t) {\n                this._lastUpdateTick = t\n            }\n            GetLastUpdateTick() {\n                return this._lastUpdateTick\n            }\n            SetVelocityIterations(v) {\n                this._velocityIterations = Math.max(v, 1)\n            }\n            GetVelocityIterations() {\n                return this._velocityIterations\n            }\n            SetPositionIterations(p) {\n                this._positionIterations = Math.max(p, 1)\n            }\n            GetPositionIterations() {\n                return this._positionIterations\n            }\n            SetIterations(v, p) {\n                this.SetVelocityIterations(v);\n                this.SetPositionIterations(p)\n            }\n            GetGravity() {\n                return this._worldG\n            }\n            SetGravity(g) {\n                if (g === this._worldG)\n                    return;\n                this._world["SetGravity"](C3.Behaviors.Physics.GetTempVec2A(0, g));\n                this._worldG = g;\n                this._WakeUpAllPhysicsBodies()\n            }\n            _WakeUpAllPhysicsBodies() {\n                for (const inst of this.GetInstances()) {\n                    const behInst = C3.Behaviors.Physics.Instance.LookupBehInstFromInst(inst);\n                    if (!behInst)\n                        continue;\n                    const body = behInst.GetBody();\n                    if (!body)\n                        continue;\n                    body["SetAwake"](true)\n                }\n            }\n            DisableShouldCollideFastPath() {\n                this._allCollisionsEnabled = false\n            }\n            SetCollisionsEnabled(typeA, typeB, state) {\n                state = !!state;\n                if (!typeA || !typeB)\n                    return;\n                if (typeB.IsFamily())\n                    for (const member of typeB.GetFamilyMembers())\n                        SetObjectTypeCollisionsEnabled(typeA, member, state);\n                else\n                    SetObjectTypeCollisionsEnabled(typeA, typeB, state);\n                this.DisableShouldCollideFastPath()\n            }\n            GetWorldManifold() {\n                return this._worldManifold\n            }\n            static GetPhysicsCollisionKey() {\n                return PHYSICS_COLLISIONS_KEY\n            }\n            static GetVec2(x, y) {\n                if (vec2RecycleCache.length) {\n                    const ret = vec2RecycleCache.pop();\n                    ret["set_x"](x);\n                    ret["set_y"](y);\n                    return ret\n                } else {\n                    const b2Vec2 = Box2D["b2Vec2"];\n                    return new b2Vec2(x,y)\n                }\n            }\n            static FreeVec2(v) {\n                vec2RecycleCache.push(v)\n            }\n            static GetTempVec2A(x, y) {\n                tempVec2a["set_x"](x);\n                tempVec2a["set_y"](y);\n                return tempVec2a\n            }\n            static GetTempVec2B(x, y) {\n                tempVec2b["set_x"](x);\n                tempVec2b["set_y"](y);\n                return tempVec2b\n            }\n            static CreatePolygonShape(vertices) {\n                const b2PolygonShape = Box2D["b2PolygonShape"];\n                const shape = new b2PolygonShape;\n                const buffer = Box2D["_malloc"](vertices.length * 8);\n                let offset = 0;\n                for (let i = 0; i < vertices.length; ++i) {\n                    Box2D["HEAPF32"][buffer + offset >> 2] = vertices[i]["get_x"]();\n                    Box2D["HEAPF32"][buffer + (offset + 4) >> 2] = vertices[i]["get_y"]();\n                    offset += 8\n                }\n                const ptr_wrapped = Box2D["wrapPointer"](buffer, Box2D["b2Vec2"]);\n                shape["Set"](ptr_wrapped, vertices.length);\n                Box2D["_free"](buffer);\n                return shape\n            }\n        }\n        ;\n        const STEPPING_MODES = ["fixed", "variable"];\n        self.IPhysicsBehavior = class IPhysicsBehavior extends self.IBehavior {\n            constructor(behavior) {\n                super(behavior);\n                physicsBehavior = behavior\n            }\n            set worldGravity(g) {\n                C3X.RequireFiniteNumber(g);\n                physicsBehavior.SetGravity(g)\n            }\n            get worldGravity() {\n                return physicsBehavior.GetGravity()\n            }\n            set steppingMode(s) {\n                const i = STEPPING_MODES.indexOf(s);\n                if (i < 0)\n                    throw new Error("invalid stepping mode");\n                physicsBehavior.SetSteppingMode(STEPPING_MODES[i])\n            }\n            get steppingMode() {\n                return STEPPING_MODES[physicsBehavior.GetSteppingMode()]\n            }\n            set velocityIterations(v) {\n                C3X.RequireFiniteNumber(v);\n                physicsBehavior.SetVelocityIterations(v)\n            }\n            get velocityIterations() {\n                return physicsBehavior.GetVelocityIterations()\n            }\n            set positionIterations(p) {\n                C3X.RequireFiniteNumber(p);\n                physicsBehavior.SetPositionIterations(p)\n            }\n            get positionIterations() {\n                return physicsBehavior.GetPositionIterations()\n            }\n            setCollisionsEnabled(iObjectClassA, iObjectClassB, state) {\n                const runtime = physicsBehavior.GetRuntime();\n                const objectClassA = runtime._UnwrapIObjectClass(iObjectClassA);\n                const objectClassB = runtime._UnwrapIObjectClass(iObjectClassB);\n                state = !!state;\n                physicsBehavior.SetCollisionsEnabled(objectClassA, objectClassB, state)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Physics.Type = class PhysicsType extends C3.SDKBehaviorTypeBase {\n            constructor(behaviorType) {\n                super(behaviorType)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        const IBehaviorInstance = self.IBehaviorInstance;\n        const assert = self.assert;\n        const IMMOVABLE = 0;\n        const COLLISION_MASK = 1;\n        const PREVENT_ROTATION = 2;\n        const DENSITY = 3;\n        const FRICTION = 4;\n        const ELASTICITY = 5;\n        const LINEAR_DAMPING = 6;\n        const ANGULAR_DAMPING = 7;\n        const BULLET = 8;\n        const ENABLE = 9;\n        const body2beh = new WeakMap;\n        const inst2beh = new WeakMap;\n        const tileConvexPolyCache = new WeakMap;\n        const TILE_FLIPPED_HORIZONTAL = -2147483648;\n        const TILE_FLIPPED_VERTICAL = 1073741824;\n        const TILE_FLIPPED_DIAGONAL = 536870912;\n        const TILE_FLAGS_MASK = 3758096384;\n        const TILE_ID_MASK = 536870911;\n        const GetTempVec2A = C3.Behaviors.Physics.GetTempVec2A;\n        const GetTempVec2B = C3.Behaviors.Physics.GetTempVec2B;\n        const tempRect = C3.New(C3.Rect);\n        const tempQuad = C3.New(C3.Quad);\n        C3.Behaviors.Physics.Instance = class PhysicsInstance extends C3.SDKBehaviorInstanceBase {\n            constructor(behInst, properties) {\n                super(behInst);\n                const behavior = this.GetBehavior();\n                const wi = this.GetWorldInfo();\n                this._box2d = behavior.GetBox2D();\n                this._world = behavior.GetWorld();\n                this._worldScale = behavior.GetWorldScale();\n                this._isImmovable = false;\n                this._collisionMask = 0;\n                this._preventRotation = false;\n                this._density = 1;\n                this._friction = .5;\n                this._restitution = .2;\n                this._linearDamping = 0;\n                this._angularDamping = .01;\n                this._isBullet = false;\n                this._isEnabled = true;\n                this._body = null;\n                this._fixtures = [];\n                this._myJoints = [];\n                this._myCreatedJoints = [];\n                this._joiningMe = new Set;\n                this._lastKnownX = wi.GetX();\n                this._lastKnownY = wi.GetY();\n                this._lastKnownAngle = wi.GetAngle();\n                this._lastWidth = 0;\n                this._lastHeight = 0;\n                this._lastTickOverride = false;\n                if (properties) {\n                    this._isImmovable = !!properties[IMMOVABLE];\n                    this._collisionMask = properties[COLLISION_MASK];\n                    this._preventRotation = !!properties[PREVENT_ROTATION];\n                    this._density = properties[DENSITY];\n                    this._friction = properties[FRICTION];\n                    this._restitution = properties[ELASTICITY];\n                    this._linearDamping = properties[LINEAR_DAMPING];\n                    this._angularDamping = properties[ANGULAR_DAMPING];\n                    this._isBullet = !!properties[BULLET];\n                    this._isEnabled = !!properties[ENABLE]\n                }\n                const rt = this._runtime.Dispatcher();\n                this._disposables = new C3.CompositeDisposable(C3.Disposable.From(rt, "instancedestroy", e => this._OnInstanceDestroyed(e.instance)),C3.Disposable.From(rt, "beforeload", () => this._OnBeforeLoad()),C3.Disposable.From(rt, "afterload", () => this._OnAfterLoad()));\n                inst2beh.set(this._inst, this);\n                if (this._isEnabled)\n                    this._StartTicking()\n            }\n            PostCreate() {\n                this._CreateBody()\n            }\n            Release() {\n                this._DestroyMyJoints();\n                C3.clearArray(this._myCreatedJoints);\n                this._joiningMe.clear();\n                if (this._body) {\n                    this._DestroyFixtures();\n                    this._world["DestroyBody"](this._body);\n                    this._body = null\n                }\n                super.Release()\n            }\n            _CreateFixture(fixDef) {\n                if (!this._body)\n                    return;\n                const fixture = this._body["CreateFixture"](fixDef);\n                this._fixtures.push(fixture);\n                return fixture\n            }\n            _DestroyFixtures() {\n                if (!this._body)\n                    return;\n                for (const fixture of this._fixtures)\n                    this._body["DestroyFixture"](fixture);\n                C3.clearArray(this._fixtures)\n            }\n            _GetBoundingQuadExcludingMesh() {\n                const wi = this.GetWorldInfo();\n                if (wi.HasMesh()) {\n                    wi.CalculateBbox(tempRect, tempQuad, false);\n                    return tempQuad\n                } else\n                    return wi.GetBoundingQuad()\n            }\n            _Destroy(o) {\n                this._box2d["destroy"](o)\n            }\n            _CreateBody() {\n                if (!this._isEnabled)\n                    return;\n                const b2FixtureDef = this._box2d["b2FixtureDef"];\n                const b2BodyDef = this._box2d["b2BodyDef"];\n                const wi = this.GetWorldInfo();\n                if (!this._body) {\n                    const bodyDef = new b2BodyDef;\n                    bodyDef["set_type"](this._isImmovable ? 0 : 2);\n                    const bquad = this._GetBoundingQuadExcludingMesh();\n                    bodyDef["set_position"](GetTempVec2B(bquad.midX() * this._worldScale, bquad.midY() * this._worldScale));\n                    bodyDef["set_angle"](wi.GetAngle());\n                    bodyDef["set_fixedRotation"](this._preventRotation);\n                    bodyDef["set_linearDamping"](this._linearDamping);\n                    bodyDef["set_angularDamping"](this._angularDamping);\n                    bodyDef["set_bullet"](this._isBullet);\n                    this._body = this._world["CreateBody"](bodyDef);\n                    this._Destroy(bodyDef);\n                    body2beh.set(this._body, this)\n                }\n                this._DestroyFixtures();\n                const fixDef = new b2FixtureDef;\n                fixDef["set_density"](this._density);\n                fixDef["set_friction"](this._friction);\n                fixDef["set_restitution"](this._restitution);\n                const hasPoly = wi.HasOwnCollisionPoly();\n                let useCollisionMask = this._collisionMask;\n                if (!hasPoly && !this._inst.HasTilemap() && useCollisionMask === 0)\n                    useCollisionMask = 1;\n                const instW = Math.max(Math.abs(wi.GetWidth()), 1);\n                const instH = Math.max(Math.abs(wi.GetHeight()), 1);\n                if (useCollisionMask === 0)\n                    if (this._inst.HasTilemap())\n                        this._CreateTilemapFixtures(fixDef);\n                    else\n                        this._CreatePolygonFixture(fixDef, instW, instH);\n                else if (useCollisionMask === 1)\n                    this._CreateBoundingBoxFixture(fixDef, instW, instH);\n                else\n                    this._CreateCircleFixture(fixDef, instW, instH);\n                this._lastWidth = wi.GetWidth();\n                this._lastHeight = wi.GetHeight();\n                wi.SetPhysicsBodyChanged(false);\n                this._Destroy(fixDef)\n            }\n            _CreateBoundingBoxFixture(fixDef, instW, instH) {\n                const b2PolygonShape = this._box2d["b2PolygonShape"];\n                const shape = new b2PolygonShape;\n                shape["SetAsBox"](instW * this._worldScale * .5, instH * this._worldScale * .5);\n                fixDef["set_shape"](shape);\n                this._CreateFixture(fixDef);\n                this._Destroy(shape)\n            }\n            _CreateCircleFixture(fixDef, instW, instH) {\n                const b2CircleShape = this._box2d["b2CircleShape"];\n                const shape = new b2CircleShape;\n                shape["set_m_radius"](Math.min(instW, instH) * this._worldScale * .5);\n                fixDef["set_shape"](shape);\n                this._CreateFixture(fixDef);\n                this._Destroy(shape)\n            }\n            _CreatePolygonFixture(fixDef, instW, instH) {\n                const wi = this.GetWorldInfo();\n                const isMirrored = wi.GetWidth() < 0;\n                const isFlipped = wi.GetHeight() < 0;\n                const worldScale = this._worldScale;\n                const angle = wi.GetAngle();\n                if (angle !== 0) {\n                    wi.SetAngle(0);\n                    wi.SetBboxChanged()\n                }\n                const bquad = this._GetBoundingQuadExcludingMesh();\n                const offX = bquad.midX() - wi.GetX();\n                const offY = bquad.midY() - wi.GetY();\n                if (angle !== 0) {\n                    wi.SetAngle(angle);\n                    wi.SetBboxChanged()\n                }\n                const transformedPoly = wi.GetCustomTransformedCollisionPoly(isMirrored ? -instW : instW, isFlipped ? -instH : instH, 0);\n                const ptsArr = transformedPoly.pointsArr();\n                const ptsCount = ptsArr.length \/ 2;\n                const arr = [];\n                for (let i = 0; i < ptsCount; ++i)\n                    arr.push(C3.Behaviors.Physics.GetVec2(ptsArr[i * 2] - offX, ptsArr[i * 2 + 1] - offY));\n                if (isMirrored !== isFlipped)\n                    arr.reverse();\n                const convexPolys = C3.Behaviors.Physics.Separator.Separate(arr, instW * instH);\n                for (const v of arr)\n                    C3.Behaviors.Physics.FreeVec2(v);\n                if (convexPolys.length)\n                    for (const arr2 of convexPolys) {\n                        for (const vec of arr2) {\n                            vec["set_x"](vec["get_x"]() * worldScale);\n                            vec["set_y"](vec["get_y"]() * worldScale)\n                        }\n                        const shape = C3.Behaviors.Physics.CreatePolygonShape(arr2);\n                        fixDef["set_shape"](shape);\n                        this._CreateFixture(fixDef);\n                        this._Destroy(shape);\n                        for (const v of arr2)\n                            C3.Behaviors.Physics.FreeVec2(v)\n                    }\n                else\n                    this._CreateBoundingBoxFixture(fixDef, instW, instH)\n            }\n            _CreateTilemapFixtures(fixDef) {\n                const wi = this.GetWorldInfo();\n                const bquad = this._GetBoundingQuadExcludingMesh();\n                const offX = bquad.midX() - wi.GetX();\n                const offY = bquad.midY() - wi.GetY();\n                const worldScale = this._worldScale;\n                const GetVec2 = C3.Behaviors.Physics.GetVec2;\n                const FreeVec2 = C3.Behaviors.Physics.FreeVec2;\n                const collRects = [];\n                this._inst.GetSdkInstance().GetAllCollisionRects(collRects);\n                const arr = [];\n                for (let i = 0, len = collRects.length; i < len; ++i) {\n                    const c = collRects[i];\n                    const rc = c.GetRect();\n                    const poly = c.GetPoly();\n                    if (poly) {\n                        let convexPolys = tileConvexPolyCache.get(poly);\n                        if (!convexPolys) {\n                            const ptsArr = poly.pointsArr();\n                            const ptsCount = poly.pointCount();\n                            for (let j = 0; j < ptsCount; ++j)\n                                arr.push(GetVec2(ptsArr[j * 2], ptsArr[j * 2 + 1]));\n                            const flags = c.GetTileId() & TILE_FLAGS_MASK;\n                            if (flags === TILE_FLIPPED_HORIZONTAL || flags === TILE_FLIPPED_VERTICAL || flags === TILE_FLIPPED_DIAGONAL || flags & TILE_FLIPPED_HORIZONTAL && flags & TILE_FLIPPED_VERTICAL && flags & TILE_FLIPPED_DIAGONAL)\n                                arr.reverse();\n                            convexPolys = C3.Behaviors.Physics.Separator.Separate(arr, rc.width() * rc.height());\n                            tileConvexPolyCache.set(poly, convexPolys);\n                            for (const v of arr)\n                                FreeVec2(v);\n                            C3.clearArray(arr)\n                        }\n                        for (let j = 0, lenj = convexPolys.length; j < lenj; ++j) {\n                            const cp = convexPolys[j];\n                            for (let k = 0, lenk = cp.length; k < lenk; ++k)\n                                arr.push(GetVec2((rc.getLeft() + cp[k]["get_x"]() - offX) * worldScale, (rc.getTop() + cp[k]["get_y"]() - offY) * worldScale));\n                            const shape = C3.Behaviors.Physics.CreatePolygonShape(arr);\n                            fixDef["set_shape"](shape);\n                            this._CreateFixture(fixDef);\n                            this._Destroy(shape);\n                            for (const v of arr)\n                                FreeVec2(v);\n                            C3.clearArray(arr)\n                        }\n                    } else {\n                        arr.push(GetVec2((rc.getLeft() - offX) * worldScale, (rc.getTop() - offY) * worldScale));\n                        arr.push(GetVec2((rc.getRight() - offX) * worldScale, (rc.getTop() - offY) * worldScale));\n                        arr.push(GetVec2((rc.getRight() - offX) * worldScale, (rc.getBottom() - offY) * worldScale));\n                        arr.push(GetVec2((rc.getLeft() - offX) * worldScale, (rc.getBottom() - offY) * worldScale));\n                        const shape = C3.Behaviors.Physics.CreatePolygonShape(arr);\n                        fixDef["set_shape"](shape);\n                        this._CreateFixture(fixDef);\n                        this._Destroy(shape)\n                    }\n                    for (const v of arr)\n                        FreeVec2(v);\n                    C3.clearArray(arr)\n                }\n            }\n            _DestroyBody() {\n                if (!this._body)\n                    return;\n                this._DestroyMyJoints();\n                body2beh.delete(this._body);\n                this._DestroyFixtures();\n                this._world["DestroyBody"](this._body);\n                this._body = null\n            }\n            _DestroyMyJoints() {\n                for (const joint of this._myJoints)\n                    this._world["DestroyJoint"](joint);\n                C3.clearArray(this._myJoints)\n            }\n            _RecreateMyJoints() {\n                for (const j of this._myCreatedJoints)\n                    switch (j.type) {\n                    case 0:\n                        this._DoCreateDistanceJoint(...j.params);\n                        break;\n                    case 1:\n                        this._DoCreateRevoluteJoint(...j.params);\n                        break;\n                    case 2:\n                        this._DoCreateLimitedRevoluteJoint(...j.params);\n                        break;\n                    case 3:\n                        this._DoCreatePrismaticJoint(...j.params);\n                        break;\n                    default:\n                    }\n            }\n            _GetInstImagePoint(imgPt) {\n                const wi = this.GetWorldInfo();\n                if (imgPt === -1)\n                    return [wi.GetX(), wi.GetY()];\n                if (imgPt === 0 && this._body) {\n                    const pos = this._body["GetPosition"]();\n                    const lc = this._body["GetLocalCenter"]();\n                    return [(pos["get_x"]() + lc["get_x"]()) \/ this._worldScale, (pos["get_y"]() + lc["get_y"]()) \/ this._worldScale]\n                }\n                return this._inst.GetImagePoint(imgPt)\n            }\n            _CreateDistanceJoint(imgPt, otherInst, otherImgPt, damping, freq) {\n                if (!this._isEnabled || !otherInst || otherInst === this._inst)\n                    return;\n                if (!C3.Behaviors.Physics.Instance.LookupBehInstFromInst(otherInst))\n                    return;\n                this._myCreatedJoints.push({\n                    type: 0,\n                    params: [imgPt, otherInst.GetUID(), otherImgPt, damping, freq]\n                });\n                this._DoCreateDistanceJoint(imgPt, otherInst.GetUID(), otherImgPt, damping, freq)\n            }\n            _DoCreateDistanceJoint(imgPt, otherInstUid, otherImgPt, damping, freq) {\n                if (!this._isEnabled)\n                    return;\n                const otherInst = this._runtime.GetInstanceByUID(otherInstUid);\n                if (!otherInst || otherInst === this._inst || !inst2beh.has(otherInst))\n                    return;\n                const otherBehInst = C3.Behaviors.Physics.Instance.LookupBehInstFromInst(otherInst);\n                otherBehInst._joiningMe.add(this._inst);\n                this._UpdateBodyToMatchInstance(false);\n                otherBehInst._UpdateBodyToMatchInstance(false);\n                const [myX,myY] = this._GetInstImagePoint(imgPt);\n                const [theirX,theirY] = otherInst.GetImagePoint(otherImgPt);\n                const dx = myX - theirX;\n                const dy = myY - theirY;\n                const b2DistanceJointDef = this._box2d["b2DistanceJointDef"];\n                const worldScale = this._worldScale;\n                const jointDef = new b2DistanceJointDef;\n                jointDef["Initialize"](this._body, otherBehInst.GetBody(), GetTempVec2A(myX * worldScale, myY * worldScale), GetTempVec2B(theirX * worldScale, theirY * worldScale));\n                jointDef["set_length"](Math.hypot(dx, dy) * worldScale);\n                jointDef["set_dampingRatio"](damping);\n                jointDef["set_frequencyHz"](freq);\n                this._myJoints.push(this._world["CreateJoint"](jointDef));\n                this._Destroy(jointDef)\n            }\n            _CreateRevoluteJoint(imgPt, otherInst) {\n                if (!this._isEnabled || !otherInst || otherInst === this._inst)\n                    return;\n                if (!C3.Behaviors.Physics.Instance.LookupBehInstFromInst(otherInst))\n                    return;\n                this._myCreatedJoints.push({\n                    type: 1,\n                    params: [imgPt, otherInst.GetUID()]\n                });\n                this._DoCreateRevoluteJoint(imgPt, otherInst.GetUID())\n            }\n            _DoCreateRevoluteJoint(imgPt, otherInstUid) {\n                if (!this._isEnabled)\n                    return;\n                const otherInst = this._runtime.GetInstanceByUID(otherInstUid);\n                if (!otherInst || otherInst === this._inst || !inst2beh.has(otherInst))\n                    return;\n                const otherBehInst = C3.Behaviors.Physics.Instance.LookupBehInstFromInst(otherInst);\n                otherBehInst._joiningMe.add(this._inst);\n                this._UpdateBodyToMatchInstance(false);\n                otherBehInst._UpdateBodyToMatchInstance(false);\n                const [myX,myY] = this._GetInstImagePoint(imgPt);\n                const b2RevoluteJointDef = this._box2d["b2RevoluteJointDef"];\n                const worldScale = this._worldScale;\n                const jointDef = new b2RevoluteJointDef;\n                jointDef["Initialize"](this._body, otherBehInst.GetBody(), GetTempVec2A(myX * worldScale, myY * worldScale));\n                this._myJoints.push(this._world["CreateJoint"](jointDef));\n                this._Destroy(jointDef)\n            }\n            _CreateLimitedRevoluteJoint(imgPt, otherInst, lower, upper) {\n                if (!this._isEnabled || !otherInst || otherInst === this._inst)\n                    return;\n                if (!C3.Behaviors.Physics.Instance.LookupBehInstFromInst(otherInst))\n                    return;\n                lower = C3.toDegrees(lower);\n                upper = C3.toDegrees(upper);\n                this._myCreatedJoints.push({\n                    type: 2,\n                    params: [imgPt, otherInst.GetUID(), lower, upper]\n                });\n                this._DoCreateLimitedRevoluteJoint(imgPt, otherInst.GetUID(), lower, upper)\n            }\n            _DoCreateLimitedRevoluteJoint(imgPt, otherInstUid, lower, upper) {\n                if (!this._isEnabled)\n                    return;\n                const otherInst = this._runtime.GetInstanceByUID(otherInstUid);\n                if (!otherInst || otherInst === this._inst || !inst2beh.has(otherInst))\n                    return;\n                const otherBehInst = C3.Behaviors.Physics.Instance.LookupBehInstFromInst(otherInst);\n                otherBehInst._joiningMe.add(this._inst);\n                this._UpdateBodyToMatchInstance(false);\n                otherBehInst._UpdateBodyToMatchInstance(false);\n                const [myX,myY] = this._GetInstImagePoint(imgPt);\n                const b2RevoluteJointDef = this._box2d["b2RevoluteJointDef"];\n                const worldScale = this._worldScale;\n                const jointDef = new b2RevoluteJointDef;\n                jointDef["Initialize"](this._body, otherBehInst.GetBody(), GetTempVec2A(myX * worldScale, myY * worldScale));\n                jointDef["set_enableLimit"](true);\n                jointDef["set_lowerAngle"](C3.toRadians(lower));\n                jointDef["set_upperAngle"](C3.toRadians(upper));\n                this._myJoints.push(this._world["CreateJoint"](jointDef));\n                this._Destroy(jointDef)\n            }\n            _CreatePrismaticJoint(imgPt, otherInst, axisAngle, enableLimit, lowerTranslation, upperTranslation, enableMotor, motorSpeed, maxMotorForce) {\n                if (!this._isEnabled || !otherInst || otherInst === this._inst)\n                    return;\n                if (!C3.Behaviors.Physics.Instance.LookupBehInstFromInst(otherInst))\n                    return;\n                axisAngle = C3.toDegrees(axisAngle);\n                motorSpeed = C3.toDegrees(motorSpeed);\n                this._myCreatedJoints.push({\n                    type: 3,\n                    params: [imgPt, otherInst.GetUID(), axisAngle, enableLimit, lowerTranslation, upperTranslation, enableMotor, motorSpeed, maxMotorForce]\n                });\n                this._DoCreatePrismaticJoint(imgPt, otherInst.GetUID(), axisAngle, enableLimit, lowerTranslation, upperTranslation, enableMotor, motorSpeed, maxMotorForce)\n            }\n            _DoCreatePrismaticJoint(imgPt, otherInstUid, axisAngle, enableLimit, lowerTranslation, upperTranslation, enableMotor, motorSpeed, maxMotorForce) {\n                if (!this._isEnabled)\n                    return;\n                const otherInst = this._runtime.GetInstanceByUID(otherInstUid);\n                if (!otherInst || otherInst === this._inst || !inst2beh.has(otherInst))\n                    return;\n                const otherBehInst = C3.Behaviors.Physics.Instance.LookupBehInstFromInst(otherInst);\n                otherBehInst._joiningMe.add(this._inst);\n                this._UpdateBodyToMatchInstance(false);\n                otherBehInst._UpdateBodyToMatchInstance(false);\n                const [myX,myY] = this._GetInstImagePoint(imgPt);\n                axisAngle = C3.toRadians(axisAngle);\n                const axisX = Math.cos(axisAngle);\n                const axisY = Math.sin(axisAngle);\n                const b2PrismaticJointDef = this._box2d["b2PrismaticJointDef"];\n                const worldScale = this._worldScale;\n                const jointDef = new b2PrismaticJointDef;\n                jointDef["Initialize"](this._body, otherBehInst.GetBody(), GetTempVec2A(myX * worldScale, myY * worldScale), GetTempVec2B(axisX, axisY));\n                jointDef["set_enableLimit"](!!enableLimit);\n                jointDef["set_lowerTranslation"](lowerTranslation * worldScale);\n                jointDef["set_upperTranslation"](upperTranslation * worldScale);\n                jointDef["set_enableMotor"](!!enableMotor);\n                jointDef["set_motorSpeed"](C3.toRadians(motorSpeed));\n                jointDef["set_maxMotorForce"](maxMotorForce);\n                this._myJoints.push(this._world["CreateJoint"](jointDef));\n                this._Destroy(jointDef)\n            }\n            _RemoveJoints() {\n                if (!this._isEnabled)\n                    return;\n                this._DestroyMyJoints();\n                C3.clearArray(this._myCreatedJoints);\n                this._joiningMe.clear()\n            }\n            _OnInstanceDestroyed(inst) {\n                const instUid = inst.GetUID();\n                let j = 0;\n                for (let i = 0, len = this._myCreatedJoints.length; i < len; ++i) {\n                    this._myCreatedJoints[j] = this._myCreatedJoints[i];\n                    if (j < this._myJoints.length)\n                        this._myJoints[j] = this._myJoints[i];\n                    if (this._myCreatedJoints[i].params[1] === instUid) {\n                        if (i < this._myJoints.length)\n                            this._world["DestroyJoint"](this._myJoints[i])\n                    } else\n                        ++j\n                }\n                C3.truncateArray(this._myCreatedJoints, j);\n                if (j < this._myJoints.length)\n                    C3.truncateArray(this._myJoints, j);\n                this._joiningMe.delete(inst)\n            }\n            GetBody() {\n                return this._body\n            }\n            static LookupBehInstFromBody(body) {\n                return body2beh.get(body) || null\n            }\n            static LookupBehInstFromInst(inst) {\n                return inst2beh.get(inst) || null\n            }\n            SaveToJson() {\n                const ret = {\n                    "e": this._isEnabled,\n                    "pr": this._preventRotation,\n                    "d": this._density,\n                    "fr": this._friction,\n                    "re": this._restitution,\n                    "ld": this._linearDamping,\n                    "ad": this._angularDamping,\n                    "b": this._isBullet,\n                    "mcj": this._myCreatedJoints\n                };\n                if (this._isEnabled) {\n                    const v = this._body["GetLinearVelocity"]();\n                    ret["vx"] = v["get_x"]();\n                    ret["vy"] = v["get_y"]();\n                    ret["om"] = this._body["GetAngularVelocity"]()\n                }\n                return ret\n            }\n            _OnBeforeLoad() {\n                this._DestroyMyJoints();\n                C3.clearArray(this._myCreatedJoints);\n                this._joiningMe.clear()\n            }\n            LoadFromJson(o) {\n                this._DestroyBody();\n                this._isEnabled = o["e"];\n                this._preventRotation = o["pr"];\n                this._density = o["d"];\n                this._friction = o["fr"];\n                this._restitution = o["re"];\n                this._linearDamping = o["ld"];\n                this._angularDamping = o["ad"];\n                this._isBullet = o["b"];\n                this._myCreatedJoints = o["mcj"];\n                const wi = this.GetWorldInfo();\n                this._lastKnownX = wi.GetX();\n                this._lastKnownY = wi.GetY();\n                this._lastKnownAngle = wi.GetAngle();\n                this._lastWidth = wi.GetWidth();\n                this._lastHeight = wi.GetHeight();\n                if (this._isEnabled) {\n                    this._CreateBody();\n                    this._body["SetLinearVelocity"](GetTempVec2A(o["vx"], o["vy"]));\n                    this._body["SetAngularVelocity"](o["om"]);\n                    if (o["vx"] !== 0 || o["vy"] !== 0 || o["om"] !== 0)\n                        this._body["SetAwake"](true);\n                    this._myCreatedJoints = o["mcj"]\n                }\n                if (this._isEnabled)\n                    this._StartTicking();\n                else\n                    this._StopTicking()\n            }\n            _OnAfterLoad() {\n                if (this._isEnabled)\n                    this._RecreateMyJoints()\n            }\n            Tick() {\n                if (!this._isEnabled)\n                    return;\n                const runtime = this._runtime;\n                const behavior = this.GetBehavior();\n                let dt = 0;\n                if (behavior.GetSteppingMode() === 0)\n                    dt = runtime.GetTimeScale() \/ 60;\n                else {\n                    dt = runtime.GetDt(this._inst);\n                    if (dt > 1 \/ 30)\n                        dt = 1 \/ 30\n                }\n                const tickCount = runtime.GetTickCountNoSave();\n                if (tickCount > behavior.GetLastUpdateTick() && runtime.GetTimeScale() > 0) {\n                    const isDebug = this._runtime.IsDebug();\n                    let startTime = 0;\n                    if (isDebug)\n                        startTime = performance.now();\n                    if (dt !== 0)\n                        this._world["Step"](dt, behavior.GetVelocityIterations(), behavior.GetPositionIterations());\n                    this._world["ClearForces"]();\n                    if (isDebug)\n                        self.C3Debugger.AddPhysicsTime(performance.now() - startTime);\n                    behavior.SetLastUpdateTick(tickCount)\n                }\n                this._UpdateBodyToMatchInstance(true)\n            }\n            _UpdateBodyToMatchInstance(isTickUpdate) {\n                const inst = this._inst;\n                const wi = inst.GetWorldInfo();\n                const worldScale = this._worldScale;\n                if (wi.GetWidth() !== this._lastWidth || wi.GetHeight() !== this._lastHeight || wi.IsPhysicsBodyChanged())\n                    this._CreateBody();\n                const body = this._body;\n                const posChanged = wi.GetX() !== this._lastKnownX || wi.GetY() !== this._lastKnownY;\n                const angleChanged = wi.GetAngle() !== this._lastKnownAngle;\n                if (posChanged) {\n                    const bquad = this._GetBoundingQuadExcludingMesh();\n                    const newMidX = bquad.midX();\n                    const newMidY = bquad.midY();\n                    const diffX = newMidX - this._lastKnownX;\n                    const diffY = newMidY - this._lastKnownY;\n                    if (angleChanged)\n                        body["SetTransform"](GetTempVec2A(newMidX * worldScale, newMidY * worldScale), wi.GetAngle());\n                    else\n                        body["SetTransform"](GetTempVec2A(newMidX * worldScale, newMidY * worldScale), body["GetAngle"]());\n                    if (isTickUpdate) {\n                        body["SetLinearVelocity"](GetTempVec2A(diffX, diffY));\n                        this._lastTickOverride = true\n                    }\n                    body["SetAwake"](true)\n                } else if (isTickUpdate && this._lastTickOverride) {\n                    const bquad = this._GetBoundingQuadExcludingMesh();\n                    this._lastTickOverride = false;\n                    body["SetLinearVelocity"](GetTempVec2A(0, 0));\n                    body["SetTransform"](GetTempVec2A(bquad.midX() * worldScale, bquad.midY() * worldScale), body["GetAngle"]())\n                }\n                if (!posChanged && angleChanged) {\n                    body["SetTransform"](body["GetPosition"](), wi.GetAngle());\n                    body["SetAwake"](true)\n                }\n                const pos = body["GetPosition"]();\n                const newX = pos["get_x"]() \/ worldScale;\n                const newY = pos["get_y"]() \/ worldScale;\n                const newAngle = body["GetAngle"]();\n                if (newX !== wi.GetX() || newY !== wi.GetY() || newAngle !== wi.GetAngle()) {\n                    wi.SetXY(newX, newY);\n                    wi.SetAngle(newAngle);\n                    wi.SetBboxChanged();\n                    const bquad = this._GetBoundingQuadExcludingMesh();\n                    const dx = bquad.midX() - wi.GetX();\n                    const dy = bquad.midY() - wi.GetY();\n                    if (dx !== 0 || dy !== 0) {\n                        wi.OffsetXY(-dx, -dy);\n                        wi.SetBboxChanged()\n                    }\n                }\n                this._lastKnownX = wi.GetX();\n                this._lastKnownY = wi.GetY();\n                this._lastKnownAngle = wi.GetAngle()\n            }\n            GetPropertyValueByIndex(index) {\n                switch (index) {\n                case PREVENT_ROTATION:\n                    return this._IsPreventRotate();\n                case DENSITY:\n                    return this._GetDensity();\n                case FRICTION:\n                    return this._GetFriction();\n                case ELASTICITY:\n                    return this._GetElasticity();\n                case LINEAR_DAMPING:\n                    return this._GetLinearDamping();\n                case ANGULAR_DAMPING:\n                    return this._GetAngularDamping();\n                case BULLET:\n                    return this._IsBullet();\n                case ENABLE:\n                    return this._IsEnabled()\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                switch (index) {\n                case PREVENT_ROTATION:\n                    this._SetPreventRotate(value);\n                    break;\n                case DENSITY:\n                    this._SetDensity(value);\n                    break;\n                case FRICTION:\n                    this._SetFriction(value);\n                    break;\n                case ELASTICITY:\n                    this._SetElasticity(value);\n                    break;\n                case LINEAR_DAMPING:\n                    this._SetLinearDamping(value);\n                    break;\n                case ANGULAR_DAMPING:\n                    this._SetAngularDamping(value);\n                    break;\n                case BULLET:\n                    this._SetBullet(value);\n                    break;\n                case ENABLE:\n                    this._SetEnabled(value);\n                    break\n                }\n            }\n            _SetEnabled(e) {\n                e = !!e;\n                if (this._isEnabled && !e) {\n                    this._DestroyBody();\n                    this._isEnabled = false;\n                    this._StopTicking()\n                } else if (!this._isEnabled && e) {\n                    this._isEnabled = true;\n                    this._CreateBody();\n                    this._StartTicking()\n                }\n            }\n            _IsEnabled() {\n                return this._isEnabled\n            }\n            GetDebuggerProperties() {\n                const prefix = "behaviors.physics";\n                const props = [{\n                    name: prefix + ".properties.enabled.name",\n                    value: this._IsEnabled(),\n                    onedit: v => this._SetEnabled(v)\n                }, {\n                    name: prefix + ".properties.immovable.name",\n                    value: this._IsImmovable(),\n                    onedit: v => this._SetImmovable(v)\n                }, {\n                    name: prefix + ".properties.density.name",\n                    value: this._GetDensity(),\n                    onedit: v => this._SetDensity(v)\n                }, {\n                    name: prefix + ".properties.friction.name",\n                    value: this._GetFriction(),\n                    onedit: v => this._SetFriction(v)\n                }, {\n                    name: prefix + ".properties.elasticity.name",\n                    value: this._GetElasticity(),\n                    onedit: v => this._SetElasticity(v)\n                }, {\n                    name: prefix + ".properties.linear-damping.name",\n                    value: this._GetLinearDamping(),\n                    onedit: v => this._SetLinearDamping(v)\n                }, {\n                    name: prefix + ".properties.angular-damping.name",\n                    value: this._GetAngularDamping(),\n                    onedit: v => this._SetAngularDamping(v)\n                }];\n                if (this._isEnabled) {\n                    props.push({\n                        name: prefix + ".debugger.is-sleeping",\n                        value: this._IsSleeping()\n                    });\n                    props.push({\n                        name: prefix + ".debugger.velocity-x",\n                        value: this._GetVelocityX(),\n                        onedit: v => this._SetVelocity(v, this._GetVelocityY())\n                    });\n                    props.push({\n                        name: prefix + ".debugger.velocity-y",\n                        value: this._GetVelocityY(),\n                        onedit: v => this._SetVelocity(this._GetVelocityX(), v)\n                    });\n                    props.push({\n                        name: prefix + ".debugger.angular-velocity",\n                        value: C3.toDegrees(this._GetAngularVelocity()),\n                        onedit: v => this._SetAngularVelocity(C3.toRadians(v))\n                    });\n                    props.push({\n                        name: prefix + ".debugger.mass",\n                        value: this._GetMass()\n                    })\n                }\n                return [{\n                    title: "$" + this.GetBehaviorType().GetName(),\n                    properties: props\n                }]\n            }\n            _ApplyForce(fx, fy, imgPt) {\n                const [x,y] = this._GetInstImagePoint(imgPt);\n                this._DoApplyForce(fx, fy, x, y)\n            }\n            _ApplyForceToward(f, px, py, imgPt) {\n                const [x,y] = this._GetInstImagePoint(imgPt);\n                const a = C3.angleTo(x, y, px, py);\n                this._DoApplyForce(Math.cos(a) * f, Math.sin(a) * f, x, y)\n            }\n            _ApplyForceAtAngle(f, a, imgPt) {\n                const [x,y] = this._GetInstImagePoint(imgPt);\n                this._DoApplyForce(Math.cos(a) * f, Math.sin(a) * f, x, y)\n            }\n            _DoApplyForce(fx, fy, ox, oy) {\n                if (!this._isEnabled)\n                    return;\n                const worldScale = this._worldScale;\n                this._body["ApplyForce"](GetTempVec2A(fx, fy), GetTempVec2B(ox * worldScale, oy * worldScale), true)\n            }\n            _ApplyImpulse(fx, fy, imgPt) {\n                const [x,y] = this._GetInstImagePoint(imgPt);\n                this._DoApplyImpulse(fx, fy, x, y)\n            }\n            _ApplyImpulseToward(f, px, py, imgPt) {\n                const [x,y] = this._GetInstImagePoint(imgPt);\n                const a = C3.angleTo(x, y, px, py);\n                this._DoApplyImpulse(Math.cos(a) * f, Math.sin(a) * f, x, y)\n            }\n            _ApplyImpulseAtAngle(f, a, imgPt) {\n                const [x,y] = this._GetInstImagePoint(imgPt);\n                this._DoApplyImpulse(Math.cos(a) * f, Math.sin(a) * f, x, y)\n            }\n            _DoApplyImpulse(fx, fy, ox, oy) {\n                if (!this._isEnabled)\n                    return;\n                const worldScale = this._worldScale;\n                this._body["ApplyLinearImpulse"](GetTempVec2A(fx, fy), GetTempVec2B(ox * worldScale, oy * worldScale), true);\n                const wi = this.GetWorldInfo();\n                this._lastKnownX = wi.GetX();\n                this._lastKnownY = wi.GetY();\n                this._lastTickOverride = false\n            }\n            _ApplyTorque(m) {\n                if (!this._isEnabled)\n                    return;\n                this._body["ApplyTorque"](m, true)\n            }\n            _ApplyTorqueToAngle(m, a) {\n                const f = C3.angleClockwise(this.GetWorldInfo().GetAngle(), a) ? -1 : 1;\n                this._ApplyTorque(m * f)\n            }\n            _ApplyTorqueToPosition(m, x, y) {\n                const wi = this.GetWorldInfo();\n                const a = C3.angleTo(wi.GetX(), wi.GetY(), x, y);\n                const f = C3.angleClockwise(wi.GetAngle(), a) ? -1 : 1;\n                this._ApplyTorque(m * f)\n            }\n            _SetAngularVelocity(v) {\n                if (!this._isEnabled)\n                    return;\n                this._body["SetAngularVelocity"](v);\n                this._body["SetAwake"](true)\n            }\n            _GetAngularVelocity() {\n                return this._isEnabled ? this._body["GetAngularVelocity"]() : 0\n            }\n            _SetVelocity(vx, vy) {\n                if (!this._isEnabled)\n                    return;\n                const worldScale = this._worldScale;\n                this._body["SetLinearVelocity"](GetTempVec2A(vx * worldScale, vy * worldScale));\n                this._body["SetAwake"](true);\n                const wi = this.GetWorldInfo();\n                this._lastKnownX = wi.GetX();\n                this._lastKnownY = wi.GetY();\n                this._lastTickOverride = false\n            }\n            _GetVelocity() {\n                if (!this._isEnabled)\n                    return [0, 0];\n                const worldScale = this._worldScale;\n                const vec = this._body["GetLinearVelocity"]();\n                return [vec["get_x"]() \/ worldScale, vec["get_y"]() \/ worldScale]\n            }\n            _GetVelocityX() {\n                return this._isEnabled ? this._body["GetLinearVelocity"]()["get_x"]() \/ this._worldScale : 0\n            }\n            _GetVelocityY() {\n                return this._isEnabled ? this._body["GetLinearVelocity"]()["get_y"]() \/ this._worldScale : 0\n            }\n            _SetDensity(d) {\n                if (!this._isEnabled)\n                    return;\n                if (this._density === d)\n                    return;\n                this._density = d;\n                for (const fixture of this._fixtures)\n                    fixture["SetDensity"](d);\n                this._body["ResetMassData"]()\n            }\n            _GetDensity() {\n                return this._isEnabled ? this._density : 0\n            }\n            _SetFriction(f) {\n                if (!this._isEnabled)\n                    return;\n                if (this._friction === f)\n                    return;\n                this._friction = f;\n                for (const fixture of this._fixtures)\n                    fixture["SetFriction"](f);\n                for (let contactEdge = this._body["GetContactList"](); this._box2d["getPointer"](contactEdge); contactEdge = contactEdge["get_next"]()) {\n                    const contact = contactEdge["get_contact"]();\n                    if (contact)\n                        contact["ResetFriction"]()\n                }\n            }\n            _GetFriction() {\n                return this._isEnabled ? this._friction : 0\n            }\n            _SetElasticity(e) {\n                if (!this._isEnabled)\n                    return;\n                if (this._restitution === e)\n                    return;\n                this._restitution = e;\n                for (const fixture of this._fixtures)\n                    fixture["SetRestitution"](e)\n            }\n            _GetElasticity() {\n                return this._isEnabled ? this._restitution : 0\n            }\n            _SetLinearDamping(ld) {\n                if (!this._isEnabled)\n                    return;\n                if (this._linearDamping === ld)\n                    return;\n                this._linearDamping = ld;\n                this._body["SetLinearDamping"](ld)\n            }\n            _GetLinearDamping() {\n                return this._isEnabled ? this._linearDamping : 0\n            }\n            _SetAngularDamping(ad) {\n                if (!this._isEnabled)\n                    return;\n                if (this._angularDamping === ad)\n                    return;\n                this._angularDamping = ad;\n                this._body["SetAngularDamping"](ad)\n            }\n            _GetAngularDamping() {\n                return this._isEnabled ? this._angularDamping : 0\n            }\n            _SetImmovable(i) {\n                if (!this._isEnabled)\n                    return;\n                i = !!i;\n                if (this._isImmovable === i)\n                    return;\n                this._isImmovable = i;\n                this._body["SetType"](this._isImmovable ? 0 : 2);\n                this._body["SetAwake"](true)\n            }\n            _IsImmovable() {\n                return this._isImmovable\n            }\n            _SetPreventRotate(i) {\n                if (!this._isEnabled)\n                    return;\n                i = !!i;\n                if (this._preventRotation === i)\n                    return;\n                this._preventRotation = i;\n                this._body["SetFixedRotation"](this._preventRotation);\n                this._body["SetAngularVelocity"](0);\n                this._body["SetAwake"](true)\n            }\n            _IsPreventRotate() {\n                return this._preventRotation\n            }\n            _SetBullet(i) {\n                if (!this._isEnabled)\n                    return;\n                i = !!i;\n                if (this._isBullet === i)\n                    return;\n                this._isBullet = i;\n                this._body["SetBullet"](this._isBullet);\n                this._body["SetAwake"](true)\n            }\n            _IsBullet() {\n                return this._isBullet\n            }\n            _GetMass() {\n                return this._isEnabled ? this._body["GetMass"]() \/ this._worldScale : 0\n            }\n            _GetCenterOfMassX() {\n                return this._isEnabled ? (this._body["GetPosition"]()["get_x"]() + this._body["GetLocalCenter"]()["get_x"]()) \/ this._worldScale : 0\n            }\n            _GetCenterOfMassY() {\n                return this._isEnabled ? (this._body["GetPosition"]()["get_y"]() + this._body["GetLocalCenter"]()["get_y"]()) \/ this._worldScale : 0\n            }\n            _GetCenterOfMass() {\n                if (!this._isEnabled)\n                    return [0, 0];\n                const posVec = this._body["GetPosition"]();\n                const centerVec = this._body["GetLocalCenter"]();\n                const worldScale = this._worldScale;\n                return [(posVec["get_x"]() + centerVec["get_x"]()) \/ worldScale, (posVec["get_y"]() + centerVec["get_y"]()) \/ worldScale]\n            }\n            _IsSleeping() {\n                return this._isEnabled ? !this._body["IsAwake"]() : false\n            }\n            _GetContactCount() {\n                if (!this._isEnabled)\n                    return 0;\n                let count = 0;\n                for (let contactEdge = this._body["GetContactList"](); this._box2d["getPointer"](contactEdge); contactEdge = contactEdge["get_next"]()) {\n                    const contact = contactEdge["get_contact"]();\n                    if (!contact)\n                        continue;\n                    const manifold = contact["GetManifold"]();\n                    const pointCount = manifold["get_pointCount"]();\n                    count += pointCount\n                }\n                return count\n            }\n            _GetContactPositionAt(index) {\n                index = Math.floor(index);\n                if (!this._isEnabled)\n                    return [0, 0];\n                let count = 0;\n                for (let contactEdge = this._body["GetContactList"](); this._box2d["getPointer"](contactEdge); contactEdge = contactEdge["get_next"]()) {\n                    const contact = contactEdge["get_contact"]();\n                    if (!contact)\n                        continue;\n                    const manifold = contact["GetManifold"]();\n                    const pointCount = manifold["get_pointCount"]();\n                    if (index >= count && index < count + pointCount) {\n                        const i = index - count;\n                        const worldManifold = this.GetBehavior().GetWorldManifold();\n                        contact["GetWorldManifold"](worldManifold);\n                        const vec = worldManifold["get_points"](i);\n                        return [vec["get_x"]() \/ this._worldScale, vec["get_y"]() \/ this._worldScale]\n                    } else\n                        count += pointCount\n                }\n                return [0, 0]\n            }\n            GetScriptInterfaceClass() {\n                return self.IPhysicsBehaviorInstance\n            }\n        }\n        ;\n        const map = new WeakMap;\n        function UnwrapIWorldInstance(this_, iinst) {\n            const runtime = map.get(this_).GetRuntime();\n            return runtime._UnwrapIWorldInstance(iinst)\n        }\n        self.IPhysicsBehaviorInstance = class IPhysicsBehaviorInstance extends IBehaviorInstance {\n            constructor() {\n                super();\n                map.set(this, IBehaviorInstance._GetInitInst().GetSdkInstance())\n            }\n            get isEnabled() {\n                return map.get(this)._IsEnabled()\n            }\n            set isEnabled(e) {\n                map.get(this)._SetEnabled(e)\n            }\n            applyForce(fx, fy, imgPt=0) {\n                C3X.RequireFiniteNumber(fx);\n                C3X.RequireFiniteNumber(fy);\n                map.get(this)._ApplyForce(fx, fy, imgPt)\n            }\n            applyForceTowardPosition(f, px, py, imgPt=0) {\n                C3X.RequireFiniteNumber(f);\n                C3X.RequireFiniteNumber(px);\n                C3X.RequireFiniteNumber(py);\n                map.get(this)._ApplyForceToward(f, px, py, imgPt)\n            }\n            applyForceAtAngle(f, a, imgPt=0) {\n                C3X.RequireFiniteNumber(f);\n                C3X.RequireFiniteNumber(a);\n                map.get(this)._ApplyForceAtAngle(f, a, imgPt)\n            }\n            applyImpulse(ix, iy, imgPt=0) {\n                C3X.RequireFiniteNumber(ix);\n                C3X.RequireFiniteNumber(iy);\n                map.get(this)._ApplyImpulse(ix, iy, imgPt)\n            }\n            applyImpulseTowardPosition(i, px, py, imgPt=0) {\n                C3X.RequireFiniteNumber(i);\n                C3X.RequireFiniteNumber(px);\n                C3X.RequireFiniteNumber(py);\n                map.get(this)._ApplyImpulseToward(i, px, py, imgPt)\n            }\n            applyImpulseAtAngle(i, a, imgPt=0) {\n                C3X.RequireFiniteNumber(i);\n                C3X.RequireFiniteNumber(a);\n                map.get(this)._ApplyImpulseAtAngle(i, a, imgPt)\n            }\n            applyTorque(m) {\n                C3X.RequireFiniteNumber(m);\n                map.get(this)._ApplyTorque(m)\n            }\n            applyTorqueToAngle(m, a) {\n                C3X.RequireFiniteNumber(m);\n                C3X.RequireFiniteNumber(a);\n                map.get(this)._ApplyTorqueToAngle(m, a)\n            }\n            applyTorqueToPosition(m, px, py) {\n                C3X.RequireFiniteNumber(m);\n                C3X.RequireFiniteNumber(px);\n                C3X.RequireFiniteNumber(py);\n                map.get(this)._ApplyTorqueToPosition(m, px, py)\n            }\n            set angularVelocity(v) {\n                C3X.RequireFiniteNumber(v);\n                map.get(this)._SetAngularVelocity(v)\n            }\n            get angularVelocity() {\n                return map.get(this)._GetAngularVelocity()\n            }\n            setVelocity(vx, vy) {\n                C3X.RequireFiniteNumber(vx);\n                C3X.RequireFiniteNumber(vy);\n                map.get(this)._SetVelocity(vx, vy)\n            }\n            getVelocityX() {\n                return map.get(this)._GetVelocityX()\n            }\n            getVelocityY() {\n                return map.get(this)._GetVelocityY()\n            }\n            getVelocity() {\n                return map.get(this)._GetVelocity()\n            }\n            set density(d) {\n                C3X.RequireFiniteNumber(d);\n                map.get(this)._SetDensity(d)\n            }\n            get density() {\n                return map.get(this)._GetDensity()\n            }\n            set friction(f) {\n                C3X.RequireFiniteNumber(f);\n                map.get(this)._SetFriction(f)\n            }\n            get friction() {\n                return map.get(this)._GetFriction()\n            }\n            set elasticity(e) {\n                C3X.RequireFiniteNumber(e);\n                map.get(this)._SetElasticity(e)\n            }\n            get elasticity() {\n                return map.get(this)._GetElasticity()\n            }\n            set linearDamping(ld) {\n                C3X.RequireFiniteNumber(ld);\n                map.get(this)._SetLinearDamping(ld)\n            }\n            get linearDamping() {\n                return map.get(this)._GetLinearDamping()\n            }\n            set angularDamping(ad) {\n                C3X.RequireFiniteNumber(ad);\n                map.get(this)._SetAngularDamping(ad)\n            }\n            get angularDamping() {\n                return map.get(this)._GetAngularDamping()\n            }\n            set isImmovable(i) {\n                map.get(this)._SetImmovable(i)\n            }\n            get isImmovable() {\n                return map.get(this)._IsImmovable()\n            }\n            set isPreventRotation(p) {\n                map.get(this)._SetPreventRotate(p)\n            }\n            get isPreventRotation() {\n                return map.get(this)._IsPreventRotate()\n            }\n            set isBullet(b) {\n                map.get(this)._SetBullet(b)\n            }\n            get isBullet() {\n                return map.get(this)._IsBullet()\n            }\n            get mass() {\n                return map.get(this)._GetMass()\n            }\n            getCenterOfMassX() {\n                return map.get(this)._GetCenterOfMassX()\n            }\n            getCenterOfMassY() {\n                return map.get(this)._GetCenterOfMassY()\n            }\n            getCenterOfMass() {\n                return map.get(this)._GetCenterOfMass()\n            }\n            getContactCount() {\n                return map.get(this)._GetContactCount()\n            }\n            getContactX(index) {\n                C3X.RequireFiniteNumber(index);\n                return map.get(this)._GetContactPositionAt(index)[0]\n            }\n            getContactY(index) {\n                C3X.RequireFiniteNumber(index);\n                return map.get(this)._GetContactPositionAt(index)[1]\n            }\n            getContact(index) {\n                C3X.RequireFiniteNumber(index);\n                return map.get(this)._GetContactPositionAt(index)\n            }\n            get isSleeping() {\n                return map.get(this)._IsSleeping()\n            }\n            createDistanceJoint(imgPt, iOtherInst, otherImgPt, damping, freq) {\n                C3X.RequireFiniteNumber(damping);\n                C3X.RequireFiniteNumber(freq);\n                const otherInst = UnwrapIWorldInstance(this, iOtherInst);\n                map.get(this)._CreateDistanceJoint(imgPt, otherInst, otherImgPt, damping, freq)\n            }\n            createRevoluteJoint(imgPt, iOtherInst) {\n                const otherInst = UnwrapIWorldInstance(this, iOtherInst);\n                map.get(this)._CreateRevoluteJoint(imgPt, otherInst)\n            }\n            createLimitedRevoluteJoint(imgPt, iOtherInst, lower, upper) {\n                C3X.RequireFiniteNumber(lower);\n                C3X.RequireFiniteNumber(upper);\n                const otherInst = UnwrapIWorldInstance(this, iOtherInst);\n                map.get(this)._CreateLimitedRevoluteJoint(imgPt, otherInst, lower, upper)\n            }\n            createPrismaticJoint(imgPt, iOtherInst, axisAngle, enableLimit, lowerTranslation, upperTranslation, enableMotor, motorSpeed, maxMotorForce) {\n                const otherInst = UnwrapIWorldInstance(this, iOtherInst);\n                map.get(this)._CreatePrismaticJoint(imgPt, otherInst, axisAngle, enableLimit, lowerTranslation, upperTranslation, enableMotor, motorSpeed, maxMotorForce)\n            }\n            removeAllJoints() {\n                map.get(this)._RemoveJoints()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Physics.Cnds = {\n            IsSleeping() {\n                return this._IsSleeping()\n            },\n            CompareVelocity(which, cmp, x) {\n                if (!this._isEnabled)\n                    return false;\n                let value = 0;\n                if (which === 0)\n                    value = this._GetVelocityX();\n                else if (which === 1)\n                    value = this._GetVelocityY();\n                else {\n                    const [vx,vy] = this._GetVelocity();\n                    value = Math.hypot(vx, vy)\n                }\n                return C3.compare(value, cmp, x)\n            },\n            CompareAngularVelocity(cmp, x) {\n                if (!this._isEnabled)\n                    return false;\n                const av = C3.toDegrees(this._GetAngularVelocity());\n                return C3.compare(av, cmp, x)\n            },\n            CompareMass(cmp, x) {\n                if (!this._isEnabled)\n                    return false;\n                const mass = this._GetMass();\n                return C3.compare(mass, cmp, x)\n            },\n            IsEnabled() {\n                return this._IsEnabled()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Physics.Acts = {\n            ApplyForce(fx, fy, imgPt) {\n                this._ApplyForce(fx, fy, imgPt)\n            },\n            ApplyForceToward(f, px, py, imgPt) {\n                this._ApplyForceToward(f, px, py, imgPt)\n            },\n            ApplyForceAtAngle(f, a, imgPt) {\n                this._ApplyForceAtAngle(f, C3.toRadians(a), imgPt)\n            },\n            ApplyImpulse(fx, fy, imgPt) {\n                this._ApplyImpulse(fx, fy, imgPt)\n            },\n            ApplyImpulseToward(f, px, py, imgPt) {\n                this._ApplyImpulseToward(f, px, py, imgPt)\n            },\n            ApplyImpulseAtAngle(f, a, imgPt) {\n                this._ApplyImpulseAtAngle(f, C3.toRadians(a), imgPt)\n            },\n            ApplyTorque(m) {\n                this._ApplyTorque(C3.toRadians(m))\n            },\n            ApplyTorqueToAngle(m, a) {\n                this._ApplyTorqueToAngle(C3.toRadians(m), C3.toRadians(a))\n            },\n            ApplyTorqueToPosition(m, x, y) {\n                this._ApplyTorqueToPosition(C3.toRadians(m), x, y)\n            },\n            SetAngularVelocity(v) {\n                this._SetAngularVelocity(C3.toRadians(v))\n            },\n            CreateDistanceJoint(imgPt, objectClass, otherImgPt, damping, freq) {\n                if (!objectClass)\n                    return;\n                const otherInst = objectClass.GetFirstPicked(this._inst);\n                this._CreateDistanceJoint(imgPt, otherInst, otherImgPt, damping, freq)\n            },\n            CreateRevoluteJoint(imgPt, objectClass) {\n                if (!objectClass)\n                    return;\n                const otherInst = objectClass.GetFirstPicked(this._inst);\n                this._CreateRevoluteJoint(imgPt, otherInst)\n            },\n            CreateLimitedRevoluteJoint(imgPt, objectClass, lower, upper) {\n                if (!objectClass)\n                    return;\n                const otherInst = objectClass.GetFirstPicked(this._inst);\n                this._CreateLimitedRevoluteJoint(imgPt, otherInst, C3.toRadians(lower), C3.toRadians(upper))\n            },\n            CreatePrismaticJoint(imgPt, objectClass, axisAngle, enableLimit, lowerTranslation, upperTranslation, enableMotor, motorSpeed, maxMotorForce) {\n                if (!objectClass)\n                    return;\n                const otherInst = objectClass.GetFirstPicked(this._inst);\n                this._CreatePrismaticJoint(imgPt, otherInst, C3.toRadians(axisAngle), enableLimit, lowerTranslation, upperTranslation, enableMotor, C3.toRadians(motorSpeed), maxMotorForce)\n            },\n            RemoveJoints() {\n                this._RemoveJoints()\n            },\n            SetWorldGravity(g) {\n                this.GetBehavior().SetGravity(g)\n            },\n            SetSteppingMode(m) {\n                this.GetBehavior().SetSteppingMode(m)\n            },\n            SetIterations(vel, pos) {\n                this.GetBehavior().SetIterations(vel, pos)\n            },\n            SetVelocity(vx, vy) {\n                this._SetVelocity(vx, vy)\n            },\n            SetDensity(d) {\n                this._SetDensity(d)\n            },\n            SetFriction(f) {\n                this._SetFriction(f)\n            },\n            SetElasticity(e) {\n                this._SetElasticity(e)\n            },\n            SetLinearDamping(ld) {\n                this._SetLinearDamping(ld)\n            },\n            SetAngularDamping(ad) {\n                this._SetAngularDamping(ad)\n            },\n            SetImmovable(i) {\n                this._SetImmovable(i)\n            },\n            EnableCollisions(objectClass, state) {\n                this.GetBehavior().SetCollisionsEnabled(this.GetObjectClass(), objectClass, state !== 0)\n            },\n            SetPreventRotate(i) {\n                this._SetPreventRotate(i !== 0)\n            },\n            SetBullet(i) {\n                this._SetBullet(i !== 0)\n            },\n            SetEnabled(e) {\n                this._SetEnabled(e !== 0)\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Physics.Exps = {\n            VelocityX() {\n                return this._GetVelocityX()\n            },\n            VelocityY() {\n                return this._GetVelocityY()\n            },\n            AngularVelocity() {\n                return C3.toDegrees(this._GetAngularVelocity())\n            },\n            Mass() {\n                return this._GetMass()\n            },\n            CenterOfMassX() {\n                return this._GetCenterOfMassX()\n            },\n            CenterOfMassY() {\n                return this._GetCenterOfMassY()\n            },\n            Density() {\n                return this._GetDensity()\n            },\n            Friction() {\n                return this._GetFriction()\n            },\n            Elasticity() {\n                return this._GetElasticity()\n            },\n            LinearDamping() {\n                return this._GetLinearDamping()\n            },\n            AngularDamping() {\n                return this._GetAngularDamping()\n            },\n            ContactCount() {\n                return this._GetContactCount()\n            },\n            ContactXAt(i) {\n                return this._GetContactPositionAt(i)[0]\n            },\n            ContactYAt(i) {\n                return this._GetContactPositionAt(i)[1]\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    const C3 = self.C3;\n    const b2Separator = {};\n    C3.Behaviors.Physics.Separator = b2Separator;\n    const GetVec2 = C3.Behaviors.Physics.GetVec2;\n    const FreeVec2 = C3.Behaviors.Physics.FreeVec2;\n    function CloneVec2(v) {\n        return GetVec2(v["get_x"](), v["get_y"]())\n    }\n    b2Separator.det = function(x1, y1, x2, y2, x3, y3) {\n        return x1 * y2 + x2 * y3 + x3 * y1 - y1 * x2 - y2 * x3 - y3 * x1\n    }\n    ;\n    b2Separator.hitRay = function(x1, y1, x2, y2, x3, y3, x4, y4) {\n        const t1 = x3 - x1\n          , t2 = y3 - y1\n          , t3 = x2 - x1\n          , t4 = y2 - y1\n          , t5 = x4 - x3\n          , t6 = y4 - y3\n          , t7 = t4 * t5 - t3 * t6;\n        const a = (t5 * t2 - t6 * t1) \/ t7;\n        const px = x1 + a * t3\n          , py = y1 + a * t4;\n        const b1 = b2Separator.isOnSegment(x2, y2, x1, y1, px, py);\n        const b2 = b2Separator.isOnSegment(px, py, x3, y3, x4, y4);\n        if (b1 && b2)\n            return GetVec2(px, py);\n        else\n            return null\n    }\n    ;\n    b2Separator.isOnSegment = function(px, py, x1, y1, x2, y2) {\n        const b1 = x1 + .1 >= px && px >= x2 - .1 || x1 - .1 <= px && px <= x2 + .1;\n        const b2 = y1 + .1 >= py && py >= y2 - .1 || y1 - .1 <= py && py <= y2 + .1;\n        return b1 && b2 && b2Separator.isOnLine(px, py, x1, y1, x2, y2)\n    }\n    ;\n    b2Separator.isOnLine = function(px, py, x1, y1, x2, y2) {\n        if (Math.abs(x2 - x1) > .1) {\n            const a = (y2 - y1) \/ (x2 - x1);\n            const possibleY = a * (px - x1) + y1;\n            const diff = Math.abs(possibleY - py);\n            return diff < .1\n        }\n        return Math.abs(px - x1) < .1\n    }\n    ;\n    b2Separator.pointsMatch = function(x1, y1, x2, y2) {\n        return Math.abs(x2 - x1) < .1 && Math.abs(y2 - y1) < .1\n    }\n    ;\n    b2Separator.Separate = function(verticesVec, objarea) {\n        const calced = b2Separator.calcShapes(verticesVec);\n        let ret = [];\n        for (let i = 0, len = calced.length; i < len; ++i) {\n            const a = calced[i];\n            const poly = [];\n            let areasum = 0;\n            for (let j = 0, lenj = a.length; j < lenj; ++j) {\n                const b = a[j];\n                const c = a[(j + 1) % lenj];\n                areasum += b["get_x"]() * c["get_y"]() - b["get_y"]() * c["get_x"]();\n                poly.push(GetVec2(b["get_x"](), b["get_y"]()))\n            }\n            areasum = Math.abs(areasum \/ 2);\n            if (areasum >= objarea * .001)\n                ret.push(poly);\n            else\n                for (let j = 0, lenj = poly.length; j < lenj; j++)\n                    FreeVec2(poly[j])\n        }\n        ret = SplitConvexPolysOver8Points(ret);\n        return ret\n    }\n    ;\n    b2Separator.calcShapes = function(verticesVec) {\n        let vec = [];\n        let i = 0\n          , n = 0\n          , j = 0;\n        let d = 0\n          , t = 0\n          , dx = 0\n          , dy = 0\n          , minLen = 0;\n        let i1 = 0\n          , i2 = 0\n          , i3 = 0;\n        let p1, p2, p3, v1, v2, v, hitV;\n        let j1 = 0\n          , j2 = 0\n          , k = 0\n          , h = 0;\n        let vec1 = []\n          , vec2 = [];\n        let isConvex = false;\n        let figsVec = []\n          , queue = [];\n        let pushed = false;\n        queue.push(verticesVec);\n        while (queue.length) {\n            vec = queue[0];\n            n = vec.length;\n            isConvex = true;\n            for (i = 0; i < n; i++) {\n                i1 = i;\n                i2 = i < n - 1 ? i + 1 : i + 1 - n;\n                i3 = i < n - 2 ? i + 2 : i + 2 - n;\n                p1 = vec[i1];\n                p2 = vec[i2];\n                p3 = vec[i3];\n                d = b2Separator.det(p1["get_x"](), p1["get_y"](), p2["get_x"](), p2["get_y"](), p3["get_x"](), p3["get_y"]());\n                if (d < 0) {\n                    isConvex = false;\n                    minLen = 1E9;\n                    for (j = 0; j < n; j++)\n                        if (j !== i1 && j !== i2) {\n                            j1 = j;\n                            j2 = j < n - 1 ? j + 1 : 0;\n                            v1 = vec[j1];\n                            v2 = vec[j2];\n                            v = b2Separator.hitRay(p1["get_x"](), p1["get_y"](), p2["get_x"](), p2["get_y"](), v1["get_x"](), v1["get_y"](), v2["get_x"](), v2["get_y"]());\n                            if (v) {\n                                dx = p2["get_x"]() - v["get_x"]();\n                                dy = p2["get_y"]() - v["get_y"]();\n                                t = dx * dx + dy * dy;\n                                if (t < minLen) {\n                                    h = j1;\n                                    k = j2;\n                                    hitV = v;\n                                    minLen = t\n                                } else\n                                    FreeVec2(v)\n                            }\n                        }\n                    if (minLen === 1E9)\n                        return [];\n                    vec1 = [];\n                    vec2 = [];\n                    j1 = h;\n                    j2 = k;\n                    v1 = vec[j1];\n                    v2 = vec[j2];\n                    pushed = false;\n                    if (!b2Separator.pointsMatch(hitV["get_x"](), hitV["get_y"](), v2["get_x"](), v2["get_y"]())) {\n                        vec1.push(hitV);\n                        pushed = true\n                    }\n                    if (!b2Separator.pointsMatch(hitV["get_x"](), hitV["get_y"](), v1["get_x"](), v1["get_y"]())) {\n                        vec2.push(hitV);\n                        pushed = true\n                    }\n                    if (!pushed)\n                        FreeVec2(hitV);\n                    h = -1;\n                    k = i1;\n                    while (true) {\n                        if (k !== j2)\n                            vec1.push(vec[k]);\n                        else {\n                            if (h < 0 || h >= n)\n                                return [];\n                            if (!b2Separator.isOnSegment(v2["get_x"](), v2["get_y"](), vec[h]["get_x"](), vec[h]["get_y"](), p1["get_x"](), p1["get_y"]()))\n                                vec1.push(vec[k]);\n                            break\n                        }\n                        h = k;\n                        if (k - 1 < 0)\n                            k = n - 1;\n                        else\n                            k--\n                    }\n                    vec1.reverse();\n                    h = -1;\n                    k = i2;\n                    while (true) {\n                        if (k !== j1)\n                            vec2.push(vec[k]);\n                        else {\n                            if (h < 0 || h >= n)\n                                return [];\n                            if (k === j1 && !b2Separator.isOnSegment(v1["get_x"](), v1["get_y"](), vec[h]["get_x"](), vec[h]["get_y"](), p2["get_x"](), p2["get_y"]()))\n                                vec2.push(vec[k]);\n                            break\n                        }\n                        h = k;\n                        if (k + 1 > n - 1)\n                            k = 0;\n                        else\n                            k++\n                    }\n                    queue.push(vec1, vec2);\n                    queue.shift();\n                    break\n                }\n            }\n            if (isConvex)\n                figsVec.push(queue.shift())\n        }\n        return figsVec\n    }\n    ;\n    function SplitConvexPolysOver8Points(convexPolys) {\n        const ret = [];\n        for (const arr of convexPolys)\n            if (arr.length <= 8)\n                ret.push(arr);\n            else\n                ret.push.apply(ret, SplitConvexPoly(arr));\n        return ret\n    }\n    function SplitConvexPoly(arr) {\n        const ret = [];\n        ret.push(arr.splice(0, 8));\n        const first = ret[0][0];\n        let last = ret[0][7];\n        while (arr.length) {\n            const poly = arr.splice(0, Math.min(arr.length, 6));\n            let nextLast = poly.at(-1);\n            poly.push(CloneVec2(first));\n            poly.push(CloneVec2(last));\n            ret.push(poly);\n            last = nextLast\n        }\n        return ret\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        const assert = self.assert;\n        const PF_OBSTACLE = Math.pow(2, 26) - 1;\n        class MapData {\n            constructor() {\n                this._hcells = 0;\n                this._vcells = 0;\n                this._cells = null\n            }\n            SetData(hcells, vcells, data) {\n                this._hcells = hcells;\n                this._vcells = vcells;\n                this._cells = data\n            }\n            UpdateRegion(cx1, cy1, lenx, leny, cellData) {\n                const cells = this._cells;\n                if (!cells)\n                    return;\n                for (let x = 0; x < lenx; ++x)\n                    cells[cx1 + x].set(cellData[x], cy1)\n            }\n            At(x, y) {\n                if (x < 0 || y < 0 || x >= this._hcells || y >= this._vcells)\n                    return PF_OBSTACLE;\n                return this._cells[x][y]\n            }\n            GetHCells() {\n                return this._hcells\n            }\n            GetVCells() {\n                return this._vcells\n            }\n        }\n        class PathfinderState {\n            constructor(behavior, mapKey) {\n                this._isReady = false;\n                this._mapData = new MapData;\n                this._isDiagonalsEnabled = true;\n                this._regenerateFlag = false;\n                this._regenerateRegions = [];\n                this._regeneratePromise = null;\n                this._regenerateResolve = null;\n                this._behavior = behavior;\n                this._mapKey = mapKey;\n                const mapKeyParts = mapKey.split(",");\n                this._scriptInterface = new self.IPathfindingMap(this);\n                this._runtime = behavior.GetRuntime();\n                this._cellSize = parseInt(mapKeyParts[0], 10);\n                this._cellBorder = parseInt(mapKeyParts[1], 10)\n            }\n            SetReady(r) {\n                this._isReady = !!r\n            }\n            IsReady() {\n                return this._isReady\n            }\n            GetMapData() {\n                return this._mapData\n            }\n            GetRuntime() {\n                return this._runtime\n            }\n            GetBehavior() {\n                return this._behavior\n            }\n            GetMapKey() {\n                return this._mapKey\n            }\n            SetDiagonalsEnabled(e) {\n                this._isDiagonalsEnabled = !!e\n            }\n            IsDiagonalsEnabled() {\n                return this._isDiagonalsEnabled\n            }\n            SetRegenerateFlag(r) {\n                this._regenerateFlag = !!r\n            }\n            IsRegenerateFlagSet() {\n                return this._regenerateFlag\n            }\n            GetRegenerateRegions() {\n                return this._regenerateRegions\n            }\n            GetRegeneratePromise() {\n                if (!this._regeneratePromise)\n                    this._regeneratePromise = new Promise(resolve => this._regenerateResolve = resolve);\n                return this._regeneratePromise\n            }\n            _ResolveRegeneratePromise() {\n                if (this._regenerateResolve)\n                    this._regenerateResolve();\n                this._regeneratePromise = null;\n                this._regenerateResolve = null\n            }\n            AddRegenerateRegion(startX, startY, endX, endY) {\n                if (this.IsRegenerateFlagSet())\n                    return true;\n                const cellSize = this._cellSize;\n                const cellBorder = this._cellBorder;\n                const hcells = this._mapData.GetHCells();\n                const vcells = this._mapData.GetVCells();\n                const x1 = Math.min(startX, endX) - cellBorder;\n                const y1 = Math.min(startY, endY) - cellBorder;\n                const x2 = Math.max(startX, endX) + cellBorder;\n                const y2 = Math.max(startY, endY) + cellBorder;\n                const cellX1 = Math.max(Math.floor(x1 \/ cellSize), 0);\n                const cellY1 = Math.max(Math.floor(y1 \/ cellSize), 0);\n                const cellX2 = Math.min(Math.ceil(x2 \/ cellSize), hcells);\n                const cellY2 = Math.min(Math.ceil(y2 \/ cellSize), vcells);\n                if (cellX1 >= cellX2 || cellY1 >= cellY2)\n                    return false;\n                this.GetRegenerateRegions().push([cellX1, cellY1, cellX2, cellY2]);\n                return true\n            }\n            AddObjectRegenerateRegion(objectClass) {\n                const instances = objectClass.GetCurrentSol().GetInstances();\n                let didAddRegion = false;\n                for (const inst of instances) {\n                    const wi = inst.GetWorldInfo();\n                    if (!wi)\n                        continue;\n                    const bbox = wi.GetBoundingBox();\n                    const result = this.AddRegenerateRegion(bbox.getLeft(), bbox.getTop(), bbox.getRight(), bbox.getBottom());\n                    didAddRegion = didAddRegion || result\n                }\n                return didAddRegion\n            }\n            GetScriptInterface() {\n                return this._scriptInterface\n            }\n        }\n        C3.Behaviors.Pathfinding = class PathfindingBehavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                super(opts);\n                this._mapState = new Map;\n                this._runtime.AddLoadPromise(this._runtime.AddJobWorkerScripts(["redblackset.js", "pathfind.js"]));\n                this._runtime.Dispatcher().addEventListener("beforelayoutchange", () => this._OnBeforeLayoutChange())\n            }\n            Release() {\n                super.Release()\n            }\n            GetMapKey(cellSize, cellBorder) {\n                return cellSize + "," + cellBorder\n            }\n            GetPathfinderState(mapKey) {\n                let ret = this._mapState.get(mapKey);\n                if (!ret) {\n                    ret = new PathfinderState(this,mapKey);\n                    this._mapState.set(mapKey, ret)\n                }\n                return ret\n            }\n            UpdateCellData(mapKey, hcells, vcells, cellData) {\n                const state = this.GetPathfinderState(mapKey);\n                this._runtime.BroadcastJob("PFCellData", {\n                    "mapKey": mapKey,\n                    "hcells": hcells,\n                    "vcells": vcells,\n                    "cellData": cellData,\n                    "diagonals": state.IsDiagonalsEnabled()\n                });\n                state.SetReady(true);\n                state.GetMapData().SetData(hcells, vcells, cellData);\n                state.SetRegenerateFlag(false)\n            }\n            UpdateRegion(mapKey, cx1, cy1, lenx, leny, cellData) {\n                this._runtime.BroadcastJob("PFUpdateRegion", {\n                    "mapKey": mapKey,\n                    "cx1": cx1,\n                    "cy1": cy1,\n                    "lenx": lenx,\n                    "leny": leny,\n                    "cellData": cellData\n                });\n                this.GetPathfinderState(mapKey).GetMapData().UpdateRegion(cx1, cy1, lenx, leny, cellData)\n            }\n            FindPath(mapKey, cellX, cellY, destCellX, destCellY) {\n                return this._runtime.AddJob("PFFindPath", {\n                    "mapKey": mapKey,\n                    "cellX": cellX,\n                    "cellY": cellY,\n                    "destCellX": destCellX,\n                    "destCellY": destCellY\n                })\n            }\n            SetDiagonalsEnabled(mapKey, diagonalsEnabled) {\n                diagonalsEnabled = !!diagonalsEnabled;\n                const state = this.GetPathfinderState(mapKey);\n                if (state.IsDiagonalsEnabled() === diagonalsEnabled)\n                    return;\n                state.SetDiagonalsEnabled(diagonalsEnabled);\n                this._runtime.BroadcastJob("PFSetDiagonals", {\n                    "mapKey": mapKey,\n                    "diagonals": diagonalsEnabled\n                })\n            }\n            _OnBeforeLayoutChange() {\n                for (const state of this._mapState.values()) {\n                    state.SetReady(false);\n                    state.GetMapData().SetData(0, 0, null);\n                    state.SetRegenerateFlag(true)\n                }\n                this._runtime.BroadcastJob("PFResetAllCellData")\n            }\n        }\n        ;\n        const map = new WeakMap;\n        self.IPathfindingMap = class IPathfindingMap {\n            constructor(state) {\n                map.set(this, state)\n            }\n            isCellObstacle(x, y) {\n                C3X.RequireFiniteNumber(x);\n                C3X.RequireFiniteNumber(y);\n                return map.get(this).GetMapData().At(x, y) === PF_OBSTACLE\n            }\n            set isDiagonalsEnabled(e) {\n                e = !!e;\n                const state = map.get(this);\n                state.GetBehavior().SetDiagonalsEnabled(state.GetMapKey(), e)\n            }\n            get isDiagonalsEnabled() {\n                return map.get(this).IsDiagonalsEnabled()\n            }\n            async regenerateMap() {\n                const state = map.get(this);\n                state.SetRegenerateFlag(true);\n                await state.GetRegeneratePromise()\n            }\n            async regenerateRegion(startX, startY, endX, endY) {\n                const state = map.get(this);\n                if (state.AddRegenerateRegion(startX, startY, endX, endY))\n                    await state.GetRegeneratePromise()\n            }\n            async regenerateObjectRegion(iObjectClass) {\n                const state = map.get(this);\n                const objectClass = state.GetRuntime()._UnwrapIObjectClass(iObjectClass);\n                if (state.AddObjectRegenerateRegion(objectClass))\n                    await state.GetRegeneratePromise()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Pathfinding.Type = class PathfindingType extends C3.SDKBehaviorTypeBase {\n            constructor(behaviorType) {\n                super(behaviorType);\n                this._obstacleTypes = [];\n                this._costTypes = []\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n            GetObstacleTypes() {\n                return this._obstacleTypes\n            }\n            GetCostTypes() {\n                return this._costTypes\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const C3X = self.C3X;\n        const IBehaviorInstance = self.IBehaviorInstance;\n        const CELL_SIZE = 0;\n        const CELL_BORDER = 1;\n        const OBSTACLES = 2;\n        const MAX_SPEED = 3;\n        const ACCELERATION = 4;\n        const DEACCELERATION = 5;\n        const ROTATE_SPEED = 6;\n        const ROTATE_ENABLE = 7;\n        const DIAGONALS_ENABLE = 8;\n        const ENABLE = 9;\n        const PF_CLEAR = 0;\n        const PF_OBSTACLE = Math.pow(2, 26) - 1;\n        const tempRect = new C3.Rect;\n        const candidates = [];\n        C3.Behaviors.Pathfinding.Instance = class PathfindingInstance extends C3.SDKBehaviorInstanceBase {\n            constructor(behInst, properties) {\n                super(behInst);\n                const wi = this.GetWorldInfo();\n                this._cellSize = 30;\n                this._cellBorder = -1;\n                this._obstacles = 0;\n                this._maxSpeed = 200;\n                this._acc = 1E3;\n                this._dec = 2E3;\n                this._av = C3.toRadians(135);\n                this._isRotateEnabled = true;\n                this._isEnabled = true;\n                this._isMoving = false;\n                this._movingFromStopped = false;\n                this._firstTickMovingWhileMoving = false;\n                this._hasPath = false;\n                this._moveNode = 0;\n                this._a = wi.GetAngle();\n                this._lastKnownAngle = wi.GetAngle();\n                this._s = 0;\n                this._rabbitX = 0;\n                this._rabbitY = 0;\n                this._rabbitA = 0;\n                this._myHcells = 0;\n                this._myVcells = 0;\n                this._myPath = [];\n                this._delayFindPath = false;\n                this._delayFindPathResolves = [];\n                this._delayPathX = 0;\n                this._delayPathY = 0;\n                this._isDestroyed = false;\n                this._isCalculating = false;\n                this._calcPathX = 0;\n                this._calcPathY = 0;\n                this._isFirstRun = true;\n                let isDiagonalsEnabled = true;\n                if (properties) {\n                    this._cellSize = properties[CELL_SIZE];\n                    this._cellBorder = properties[CELL_BORDER];\n                    this._obstacles = properties[OBSTACLES];\n                    this._maxSpeed = properties[MAX_SPEED];\n                    this._acc = properties[ACCELERATION];\n                    this._dec = properties[DEACCELERATION];\n                    this._av = C3.toRadians(properties[ROTATE_SPEED]);\n                    this._isRotateEnabled = !!properties[ROTATE_ENABLE];\n                    isDiagonalsEnabled = !!properties[DIAGONALS_ENABLE];\n                    this._isEnabled = !!properties[ENABLE]\n                }\n                const layout = wi.GetLayout();\n                this._myHcells = Math.ceil(layout.GetWidth() \/ this._cellSize);\n                this._myVcells = Math.ceil(layout.GetHeight() \/ this._cellSize);\n                const rt = this._runtime.Dispatcher();\n                this._disposables = new C3.CompositeDisposable(C3.Disposable.From(rt, "afterload", e => this._OnAfterLoad()));\n                if (this._cellSize < 3)\n                    this._cellSize = 3;\n                if (this._isEnabled) {\n                    this._StartTicking();\n                    this._StartTicking2()\n                }\n                this.GetBehavior().SetDiagonalsEnabled(this.GetMapKey(), isDiagonalsEnabled)\n            }\n            Release() {\n                this._isDestroyed = true;\n                super.Release()\n            }\n            GetMapKey() {\n                return this.GetBehavior().GetMapKey(this._cellSize, this._cellBorder)\n            }\n            GetMyState() {\n                return this.GetBehavior().GetPathfinderState(this.GetMapKey())\n            }\n            SaveToJson() {\n                const ret = {\n                    "cs": this._cellSize,\n                    "cb": this._cellBorder,\n                    "ms": this._maxSpeed,\n                    "acc": this._acc,\n                    "dec": this._dec,\n                    "av": this._av,\n                    "re": this._isRotateEnabled,\n                    "de": this.GetMyState().IsDiagonalsEnabled(),\n                    "o": this._obstacles,\n                    "im": this._isMoving,\n                    "mfs": this._movingFromStopped,\n                    "ftmwm": this._firstTickMovingWhileMoving,\n                    "hp": this._hasPath,\n                    "mn": this._moveNode,\n                    "a": this._a,\n                    "lka": this._lastKnownAngle,\n                    "s": this._s,\n                    "rx": this._rabbitX,\n                    "ry": this._rabbitY,\n                    "ra": this._rabbitA,\n                    "hc": this._myHcells,\n                    "vc": this._myVcells,\n                    "p": this._myPath,\n                    "e": this._isEnabled,\n                    "fr": this._isFirstRun,\n                    "obs": this.GetSdkType().GetObstacleTypes().map(t => t.GetSID()),\n                    "costs": this.GetSdkType().GetCostTypes().map(c => ({\n                        "sid": c.objectClass.GetSID(),\n                        "cost": c.cost\n                    }))\n                };\n                if (this._isCalculating) {\n                    ret["dfp"] = true;\n                    ret["dfx"] = this._calcPathX;\n                    ret["dfy"] = this._calcPathY\n                } else {\n                    ret["dfp"] = this._delayFindPath;\n                    ret["dfx"] = this._delayPathX;\n                    ret["dfy"] = this._delayPathY\n                }\n                return ret\n            }\n            LoadFromJson(o) {\n                this._cellSize = o["cs"];\n                this._cellBorder = o["cb"];\n                this._maxSpeed = o["ms"];\n                this._acc = o["acc"];\n                this._dec = o["dec"];\n                this._av = o["av"];\n                this._isRotateEnabled = o["re"];\n                let isDiagonalsEnabled = o["de"];\n                this._obstacles = o["o"];\n                this._isMoving = o["im"];\n                this._movingFromStopped = o["mfs"];\n                this._firstTickMovingWhileMoving = o["ftmwm"];\n                this._hasPath = o["hp"];\n                this._moveNode = o["mn"];\n                this._a = o["a"];\n                this._lastKnownAngle = o["lka"];\n                this._s = o["s"];\n                this._rabbitX = o["rx"];\n                this._rabbitY = o["ry"];\n                this._rabbitA = o["ra"];\n                this._myHcells = o["hc"];\n                this._myVcells = o["vc"];\n                this._myPath = o["p"];\n                this._SetEnabled(o["e"]);\n                this._isFirstRun = o["fr"];\n                this._delayFindPath = o["dfp"];\n                C3.clearArray(this._delayFindPathResolves);\n                this._delayPathX = o["dfx"];\n                this._delayPathY = o["dfy"];\n                const obstacleTypes = this.GetSdkType().GetObstacleTypes();\n                C3.clearArray(obstacleTypes);\n                for (const sid of o["obs"]) {\n                    const objectClass = this._runtime.GetObjectClassBySID(sid);\n                    if (objectClass)\n                        obstacleTypes.push(objectClass)\n                }\n                const costTypes = this.GetSdkType().GetCostTypes();\n                C3.clearArray(costTypes);\n                for (const c of costTypes) {\n                    const objectClass = this._runtime.GetObjectClassBySID(c["sid"]);\n                    if (objectClass)\n                        costTypes.push({\n                            objectClass,\n                            cost: c["cost"]\n                        })\n                }\n                if (this._cellSize < 3)\n                    this._cellSize = 3;\n                this.GetBehavior().SetDiagonalsEnabled(this.GetMapKey(), isDiagonalsEnabled)\n            }\n            _OnAfterLoad() {\n                this.GetMyState().SetRegenerateFlag(true)\n            }\n            Tick() {\n                if (!this._isEnabled || !this._isMoving)\n                    return;\n                const dt = this._runtime.GetDt(this._inst);\n                const wi = this._inst.GetWorldInfo();\n                if (this._isRotateEnabled && wi.GetAngle() !== this._lastKnownAngle)\n                    this._a = wi.GetAngle();\n                const myPath = this._myPath;\n                const rabbitAheadDist = Math.min(this._maxSpeed * .4, Math.abs(wi.GetWidth()) * 2);\n                const rabbitSpeed = Math.max(this._s * 1.5, 30);\n                let nextX = 0;\n                let nextY = 0;\n                if (this._moveNode < myPath.length) {\n                    nextX = myPath[this._moveNode].x;\n                    nextY = myPath[this._moveNode].y;\n                    const dist = C3.distanceTo(this._rabbitX, this._rabbitY, nextX, nextY);\n                    if (dist < 3 * rabbitSpeed * dt) {\n                        this._moveNode++;\n                        this._rabbitX = nextX;\n                        this._rabbitY = nextY;\n                        if (this._moveNode < myPath.length) {\n                            nextX = myPath[this._moveNode].x;\n                            nextY = myPath[this._moveNode].y\n                        }\n                    }\n                } else {\n                    nextX = myPath.at(-1).x;\n                    nextY = myPath.at(-1).y\n                }\n                this._rabbitA = C3.angleTo(this._rabbitX, this._rabbitY, nextX, nextY);\n                const distToRabbit = C3.distanceTo(wi.GetX(), wi.GetY(), this._rabbitX, this._rabbitY);\n                if (distToRabbit < rabbitAheadDist && this._moveNode < myPath.length) {\n                    let moveDist = 0;\n                    if (this._firstTickMovingWhileMoving) {\n                        moveDist = rabbitAheadDist;\n                        this._firstTickMovingWhileMoving = false\n                    } else\n                        moveDist = rabbitSpeed * dt;\n                    this._rabbitX += Math.cos(this._rabbitA) * moveDist;\n                    this._rabbitY += Math.sin(this._rabbitA) * moveDist\n                }\n                const targetAngle = C3.angleTo(wi.GetX(), wi.GetY(), this._rabbitX, this._rabbitY);\n                const da = C3.angleDiff(this._a, targetAngle);\n                const distToFinish = C3.distanceTo(wi.GetX(), wi.GetY(), myPath.at(-1).x, myPath.at(-1).y);\n                const decelDist = this._maxSpeed * this._maxSpeed \/ (2 * this._dec);\n                if (distToRabbit > 1) {\n                    this._a = C3.angleRotate(this._a, targetAngle, this._av * dt);\n                    let curMaxSpeed = 0;\n                    if (C3.toDegrees(da) <= .5)\n                        curMaxSpeed = this._maxSpeed;\n                    else if (C3.toDegrees(da) >= 120 || this._movingFromStopped && this._moveNode === 0)\n                        this._movingFromStopped = true;\n                    else {\n                        const t = da \/ this._av;\n                        const dist = C3.distanceTo(wi.GetX(), wi.GetY(), this._rabbitX, this._rabbitY);\n                        const r = dist \/ (2 * Math.sin(da));\n                        const curveDist = r * da;\n                        curMaxSpeed = C3.clamp(curveDist \/ t, 0, this._maxSpeed)\n                    }\n                    if (distToFinish < decelDist)\n                        curMaxSpeed = Math.min(curMaxSpeed, distToFinish \/ decelDist * this._maxSpeed + this._maxSpeed \/ 40);\n                    this._s += this._acc * dt;\n                    if (this._s > curMaxSpeed)\n                        this._s = curMaxSpeed\n                }\n                wi.OffsetXY(Math.cos(this._a) * this._s * dt, Math.sin(this._a) * this._s * dt);\n                if (this._isRotateEnabled) {\n                    wi.SetAngle(this._a);\n                    this._lastKnownAngle = wi.GetAngle()\n                }\n                wi.SetBboxChanged();\n                if (this._moveNode === myPath.length && C3.distanceTo(wi.GetX(), wi.GetY(), nextX, nextY) < Math.max(3 * this._s * dt, 10)) {\n                    this._isMoving = false;\n                    this._hasPath = false;\n                    this._moveNode = 0;\n                    this._s = 0;\n                    this.DispatchScriptEvent("arrived");\n                    return this.DebugTrigger(C3.Behaviors.Pathfinding.Cnds.OnArrived)\n                }\n            }\n            Tick2() {\n                if (!this._isEnabled)\n                    return;\n                this._MaybeGenerateMap();\n                this._DoDelayFindPath()\n            }\n            _MaybeGenerateMap() {\n                const state = this.GetMyState();\n                const regenerateRegions = state.GetRegenerateRegions();\n                if (state.IsReady() && !state.IsRegenerateFlagSet() && !regenerateRegions.length)\n                    return;\n                if (!state.IsReady() || state.IsRegenerateFlagSet())\n                    this._GenerateFullMap();\n                else if (regenerateRegions.length)\n                    this._RegenerateRegions(regenerateRegions);\n                C3.clearArray(regenerateRegions);\n                state._ResolveRegeneratePromise()\n            }\n            _GenerateFullMap() {\n                const layout = this.GetWorldInfo().GetLayout();\n                this._myHcells = Math.ceil(layout.GetWidth() \/ this._cellSize);\n                this._myVcells = Math.ceil(layout.GetHeight() \/ this._cellSize);\n                const cellData = C3.MakeFilledArray(this._myHcells, () => new Int32Array(this._myVcells));\n                const leny = this._myVcells;\n                for (let x = 0, lenx = this._myHcells; x < lenx; ++x)\n                    for (let y = 0; y < leny; ++y)\n                        cellData[x][y] = this._QueryCellCollision(x, y);\n                this.GetBehavior().UpdateCellData(this.GetMapKey(), this._myHcells, this._myVcells, cellData)\n            }\n            _RegenerateRegions(regions) {\n                for (const [cx1,cy1,cx2,cy2] of regions)\n                    this._RegenerateRegion(cx1, cy1, cx2, cy2)\n            }\n            _RegenerateRegion(cx1, cy1, cx2, cy2) {\n                const lenx = cx2 - cx1;\n                const leny = cy2 - cy1;\n                const cellData = C3.MakeFilledArray(lenx, () => new Int32Array(leny));\n                for (let x = 0; x < lenx; ++x)\n                    for (let y = 0; y < leny; ++y)\n                        cellData[x][y] = this._QueryCellCollision(cx1 + x, cy1 + y);\n                this.GetBehavior().UpdateRegion(this.GetMapKey(), cx1, cy1, lenx, leny, cellData)\n            }\n            _QueryCellCollision(x, y) {\n                const wi = this.GetWorldInfo();\n                const layer = wi.GetLayer();\n                const cellSize = this._cellSize;\n                const cellBorder = this._cellBorder;\n                const collisionEngine = this._runtime.GetCollisionEngine();\n                tempRect.set(x * cellSize - cellBorder, y * cellSize - cellBorder, (x + 1) * cellSize + cellBorder, (y + 1) * cellSize + cellBorder);\n                if (this._obstacles === 0) {\n                    if (collisionEngine.TestRectOverlapSolid(tempRect))\n                        return PF_OBSTACLE\n                } else {\n                    collisionEngine.GetObjectClassesCollisionCandidates(layer, this._sdkType.GetObstacleTypes(), tempRect, candidates);\n                    for (let i = 0, len = candidates.length; i < len; ++i)\n                        if (collisionEngine.TestRectOverlap(tempRect, candidates[i])) {\n                            C3.clearArray(candidates);\n                            return PF_OBSTACLE\n                        }\n                    C3.clearArray(candidates)\n                }\n                let ret = 0;\n                const costTypes = this._sdkType.GetCostTypes();\n                for (const {objectClass, cost} of costTypes) {\n                    collisionEngine.GetCollisionCandidates(layer, objectClass, tempRect, candidates);\n                    if (candidates.length > 0) {\n                        const seenCandidates = new Set;\n                        for (let i = 0, len = candidates.length; i < len; ++i) {\n                            const candidate = candidates[i];\n                            if (seenCandidates.has(candidate))\n                                continue;\n                            if (collisionEngine.TestRectOverlap(tempRect, candidate)) {\n                                ret += cost;\n                                seenCandidates.add(candidate)\n                            }\n                        }\n                    }\n                    C3.clearArray(candidates)\n                }\n                return Math.min(ret, PF_OBSTACLE)\n            }\n            async _DoDelayFindPath() {\n                if (this._delayFindPath && !this._isDestroyed) {\n                    this._delayFindPath = false;\n                    const resolves = this._delayFindPathResolves;\n                    this._delayFindPathResolves = [];\n                    const wi = this.GetWorldInfo();\n                    await this._DoFindPath(wi.GetX(), wi.GetY(), this._delayPathX, this._delayPathY);\n                    for (const resolve of resolves)\n                        resolve()\n                }\n            }\n            _FindNearestNonObstacleCell(mapData, cellX, cellY) {\n                let bestDist = Infinity;\n                let bestX = 0;\n                let bestY = 0;\n                for (let x = 0, lenx = this._myHcells; x < lenx; ++x)\n                    for (let y = 0, leny = this._myVcells; y < leny; ++y)\n                        if (mapData.At(x, y) !== PF_OBSTACLE) {\n                            const dx = cellX - x;\n                            const dy = cellY - y;\n                            const curDist = dx * dx + dy * dy;\n                            if (curDist < bestDist) {\n                                bestDist = curDist;\n                                bestX = x;\n                                bestY = y\n                            }\n                        }\n                return [bestX, bestY]\n            }\n            async _DoFindPath(startX, startY, endX, endY) {\n                const state = this.GetMyState();\n                if (!state.IsReady())\n                    return false;\n                const mapData = state.GetMapData();\n                this._isCalculating = true;\n                this._calcPathX = endX;\n                this._calcPathY = endY;\n                const cellSize = this._cellSize;\n                const cellX = Math.floor(startX \/ cellSize);\n                const cellY = Math.floor(startY \/ cellSize);\n                let destCellX = Math.floor(endX \/ cellSize);\n                let destCellY = Math.floor(endY \/ cellSize);\n                if (mapData.At(destCellX, destCellY) === PF_OBSTACLE)\n                    [destCellX,destCellY] = this._FindNearestNonObstacleCell(mapData, destCellX, destCellY);\n                const path = await this.GetBehavior().FindPath(this.GetMapKey(), cellX, cellY, destCellX, destCellY);\n                if (this._isDestroyed)\n                    return;\n                this._isCalculating = false;\n                this._moveNode = 0;\n                if (path === null) {\n                    C3.clearArray(this._myPath);\n                    this._hasPath = false;\n                    this._isMoving = false;\n                    await this.TriggerAsync(C3.Behaviors.Pathfinding.Cnds.OnFailedToFindPath)\n                } else {\n                    const cellSize = this._cellSize;\n                    this._myPath = path.map(n => ({\n                        x: (n.x + .5) * cellSize,\n                        y: (n.y + .5) * cellSize\n                    }));\n                    this._hasPath = this._myPath.length > 0;\n                    await this.TriggerAsync(C3.Behaviors.Pathfinding.Cnds.OnPathFound)\n                }\n                this._DoDelayFindPath()\n            }\n            _GetPath() {\n                return this._myPath\n            }\n            GetPropertyValueByIndex(index) {\n                switch (index) {\n                case MAX_SPEED:\n                    return this._GetMaxSpeed();\n                case ACCELERATION:\n                    return this._GetAcceleration();\n                case DEACCELERATION:\n                    return this._GetDeceleration();\n                case ROTATE_SPEED:\n                    return C3.toDegrees(this._GetRotateSpeed());\n                case ROTATE_ENABLE:\n                    return this._isRotateEnabled;\n                case DIAGONALS_ENABLE:\n                    return this.GetMyState().IsDiagonalsEnabled();\n                case ENABLE:\n                    return this._IsEnabled()\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                switch (index) {\n                case MAX_SPEED:\n                    this._SetMaxSpeed(value);\n                    break;\n                case ACCELERATION:\n                    this._SetAcceleration(value);\n                    break;\n                case DEACCELERATION:\n                    this._SetDeceleration(value);\n                    break;\n                case ROTATE_SPEED:\n                    this._SetRotateSpeed(C3.toRadians(value));\n                    break;\n                case ROTATE_ENABLE:\n                    this._isRotateEnabled = !!value;\n                    break;\n                case DIAGONALS_ENABLE:\n                    this.GetBehavior().SetDiagonalsEnabled(this.GetMapKey(), !!value);\n                    break;\n                case ENABLE:\n                    this._SetEnabled(value);\n                    break\n                }\n            }\n            async _FindPath(x, y) {\n                if (!this._isEnabled)\n                    return;\n                const state = this.GetMyState();\n                if (this._isCalculating || !state.IsReady())\n                    await new Promise(resolve => {\n                        this._delayFindPath = true;\n                        this._delayFindPathResolves.push(resolve);\n                        this._delayPathX = x;\n                        this._delayPathY = y\n                    }\n                    );\n                else {\n                    const wi = this.GetWorldInfo();\n                    await this._DoFindPath(wi.GetX(), wi.GetY(), x, y)\n                }\n            }\n            _StartMoving() {\n                if (!this._hasPath)\n                    return;\n                if (this._isMoving)\n                    this._firstTickMovingWhileMoving = true;\n                this._movingFromStopped = !this._isMoving;\n                this._isMoving = true;\n                const wi = this.GetWorldInfo();\n                this._rabbitX = wi.GetX();\n                this._rabbitY = wi.GetY();\n                this._rabbitA = wi.GetAngle()\n            }\n            _Stop() {\n                this._isMoving = false\n            }\n            _SetMaxSpeed(s) {\n                this._maxSpeed = s\n            }\n            _GetMaxSpeed() {\n                return this._maxSpeed\n            }\n            _SetSpeed(s) {\n                this._s = C3.clamp(s, 0, this._maxSpeed)\n            }\n            _GetSpeed() {\n                return this._IsMoving() ? this._s : 0\n            }\n            _SetAcceleration(a) {\n                this._acc = a\n            }\n            _GetAcceleration() {\n                return this._acc\n            }\n            _SetDeceleration(d) {\n                this._dec = d\n            }\n            _GetDeceleration() {\n                return this._dec\n            }\n            _SetRotateSpeed(r) {\n                this._av = r\n            }\n            _GetRotateSpeed() {\n                return this._av\n            }\n            _IsCalculatingPath() {\n                return this._isCalculating\n            }\n            _IsMoving() {\n                return this._isMoving\n            }\n            _HasPath() {\n                return this._hasPath\n            }\n            _GetMovingAngle() {\n                return this._a\n            }\n            _GetNodeCount() {\n                return this._myPath.length\n            }\n            _GetCurrentNode() {\n                return this._moveNode\n            }\n            _GetNodeAt(i) {\n                i = Math.floor(i);\n                if (i < 0 || i >= this._myPath.length)\n                    return null;\n                else\n                    return this._myPath[i]\n            }\n            _GetNodeXAt(i) {\n                const n = this._GetNodeAt(i);\n                return n ? n.x : 0\n            }\n            _GetNodeYAt(i) {\n                const n = this._GetNodeAt(i);\n                return n ? n.y : 0\n            }\n            _SetEnabled(e) {\n                this._isEnabled = !!e;\n                if (this._isEnabled) {\n                    this._StartTicking();\n                    this._StartTicking2()\n                } else {\n                    this._StopTicking();\n                    this._StopTicking2()\n                }\n            }\n            _IsEnabled() {\n                return this._isEnabled\n            }\n            GetDebuggerProperties() {\n                const prefix = "behaviors.pathfinding";\n                return [{\n                    title: "$" + this.GetBehaviorType().GetName(),\n                    properties: [{\n                        name: prefix + ".debugger.has-path",\n                        value: this._hasPath\n                    }, {\n                        name: prefix + ".debugger.is-calculating-path",\n                        value: this._IsCalculatingPath()\n                    }, {\n                        name: prefix + ".debugger.is-moving",\n                        value: this._IsMoving()\n                    }, {\n                        name: prefix + ".debugger.speed",\n                        value: this._GetSpeed(),\n                        onedit: v => this._SetSpeed(v)\n                    }, {\n                        name: prefix + ".debugger.angle-of-motion",\n                        value: C3.toDegrees(this._a),\n                        onedit: v => this._a = C3.toRadians(v)\n                    }, {\n                        name: prefix + ".properties.max-speed.name",\n                        value: this._GetMaxSpeed(),\n                        onedit: v => this._SetMaxSpeed(v)\n                    }, {\n                        name: prefix + ".properties.acceleration.name",\n                        value: this._GetAcceleration(),\n                        onedit: v => this._SetAcceleration(v)\n                    }, {\n                        name: prefix + ".properties.deceleration.name",\n                        value: this._GetDeceleration(),\n                        onedit: v => this._SetDeceleration(v)\n                    }, {\n                        name: prefix + ".properties.rotate-speed.name",\n                        value: C3.toDegrees(this._GetRotateSpeed()),\n                        onedit: v => this._SetRotateSpeed(C3.toRadians(v))\n                    }, {\n                        name: prefix + ".properties.enabled.name",\n                        value: this._IsEnabled(),\n                        onedit: v => this._SetEnabled(v)\n                    }]\n                }]\n            }\n            GetScriptInterfaceClass() {\n                return self.IPathfindingBehaviorInstance\n            }\n        }\n        ;\n        const map = new WeakMap;\n        self.IPathfindingBehaviorInstance = class IPathfindingBehaviorInstance extends IBehaviorInstance {\n            constructor() {\n                super();\n                const sdkInst = IBehaviorInstance._GetInitInst().GetSdkInstance();\n                map.set(this, sdkInst);\n                Object.defineProperties(this, {\n                    map: {\n                        value: sdkInst.GetMyState().GetScriptInterface(),\n                        writable: false\n                    }\n                })\n            }\n            async findPath(x, y) {\n                C3X.RequireFiniteNumber(x);\n                C3X.RequireFiniteNumber(y);\n                const inst = map.get(this);\n                await inst._FindPath(x, y);\n                return inst._HasPath()\n            }\n            startMoving() {\n                map.get(this)._StartMoving()\n            }\n            stop() {\n                map.get(this)._Stop()\n            }\n            set maxSpeed(s) {\n                C3X.RequireFiniteNumber(s);\n                map.get(this)._SetMaxSpeed(s)\n            }\n            get maxSpeed() {\n                return map.get(this)._GetMaxSpeed()\n            }\n            set speed(s) {\n                C3X.RequireFiniteNumber(s);\n                map.get(this)._SetSpeed(s)\n            }\n            get speed() {\n                return map.get(this)._GetSpeed()\n            }\n            set acceleration(a) {\n                C3X.RequireFiniteNumber(a);\n                map.get(this)._SetAcceleration(a)\n            }\n            get acceleration() {\n                return map.get(this)._GetAcceleration()\n            }\n            set deceleration(d) {\n                C3X.RequireFiniteNumber(d);\n                map.get(this)._SetDeceleration(d)\n            }\n            get deceleration() {\n                return map.get(this)._GetAcceleration()\n            }\n            set rotateSpeed(r) {\n                C3X.RequireFiniteNumber(r);\n                map.get(this)._SetRotateSpeed(r)\n            }\n            get rotateSpeed() {\n                return map.get(this)._GetRotateSpeed()\n            }\n            get isCalculatingPath() {\n                return map.get(this)._IsCalculatingPath()\n            }\n            get isMoving() {\n                return map.get(this)._IsMoving()\n            }\n            get currentNode() {\n                return map.get(this)._GetCurrentNode()\n            }\n            getNodeCount() {\n                return map.get(this)._GetNodeCount()\n            }\n            getNodeXAt(i) {\n                C3X.RequireFiniteNumber(i);\n                return map.get(this)._GetNodeXAt(i)\n            }\n            getNodeYAt(i) {\n                C3X.RequireFiniteNumber(i);\n                return map.get(this)._GetNodeYAt(i)\n            }\n            getNodeAt(i) {\n                C3X.RequireFiniteNumber(i);\n                const n = map.get(this)._GetNodeAt(i);\n                return n ? [n.x, n.y] : [0, 0]\n            }\n            set isEnabled(e) {\n                map.get(this)._SetEnabled(!!e)\n            }\n            get isEnabled() {\n                return map.get(this)._IsEnabled()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        const PF_OBSTACLE = Math.pow(2, 26) - 1;\n        C3.Behaviors.Pathfinding.Cnds = {\n            OnPathFound() {\n                return true\n            },\n            OnFailedToFindPath() {\n                return true\n            },\n            IsCellObstacle(x, y) {\n                return this.GetMyState().GetMapData().At(x, y) === PF_OBSTACLE\n            },\n            IsCalculatingPath() {\n                return this._IsCalculatingPath()\n            },\n            IsMoving() {\n                return this._IsMoving()\n            },\n            OnArrived() {\n                return true\n            },\n            CompareSpeed(cmp, x) {\n                return C3.compare(this._IsMoving() ? this._GetSpeed() : 0, cmp, x)\n            },\n            DiagonalsEnabled() {\n                return this.GetMyState().IsDiagonalsEnabled()\n            },\n            IsEnabled() {\n                return this._IsEnabled()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Pathfinding.Acts = {\n            FindPath(x, y) {\n                return this._FindPath(x, y)\n            },\n            StartMoving() {\n                this._StartMoving()\n            },\n            Stop() {\n                this._Stop()\n            },\n            SetEnabled(e) {\n                this._SetEnabled(e !== 0)\n            },\n            AddObstacle(objectClass) {\n                const obstacleTypes = this.GetSdkType().GetObstacleTypes();\n                if (obstacleTypes.includes(objectClass))\n                    return;\n                for (const t of obstacleTypes)\n                    if (t.IsFamily() && t.FamilyHasMember(objectClass))\n                        return;\n                obstacleTypes.push(objectClass)\n            },\n            ClearObstacles() {\n                C3.clearArray(this._sdkType.GetObstacleTypes())\n            },\n            AddCost(objectClass, cost) {\n                const costTypes = this.GetSdkType().GetCostTypes();\n                for (const o of costTypes) {\n                    const t = o.objectClass;\n                    if (t === objectClass)\n                        return;\n                    if (t.IsFamily() && t.FamilyHasMember(objectClass))\n                        return\n                }\n                costTypes.push({\n                    objectClass,\n                    cost\n                })\n            },\n            ClearCost() {\n                C3.clearArray(this._sdkType.GetCostTypes())\n            },\n            SetMaxSpeed(s) {\n                this._SetMaxSpeed(s)\n            },\n            SetSpeed(s) {\n                this._SetSpeed(s)\n            },\n            SetAcc(a) {\n                this._SetAcceleration(a)\n            },\n            SetDec(d) {\n                this._SetDeceleration(d)\n            },\n            SetRotateSpeed(r) {\n                this._SetRotateSpeed(C3.toRadians(r))\n            },\n            SetDiagonalsEnabled(e) {\n                this.GetBehavior().SetDiagonalsEnabled(this.GetMapKey(), e !== 0)\n            },\n            async RegenerateMap() {\n                const state = this.GetMyState();\n                state.SetRegenerateFlag(true);\n                await state.GetRegeneratePromise()\n            },\n            async RegenerateRegion(startX, startY, endX, endY) {\n                const state = this.GetMyState();\n                if (state.AddRegenerateRegion(startX, startY, endX, endY))\n                    await state.GetRegeneratePromise()\n            },\n            async RegenerateObjectRegion(objectClass) {\n                if (!objectClass)\n                    return;\n                const state = this.GetMyState();\n                if (state.AddObjectRegenerateRegion(objectClass))\n                    await state.GetRegeneratePromise()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Pathfinding.Exps = {\n            NodeCount() {\n                return this._GetNodeCount()\n            },\n            NodeXAt(i) {\n                return this._GetNodeXAt(i)\n            },\n            NodeYAt(i) {\n                return this._GetNodeYAt(i)\n            },\n            CellSize() {\n                return this._cellSize\n            },\n            RabbitX() {\n                return this._rabbitX\n            },\n            RabbitY() {\n                return this._rabbitY\n            },\n            MaxSpeed() {\n                return this._GetMaxSpeed()\n            },\n            Acceleration() {\n                return this._GetAcceleration()\n            },\n            Deceleration() {\n                return this._GetDeceleration()\n            },\n            RotateSpeed() {\n                return C3.toDegrees(this._GetRotateSpeed())\n            },\n            MovingAngle() {\n                return C3.toDegrees(this._GetMovingAngle())\n            },\n            CurrentNode() {\n                return this._GetCurrentNode()\n            },\n            Speed() {\n                return this._GetSpeed()\n            }\n        }\n    }\n    ;\n\n}\n\n{\n    "use strict";\n\n    {\n        const C3 = self.C3;\n\n        C3.Behaviors.CV_BoundedDragnDrop = class BoundedDragnDrop_Behavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                super(opts);\n                const b = this._runtime.Dispatcher();\n                this._disposables = new C3.CompositeDisposable(C3.Disposable.From(b, "pointerdown", (a) => this._OnPointerDown(a.data)),C3.Disposable.From(b, "pointermove", (a) => this._OnPointerMove(a.data)),C3.Disposable.From(b, "pointerup", (a) => this._OnPointerUp(a.data, !1)),C3.Disposable.From(b, "pointercancel", (a) => this._OnPointerUp(a.data, !0)))\n            }\n\n            Release() {\n                this._disposables.Release(),\n                this._disposables = null,\n                super.Release();\n            }\n\n            \/\/-- Custom Class Functions :: Start\n\n            _OnPointerDown(a) {\n                this._OnInputDown(a["pointerId"].toString(), a["clientX"] - this._runtime.GetCanvasClientX(), a["clientY"] - this._runtime.GetCanvasClientY())\n            }\n            _OnPointerMove(a) {\n                this._OnInputMove(a["pointerId"].toString(), a["clientX"] - this._runtime.GetCanvasClientX(), a["clientY"] - this._runtime.GetCanvasClientY())\n            }\n            _OnPointerUp(a) {\n                this._OnInputUp(a["pointerId"].toString())\n            }\n            async _OnInputDown(a, b, c) {\n                const d = this.GetInstances();\n                let e = null\n                  , f = null\n                  , g = 0\n                  , h = 0;\n                for (const i of d) {\n                    const a = i.GetBehaviorSdkInstanceFromCtor(C3.Behaviors.CV_BoundedDragnDrop);\n                    if (!a.IsEnabled() || a.IsDragging())\n                        continue;\n                    const d = i.GetWorldInfo()\n                      , j = d.GetLayer()\n                      , [k,l] = j.CanvasCssToLayer(b, c, d.GetTotalZElevation());\n                    if (!d.ContainsPoint(k, l))\n                        continue;\n                    if (!e) {\n                        e = i,\n                        f = a,\n                        g = k,\n                        h = l;\n                        continue\n                    }\n                    const m = e.GetWorldInfo();\n                    (j.GetIndex() > m.GetLayer().GetIndex() || j.GetIndex() === m.GetLayer().GetIndex() && d.GetZIndex() > m.GetZIndex()) && (e = i,\n                    f = a,\n                    g = k,\n                    h = l)\n                }\n                e && (await f._OnDown(a, g, h))\n            }\n            _OnInputMove(a, b, c) {\n                const d = this.GetInstances();\n                for (const e of d) {\n                    const d = e.GetBehaviorSdkInstanceFromCtor(C3.Behaviors.CV_BoundedDragnDrop);\n                    if (!d.IsEnabled() || !d.IsDragging() || d.IsDragging() && d.GetDragSource() !== a)\n                        continue;\n                    const f = e.GetWorldInfo()\n                      , g = f.GetLayer()\n                      , [h,i] = g.CanvasCssToLayer(b, c, f.GetTotalZElevation());\n                    d._OnMove(h, i)\n                }\n            }\n            async _OnInputUp(a) {\n                const b = this.GetInstances();\n                for (const c of b) {\n                    const b = c.GetBehaviorSdkInstanceFromCtor(C3.Behaviors.CV_BoundedDragnDrop);\n                    b.IsDragging() && b.GetDragSource() === a && (await b._OnUp())\n                }\n            }\n\n            \/\/-- Custom Class Functions :: End\n\n        }\n        ;\n    }\n}\n\n{\n    "use strict";\n\n    {\n        const C3 = self.C3;\n\n        C3.Behaviors.CV_BoundedDragnDrop.Type = class BoundedDragnDrop_Type extends C3.SDKBehaviorTypeBase {\n            constructor(behaviorType) {\n                super(behaviorType);\n            }\n\n            Release() {\n                super.Release();\n            }\n\n            OnCreate() {}\n        }\n        ;\n    }\n}\n\n{\n    "use strict";\n\n    {\n        const C3 = self.C3;\n\n        C3.Behaviors.CV_BoundedDragnDrop.Instance = class BoundedDragnDrop_Instance extends C3.SDKBehaviorInstanceBase {\n            constructor(behInst, properties) {\n                super(behInst);\n\n                const WI = this._inst.GetWorldInfo();\n\n                if (properties) {\n                    this.axes = properties[0];\n                    this.enabled = properties[1];\n\n                    this.dragging = false;\n                    this.dx = 0;\n                    this.dy = 0;\n                    this.dragsource = "<none>";\n\n                    \/\/ 0 = both, 1 = horizontal, 2 = vertical\n                    this.axes = properties[0];\n                    this.enabled = (properties[1] !== 0);\n\n                    \/\/ Start\n                    \/\/user-defined\n                    this.boundTo = properties[2];\n                    this.boundBy = properties[3];\n                    this.boundMethod = properties[4];\n                    this.boundXRadius = properties[5];\n                    this.boundYRadius = properties[6];\n                    this.boundMinX = properties[7];\n                    this.boundMaxX = properties[8];\n                    this.boundMinY = properties[9];\n                    this.boundMaxY = properties[10];\n                    \/\/background\n                    this.boundEnabled = false;\n                    this.radiusBound = false;\n                    this.posBound = false;\n                    this.posX = WI.GetX();\n                    this.posY = WI.GetY();\n                    \/\/dedicated for expressions\n                    this.radiusExceeded = false;\n                    this.positionExceeded = false;\n\n                    this.getBoundValues = function() {\n\n                        \/\/Off\n                        if (this.boundTo === 0) {\n                            \/\/All (false)\n                            this.boundEnabled = false;\n                            this.radiusBound = false;\n                            this.posBound = false;\n\n                        }\n                        \/\/Both\n                        else if (this.boundTo === 1) {\n\n                            \/\/Enable Bound (true)\n                            this.boundEnabled = true;\n\n                            \/\/Radius (true)\n                            if (this.boundXRadius !== 0 || this.boundYRadius !== 0) {\n                                this.radiusBound = true;\n\n                                \/\/XAxis Adjust\n                                if (this.boundXRadius === 0) {\n                                    if (this.axes === 0 || this.axes === 1) {\n                                        this.axes = 2;\n                                    }\n                                }\n                                \/\/YAxis Adjust\n                                if (this.boundYRadius === 0) {\n                                    if (this.axes === 0 || this.axes === 2) {\n                                        this.axes = 1;\n                                    }\n                                }\n\n                            }\n                            else {\n                                this.radiusBound = false;\n                            }\n\n                            \/\/Position (true)\n                            this.posBound = true;\n\n                        }\n                        else if (this.boundTo === 2) {\n\n                            if (this.boundXRadius !== 0 || this.boundYRadius !== 0)\n                            {\n                                \/\/Enable Bound (true)\n                                this.boundEnabled = true;\n\n                                \/\/Radius (true)\n                                if (this.boundXRadius !== 0 || this.boundYRadius !== 0) {\n\n                                    this.radiusBound = true;\n\n                                    \/\/XAxis Adjust\n                                    if (this.boundXRadius === 0) {\n                                        if (this.axes === 0 || this.axes === 1) {\n                                            this.axes = 2;\n                                        }\n                                    }\n                                    \/\/YAxis Adjust\n                                    if (this.boundYRadius === 0) {\n                                        if (this.axes === 0 || this.axes === 2) {\n                                            this.axes = 1;\n                                        }\n                                    }\n\n                                }\n                                else {\n                                    this.radiusBound = false;\n                                }\n\n                                \/\/Position (false)\n                                this.posBound = false;\n\n                            }\n                        }\n                        else \/\/ (this.boundTo === 3)\n                        {\n                            \/\/Enable Bound (true)\n                            this.boundEnabled = true;\n\n                            \/\/radius (false)\n                            this.radiusBound = false;\n\n                            \/\/position (true)\n                            this.posBound = true;\n                        }\n\n                    }\n\n                    this.getBoundValues();\n\n                }\n\n                this.inst = {\n\n                    get: {\n                        x: WI.GetX(),\n                        y: WI.GetY()\n                    },\n\n                    set: {\n                        x: function(a) {\n                            return WI.SetX(a)\n                        },\n                        y: function(b) {\n                            return WI.SetY(b)\n                        }\n                    },\n\n                    set_bbox_changed: function() {\n                        WI.SetBboxChanged();\n                    },\n\n                    hotspotX: WI.GetOriginX(),\n\n                    hotspotY: WI.GetOriginY(),\n\n                    width: WI.GetWidth(),\n\n                    height: WI.GetHeight()\n\n                }\n            }\n\n            Release() {\n                super.Release();\n            }\n\n            SaveToJson() {\n                return {\n                    "a": this.axes,\n                    "e": this.enabled\n                };\n            }\n\n            LoadFromJson(o) {\n                this.axes = o["a"];\n                this.enabled = o["e"];\n                this.dragging = false;\n            }\n\n            \/\/ -- Construct 3 Runtime -> Instancse Class Functions :: Start\n\n            IsEnabled() {\n                return this.enabled;\n            }\n\n            IsDragging() {\n                return this.dragging;\n            }\n\n            GetDragSource() {\n                return this.dragsource;\n            }\n\n            \/\/ "_ClassFunction"s are Construct 3 Runtime  Custom Class Functions.\n\n            async _OnDown(a, b, c) {\n                const d = this.GetWorldInfo();\n                this.dx = b - d.GetX();\n                this.dy = c - d.GetY();\n                this.dragging = true;\n                this.dragsource = a;\n                this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnDragStart);\n            }\n\n            _OnMove(x, y) {\n                var newx = x - this.dx;\n                var newy = y - this.dy;\n\n                if (this.axes === 0) \/\/ both\n                {\n\n                    \/\/If one or more Bound values aren\'t 0.\n                    if (this.boundEnabled) {\n                        \/\/origin\n                        if (this.boundBy === 0) {\n                            \/\/Radius\n                            this.limitLowX = this.posX - this.boundXRadius;\n                            this.limitHighX = this.posX + this.boundXRadius;\n                            this.limitLowY = this.posY - this.boundYRadius;\n                            this.limitHighY = this.posY + this.boundYRadius;\n                            \/\/Position\n                            this.limitLowPosX = this.boundMinX;\n                            this.limitHighPosX = this.boundMaxX;\n                            this.limitLowPosY = this.boundMinY;\n                            this.limitHighPosY = this.boundMaxY;\n                            \/\/Boolean\n                            var radiusClear = false;\n                            var posClear = false;\n\n                            \/\/Set Clearance\n                            \/\/radiusBound clearance\n                            if (this.radiusBound) {\n                                if (newx < this.limitLowX || newx > this.limitHighX || newy < this.limitLowY || newy > this.limitHighY) {\n                                    radiusClear = false;\n                                    \/\/not necessary (redundant)\n\n                                    \/\/radius Exceeded\n                                    this.radiusExceeded = true;\n\n                                    \/\/OnAnyBoundExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnAnyBoundExceeded);\n\n                                    \/\/OnRadiusExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnRadiusExceeded);\n\n                                }\n                                else {\n\n                                    radiusClear = true;\n\n                                    \/\/radius !Exceeded\n                                    this.radiusExceeded = false;\n                                }\n\n                            }\n                            else {\n                                radiusClear = true;\n\n                                \/\/radius !Exceeded\n                                this.radiusExceeded = false;\n\n                            }\n\n                            \/\/posBound clearance\n                            if (this.posBound) {\n                                if (newx < this.limitLowPosX || newx > this.limitHighPosX || newy < this.limitLowPosY || newy > this.limitHighPosY) {\n                                    posClear = false;\n                                    \/\/not necessary (redundant)\n\n                                    \/\/position Exceeded\n                                    this.positionExceeded = true;\n\n                                    \/\/OnAnyBoundExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnAnyBoundExceeded);\n\n                                    \/\/OnPositionExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnPositionExceeded);\n\n                                }\n                                else {\n\n                                    posClear = true;\n\n                                    \/\/position !Exceeded\n                                    this.positionExceeded = false;\n                                }\n\n                            }\n                            else {\n                                posClear = true;\n\n                                \/\/position !Exceeded\n                                this.positionExceeded = false;\n\n                            }\n\n                            \/\/Set New Position\n                            \/\/BoundMethod = \'Halt\'\n                            if (this.boundMethod === 0) {\n\n                                if (radiusClear && posClear) {\n                                    if (this.inst.get.x !== newx || this.inst.get.y !== newy) {\n                                        this.inst.set.x(newx);\n                                        this.inst.set.y(newy);\n                                        this.inst.set_bbox_changed();\n\n                                    }\n                                }\n\n                            }\/\/BoundMethod = \'Clamp\'\n                            else {\n                                \/\/!RadiusClear\n                                if (!radiusClear) {\n                                    \/\/RadiusX\n                                    if (newx < this.limitLowX) {\n\n                                        newx = this.limitLowX;\n\n                                    }\n\n                                    if (newx > this.limitHighX) {\n\n                                        newx = this.limitHighX;\n\n                                    }\n                                    \/\/RadiusY\n                                    if (newy < this.limitLowY) {\n\n                                        newy = this.limitLowY;\n\n                                    }\n\n                                    if (newy > this.limitHighY) {\n\n                                        newy = this.limitHighY;\n\n                                    }\n\n                                }\n                                \/\/!PosClear\n                                if (!posClear) {\n                                    \/\/PosX\n                                    if (newx < this.limitLowPosX) {\n\n                                        newx = this.limitLowPosX;\n\n                                    }\n\n                                    if (newx > this.limitHighPosX) {\n\n                                        newx = this.limitHighPosX;\n\n                                    }\n                                    \/\/PosY\n                                    if (newy < this.limitLowPosY) {\n\n                                        newy = this.limitLowPosY;\n\n                                    }\n\n                                    if (newy > this.limitHighPosY) {\n\n                                        newy = this.limitHighPosY;\n\n                                    }\n\n                                }\n\n                                \/\/New Position\n\n                                if (this.inst.get.x !== newx || this.inst.get.y !== newy) {\n                                    this.inst.set.x(newx);\n                                    this.inst.set.y(newy);\n                                    this.inst.set_bbox_changed();\n\n                                }\n\n                            }\n                        }\n                        \/\/edge\n                        else\n                        {\n                            \/\/Hotspot\n                            var hotspotX = this.inst.hotspotX;\n                            var hotspotY = this.inst.hotspotY;\n\n                            var hotspotWidthLeft = (hotspotX * this.inst.width);\n                            var hotspotWidthRight = ((1 - hotspotX) * this.inst.width);\n\n                            var hotspotHeightTop = (hotspotY * this.inst.height);\n                            var hotspotHeightBottom = ((1 - hotspotY) * this.inst.height);\n\n                            \/\/Radius\n                            this.limitLowX = (this.posX + hotspotWidthLeft) - this.boundXRadius;\n                            this.limitHighX = (this.posX - hotspotWidthRight) + this.boundXRadius;\n                            this.limitLowY = (this.posY + hotspotHeightTop) - this.boundYRadius;\n                            this.limitHighY = (this.posY - hotspotHeightBottom) + this.boundYRadius;\n                            \/\/Position\n                            this.limitLowPosX = this.boundMinX + hotspotWidthLeft;\n                            this.limitHighPosX = this.boundMaxX - hotspotWidthRight;\n                            this.limitLowPosY = this.boundMinY + hotspotHeightTop;\n                            this.limitHighPosY = this.boundMaxY - hotspotHeightBottom;\n                            \/\/Boolean\n                            var radiusClear = false;\n                            var posClear = false;\n\n                            \/\/Set New Position\n\n                            \/\/Set Clearance\n                            \/\/radiusBound clearance\n                            if (this.radiusBound) {\n                                if (newx < this.limitLowX || newx > this.limitHighX || newy < this.limitLowY || newy > this.limitHighY) {\n                                    radiusClear = false;\n                                    \/\/not necessary (redundant)\n\n                                    \/\/radius Exceeded\n                                    this.radiusExceeded = true;\n\n                                    \/\/OnAnyBoundExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnAnyBoundExceeded);\n\n                                    \/\/OnRadiusExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnRadiusExceeded);\n\n                                }\n                                else {\n\n                                    radiusClear = true;\n\n                                    \/\/radius !Exceeded\n                                    this.radiusExceeded = false;\n\n                                }\n\n                            }\n                            else {\n                                radiusClear = true;\n\n                                \/\/radius !Exceeded\n                                this.radiusExceeded = false;\n\n                            }\n\n                            \/\/posBound clearance\n                            if (this.posBound) {\n                                if (newx < this.limitLowPosX || newx > this.limitHighPosX || newy < this.limitLowPosY || newy > this.limitHighPosY) {\n                                    posClear = false;\n                                    \/\/not necessary (redundant)\n\n                                    \/\/position Exceeded\n                                    this.positionExceeded = true;\n\n                                    \/\/OnAnyBoundExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnAnyBoundExceeded);\n\n                                    \/\/OnPositionExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnPositionExceeded);\n                                }\n                                else {\n\n                                    posClear = true;\n\n                                    \/\/position !Exceeded\n                                    this.positionExceeded = false;\n\n                                }\n\n                            }\n                            else {\n                                posClear = true;\n\n                                \/\/position !Exceeded\n                                this.positionExceeded = false;\n\n                            }\n\n                            \/\/Set New Position\n                            \/\/BoundMethod = \'Halt\'\n                            if (this.boundMethod === 0) {\n\n                                if (radiusClear && posClear) {\n                                    if (this.inst.get.x !== newx || this.inst.get.y !== newy) {\n                                        this.inst.set.x(newx);\n                                        this.inst.set.y(newy);\n                                        this.inst.set_bbox_changed();\n\n                                    }\n                                }\n\n                            }\/\/BoundMethod = \'Clamp\'\n                            else {\n                                \/\/!RadiusClear\n                                if (!radiusClear) {\n                                    \/\/RadiusX\n                                    if (newx < this.limitLowX) {\n\n                                        newx = this.limitLowX;\n\n                                    }\n\n                                    if (newx > this.limitHighX) {\n\n                                        newx = this.limitHighX;\n\n                                    }\n                                    \/\/RadiusY\n                                    if (newy < this.limitLowY) {\n\n                                        newy = this.limitLowY;\n\n                                    }\n\n                                    if (newy > this.limitHighY) {\n\n                                        newy = this.limitHighY;\n\n                                    }\n\n                                }\n                                \/\/!PosClear\n                                if (!posClear) {\n                                    \/\/PosX\n                                    if (newx < this.limitLowPosX) {\n\n                                        newx = this.limitLowPosX;\n\n                                    }\n\n                                    if (newx > this.limitHighPosX) {\n\n                                        newx = this.limitHighPosX;\n\n                                    }\n                                    \/\/PosY\n                                    if (newy < this.limitLowPosY) {\n\n                                        newy = this.limitLowPosY;\n\n                                    }\n\n                                    if (newy > this.limitHighPosY) {\n\n                                        newy = this.limitHighPosY;\n\n                                    }\n\n                                }\n\n                                \/\/New Position\n\n                                if (this.inst.get.x !== newx || this.inst.get.y !== newy) {\n                                    this.inst.set.x(newx);\n                                    this.inst.set.y(newy);\n                                    this.inst.set_bbox_changed();\n\n                                }\n\n                            }\n\n                        }\n\n                    }\/\/If all Bound values are 0.\n                    else {\n\n                        if (this.inst.get.x !== newx || this.inst.get.y !== newy) {\n                            this.inst.set.x(newx);\n                            this.inst.set.y(newy);\n                            this.inst.set_bbox_changed();\n                        }\n\n                    }\n\n                }\n                else if (this.axes === 1) \/\/ horizontal\n                {\n                    \/\/If one or more Bound values aren\'t 0.\n                    if (this.boundEnabled) {\n                        \/\/origin\n                        if (this.boundBy === 0) {\n                            \/\/Radius\n                            this.limitLowX = this.posX - this.boundXRadius;\n                            this.limitHighX = this.posX + this.boundXRadius;\n                            \/\/Position\n                            this.limitLowPosX = this.boundMinX;\n                            this.limitHighPosX = this.boundMaxX;\n                            \/\/Boolean\n                            var radiusClear = false;\n                            var posClear = false;\n\n                            \/\/Set Clearance\n                            \/\/radiusBound clearance\n                            if (this.radiusBound) {\n                                if (newx < this.limitLowX || newx > this.limitHighX) {\n                                    radiusClear = false;\n                                    \/\/not necessary (redundant)\n\n                                    \/\/radius Exceeded\n                                    this.radiusExceeded = true;\n\n                                    \/\/OnAnyBoundExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnAnyBoundExceeded);\n\n                                    \/\/OnRadiusExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnRadiusExceeded);\n\n                                }\n                                else {\n\n                                    radiusClear = true;\n\n                                    \/\/radius !Exceeded\n                                    this.radiusExceeded = false;\n\n                                }\n\n                            }\n                            else {\n                                radiusClear = true;\n\n                                \/\/radius !Exceeded\n                                this.radiusExceeded = false;\n\n                            }\n\n                            \/\/posBound clearance\n                            if (this.posBound) {\n                                if (newx < this.limitLowPosX || newx > this.limitHighPosX) {\n                                    posClear = false;\n                                    \/\/not necessary (redundant)\n\n                                    \/\/position Exceeded\n                                    this.positionExceeded = true;\n\n                                    \/\/OnAnyBoundExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnAnyBoundExceeded);\n\n                                    \/\/OnPositionExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnPositionExceeded);\n\n                                }\n                                else {\n\n                                    posClear = true;\n\n                                    \/\/position !Exceeded\n                                    this.positionExceeded = false;\n\n                                }\n\n                            }\n                            else {\n                                posClear = true;\n\n                                \/\/position !Exceeded\n                                this.positionExceeded = false;\n\n                            }\n\n                            \/\/Set New Position\n                            \/\/BoundMethod = \'Halt\'\n                            if (this.boundMethod === 0) {\n\n                                if (radiusClear && posClear) {\n                                    if (this.inst.get.x !== newx) {\n                                        this.inst.set.x(newx);\n                                        this.inst.set_bbox_changed();\n\n                                    }\n                                }\n\n                            }\/\/BoundMethod = \'Clamp\'\n                            else {\n                                \/\/!RadiusClear\n                                if (!radiusClear) {\n                                    \/\/RadiusX\n                                    if (newx < this.limitLowX) {\n\n                                        newx = this.limitLowX;\n\n                                    }\n\n                                    if (newx > this.limitHighX) {\n\n                                        newx = this.limitHighX;\n\n                                    }\n                                    \/\/RadiusY\n                                    if (newy < this.limitLowY) {\n\n                                        newy = this.limitLowY;\n\n                                    }\n\n                                    if (newy > this.limitHighY) {\n\n                                        newy = this.limitHighY;\n\n                                    }\n\n                                }\n                                \/\/!PosClear\n                                if (!posClear) {\n                                    \/\/PosX\n                                    if (newx < this.limitLowPosX) {\n\n                                        newx = this.limitLowPosX;\n\n                                    }\n\n                                    if (newx > this.limitHighPosX) {\n\n                                        newx = this.limitHighPosX;\n\n                                    }\n                                    \/\/PosY\n                                    if (newy < this.limitLowPosY) {\n\n                                        newy = this.limitLowPosY;\n\n                                    }\n\n                                    if (newy > this.limitHighPosY) {\n\n                                        newy = this.limitHighPosY;\n\n                                    }\n\n                                }\n\n                                \/\/New Position\n\n                                if (this.inst.get.x !== newx) {\n                                    this.inst.set.x(newx);\n                                    this.inst.set_bbox_changed();\n\n                                }\n\n                            }\n\n                        }\n                        \/\/edge\n                        else\n                        {\n\n                            \/\/Hotspot\n                            var hotspotX = this.inst.hotspotX;\n\n                            var hotspotWidthLeft = (hotspotX * this.inst.width);\n                            var hotspotWidthRight = ((1 - hotspotX) * this.inst.width);\n\n                            \/\/Radius\n                            this.limitLowX = (this.posX + hotspotWidthLeft) - this.boundXRadius;\n                            this.limitHighX = (this.posX - hotspotWidthRight) + this.boundXRadius;\n                            \/\/Position\n                            this.limitLowPosX = this.boundMinX + hotspotWidthLeft;\n                            this.limitHighPosX = this.boundMaxX - hotspotWidthRight;\n                            \/\/Boolean\n                            var radiusClear = false;\n                            var posClear = false;\n\n                            \/\/Set New Position\n\n                            \/\/Set Clearance\n                            \/\/radiusBound clearance\n                            if (this.radiusBound) {\n                                if (newx < this.limitLowX || newx > this.limitHighX) {\n                                    radiusClear = false;\n                                    \/\/not necessary (redundant)\n\n                                    \/\/radius Exceeded\n                                    this.radiusExceeded = true;\n\n                                    \/\/OnAnyBoundExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnAnyBoundExceeded);\n\n                                    \/\/OnRadiusExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnRadiusExceeded);\n\n                                }\n                                else {\n\n                                    radiusClear = true;\n\n                                    \/\/radius !Exceeded\n                                    this.radiusExceeded = false;\n\n                                }\n\n                            }\n                            else {\n                                radiusClear = true;\n\n                                \/\/radius !Exceeded\n                                this.radiusExceeded = false;\n\n                            }\n\n                            \/\/posBound clearance\n                            if (this.posBound) {\n                                if (newx < this.limitLowPosX || newx > this.limitHighPosX) {\n                                    posClear = false;\n                                    \/\/not necessary (redundant)\n\n                                    \/\/position Exceeded\n                                    this.positionExceeded = true;\n\n                                    \/\/OnAnyBoundExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnAnyBoundExceeded);\n\n                                    \/\/OnPositionExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnPositionExceeded);\n\n                                }\n                                else {\n\n                                    posClear = true;\n\n                                    \/\/position !Exceeded\n                                    this.positionExceeded = false;\n\n                                }\n\n                            }\n                            else {\n                                posClear = true;\n\n                                \/\/position !Exceeded\n                                this.positionExceeded = false;\n\n                            }\n\n                            \/\/Set New Position\n                            \/\/BoundMethod = \'Halt\'\n                            if (this.boundMethod === 0) {\n\n                                if (radiusClear && posClear) {\n                                    if (this.inst.get.x !== newx) {\n                                        this.inst.set.x(newx);\n                                        this.inst.set_bbox_changed();\n\n                                    }\n                                }\n\n                            }\/\/BoundMethod = \'Clamp\'\n                            else {\n                                \/\/!RadiusClear\n                                if (!radiusClear) {\n                                    \/\/RadiusX\n                                    if (newx < this.limitLowX) {\n\n                                        newx = this.limitLowX;\n\n                                    }\n\n                                    if (newx > this.limitHighX) {\n\n                                        newx = this.limitHighX;\n\n                                    }\n                                    \/\/RadiusY\n                                    if (newy < this.limitLowY) {\n\n                                        newy = this.limitLowY;\n\n                                    }\n\n                                    if (newy > this.limitHighY) {\n\n                                        newy = this.limitHighY;\n\n                                    }\n\n                                }\n                                \/\/!PosClear\n                                if (!posClear) {\n                                    \/\/PosX\n                                    if (newx < this.limitLowPosX) {\n\n                                        newx = this.limitLowPosX;\n\n                                    }\n\n                                    if (newx > this.limitHighPosX) {\n\n                                        newx = this.limitHighPosX;\n\n                                    }\n                                    \/\/PosY\n                                    if (newy < this.limitLowPosY) {\n\n                                        newy = this.limitLowPosY;\n\n                                    }\n\n                                    if (newy > this.limitHighPosY) {\n\n                                        newy = this.limitHighPosY;\n\n                                    }\n\n                                }\n\n                                \/\/New Position\n\n                                if (this.inst.get.x !== newx) {\n                                    this.inst.set.x(newx);\n                                    this.inst.set_bbox_changed();\n\n                                }\n\n                            }\n\n                        }\n\n                    }\/\/If all Bound values are 0.\n                    else {\n\n                        if (this.inst.get.x !== newx) {\n                            this.inst.set.x(newx);\n                            this.inst.set_bbox_changed();\n                        }\n\n                    }\n\n                }\n                else if (this.axes === 2) \/\/ vertical\n                {\n                    \/\/If one or more Bound values aren\'t 0.\n                    if (this.boundEnabled) {\n                        \/\/origin\n                        if (this.boundBy === 0) {\n                            \/\/Radius\n                            this.limitLowY = this.posY - this.boundYRadius;\n                            this.limitHighY = this.posY + this.boundYRadius;\n                            \/\/Position\n                            this.limitLowPosY = this.boundMinY;\n                            this.limitHighPosY = this.boundMaxY;\n                            \/\/Boolean\n                            var radiusClear = false;\n                            var posClear = false;\n\n                            \/\/Set Clearance\n                            \/\/radiusBound clearance\n                            if (this.radiusBound) {\n                                if (newy < this.limitLowY || newy > this.limitHighY) {\n                                    radiusClear = false;\n                                    \/\/not necessary (redundant)\n\n                                    \/\/radius Exceeded\n                                    this.radiusExceeded = true;\n\n                                    \/\/OnAnyBoundExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnAnyBoundExceeded);\n\n                                    \/\/OnRadiusExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnRadiusExceeded);\n\n                                }\n                                else {\n\n                                    radiusClear = true;\n\n                                    \/\/radius !Exceeded\n                                    this.radiusExceeded = false;\n\n                                }\n\n                            }\n                            else {\n                                radiusClear = true;\n\n                                \/\/radius !Exceeded\n                                this.radiusExceeded = false;\n\n                            }\n\n                            \/\/posBound clearance\n                            if (this.posBound) {\n                                if (newy < this.limitLowPosY || newy > this.limitHighPosY) {\n                                    posClear = false;\n                                    \/\/not necessary (redundant)\n\n                                    \/\/position Exceeded\n                                    this.positionExceeded = true;\n\n                                    \/\/OnAnyBoundExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnAnyBoundExceeded);\n\n                                    \/\/OnPositionExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnPositionExceeded);\n\n                                }\n                                else {\n\n                                    posClear = true;\n\n                                    \/\/position !Exceeded\n                                    this.positionExceeded = false;\n\n                                }\n\n                            }\n                            else {\n                                posClear = true;\n\n                                \/\/position !Exceeded\n                                this.positionExceeded = false;\n\n                            }\n\n                            \/\/Set New Position\n                            \/\/BoundMethod = \'Halt\'\n                            if (this.boundMethod === 0) {\n\n                                if (radiusClear && posClear) {\n                                    if (this.inst.get.y !== newy) {\n                                        this.inst.set.y(newy);\n                                        this.inst.set_bbox_changed();\n\n                                    }\n                                }\n\n                            }\/\/BoundMethod = \'Clamp\'\n                            else {\n                                \/\/!RadiusClear\n                                if (!radiusClear) {\n                                    \/\/RadiusX\n                                    if (newx < this.limitLowX) {\n\n                                        newx = this.limitLowX;\n\n                                    }\n\n                                    if (newx > this.limitHighX) {\n\n                                        newx = this.limitHighX;\n\n                                    }\n                                    \/\/RadiusY\n                                    if (newy < this.limitLowY) {\n\n                                        newy = this.limitLowY;\n\n                                    }\n\n                                    if (newy > this.limitHighY) {\n\n                                        newy = this.limitHighY;\n\n                                    }\n\n                                }\n                                \/\/!PosClear\n                                if (!posClear) {\n                                    \/\/PosX\n                                    if (newx < this.limitLowPosX) {\n\n                                        newx = this.limitLowPosX;\n\n                                    }\n\n                                    if (newx > this.limitHighPosX) {\n\n                                        newx = this.limitHighPosX;\n\n                                    }\n                                    \/\/PosY\n                                    if (newy < this.limitLowPosY) {\n\n                                        newy = this.limitLowPosY;\n\n                                    }\n\n                                    if (newy > this.limitHighPosY) {\n\n                                        newy = this.limitHighPosY;\n\n                                    }\n\n                                }\n\n                                \/\/New Position\n\n                                if (this.inst.get.y !== newy) {\n                                    this.inst.set.y(newy);\n                                    this.inst.set_bbox_changed();\n\n                                }\n\n                            }\n\n                        }\n                        \/\/edge\n                        else\n                        {\n                            \/\/Hotspot\n                            var hotspotY = this.inst.hotspotY;\n\n                            var hotspotHeightTop = (hotspotY * this.inst.height);\n                            var hotspotHeightBottom = ((1 - hotspotY) * this.inst.height);\n\n                            \/\/Radius\n                            this.limitLowY = (this.posY + hotspotHeightTop) - this.boundYRadius;\n                            this.limitHighY = (this.posY - hotspotHeightBottom) + this.boundYRadius;\n                            \/\/Position\n                            this.limitLowPosY = this.boundMinY + hotspotHeightTop;\n                            this.limitHighPosY = this.boundMaxY - hotspotHeightBottom;\n                            \/\/Boolean\n                            var radiusClear = false;\n                            var posClear = false;\n\n                            \/\/Set New Position\n\n                            \/\/Set Clearance\n                            \/\/radiusBound clearance\n                            if (this.radiusBound) {\n                                if (newy < this.limitLowY || newy > this.limitHighY) {\n                                    radiusClear = false;\n                                    \/\/not necessary (redundant)\n\n                                    \/\/radius Exceeded\n                                    this.radiusExceeded = true;\n\n                                    \/\/OnAnyBoundExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnAnyBoundExceeded);\n\n                                    \/\/OnRadiusExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnRadiusExceeded);\n\n                                }\n                                else {\n\n                                    radiusClear = true;\n\n                                    \/\/radius !Exceeded\n                                    this.radiusExceeded = false;\n\n                                }\n\n                            }\n                            else {\n                                radiusClear = true;\n\n                                \/\/radius !Exceeded\n                                this.radiusExceeded = false;\n\n                            }\n\n                            \/\/posBound clearance\n                            if (this.posBound) {\n                                if (newy < this.limitLowPosY || newy > this.limitHighPosY) {\n                                    posClear = false;\n                                    \/\/not necessary (redundant)\n\n                                    \/\/position Exceeded\n                                    this.positionExceeded = true;\n\n                                    \/\/OnAnyBoundExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnAnyBoundExceeded);\n\n                                    \/\/OnPositionExceeded conditional trigger\n                                    this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnPositionExceeded);\n\n                                }\n                                else {\n\n                                    posClear = true;\n\n                                    \/\/position !Exceeded\n                                    this.positionExceeded = false;\n\n                                }\n\n                            }\n                            else {\n                                posClear = true;\n\n                                \/\/position !Exceeded\n                                this.positionExceeded = false;\n\n                            }\n\n                            \/\/Set New Position\n                            \/\/BoundMethod = \'Halt\'\n                            if (this.boundMethod === 0) {\n\n                                if (radiusClear && posClear) {\n                                    if (this.inst.get.y !== newy) {\n                                        this.inst.set.y(newy);\n                                        this.inst.set_bbox_changed();\n\n                                    }\n                                }\n\n                            }\/\/BoundMethod = \'Clamp\'\n                            else {\n                                \/\/!RadiusClear\n                                if (!radiusClear) {\n                                    \/\/RadiusX\n                                    if (newx < this.limitLowX) {\n\n                                        newx = this.limitLowX;\n\n                                    }\n\n                                    if (newx > this.limitHighX) {\n\n                                        newx = this.limitHighX;\n\n                                    }\n                                    \/\/RadiusY\n                                    if (newy < this.limitLowY) {\n\n                                        newy = this.limitLowY;\n\n                                    }\n\n                                    if (newy > this.limitHighY) {\n\n                                        newy = this.limitHighY;\n\n                                    }\n\n                                }\n                                \/\/!PosClear\n                                if (!posClear) {\n                                    \/\/PosX\n                                    if (newx < this.limitLowPosX) {\n\n                                        newx = this.limitLowPosX;\n\n                                    }\n\n                                    if (newx > this.limitHighPosX) {\n\n                                        newx = this.limitHighPosX;\n\n                                    }\n                                    \/\/PosY\n                                    if (newy < this.limitLowPosY) {\n\n                                        newy = this.limitLowPosY;\n\n                                    }\n\n                                    if (newy > this.limitHighPosY) {\n\n                                        newy = this.limitHighPosY;\n\n                                    }\n\n                                }\n\n                                \/\/New Position\n\n                                if (this.inst.get.y !== newy) {\n                                    this.inst.set.y(newy);\n                                    this.inst.set_bbox_changed();\n\n                                }\n\n                            }\n\n                        }\n                    }\/\/If all Bound values are 0.\n                    else {\n\n                        if (this.inst.get.y !== newy) {\n                            this.inst.set.y(newy);\n                            this.inst.set_bbox_changed();\n                        }\n\n                    }\n                }\n\n            }\n            _OnUp() {\n                this.dragging = !1,\n                this.Trigger(C3.Behaviors.CV_BoundedDragnDrop.Cnds.OnDrop)\n            }\n            _GetPropertyValueByIndex(a) {\n                return a === 0 ? this.axes : 1 === a ? this.enabled : void 0\n            }\n            _SetPropertyValueByIndex(a, b) {\n                a === 0 ? this.axes = b : 1 === a ? this.enabled = !!b : void 0\n            }\n\n            \/\/ -- Construct 3 Runtime -> Instancse Class Functions :: End\n\n        }\n        ;\n    }\n}\n\n{\n    "use strict";\n\n    {\n        const C3 = self.C3;\n\n        C3.Behaviors.CV_BoundedDragnDrop.Cnds = {\n            IsDragging() {\n                return this.dragging;\n            },\n\n            OnDragStart() {\n                return true;\n            },\n\n            OnDrop() {\n                return true;\n            },\n\n            IsEnabled() {\n                return !!this.enabled;\n            },\n\n            \/\/ Start\n\n            OnAnyBoundExceeded() {\n                return true;\n            },\n\n            OnRadiusExceeded() {\n                return true;\n            },\n\n            OnPositionExceeded() {\n                return true;\n            },\n\n            IsRadiusExceeded() {\n                return this.radiusExceeded;\n            },\n\n            IsPositionExceeded() {\n                return this.positionExceeded;\n            }\n        };\n    }\n}\n\n{\n    "use strict";\n\n    {\n        const C3 = self.C3;\n\n        C3.Behaviors.CV_BoundedDragnDrop.Acts = {\n            SetEnabled(s) {\n                this.enabled = (s !== 0);\n\n                \/\/ Got disabled: cancel any drag\n                if (!this.enabled)\n                    this.dragging = false;\n            },\n\n            Drop() {\n                if (this.dragging)\n                    this.onUp();\n            },\n\n            \/\/ Start\n\n            SetBoundTo(boundTo) {\n                this.boundTo = boundTo;\n\n                this.getBoundValues();\n            },\n\n            SetBoundBy(boundBy) {\n                this.boundBy = boundBy;\n\n                this.getBoundValues();\n            },\n\n            SetBoundMethod(boundMethod) {\n                this.boundMethod = boundMethod;\n\n                \/\/this.getBoundValues();\n            },\n\n            SetXYRadius(x, y) {\n                this.boundXRadius = x;\n                this.boundYRadius = y;\n\n                this.getBoundValues();\n            },\n\n            SetXRadius(x) {\n                this.boundXRadius = x;\n\n                this.getBoundValues();\n            },\n\n            SetYRadius(y) {\n                this.boundYRadius = y;\n\n                this.getBoundValues();\n            },\n\n            SetBoundPosition(xI, xF, yI, yF) {\n                this.boundMinX = xI;\n                this.boundMaxX = xF;\n                this.boundMinY = yI;\n                this.boundMaxY = yF;\n\n                this.getBoundValues();\n            },\n\n            SetBoundX(xI, xF) {\n                this.boundMinX = xI;\n                this.boundMaxX = xF;\n\n                this.getBoundValues();\n            },\n\n            SetBoundY(yI, yF) {\n                this.boundMinY = yI;\n                this.boundMaxY = yF;\n\n                this.getBoundValues();\n            },\n\n            OverwriteOrigin(x, y) {\n                this.posX = x;\n                this.posY = y;\n\n                this.getBoundValues();\n            }\n        };\n    }\n}\n\n{\n    "use strict";\n\n    {\n        const C3 = self.C3;\n\n        C3.Behaviors.CV_BoundedDragnDrop.Exps = {\n            BoundTo() {\n\n                var boundToString;\n\n                switch (this.boundTo)\n                {\n\n                case 0:\n\n                    boundToString = "Off";\n                    break;\n\n                case 1:\n\n                    boundToString = "Both";\n                    break;\n\n                case 2:\n\n                    boundToString = "Radius";\n                    break;\n\n                case 3:\n\n                    boundToString = "Position";\n                }\n\n                return (boundToString);\n            },\n\n            BoundBy() {\n\n                var boundByString;\n\n                switch (this.boundBy)\n                {\n\n                case 0:\n\n                    boundByString = "Origin";\n                    break;\n\n                case 1:\n\n                    boundByString = "Edge";\n\n                }\n\n                return (boundByString);\n            },\n\n            BoundMethod() {\n\n                var boundMethodString;\n\n                switch (this.boundMethod)\n                {\n\n                case 0:\n\n                    boundMethodString = "Halt";\n                    break;\n\n                case 1:\n\n                    boundMethodString = "Clamp";\n\n                }\n\n                return (boundMethodString);\n            },\n\n            xBoundRadius() {\n                return (this.boundXRadius);\n            },\n\n            yBoundRadius() {\n                return (this.boundYRadius);\n            },\n\n            xMinBoundPos() {\n                return (this.boundMinX);\n            },\n\n            xMaxBoundPos() {\n                return (this.boundMaxX);\n            },\n\n            yMinBoundPos() {\n                return (this.boundMinY);\n            },\n\n            yMaxBoundPos() {\n                return (this.boundMaxY);\n            },\n\n            xOrigin() {\n                return (this.posX);\n            },\n\n            yOrigin() {\n                return (this.posY);\n            }\n        };\n    }\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Behaviors.wrap = class WrapBehavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.wrap.Type = class WrapType extends C3.SDKBehaviorTypeBase {\n            constructor(behaviorType) {\n                super(behaviorType)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        const MODE = 0;\n        const bound = new C3.Rect;\n        C3.Behaviors.wrap.Instance = class WrapInstance extends C3.SDKBehaviorInstanceBase {\n            constructor(behInst, properties) {\n                super(behInst);\n                this._mode = 0;\n                if (properties)\n                    this._mode = properties[MODE];\n                this._StartTicking()\n            }\n            Release() {\n                super.Release()\n            }\n            SaveToJson() {\n                return {\n                    "m": this._mode\n                }\n            }\n            LoadFromJson(o) {\n                this._mode = o["m"]\n            }\n            Tick() {\n                const wi = this._inst.GetWorldInfo();\n                const layer = wi.GetLayer();\n                const layout = layer.GetLayout();\n                const bbox = wi.GetBoundingBox();\n                if (this._mode === 0)\n                    bound.set(0, 0, layout.GetWidth(), layout.GetHeight());\n                else\n                    bound.copy(layer.GetViewport());\n                if (bbox.getRight() < bound.getLeft()) {\n                    wi.SetX(bound.getRight() - 1 + (wi.GetX() - bbox.getLeft()));\n                    wi.SetBboxChanged()\n                } else if (bbox.getLeft() > bound.getRight()) {\n                    wi.SetX(bound.getLeft() + 1 - (bbox.getRight() - wi.GetX()));\n                    wi.SetBboxChanged()\n                } else if (bbox.getBottom() < bound.getTop()) {\n                    wi.SetY(bound.getBottom() - 1 + (wi.GetY() - bbox.getTop()));\n                    wi.SetBboxChanged()\n                } else if (bbox.getTop() > bound.getBottom()) {\n                    wi.SetY(bound.getTop() + 1 - (bbox.getBottom() - wi.GetY()));\n                    wi.SetBboxChanged()\n                }\n            }\n            GetPropertyValueByIndex(index) {\n                switch (index) {\n                case MODE:\n                    return this._mode\n                }\n            }\n            SetPropertyValueByIndex(index, value) {\n                switch (index) {\n                case MODE:\n                    this._mode = value;\n                    break\n                }\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.wrap.Cnds = {}\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.wrap.Acts = {}\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.wrap.Exps = {}\n    }\n    ;\n\n}\n\n{\n    \'use strict\';\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Flash = class FlashBehavior extends C3.SDKBehaviorBase {\n            constructor(opts) {\n                super(opts)\n            }\n            Release() {\n                super.Release()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Flash.Type = class FlashType extends C3.SDKBehaviorTypeBase {\n            constructor(behaviorType) {\n                super(behaviorType)\n            }\n            Release() {\n                super.Release()\n            }\n            OnCreate() {}\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Flash.Instance = class FlashInstance extends C3.SDKBehaviorInstanceBase {\n            constructor(behInst, properties) {\n                super(behInst);\n                this._onTime = 0;\n                this._offTime = 0;\n                this._stage = 0;\n                this._stageTimeLeft = 0;\n                this._timeLeft = 0;\n                this._StartTicking()\n            }\n            Release() {\n                super.Release()\n            }\n            SaveToJson() {\n                return {\n                    "on": this._onTime,\n                    "off": this._offTime,\n                    "s": this._stage,\n                    "stl": this._stageTimeLeft,\n                    "tl": this._timeLeft\n                }\n            }\n            LoadFromJson(o) {\n                this._onTime = o["on"];\n                this._offTime = o["off"];\n                this._stage = o["s"];\n                this._stageTimeLeft = o["stl"];\n                this._timeLeft = o["tl"] === null ? Infinity : o["tl"]\n            }\n            Tick() {\n                if (this._timeLeft <= 0)\n                    return;\n                const dt = this._runtime.GetDt(this._inst);\n                this._timeLeft -= dt;\n                if (this._timeLeft <= 0) {\n                    this._timeLeft = 0;\n                    this._inst.GetWorldInfo().SetVisible(true);\n                    this._runtime.UpdateRender();\n                    return this.DebugTrigger(C3.Behaviors.Flash.Cnds.OnFlashEnded)\n                }\n                this._stageTimeLeft -= dt;\n                if (this._stageTimeLeft <= 0) {\n                    if (this._stage === 0) {\n                        this._inst.GetWorldInfo().SetVisible(false);\n                        this._stage = 1;\n                        this._stageTimeLeft += this._offTime\n                    } else {\n                        this._inst.GetWorldInfo().SetVisible(true);\n                        this._stage = 0;\n                        this._stageTimeLeft += this._onTime\n                    }\n                    this._runtime.UpdateRender()\n                }\n            }\n            GetDebuggerProperties() {\n                const prefix = "behaviors.flash.debugger";\n                return [{\n                    title: "$" + this.GetBehaviorType().GetName(),\n                    properties: [{\n                        name: prefix + ".on-time",\n                        value: this._onTime,\n                        onedit: v => this._onTime = v\n                    }, {\n                        name: prefix + ".off-time",\n                        value: this._offTime,\n                        onedit: v => this._offTime = v\n                    }, {\n                        name: prefix + ".is-flashing",\n                        value: this._timeLeft > 0\n                    }, {\n                        name: prefix + ".time-left",\n                        value: this._timeLeft\n                    }]\n                }]\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Flash.Cnds = {\n            IsFlashing() {\n                return this._timeLeft > 0\n            },\n            OnFlashEnded() {\n                return true\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Flash.Acts = {\n            Flash(on, off, dur) {\n                this._onTime = on;\n                this._offTime = off;\n                this._stage = 1;\n                this._stageTimeLeft = off;\n                this._timeLeft = dur;\n                this._inst.GetWorldInfo().SetVisible(false);\n                this._runtime.UpdateRender()\n            },\n            StopFlashing() {\n                this._timeLeft = 0;\n                this._inst.GetWorldInfo().SetVisible(true);\n                this._runtime.UpdateRender()\n            }\n        }\n    }\n    {\n        const C3 = self.C3;\n        C3.Behaviors.Flash.Exps = {}\n    }\n    ;\n\n}\n\n{\n    const C3 = self.C3;\n    self.C3_GetObjectRefTable = function() {\n        return [C3.Plugins.Text, C3.Plugins.Sprite, C3.Behaviors.Sin, C3.Behaviors.DragnDrop, C3.Behaviors.Pin, C3.Behaviors.Tween, C3.Plugins.Dictionary, C3.Plugins.Particles, C3.Plugins.Arr, C3.Behaviors.bound, C3.Behaviors.MoveTo, C3.Behaviors.Bullet, C3.Behaviors.solid, C3.Behaviors.Rotate, C3.Behaviors.EightDir, C3.Behaviors.Physics, C3.Behaviors.Pathfinding, C3.Behaviors.CV_BoundedDragnDrop, C3.Behaviors.wrap, C3.Behaviors.Flash, C3.Plugins.Touch, C3.Plugins.Audio, C3.Plugins.Browser, C3.Plugins.AJAX, C3.Plugins.LocalStorage, C3.Plugins.PlatformInfo, C3.Plugins.Json, C3.Plugins.System.Cnds.IsGroupActive, C3.Plugins.Touch.Cnds.OnTouchObject, C3.Plugins.System.Cnds.CompareBoolVar, C3.Plugins.Text.Acts.SetText, C3.Plugins.System.Cnds.Compare, C3.Plugins.Text.Exps.Text, C3.Plugins.Sprite.Exps.X, C3.Plugins.Sprite.Exps.Y, C3.Plugins.System.Cnds.Else, C3.Plugins.System.Exps.len, C3.Plugins.Sprite.Cnds.CompareFrame, C3.Plugins.Sprite.Exps.AnimationFrame, C3.Plugins.Touch.Cnds.IsTouchingObject, C3.Plugins.Touch.Cnds.CompareTouchSpeed, C3.Plugins.System.Cnds.CompareBetween, C3.Plugins.Touch.Exps.AngleAt, C3.Plugins.System.Cnds.TriggerOnce, C3.Behaviors.MoveTo.Acts.MoveToPosition, C3.Plugins.Sprite.Cnds.OnCollision, C3.Behaviors.DragnDrop.Acts.Drop, C3.Plugins.Sprite.Acts.SetPos, C3.Behaviors.DragnDrop.Cnds.OnDrop, C3.Plugins.Sprite.Cnds.CompareX, C3.Plugins.Sprite.Cnds.CompareY, C3.Plugins.System.Acts.SetBoolVar, C3.Behaviors.Physics.Acts.SetEnabled, C3.Behaviors.MoveTo.Cnds.IsMoving, C3.Plugins.System.Acts.Wait, C3.Plugins.Sprite.Acts.SetAnimFrame, C3.Plugins.Dictionary.Exps.Get, C3.Plugins.Audio.Acts.Play, C3.Behaviors.DragnDrop.Cnds.IsDragging, C3.Plugins.Sprite.Cnds.IsOnScreen, C3.Plugins.System.Acts.RestartLayout, C3.Plugins.Sprite.Acts.Destroy, C3.Plugins.Sprite.Acts.SetAngle, C3.Behaviors.MoveTo.Cnds.OnArrived, C3.Plugins.Sprite.Acts.SetVisible, C3.Behaviors.DragnDrop.Cnds.OnDragStart, C3.Plugins.System.Cnds.EveryTick, C3.Plugins.System.Acts.AddVar, C3.Plugins.System.Acts.SubVar, C3.Behaviors.Tween.Acts.TweenOneProperty, C3.Plugins.System.Acts.WaitForPreviousActions, C3.Plugins.Text.Exps.X, C3.Plugins.Text.Exps.Y, C3.Plugins.Sprite.Cnds.IsVisible, C3.Plugins.System.Cnds.OnLayoutStart, C3.Behaviors.Pin.Acts.Pin, C3.Plugins.Sprite.Cnds.IsOverlapping, C3.Plugins.Sprite.Cnds.IsBetweenAngles, C3.Plugins.System.Acts.CreateObject, C3.Behaviors.Bullet.Acts.SetAngleOfMotion, C3.Plugins.Sprite.Exps.Angle, C3.Behaviors.Bullet.Acts.SetSpeed, C3.Behaviors.Bullet.Acts.SetAcceleration, C3.Behaviors.Bullet.Acts.SetEnabled, C3.Behaviors.MoveTo.Acts.MoveToObject, C3.Plugins.System.Cnds.PickNth, C3.Plugins.Sprite.Cnds.CompareInstanceVar, C3.Plugins.Sprite.Acts.SetInstanceVar, C3.Plugins.Text.Acts.Destroy, C3.Plugins.System.Exps.left, C3.Plugins.Sprite.Acts.SetX, C3.Plugins.Text.Acts.SetPos, C3.Plugins.Text.Cnds.IsOnScreen, C3.Plugins.System.Acts.SetVar, C3.Plugins.Arr.Acts.Clear, C3.Plugins.System.Cnds.CompareVar, C3.Plugins.Sprite.Acts.SetSize, C3.Plugins.Arr.Acts.SetX, C3.Plugins.Text.Acts.SetBoolInstanceVar, C3.Plugins.Arr.Cnds.CompareX, C3.Plugins.Text.Acts.SetX, C3.Plugins.Touch.Cnds.OnTapGestureObject, C3.Plugins.System.Exps.viewportright, C3.Plugins.System.Exps.viewportleft, C3.Plugins.System.Exps.viewporttop, C3.Plugins.System.Exps.viewportbottom, C3.Plugins.System.Exps.mid, C3.Behaviors.CV_BoundedDragnDrop.Acts.SetEnabled, C3.Behaviors.MoveTo.Acts.SetMaxSpeed, C3.Behaviors.MoveTo.Acts.SetAcceleration, C3.Behaviors.MoveTo.Acts.SetDeceleration, C3.Plugins.Sprite.Acts.MoveToTop, C3.Behaviors.Sin.Acts.SetEnabled, C3.Plugins.System.Cnds.PickByComparison, C3.Plugins.Text.Acts.SetOpacity, C3.Behaviors.DragnDrop.Acts.SetEnabled, C3.Plugins.Text.Acts.MoveToLayer, C3.Plugins.Text.Acts.MoveToBottom, C3.Plugins.Audio.Acts.Stop, C3.Plugins.System.Cnds.OnLayoutEnd, C3.Plugins.Particles.Acts.Destroy, C3.Plugins.Text.Acts.SetSize, C3.Behaviors.MoveTo.Acts.Stop, C3.Plugins.Sprite.Acts.ZMoveToObject, C3.Plugins.Sprite.Acts.SetY, C3.Plugins.Sprite.Exps.PickedCount, C3.Plugins.Text.Cnds.CompareY, C3.Plugins.Text.Acts.SetFontColor, C3.Plugins.Sprite.Acts.SetOpacity, C3.Plugins.Text.Acts.SetFontSize, C3.Plugins.Touch.Exps.SpeedAt, C3.Plugins.Touch.Exps.X, C3.Plugins.Touch.Exps.Y, C3.Plugins.Text.Cnds.IsBetweenAngles, C3.Plugins.Text.Acts.SetAngle, C3.Behaviors.Pin.Acts.Unpin, C3.Plugins.Text.Cnds.CompareText, C3.Plugins.Sprite.Acts.SetAnimSpeed, C3.Behaviors.Rotate.Acts.SetEnabled, C3.Behaviors.Rotate.Acts.SetSpeed, C3.Behaviors.EightDir.Acts.SimulateControl, C3.Behaviors.EightDir.Acts.SetEnabled, C3.Plugins.System.Acts.SetLayerOpacity, C3.Behaviors.Tween.Acts.TweenTwoProperties, C3.Plugins.Sprite.Acts.SetCollisions, C3.Plugins.System.Cnds.Every, C3.Plugins.System.Exps.random, C3.Behaviors.Bullet.Cnds.CompareSpeed, C3.Plugins.Sprite.Exps.Opacity, C3.Plugins.Sprite.Cnds.CompareOpacity, C3.Plugins.Sprite.Cnds.OnDestroyed, C3.Behaviors.DragnDrop.Cnds.IsEnabled, C3.Plugins.Text.Acts.SetInstanceVar, C3.Plugins.Text.Cnds.CompareInstanceVar, C3.Plugins.System.Exps.int, C3.Plugins.System.Cnds.ForEach, C3.Plugins.Sprite.Acts.MoveToLayer, C3.Behaviors.Pathfinding.Acts.FindPath, C3.Behaviors.Pathfinding.Acts.StartMoving, C3.Behaviors.Pathfinding.Acts.Stop, C3.Plugins.Sprite.Exps.Width, C3.Plugins.Sprite.Exps.Height, C3.Behaviors.Tween.Cnds.OnTweensFinished, C3.Plugins.System.Cnds.PickRandom, C3.Plugins.Touch.Cnds.OnTouchStart, C3.Behaviors.MoveTo.Acts.SetEnabled, C3.Plugins.Sprite.Acts.SetTowardPosition, C3.Plugins.Sprite.Acts.SetWidth, C3.Behaviors.CV_BoundedDragnDrop.Cnds.IsDragging, C3.Behaviors.Physics.Cnds.CompareVelocity, C3.Behaviors.MoveTo.Exps.TargetX, C3.Plugins.Sprite.Acts.SetScale, C3.Behaviors.DragnDrop.Acts.SetAxes, C3.Behaviors.Pin.Cnds.IsPinned, C3.Plugins.Sprite.Acts.SetPosToObject, C3.Plugins.Sprite.Cnds.PickDistance, C3.Plugins.Sprite.Acts.SetHeight, C3.Plugins.System.Cnds.PickAll, C3.Behaviors.Tween.Cnds.IsAnyPlaying, C3.Plugins.Sprite.Exps.ImagePointX, C3.Plugins.Sprite.Exps.ImagePointY, C3.Behaviors.Bullet.Cnds.IsEnabled, C3.Plugins.Sprite.Acts.MoveToBottom, C3.Behaviors.Pin.Acts.PinByProperties, C3.Behaviors.Flash.Acts.Flash, C3.Behaviors.Flash.Cnds.OnFlashEnded, C3.Plugins.Text.Cnds.IsBoolInstanceVarSet, C3.Plugins.Text.Exps.Opacity, C3.Plugins.Text.Cnds.CompareOpacity, C3.Plugins.Arr.Exps.At, C3.Plugins.Text.Acts.SetVisible, C3.Plugins.PlatformInfo.Cnds.IsOnMobile, C3.Plugins.PlatformInfo.Cnds.IsOniOS, C3.Plugins.Text.Acts.SetY, C3.Plugins.Dictionary.Cnds.HasKey, C3.Plugins.Browser.Cnds.IsPortraitLandscape, C3.Plugins.System.Cnds.LayerCmpOpacity, C3.ScriptsInEvents.Globalevent_Event17_Act2, C3.ScriptsInEvents.Globalevent_Event18_Act2, C3.ScriptsInEvents.Globalevent_Event18_Act11, C3.ScriptsInEvents.Globalevent_Event18_Act12, C3.ScriptsInEvents.Globalevent_Event20_Act1, C3.ScriptsInEvents.Globalevent_Event21_Act1, C3.Plugins.System.Exps.windowwidth, C3.ScriptsInEvents.Globalevent_Event23_Act1, C3.ScriptsInEvents.Globalevent_Event24_Act1, C3.ScriptsInEvents.Globalevent_Event30_Act8, C3.Plugins.Sprite.Acts.SetBoolInstanceVar, C3.Plugins.Arr.Cnds.Contains, C3.Plugins.Arr.Acts.Push, C3.Plugins.Dictionary.Acts.SetKey, C3.Plugins.Arr.Exps.AsJSON, C3.ScriptsInEvents.Globalevent_Event36_Act1, C3.Plugins.LocalStorage.Acts.SetItem, C3.Plugins.Dictionary.Exps.AsJSON, C3.Plugins.System.Acts.GoToLayoutByName, C3.Plugins.System.Acts.GoToLayout, C3.ScriptsInEvents.Globalevent_Event41_Act1, C3.Plugins.Audio.Acts.SetMuted, C3.Plugins.Audio.Acts.SetPaused, C3.Plugins.Dictionary.Cnds.CompareValue, C3.ScriptsInEvents.Globalevent_Event56_Act4, C3.ScriptsInEvents.Globalevent_Event60_Act3, C3.ScriptsInEvents.Globalevent_Event68_Act1, C3.Plugins.System.Cnds.IsPreview, C3.ScriptsInEvents.Globalevent_Event70_Act1, C3.ScriptsInEvents.Globalevent_Event85_Act1, C3.ScriptsInEvents.Globalevent_Event88_Act1, C3.ScriptsInEvents.Globalevent_Event89_Act1, C3.ScriptsInEvents.Globalevent_Event93_Act1, C3.ScriptsInEvents.Globalevent_Event100_Act5, C3.ScriptsInEvents.Globalevent_Event102_Act1, C3.ScriptsInEvents.Globalevent_Event105_Act1, C3.ScriptsInEvents.Globalevent_Event106_Act1, C3.ScriptsInEvents.Globalevent_Event107_Act3, C3.Plugins.Arr.Acts.Delete, C3.Plugins.Arr.Exps.IndexOf, C3.ScriptsInEvents.Globalevent_Event113_Act4, C3.Plugins.Arr.Exps.CurValue, C3.ScriptsInEvents.Globalevent_Event122_Act1, C3.Plugins.Sprite.Cnds.OnCreated, C3.Plugins.AJAX.Cnds.OnComplete, C3.Plugins.Arr.Acts.JSONLoad, C3.Plugins.AJAX.Exps.LastData, C3.Plugins.Text.Acts.SetFontFace, C3.Plugins.Text.Acts.SetWrapping, C3.ScriptsInEvents.Levelselecte_Event21_Act1, C3.Plugins.System.Cnds.For, C3.Plugins.System.Exps.loopindex, C3.ScriptsInEvents.Levelselecte_Event37_Act4, C3.Plugins.Arr.Acts.SetSize, C3.Plugins.LocalStorage.Acts.CheckItemExists, C3.Plugins.Browser.Exps.ExecJS, C3.ScriptsInEvents.Starte_Event1_Act13, C3.ScriptsInEvents.Starte_Event3_Act4, C3.Plugins.LocalStorage.Cnds.OnItemMissing, C3.Plugins.Dictionary.Acts.AddKey, C3.Plugins.Audio.Cnds.IsTagPlaying, C3.Plugins.LocalStorage.Cnds.OnItemExists, C3.Plugins.Dictionary.Acts.JSONLoad, C3.Plugins.LocalStorage.Exps.ItemValue, C3.Plugins.Json.Acts.Parse, C3.Plugins.Json.Cnds.ForEach, C3.Plugins.Json.Exps.CurrentKey, C3.Plugins.Json.Exps.CurrentValue, C3.Plugins.Browser.Exps.Language, C3.Plugins.AJAX.Acts.RequestFile, C3.ScriptsInEvents.Settingse_Event5_Act1, C3.Plugins.Audio.Acts.StopAll, C3.Plugins.Dictionary.Acts.Clear, C3.Plugins.System.Acts.SetFunctionReturnValue, C3.Plugins.Sprite.Acts.SetMirrored, C3.Plugins.Sprite.Acts.RemoveFromParent, C3.Behaviors.Sin.Acts.SetPeriod, C3.Behaviors.Sin.Acts.SetMagnitude, C3.ScriptsInEvents.Levelselecte2_Event5_Act1, C3.ScriptsInEvents.Levelselecte2_Event10_Act4, C3.Plugins.System.Cnds.OnLoadFinished, C3.ScriptsInEvents.Loaderlayout_Event1_Act1, C3.Plugins.System.Exps.loadingprogress, C3.ScriptsInEvents.Loaderlayout_Event3_Act1];\n    }\n    ;\n    self.C3_JsPropNameTable = [{\n        levelDisplayTxt: 0\n    }, {\n        Sine: 0\n    }, {\n        Sine2: 0\n    }, {\n        hintBtn: 0\n    }, {\n        skipBtn: 0\n    }, {\n        DragDrop: 0\n    }, {\n        giftBtn: 0\n    }, {\n        adBtn: 0\n    }, {\n        questionText: 0\n    }, {\n        Pin: 0\n    }, {\n        nextBtn: 0\n    }, {\n        Tween: 0\n    }, {\n        nextBack: 0\n    }, {\n        hintBack: 0\n    }, {\n        hintBackText: 0\n    }, {\n        nextBackText: 0\n    }, {\n        hintClose: 0\n    }, {\n        levelBtn: 0\n    }, {\n        settingsBtn: 0\n    }, {\n        backGround: 0\n    }, {\n        coinframe: 0\n    }, {\n        coinAmpul: 0\n    }, {\n        type: 0\n    }, {\n        priceTxt: 0\n    }, {\n        clappingHands: 0\n    }, {\n        coinAmpul2: 0\n    }, {\n        GameData: 0\n    }, {\n        coinDisplayText: 0\n    }, {\n        val: 0\n    }, {\n        hint: 0\n    }, {\n        sureBtn: 0\n    }, {\n        sureBack: 0\n    }, {\n        sureBtnText: 0\n    }, {\n        sureText: 0\n    }, {\n        sureClose: 0\n    }, {\n        surePrice: 0\n    }, {\n        coinAmpul3: 0\n    }, {\n        giftBottom: 0\n    }, {\n        giftTop: 0\n    }, {\n        giftBack: 0\n    }, {\n        giftText: 0\n    }, {\n        coinAmpul4: 0\n    }, {\n        Particles: 0\n    }, {\n        Particles2: 0\n    }, {\n        nogiftText: 0\n    }, {\n        giftClose: 0\n    }, {\n        konfetti1: 0\n    }, {\n        konfetti2: 0\n    }, {\n        konfetti3: 0\n    }, {\n        konfetti4: 0\n    }, {\n        konfetti5: 0\n    }, {\n        arrayLevelText: 0\n    }, {\n        submitempty: 0\n    }, {\n        submitText: 0\n    }, {\n        shareBtnText: 0\n    }, {\n        arraySkippedEN: 0\n    }, {\n        arraySkippedTR: 0\n    }, {\n        arraySkippedES: 0\n    }, {\n        arraySkippedPT: 0\n    }, {\n        arraySkippedIT: 0\n    }, {\n        arraySkippedDE: 0\n    }, {\n        arraySkippedVI: 0\n    }, {\n        arraySkippedFR: 0\n    }, {\n        arraySkippedPL: 0\n    }, {\n        arraySkippedRU: 0\n    }, {\n        arraySkippedKO: 0\n    }, {\n        arraySkippedJA: 0\n    }, {\n        arraySkippedTH: 0\n    }, {\n        arrayLevelText2: 0\n    }, {\n        arraySkippedENC: 0\n    }, {\n        lion: 0\n    }, {\n        mice: 0\n    }, {\n        zebra: 0\n    }, {\n        elephant: 0\n    }, {\n        monkey: 0\n    }, {\n        elephant2: 0\n    }, {\n        banana: 0\n    }, {\n        pear: 0\n    }, {\n        plusText: 0\n    }, {\n        slideBtn: 0\n    }, {\n        slideCerceve: 0\n    }, {\n        slideText: 0\n    }, {\n        rightBarrier: 0\n    }, {\n        leftBarrierr: 0\n    }, {\n        index: 0\n    }, {\n        catControl: 0\n    }, {\n        BoundToLayout: 0\n    }, {\n        cracker: 0\n    }, {\n        cat: 0\n    }, {\n        fences: 0\n    }, {\n        picked: 0\n    }, {\n        cat3: 0\n    }, {\n        catControl2: 0\n    }, {\n        catControl3: 0\n    }, {\n        MoveTo: 0\n    }, {\n        cat5: 0\n    }, {\n        catControl4: 0\n    }, {\n        catControl5: 0\n    }, {\n        catControl6: 0\n    }, {\n        Bullet: 0\n    }, {\n        red: 0\n    }, {\n        blue: 0\n    }, {\n        yellow: 0\n    }, {\n        green: 0\n    }, {\n        orange: 0\n    }, {\n        marchText: 0\n    }, {\n        mayText: 0\n    }, {\n        febText: 0\n    }, {\n        cursText: 0\n    }, {\n        pizza: 0\n    }, {\n        kettle: 0\n    }, {\n        scissors: 0\n    }, {\n        kettleButon: 0\n    }, {\n        fis: 0\n    }, {\n        cizirt: 0\n    }, {\n        "100Bartext": 0\n    }, {\n        "100Kntext": 0\n    }, {\n        barbarText: 0\n    }, {\n        knightText: 0\n    }, {\n        vsText: 0\n    }, {\n        rock: 0\n    }, {\n        numbersText: 0\n    }, {\n        baby: 0\n    }, {\n        cry: 0\n    }, {\n        crydrop: 0\n    }, {\n        crydrop2: 0\n    }, {\n        blueBtn: 0\n    }, {\n        redBtn: 0\n    }, {\n        Text: 0\n    }, {\n        redCar: 0\n    }, {\n        blueCar: 0\n    }, {\n        Solid: 0\n    }, {\n        road: 0\n    }, {\n        redText: 0\n    }, {\n        finish: 0\n    }, {\n        digitalText: 0\n    }, {\n        fridge: 0\n    }, {\n        fridgeHandle: 0\n    }, {\n        ampul: 0\n    }, {\n        ampul2: 0\n    }, {\n        ampul3: 0\n    }, {\n        anahtar: 0\n    }, {\n        anahtar2: 0\n    }, {\n        anahtar3: 0\n    }, {\n        anahtar4: 0\n    }, {\n        FireParticles: 0\n    }, {\n        blackBg: 0\n    }, {\n        torch: 0\n    }, {\n        tshirt: 0\n    }, {\n        bear: 0\n    }, {\n        sofa: 0\n    }, {\n        control: 0\n    }, {\n        shelf: 0\n    }, {\n        shelfholder: 0\n    }, {\n        qtext: 0\n    }, {\n        blackText: 0\n    }, {\n        sheep: 0\n    }, {\n        mathText: 0\n    }, {\n        man1: 0\n    }, {\n        man2: 0\n    }, {\n        man3: 0\n    }, {\n        man4: 0\n    }, {\n        button: 0\n    }, {\n        buttonImg: 0\n    }, {\n        equ1: 0\n    }, {\n        equ2: 0\n    }, {\n        tshirtripped: 0\n    }, {\n        front: 0\n    }, {\n        cherry: 0\n    }, {\n        woman: 0\n    }, {\n        ring: 0\n    }, {\n        man: 0\n    }, {\n        balon: 0\n    }, {\n        chocolate: 0\n    }, {\n        heart: 0\n    }, {\n        zzzz: 0\n    }, {\n        lText: 0\n    }, {\n        dropped: 0\n    }, {\n        total: 0\n    }, {\n        dropControl: 0\n    }, {\n        araba: 0\n    }, {\n        kedi: 0\n    }, {\n        solucan: 0\n    }, {\n        elma: 0\n    }, {\n        numText: 0\n    }, {\n        cats: 0\n    }, {\n        catss1: 0\n    }, {\n        catss2: 0\n    }, {\n        catss3: 0\n    }, {\n        cshadow: 0\n    }, {\n        rightCat: 0\n    }, {\n        cows: 0\n    }, {\n        bull: 0\n    }, {\n        cowsshadow: 0\n    }, {\n        "48text": 0\n    }, {\n        flower: 0\n    }, {\n        cloud1: 0\n    }, {\n        cloud2: 0\n    }, {\n        sun: 0\n    }, {\n        cloud3: 0\n    }, {\n        cloud4: 0\n    }, {\n        Rotate: 0\n    }, {\n        rotatingray: 0\n    }, {\n        cloud5: 0\n    }, {\n        equation: 0\n    }, {\n        equation50: 0\n    }, {\n        moon: 0\n    }, {\n        tree: 0\n    }, {\n        sortArray: 0\n    }, {\n        apple: 0\n    }, {\n        lettuce: 0\n    }, {\n        olive2: 0\n    }, {\n        carrot1: 0\n    }, {\n        radish: 0\n    }, {\n        birthdaycke: 0\n    }, {\n        match: 0\n    }, {\n        selfx: 0\n    }, {\n        selfy: 0\n    }, {\n        candle: 0\n    }, {\n        sadwoman: 0\n    }, {\n        burnt_bg: 0\n    }, {\n        watchburnt: 0\n    }, {\n        watchburntakr: 0\n    }, {\n        watchburntyel: 0\n    }, {\n        tava: 0\n    }, {\n        cupcake: 0\n    }, {\n        choc: 0\n    }, {\n        burnng: 0\n    }, {\n        calve: 0\n    }, {\n        bullca: 0\n    }, {\n        calves1: 0\n    }, {\n        calves2: 0\n    }, {\n        lovve: 0\n    }, {\n        calves3: 0\n    }, {\n        calves4: 0\n    }, {\n        canonn: 0\n    }, {\n        canontext: 0\n    }, {\n        canonn2: 0\n    }, {\n        canontext2: 0\n    }, {\n        canonn3: 0\n    }, {\n        mousehd: 0\n    }, {\n        maze: 0\n    }, {\n        "8Direction": 0\n    }, {\n        cathd: 0\n    }, {\n        leftmove: 0\n    }, {\n        rightmove: 0\n    }, {\n        up: 0\n    }, {\n        down: 0\n    }, {\n        solid: 0\n    }, {\n        cheaterboy: 0\n    }, {\n        chgirl: 0\n    }, {\n        boysad: 0\n    }, {\n        boyneck: 0\n    }, {\n        box: 0\n    }, {\n        sunn: 0\n    }, {\n        egg: 0\n    }, {\n        egg2: 0\n    }, {\n        egg3: 0\n    }, {\n        blueclick: 0\n    }, {\n        greencl: 0\n    }, {\n        redcl: 0\n    }, {\n        bluecnt: 0\n    }, {\n        counterBg: 0\n    }, {\n        redcnt: 0\n    }, {\n        greencnt: 0\n    }, {\n        cubes: 0\n    }, {\n        sideCube: 0\n    }, {\n        knife: 0\n    }, {\n        shape: 0\n    }, {\n        shape4: 0\n    }, {\n        shape5: 0\n    }, {\n        shape6: 0\n    }, {\n        shape7: 0\n    }, {\n        shape8: 0\n    }, {\n        eggs: 0\n    }, {\n        egghead: 0\n    }, {\n        boxx: 0\n    }, {\n        used: 0\n    }, {\n        nmbrText: 0\n    }, {\n        fishscene: 0\n    }, {\n        fed: 0\n    }, {\n        fish1: 0\n    }, {\n        fishfood: 0\n    }, {\n        fisher_bg: 0\n    }, {\n        fisher: 0\n    }, {\n        fish: 0\n    }, {\n        hook: 0\n    }, {\n        fishapple1: 0\n    }, {\n        fishapple2: 0\n    }, {\n        fishapple3: 0\n    }, {\n        half1: 0\n    }, {\n        half2: 0\n    }, {\n        form: 0\n    }, {\n        worm: 0\n    }, {\n        Physics: 0\n    }, {\n        anvil: 0\n    }, {\n        apppple: 0\n    }, {\n        brd: 0\n    }, {\n        catanvil: 0\n    }, {\n        sceneanvil: 0\n    }, {\n        seesaw: 0\n    }, {\n        leaf: 0\n    }, {\n        hopper: 0\n    }, {\n        mc: 0\n    }, {\n        gassy: 0\n    }, {\n        hat: 0\n    }, {\n        by1: 0\n    }, {\n        by2: 0\n    }, {\n        hair: 0\n    }, {\n        zeroimg: 0\n    }, {\n        mouthboy: 0\n    }, {\n        shelfsoup: 0\n    }, {\n        shelffoot1: 0\n    }, {\n        shelffoot2: 0\n    }, {\n        screw: 0\n    }, {\n        bardak: 0\n    }, {\n        hitsign: 0\n    }, {\n        role: 0\n    }, {\n        data: 0\n    }, {\n        cancel: 0\n    }, {\n        numberCounter: 0\n    }, {\n        submit: 0\n    }, {\n        tick: 0\n    }, {\n        wrong: 0\n    }, {\n        plusBtn: 0\n    }, {\n        minusBtn: 0\n    }, {\n        lang: 0\n    }, {\n        circle: 0\n    }, {\n        line: 0\n    }, {\n        submit2: 0\n    }, {\n        inputTextBg: 0\n    }, {\n        inputText: 0\n    }, {\n        comingsoon: 0\n    }, {\n        alphabet: 0\n    }, {\n        numberBtns: 0\n    }, {\n        patience: 0\n    }, {\n        rabbit: 0\n    }, {\n        scenerabbit: 0\n    }, {\n        trap: 0\n    }, {\n        boxrabbit: 0\n    }, {\n        receipt: 0\n    }, {\n        rect1: 0\n    }, {\n        rect2: 0\n    }, {\n        rect3: 0\n    }, {\n        rockk: 0\n    }, {\n        paper: 0\n    }, {\n        scissor: 0\n    }, {\n        glass: 0\n    }, {\n        tray: 0\n    }, {\n        dirtyglass: 0\n    }, {\n        shine: 0\n    }, {\n        sheepscene: 0\n    }, {\n        sheepboat: 0\n    }, {\n        shp: 0\n    }, {\n        wlf: 0\n    }, {\n        lttce: 0\n    }, {\n        childrn: 0\n    }, {\n        app1: 0\n    }, {\n        app2: 0\n    }, {\n        app3: 0\n    }, {\n        plate: 0\n    }, {\n        platetop: 0\n    }, {\n        pipe: 0\n    }, {\n        trapmc: 0\n    }, {\n        pipe3: 0\n    }, {\n        trapmc2: 0\n    }, {\n        trapmc3: 0\n    }, {\n        pipe4: 0\n    }, {\n        pipe5: 0\n    }, {\n        video: 0\n    }, {\n        robotarm: 0\n    }, {\n        superboy: 0\n    }, {\n        boytea: 0\n    }, {\n        mirror1: 0\n    }, {\n        flashlight: 0\n    }, {\n        heatt: 0\n    }, {\n        mirror2: 0\n    }, {\n        lightray: 0\n    }, {\n        lightsp: 0\n    }, {\n        lightsp2: 0\n    }, {\n        patch: 0\n    }, {\n        patch2: 0\n    }, {\n        patch3: 0\n    }, {\n        squere: 0\n    }, {\n        triangle1: 0\n    }, {\n        triangle2: 0\n    }, {\n        squere2: 0\n    }, {\n        actors: 0\n    }, {\n        wig: 0\n    }, {\n        bc: 0\n    }, {\n        alien: 0\n    }, {\n        rockscene: 0\n    }, {\n        rockscene2: 0\n    }, {\n        catal: 0\n    }, {\n        gun: 0\n    }, {\n        head: 0\n    }, {\n        yellowblow: 0\n    }, {\n        purpblow: 0\n    }, {\n        pinkblow: 0\n    }, {\n        akvaryum: 0\n    }, {\n        equpar1: 0\n    }, {\n        equpar2: 0\n    }, {\n        cake: 0\n    }, {\n        fruit1: 0\n    }, {\n        fruit2: 0\n    }, {\n        fruit3: 0\n    }, {\n        fruit4: 0\n    }, {\n        opened: 0\n    }, {\n        pos: 0\n    }, {\n        open: 0\n    }, {\n        block1: 0\n    }, {\n        mcmaze: 0\n    }, {\n        cheese: 0\n    }, {\n        cat1: 0\n    }, {\n        cat2: 0\n    }, {\n        cat4: 0\n    }, {\n        Pathfinding: 0\n    }, {\n        mched: 0\n    }, {\n        block2: 0\n    }, {\n        block3: 0\n    }, {\n        block4: 0\n    }, {\n        block5: 0\n    }, {\n        block6: 0\n    }, {\n        block7: 0\n    }, {\n        block8: 0\n    }, {\n        block9: 0\n    }, {\n        block10: 0\n    }, {\n        snowscene: 0\n    }, {\n        snowball: 0\n    }, {\n        thumb: 0\n    }, {\n        bigsnowball: 0\n    }, {\n        snowsh: 0\n    }, {\n        spiderb: 0\n    }, {\n        spiderby: 0\n    }, {\n        spiderby2: 0\n    }, {\n        barrel: 0\n    }, {\n        spiderscene: 0\n    }, {\n        roccck: 0\n    }, {\n        roccck2: 0\n    }, {\n        bat: 0\n    }, {\n        Text2: 0\n    }, {\n        wc: 0\n    }, {\n        outsign: 0\n    }, {\n        mansym: 0\n    }, {\n        mansymsk: 0\n    }, {\n        wcboy: 0\n    }, {\n        wcboyfrt: 0\n    }, {\n        outofordertext: 0\n    }, {\n        car: 0\n    }, {\n        bridge: 0\n    }, {\n        birdgeBg: 0\n    }, {\n        bridgeTouch: 0\n    }, {\n        kid: 0\n    }, {\n        salt: 0\n    }, {\n        water: 0\n    }, {\n        corba: 0\n    }, {\n        corbash: 0\n    }, {\n        saltsh: 0\n    }, {\n        watersh: 0\n    }, {\n        heat: 0\n    }, {\n        waterparticle: 0\n    }, {\n        saltparticle: 0\n    }, {\n        row: 0\n    }, {\n        column: 0\n    }, {\n        light: 0\n    }, {\n        "56Text": 0\n    }, {\n        animals: 0\n    }, {\n        shape1: 0\n    }, {\n        shape2: 0\n    }, {\n        shape3: 0\n    }, {\n        nrText: 0\n    }, {\n        lvl58cat: 0\n    }, {\n        darkroom: 0\n    }, {\n        watch: 0\n    }, {\n        road2: 0\n    }, {\n        clock: 0\n    }, {\n        clockCrack: 0\n    }, {\n        clockCrack2: 0\n    }, {\n        "3dot": 0\n    }, {\n        "60equ": 0\n    }, {\n        brothers: 0\n    }, {\n        avangers: 0\n    }, {\n        racingcarblue: 0\n    }, {\n        racingcarred: 0\n    }, {\n        racingcaryellow: 0\n    }, {\n        audience: 0\n    }, {\n        nitro: 0\n    }, {\n        BoundedDragDrop: 0\n    }, {\n        finishline: 0\n    }, {\n        Wrap: 0\n    }, {\n        racingcarblue2: 0\n    }, {\n        racingcarred2: 0\n    }, {\n        racingcaryellow2: 0\n    }, {\n        party: 0\n    }, {\n        money1: 0\n    }, {\n        money2: 0\n    }, {\n        money3: 0\n    }, {\n        money4: 0\n    }, {\n        money5: 0\n    }, {\n        wallet: 0\n    }, {\n        boy: 0\n    }, {\n        wallettop: 0\n    }, {\n        boyshadow: 0\n    }, {\n        circles: 0\n    }, {\n        scboy: 0\n    }, {\n        gardenbg: 0\n    }, {\n        dog70: 0\n    }, {\n        dogangry: 0\n    }, {\n        bone: 0\n    }, {\n        rock2: 0\n    }, {\n        shovel: 0\n    }, {\n        gardenbump: 0\n    }, {\n        apples: 0\n    }, {\n        aple: 0\n    }, {\n        aple2: 0\n    }, {\n        "6Text": 0\n    }, {\n        dlmtns: 0\n    }, {\n        catt: 0\n    }, {\n        mouse: 0\n    }, {\n        road74: 0\n    }, {\n        quest75: 0\n    }, {\n        itext: 0\n    }, {\n        "77equ": 0\n    }, {\n        minus: 0\n    }, {\n        card1: 0\n    }, {\n        card2: 0\n    }, {\n        card3: 0\n    }, {\n        card4: 0\n    }, {\n        card5: 0\n    }, {\n        miniCard5: 0\n    }, {\n        circle11: 0\n    }, {\n        circle12: 0\n    }, {\n        circle13: 0\n    }, {\n        can: 0\n    }, {\n        stove: 0\n    }, {\n        micce: 0\n    }, {\n        stick: 0\n    }, {\n        comingsoonText: 0\n    }, {\n        newLevelsText: 0\n    }, {\n        equ84: 0\n    }, {\n        "8text": 0\n    }, {\n        "4text": 0\n    }, {\n        drop1: 0\n    }, {\n        drop2: 0\n    }, {\n        drop3: 0\n    }, {\n        drop4: 0\n    }, {\n        drop5: 0\n    }, {\n        drop6: 0\n    }, {\n        scene: 0\n    }, {\n        shelf85: 0\n    }, {\n        match85: 0\n    }, {\n        canonball: 0\n    }, {\n        "85drop": 0\n    }, {\n        mice85: 0\n    }, {\n        immovable: 0\n    }, {\n        canonball2: 0\n    }, {\n        scenery: 0\n    }, {\n        woman1: 0\n    }, {\n        thief: 0\n    }, {\n        scene88: 0\n    }, {\n        trashcan: 0\n    }, {\n        cat88: 0\n    }, {\n        lightning: 0\n    }, {\n        "89equ": 0\n    }, {\n        birthdaykid: 0\n    }, {\n        car91: 0\n    }, {\n        boy91: 0\n    }, {\n        zombies: 0\n    }, {\n        ucgenler: 0\n    }, {\n        "93text": 0\n    }, {\n        cloudscene: 0\n    }, {\n        cloudscene2: 0\n    }, {\n        cloudscene3: 0\n    }, {\n        cloudscene4: 0\n    }, {\n        cloudss: 0\n    }, {\n        clown: 0\n    }, {\n        table: 0\n    }, {\n        cup1: 0\n    }, {\n        cup2: 0\n    }, {\n        cup3: 0\n    }, {\n        cupball: 0\n    }, {\n        diomandscene: 0\n    }, {\n        hairpc1: 0\n    }, {\n        hairpc2: 0\n    }, {\n        hairpc3: 0\n    }, {\n        hairpc4: 0\n    }, {\n        hairpc5: 0\n    }, {\n        dioamandtable1: 0\n    }, {\n        dioamandtable2: 0\n    }, {\n        dioamandtable3: 0\n    }, {\n        dioamandtable4: 0\n    }, {\n        dioamandtable5: 0\n    }, {\n        dioamandhat: 0\n    }, {\n        diamond: 0\n    }, {\n        tower1: 0\n    }, {\n        tower2: 0\n    }, {\n        tower3: 0\n    }, {\n        flrr: 0\n    }, {\n        gscene: 0\n    }, {\n        things1: 0\n    }, {\n        things2: 0\n    }, {\n        things3: 0\n    }, {\n        things4: 0\n    }, {\n        googlyeyes1: 0\n    }, {\n        googlyeyes2: 0\n    }, {\n        things5: 0\n    }, {\n        smile: 0\n    }, {\n        things6: 0\n    }, {\n        bodybuilder: 0\n    }, {\n        haltr: 0\n    }, {\n        bodyarm1: 0\n    }, {\n        bodyarm2: 0\n    }, {\n        weight1: 0\n    }, {\n        weight2: 0\n    }, {\n        weight3: 0\n    }, {\n        weight4: 0\n    }, {\n        hrz: 0\n    }, {\n        hrz2: 0\n    }, {\n        hrz3: 0\n    }, {\n        hrz4: 0\n    }, {\n        dot: 0\n    }, {\n        cnt1Text: 0\n    }, {\n        cnt1Text2: 0\n    }, {\n        cnt1Text3: 0\n    }, {\n        cnt1Text4: 0\n    }, {\n        blackline: 0\n    }, {\n        catmath: 0\n    }, {\n        tripart1: 0\n    }, {\n        "111text": 0\n    }, {\n        "111text2": 0\n    }, {\n        "111text3": 0\n    }, {\n        wholescene: 0\n    }, {\n        catw: 0\n    }, {\n        catw2: 0\n    }, {\n        catw3: 0\n    }, {\n        catw4: 0\n    }, {\n        catw5: 0\n    }, {\n        partbcc: 0\n    }, {\n        phonesmall: 0\n    }, {\n        phonebig: 0\n    }, {\n        noisse: 0\n    }, {\n        noisse2: 0\n    }, {\n        smilekid: 0\n    }, {\n        dragth1: 0\n    }, {\n        dragth2: 0\n    }, {\n        dragth3: 0\n    }, {\n        tablesad: 0\n    }, {\n        dragth4: 0\n    }, {\n        dragth5: 0\n    }, {\n        dragth6: 0\n    }, {\n        smile1: 0\n    }, {\n        smile2: 0\n    }, {\n        smile3: 0\n    }, {\n        smile4: 0\n    }, {\n        vampiresc: 0\n    }, {\n        vampire: 0\n    }, {\n        curt: 0\n    }, {\n        vampboy: 0\n    }, {\n        vampiredis: 0\n    }, {\n        blac: 0\n    }, {\n        curt2: 0\n    }, {\n        bwscene: 0\n    }, {\n        ths1: 0\n    }, {\n        ths2: 0\n    }, {\n        ths3: 0\n    }, {\n        ths4: 0\n    }, {\n        windowtext1: 0\n    }, {\n        windowtext2: 0\n    }, {\n        Particles3: 0\n    }, {\n        icescene: 0\n    }, {\n        iceboy: 0\n    }, {\n        icegirl: 0\n    }, {\n        icegirl2: 0\n    }, {\n        icream1: 0\n    }, {\n        icream2: 0\n    }, {\n        smileice: 0\n    }, {\n        smileice2: 0\n    }, {\n        wizardscene: 0\n    }, {\n        post: 0\n    }, {\n        wizardcard1: 0\n    }, {\n        wizardcard2: 0\n    }, {\n        wizardcard3: 0\n    }, {\n        clockprt: 0\n    }, {\n        akrp: 0\n    }, {\n        yelkvn: 0\n    }, {\n        torteise: 0\n    }, {\n        torteise2: 0\n    }, {\n        rocket: 0\n    }, {\n        rabbt: 0\n    }, {\n        rocketfire: 0\n    }, {\n        unicornsc: 0\n    }, {\n        unicorn: 0\n    }, {\n        unicornstar: 0\n    }, {\n        wizard: 0\n    }, {\n        wizard2: 0\n    }, {\n        magicsign: 0\n    }, {\n        fallingstar: 0\n    }, {\n        twig: 0\n    }, {\n        unlocksc: 0\n    }, {\n        lock: 0\n    }, {\n        ps: 0\n    }, {\n        lock2: 0\n    }, {\n        lock3: 0\n    }, {\n        seperat: 0\n    }, {\n        matt: 0\n    }, {\n        key: 0\n    }, {\n        tickleboy: 0\n    }, {\n        dice: 0\n    }, {\n        dicepaper: 0\n    }, {\n        babyspider: 0\n    }, {\n        babyspider2: 0\n    }, {\n        shaked: 0\n    }, {\n        parach1: 0\n    }, {\n        parach2: 0\n    }, {\n        parach3: 0\n    }, {\n        parachreal: 0\n    }, {\n        pst: 0\n    }, {\n        fallingsign1: 0\n    }, {\n        lastparach: 0\n    }, {\n        sonnametext: 0\n    }, {\n        sonname: 0\n    }, {\n        animalsscene: 0\n    }, {\n        horse: 0\n    }, {\n        snake: 0\n    }, {\n        horsehair: 0\n    }, {\n        horcemc: 0\n    }, {\n        dogg: 0\n    }, {\n        doggsh: 0\n    }, {\n        crowsc: 0\n    }, {\n        walnut: 0\n    }, {\n        crowgg: 0\n    }, {\n        walnutpc1: 0\n    }, {\n        walnutpc2: 0\n    }, {\n        walnutpc3: 0\n    }, {\n        cracksgn: 0\n    }, {\n        snowmansc: 0\n    }, {\n        snowball1: 0\n    }, {\n        snowball2: 0\n    }, {\n        snowball3: 0\n    }, {\n        snowballcloud: 0\n    }, {\n        snowball4: 0\n    }, {\n        snowball5: 0\n    }, {\n        snowball6: 0\n    }, {\n        snowball7: 0\n    }, {\n        hill1: 0\n    }, {\n        hill2: 0\n    }, {\n        snowball8: 0\n    }, {\n        lionimg: 0\n    }, {\n        liongrid: 0\n    }, {\n        corx: 0\n    }, {\n        cory: 0\n    }, {\n        liongrdpc1: 0\n    }, {\n        liongrdpc2: 0\n    }, {\n        liongrdpc3: 0\n    }, {\n        liongrdpc4: 0\n    }, {\n        liongrdpc5: 0\n    }, {\n        liongrdpc6: 0\n    }, {\n        liongrdpc7: 0\n    }, {\n        liongrdpc8: 0\n    }, {\n        papatyasc: 0\n    }, {\n        papatyasc2: 0\n    }, {\n        flobase: 0\n    }, {\n        ang: 0\n    }, {\n        leafp: 0\n    }, {\n        toka: 0\n    }, {\n        toka2: 0\n    }, {\n        emsc: 0\n    }, {\n        emsc2: 0\n    }, {\n        emgcar1: 0\n    }, {\n        emgcar2: 0\n    }, {\n        emgcar3: 0\n    }, {\n        emgcar4: 0\n    }, {\n        emgcar5: 0\n    }, {\n        emgcar6: 0\n    }, {\n        blinker: 0\n    }, {\n        doorcar: 0\n    }, {\n        doorcarhandler: 0\n    }, {\n        tabela: 0\n    }, {\n        tabela2: 0\n    }, {\n        tabelatext1: 0\n    }, {\n        tabelatext2: 0\n    }, {\n        ghostscene: 0\n    }, {\n        ghostwizard: 0\n    }, {\n        ghosttrap: 0\n    }, {\n        ghost: 0\n    }, {\n        pers: 0\n    }, {\n        pers2: 0\n    }, {\n        chsn: 0\n    }, {\n        pers3: 0\n    }, {\n        catjumpscene: 0\n    }, {\n        mashroom: 0\n    }, {\n        offsc: 0\n    }, {\n        thingsco1: 0\n    }, {\n        thingsco2: 0\n    }, {\n        thingsco3: 0\n    }, {\n        lid: 0\n    }, {\n        policeface: 0\n    }, {\n        birthdaygf1: 0\n    }, {\n        birthdaygfl1: 0\n    }, {\n        birthdaygf2: 0\n    }, {\n        birthdaygf3: 0\n    }, {\n        birthdaygfl2: 0\n    }, {\n        birthdaygfl3: 0\n    }, {\n        ratp: 0\n    }, {\n        explosion: 0\n    }, {\n        clownhead: 0\n    }, {\n        spring: 0\n    }, {\n        boxer1: 0\n    }, {\n        boxer2: 0\n    }, {\n        ringboxer: 0\n    }, {\n        ringboxer2: 0\n    }, {\n        boxerglovebig: 0\n    }, {\n        ringball: 0\n    }, {\n        fighterblue1: 0\n    }, {\n        fighterblue2: 0\n    }, {\n        fighterblue3: 0\n    }, {\n        fighterred1: 0\n    }, {\n        fighterred2: 0\n    }, {\n        fighterred3: 0\n    }, {\n        fightercanon: 0\n    }, {\n        fightercanon2: 0\n    }, {\n        fighterbg: 0\n    }, {\n        fball: 0\n    }, {\n        futb1: 0\n    }, {\n        ftb: 0\n    }, {\n        futb2: 0\n    }, {\n        matchcourt: 0\n    }, {\n        a183: 0\n    }, {\n        a184: 0\n    }, {\n        a185: 0\n    }, {\n        a186: 0\n    }, {\n        a187: 0\n    }, {\n        a188: 0\n    }, {\n        back181: 0\n    }, {\n        brnchh: 0\n    }, {\n        bteet1: 0\n    }, {\n        bteet2: 0\n    }, {\n        bteet3: 0\n    }, {\n        bteet4: 0\n    }, {\n        car182: 0\n    }, {\n        car183: 0\n    }, {\n        car184: 0\n    }, {\n        car185: 0\n    }, {\n        chse: 0\n    }, {\n        cn186: 0\n    }, {\n        cn187: 0\n    }, {\n        cn188: 0\n    }, {\n        changed: 0\n    }, {\n        cntxt: 0\n    }, {\n        cntxt2: 0\n    }, {\n        detect: 0\n    }, {\n        farre: 0\n    }, {\n        fbox: 0\n    }, {\n        fcat: 0\n    }, {\n        fplate: 0\n    }, {\n        hayri: 0\n    }, {\n        hayri2: 0\n    }, {\n        hayri3: 0\n    }, {\n        hayri4: 0\n    }, {\n        hayri5: 0\n    }, {\n        hayri6: 0\n    }, {\n        hayri7: 0\n    }, {\n        holle: 0\n    }, {\n        kitchen: 0\n    }, {\n        lama187: 0\n    }, {\n        lama188: 0\n    }, {\n        lama189: 0\n    }, {\n        lama190: 0\n    }, {\n        monkey184: 0\n    }, {\n        monkey185: 0\n    }, {\n        monkey186: 0\n    }, {\n        monkey187: 0\n    }, {\n        monkey188: 0\n    }, {\n        Flash: 0\n    }, {\n        mtl: 0\n    }, {\n        plte: 0\n    }, {\n        rain187: 0\n    }, {\n        rck1: 0\n    }, {\n        rck2: 0\n    }, {\n        rck3: 0\n    }, {\n        rck4: 0\n    }, {\n        shovell: 0\n    }, {\n        spit: 0\n    }, {\n        teet1: 0\n    }, {\n        teet2: 0\n    }, {\n        teet3: 0\n    }, {\n        teet4: 0\n    }, {\n        teethyboy: 0\n    }, {\n        trsr: 0\n    }, {\n        mothersc: 0\n    }, {\n        lioness: 0\n    }, {\n        lionesshead: 0\n    }, {\n        lionlay: 0\n    }, {\n        lionhead: 0\n    }, {\n        lionch1: 0\n    }, {\n        lionhair: 0\n    }, {\n        flwer: 0\n    }, {\n        butterfly: 0\n    }, {\n        firstText: 0\n    }, {\n        firstText2: 0\n    }, {\n        firstText3: 0\n    }, {\n        goneText: 0\n    }, {\n        levels: 0\n    }, {\n        level: 0\n    }, {\n        levelSelectBtn: 0\n    }, {\n        levelSelectText: 0\n    }, {\n        backBtn: 0\n    }, {\n        leftBtn: 0\n    }, {\n        rightBtn: 0\n    }, {\n        readyBtn: 0\n    }, {\n        startText: 0\n    }, {\n        arraySelectList: 0\n    }, {\n        settingsText: 0\n    }, {\n        langDown: 0\n    }, {\n        langText: 0\n    }, {\n        langBg: 0\n    }, {\n        langClose: 0\n    }, {\n        langTextBg: 0\n    }, {\n        langBgChosen: 0\n    }, {\n        Arm: 0\n    }, {\n        BG: 0\n    }, {\n        Car2: 0\n    }, {\n        Head_Looking: 0\n    }, {\n        Line_Back: 0\n    }, {\n        Line_Front: 0\n    }, {\n        Rudolph_Nose: 0\n    }, {\n        Rudolph_scarf: 0\n    }, {\n        Rudolph_ShinyNose: 0\n    }, {\n        Normal_Nose: 0\n    }, {\n        Reindeer_Backleg: 0\n    }, {\n        Reindeer_Body: 0\n    }, {\n        Reindeer_Frontleg: 0\n    }, {\n        Reindeer_Head: 0\n    }, {\n        Asset: 0\n    }, {\n        Asset2: 0\n    }, {\n        Boy1_NormalFace: 0\n    }, {\n        Boy2: 0\n    }, {\n        Boy2_NormalFace: 0\n    }, {\n        Boy3: 0\n    }, {\n        charcoal: 0\n    }, {\n        Extra_Gift: 0\n    }, {\n        Extra_Gift2: 0\n    }, {\n        Extra_Gift3: 0\n    }, {\n        Fireplace: 0\n    }, {\n        Giftopen_lid: 0\n    }, {\n        Main_Gift: 0\n    }, {\n        toycar: 0\n    }, {\n        Tree2: 0\n    }, {\n        roomline: 0\n    }, {\n        backline: 0\n    }, {\n        bg2: 0\n    }, {\n        bigstar: 0\n    }, {\n        bulb_off: 0\n    }, {\n        bulb_off2: 0\n    }, {\n        button_off: 0\n    }, {\n        cable: 0\n    }, {\n        cat6: 0\n    }, {\n        cat_dizzysign: 0\n    }, {\n        cat_normalface: 0\n    }, {\n        cateyes_: 0\n    }, {\n        cateyes_2: 0\n    }, {\n        chris: 0\n    }, {\n        christmasText: 0\n    }, {\n        Fat_backleg: 0\n    }, {\n        Fat_backleg2: 0\n    }, {\n        curindex: 0\n    }, {\n        selfX: 0\n    }, {\n        selfY: 0\n    }, {\n        Fat_body1: 0\n    }, {\n        Fat_body2: 0\n    }, {\n        Fat_body3: 0\n    }, {\n        Fat_frontleg: 0\n    }, {\n        Fat_frontleg2: 0\n    }, {\n        Fat_Head: 0\n    }, {\n        frontline: 0\n    }, {\n        newyear_chimneysnowpiece: 0\n    }, {\n        newyear_giftbag: 0\n    }, {\n        newyear_giftbagsnowpiece: 0\n    }, {\n        newyear_hammer: 0\n    }, {\n        newyear_roof: 0\n    }, {\n        newyear_santaarm: 0\n    }, {\n        newyear_santafat: 0\n    }, {\n        rudolph_backleg: 0\n    }, {\n        rudolph_backleg2: 0\n    }, {\n        rudolph_body: 0\n    }, {\n        rudolph_frontleg: 0\n    }, {\n        rudolph_frontleg2: 0\n    }, {\n        Rudolph_Happyface: 0\n    }, {\n        Rudolph_Head: 0\n    }, {\n        Santa_Arm: 0\n    }, {\n        Santa_Car: 0\n    }, {\n        Santa_Head: 0\n    }, {\n        Santa_ScaredFace: 0\n    }, {\n        select: 0\n    }, {\n        Thin_backleg: 0\n    }, {\n        Thin_backleg2: 0\n    }, {\n        value: 0\n    }, {\n        Thin_body1: 0\n    }, {\n        Thin_body2: 0\n    }, {\n        Thin_body3: 0\n    }, {\n        Thin_frontleg: 0\n    }, {\n        Thin_frontleg2: 0\n    }, {\n        Thin_head: 0\n    }, {\n        Touch: 0\n    }, {\n        Audio: 0\n    }, {\n        Browser: 0\n    }, {\n        AJAX: 0\n    }, {\n        LocalStorage: 0\n    }, {\n        PlatformInfo: 0\n    }, {\n        home: 0\n    }, {\n        ArrayLevels: 0\n    }, {\n        readyText: 0\n    }, {\n        JSON: 0\n    }, {\n        Texts: 0\n    }, {\n        nextText: 0\n    }, {\n        ArraySkipped: 0\n    }, {\n        ikon_: 0\n    }, {\n        Sprite: 0\n    }, {\n        loadText: 0\n    }, {\n        globalBoost: 0\n    }, {\n        globalText: 0\n    }, {\n        globalSprites: 0\n    }, {\n        level41: 0\n    }, {\n        boost: 0\n    }, {\n        konfetti: 0\n    }, {\n        cards: 0\n    }, {\n        calves: 0\n    }, {\n        blocks: 0\n    }, {\n        googly: 0\n    }, {\n        lionpcf: 0\n    }, {\n        teet: 0\n    }, {\n        reinBody: 0\n    }, {\n        thin_body: 0\n    }, {\n        fat_body: 0\n    }, {\n        numTrackingCode: 0\n    }, {\n        blueTickCount: 0\n    }, {\n        correctAnswer: 0\n    }, {\n        opacityValue: 0\n    }, {\n        first_x: 0\n    }, {\n        first_y: 0\n    }, {\n        popped: 0\n    }, {\n        salted: 0\n    }, {\n        watered: 0\n    }, {\n        row1: 0\n    }, {\n        row2: 0\n    }, {\n        row3: 0\n    }, {\n        row4: 0\n    }, {\n        row5: 0\n    }, {\n        column1: 0\n    }, {\n        column2: 0\n    }, {\n        column3: 0\n    }, {\n        column4: 0\n    }, {\n        column5: 0\n    }, {\n        carinc: 0\n    }, {\n        cardindex1: 0\n    }, {\n        cardindex2: 0\n    }, {\n        cardindex3: 0\n    }, {\n        cardindex4: 0\n    }, {\n        cardindex5: 0\n    }, {\n        globalindex: 0\n    }, {\n        cardbool1: 0\n    }, {\n        cardbool2: 0\n    }, {\n        cardbool3: 0\n    }, {\n        cardbool4: 0\n    }, {\n        wait: 0\n    }, {\n        numc: 0\n    }, {\n        numd: 0\n    }, {\n        speed: 0\n    }, {\n        trackingCount: 0\n    }, {\n        appleCount: 0\n    }, {\n        fallCount: 0\n    }, {\n        result: 0\n    }, {\n        curr: 0\n    }, {\n        phonenumber: 0\n    }, {\n        frame: 0\n    }, {\n        localX: 0\n    }, {\n        localY: 0\n    }, {\n        clickable: 0\n    }, {\n        counterNumber: 0\n    }, {\n        counterNumber2: 0\n    }, {\n        hintPrice: 0\n    }, {\n        skipPrice: 0\n    }, {\n        adPrice: 0\n    }, {\n        back: 0\n    }, {\n        hintPressed: 0\n    }, {\n        waitTime: 0\n    }, {\n        shopreturn: 0\n    }, {\n        globalBool: 0\n    }, {\n        levelTrans: 0\n    }, {\n        sureTransText: 0\n    }, {\n        skipTransText: 0\n    }, {\n        sureTransBtnText: 0\n    }, {\n        skipTransBtnText: 0\n    }, {\n        turnText: 0\n    }, {\n        christmas: 0\n    }, {\n        check: 0\n    }, {\n        surePriceText: 0\n    }, {\n        sureBtnType: 0\n    }, {\n        withHint: 0\n    }, {\n        curLevel: 0\n    }, {\n        x: 0\n    }, {\n        y: 0\n    }, {\n        kab: 0\n    }, {\n        part: 0\n    }, {\n        levelSortStart: 0\n    }, {\n        levelSortValue: 0\n    }, {\n        levelMaxSize: 0\n    }, {\n        levelCapSize: 0\n    }, {\n        dataReady: 0\n    }, {\n        coins: 0\n    }, {\n        date: 0\n    }, {\n        giftReady: 0\n    }, {\n        shareText: 0\n    }, {\n        curIndex: 0\n    }, {\n        curIndex2: 0\n    }, {\n        rowc1: 0\n    }, {\n        rowc2: 0\n    }, {\n        rowc3: 0\n    }, {\n        levelSortStart2: 0\n    }];\n}\n\n{\n\n    const C3 = self.C3;\n\n    function unaryminus(n) {\n        return (typeof n === "number" ? -n : n);\n    }\n\n    function bothNumbers(a, b) {\n        return typeof a === "number" && typeof b === "number";\n    }\n\n    function add(l, r) {\n        if (bothNumbers(l, r))\n            return l + r;\n        else\n            return l;\n    }\n\n    function subtract(l, r) {\n        if (bothNumbers(l, r))\n            return l - r;\n        else\n            return l;\n    }\n\n    function multiply(l, r) {\n        if (bothNumbers(l, r))\n            return l * r;\n        else\n            return l;\n    }\n\n    function divide(l, r) {\n        if (bothNumbers(l, r))\n            return l \/ r;\n        else\n            return l;\n    }\n\n    function mod(l, r) {\n        if (bothNumbers(l, r))\n            return l % r;\n        else\n            return l;\n    }\n\n    function pow(l, r) {\n        if (bothNumbers(l, r))\n            return Math.pow(l, r);\n        else\n            return l;\n    }\n\n    function and(l, r) {\n        if (typeof l === "string" || typeof r === "string") {\n            \/\/ & with either side string does string concatenation\n            let lstr, rstr;\n\n            if (typeof l === "number")\n                lstr = (Math.round(l * 1e10) \/ 1e10).toString();\n            else\n                lstr = l;\n\n            if (typeof r === "number")\n                rstr = (Math.round(r * 1e10) \/ 1e10).toString();\n            else\n                rstr = r;\n\n            return lstr + rstr;\n        } else {\n            \/\/ & with neither side a string does logical AND\n            return (l && r ? 1 : 0);\n        }\n    }\n\n    function or(l, r) {\n        if (bothNumbers(l, r))\n            return (l || r ? 1 : 0);\n        else\n            return l;\n    }\n\n    self.C3_ExpressionFuncs = [ () => "numeric16", () => "", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject();\n    }\n    , () => "7", p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        const n1 = p._GetNode(1);\n        return () => f0(n1.ExpObject());\n    }\n    , () => 5, () => 0, p => {\n        const n0 = p._GetNode(0);\n        return () => and(n0.ExpObject(), 0);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        const n1 = p._GetNode(1);\n        return () => and(n0.ExpObject(), n1.ExpObject());\n    }\n    , () => 50, p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => f0(0);\n    }\n    , () => -135, () => -45, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 200);\n    }\n    , () => 337, () => 145, () => 200, () => -50, () => 0.1, () => 1, p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("sound");\n    }\n    , () => -10, () => 0.2, () => 360, () => 640, () => "hopper", () => 0.3, () => "mouse", () => "leaf", () => "cat", () => 40, () => 341, () => 429, () => 874, () => "incr10", p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => v0.GetValue();\n    }\n    , () => 12, () => 100, () => 0.6, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 50);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 80);\n    }\n    , () => 0.5, () => 330, () => 332, () => 285, () => 284, () => 286, () => 313, () => 331, () => 600, () => 20, () => "15 x 15 x 15 = 45", () => "15 + 15 x 15 = 45", () => "15 x 15 + 15 = 45", () => "15 + 15 + 15 = 45", () => 0.4, () => -60, () => -30, () => 0.8, () => 338, () => "numeric2", () => "15", () => 2, () => 3, () => -100, () => 370, () => 210, () => 585, p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("question_11");\n    }\n    , () => 354, () => 410, p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        const n1 = p._GetNode(1);\n        return () => f0(n1.ExpObject("language"), 2);\n    }\n    , () => "tr", () => 164, () => "es", () => "pt", () => 288, () => "it", () => "de", () => 366, () => "vi", () => "pl", () => 302, () => "ru", () => 326, () => "ko", () => 101, () => "ja", () => 70, () => "th", () => 304, () => "ar", () => "ms", () => 290, () => "in", () => 250, () => "zh", () => 234, () => "cs", () => "hu", () => 173, () => "hi", () => 214, () => 272, p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("march");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("february");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("may");\n    }\n    , () => "merak", () => 190, () => 252, () => "curiosidad", () => 352, () => "curiosidade", () => 356, () => "curiosità", () => "Neugier", () => 91, () => "tò mò", () => 357, () => "ciekawość", () => "любопытство", () => 334, () => "호기심", () => "الفضول", () => 473, () => "rasa nak tahu", () => 340, () => 232, () => "好奇心", () => 198, () => "kíváncsiság", () => 527, () => "जिज्ञासा", () => 404, () => "curiosity", () => 282, () => "inc", () => 9, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 30);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 30);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("knights");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("barbarians");\n    }\n    , () => "numeric6", () => "27", () => 8, p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("custom1_20");\n    }\n    , () => "1", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpInstVar();\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (v0.GetValue() + 1);\n    }\n    , () => "49", () => 49, () => "80", () => 80, () => "5", () => 7, () => "11", () => 11, () => "101", () => 4, () => 6, p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("question_20");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Mavi düğmeye ", v0.GetValue()) + " kez tıkla.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Toca el botón azul ", v0.GetValue()) + " veces.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Clique no botão azul ", v0.GetValue()) + " vezes.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Fai clic sul pulsante blu ", v0.GetValue()) + " volte.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Tippe ", v0.GetValue()) + "-mal auf den blauen Knopf.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Nhấp vào nút màu xanh ", v0.GetValue()) + " lần.");\n    }\n    , () => "fr", p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Appuyez ", v0.GetValue()) + " fois sur le bouton bleu.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Naciśnij niebieski przycisk ", v0.GetValue()) + " razy.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Нажми на синюю кнопку ", v0.GetValue()) + " раз.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("파란색 버튼을 ", v0.GetValue()) + "번 클릭하세요.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("青いボタンを", v0.GetValue()) + "回押してください。.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("กดปุ่มสีน้ำเงิน ", v0.GetValue()) + " ที.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("नीले बटन क ", v0.GetValue()) + " बार क्लिक करें।");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Koppints a kék gombra ", v0.GetValue()) + " alkalommal.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Klikni krát na modré ", v0.GetValue()) + " tlačítko.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Tekan butang biru ", v0.GetValue()) + " kali.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("مرات ", v0.GetValue()) + " انقر على الزر الأزرق");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Tekan tombol biru ", v0.GetValue()) + " kali.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("按藍色按鈕 ", v0.GetValue()) + " 次。");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Click on the blue button ", v0.GetValue()) + " times.");\n    }\n    , () => "numeric11", () => "12", p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 96);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 96);\n    }\n    , () => 150, () => 300, () => 237, () => "Kırmızı", () => 322, () => "rojo", () => 280, () => "vermelho", () => 520, () => "rosso", () => 258, () => "rote", () => 346, () => "màu đỏ", () => 426, () => "rouge", () => "czerwony", () => 220, () => "Красный", () => 154, () => "빨간색", () => 55, () => "赤", () => 440, () => "สีแดง", () => 407, () => "الأحمر", () => 350, () => "merah", () => 293, () => 273, () => "紅", () => 259, () => "Červená", () => 433, () => "piros", () => 216, () => "लाल", () => 329, () => "red", () => "Kara", () => 240, () => "negro", () => "negra", () => 508, () => "nera", () => 478, () => "schwarze", () => 418, () => "đen", () => "noir", () => 486, () => "czarna", () => 383, () => "черная", () => 328, () => "검은색", () => 207, () => "黒", () => 162, () => "ดำ", () => 320, () => "أسود", () => 267, () => "hitam", () => 467, () => 479, () => "黑色", () => 251, () => "černo", () => "fekete", () => 333, () => "काला", () => 275, () => "black", () => 405, () => 2000, () => -2000, () => -1000, () => 2200, () => "numeric5", () => "10", () => "numeric", () => "40", () => "E", () => "O", () => "T", () => "D", () => "Y", () => "G", p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        const n1 = p._GetNode(1);\n        return () => f0("ABCDEFGHIJKLMNOPQRSTUVWXYZ", n1.ExpObject(), 1);\n    }\n    , () => "Başla!", () => "Los!", () => "ĐUA NÀO!", () => "ПОЕХАЛИ!", () => "Go!", () => 1700, () => 1.5, () => 2.5, () => 167, () => 170, () => 161, p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("dog");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("kit");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("calf");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("mitty");\n    }\n    , () => 570, () => 598, () => 464, () => "Hund", () => "Katze", () => "Kalb", () => "Miez", () => 534, () => 523, () => 189, () => 309, () => 283, () => 298, () => 238, () => 516, () => 291, () => 192, () => 335, () => "EquControl", () => "numeric7", () => "32", () => 10, () => 336, () => 400, p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => and("SEV YE ", v0.GetValue());\n    }\n    , () => 365, () => 303, () => "İ", p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => and("NIVE  ", v0.GetValue());\n    }\n    , () => 395, () => "L", p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => and("NÍVE  ", v0.GetValue());\n    }\n    , () => 576, p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => and("LIVEL  O ", v0.GetValue());\n    }\n    , () => 457, p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => and("LEVE  ", v0.GetValue());\n    }\n    , () => 397, p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => and("CẤ  ĐỘ ", v0.GetValue());\n    }\n    , () => 430, () => "P", p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => and("NIVEA    ", v0.GetValue());\n    }\n    , () => 494, () => "U", p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => and("POZIO    ", v0.GetValue());\n    }\n    , () => 502, () => "M", p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => and("УРОВЕН    ", v0.GetValue());\n    }\n    , () => 387, () => "Ь", p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => and("TAHA   ", v0.GetValue());\n    }\n    , () => 392, () => 549, () => 462, p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => and("ÚROVE   ", v0.GetValue());\n    }\n    , () => 409, () => 514, () => "Ň", p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => and("SZIN  ", v0.GetValue());\n    }\n    , () => 391, p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => and("लेव   ", v0.GetValue());\n    }\n    , () => 386, () => 160, () => "ल", () => 375, p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("custom1_42");\n    }\n    , () => 470, () => 540, () => 342, () => 491, () => 436, () => 471, () => 339, () => 454, () => 442, () => 351, () => "Bu sorudaki hatayi bul.", () => "Encuentra el error aqui.", () => "Encontre o incorreto aqui.", () => "Trova l\'errore qui.", () => "Finde den Fehler.", () => "Znajdź tu błąd.", () => "Найди здесь ошибку.", () => "여기서 잘못된 것을 찾으세요.", () => "間違いを探してくでさい。", () => "Find the mistake here.", () => 135, () => 180, () => -180, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 900);\n    }\n    , () => "ates", () => 385, () => 441, () => 420, () => 460, () => 310, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 60);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 100);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 80);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 140);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 70);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 5);\n    }\n    , () => 450, () => 550, () => 95, () => "Isso é um touro, não uma \\n arara-              .", () => "vermelha", () => 292, () => 158, () => "rot", () => 209, () => "roz", () => "красная", () => 257, () => 168, () => 306, () => 388, () => 363, () => 343, () => 638, () => "numeric8", () => "25", () => "numeric9", p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("1000  +  50  =  ", (v0.GetValue() + 10)) + "50");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => and(n0.ExpObject("level_50_title"), "     ");\n    }\n    , () => 439, () => 428, () => 446, () => 425, () => 438, () => 422, () => 424, p => {\n        const v0 = p._GetNode(0).GetVar();\n        const v1 = p._GetNode(1).GetVar();\n        return () => (and((and("1000  +  ", v0.GetValue()) + "50  =  "), (v1.GetValue() + 10)) + "50");\n    }\n    , () => 380, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 50);\n    }\n    , () => 121, () => 595, () => 700, () => 780, () => "submit", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("question_56");\n    }\n    , () => "incr2", () => -717750023016447, () => -1023, p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("front");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("back");\n    }\n    , () => "incr", () => "car", () => 102, () => 500, p => {\n        const n0 = p._GetNode(0);\n        const v1 = p._GetNode(1).GetVar();\n        return () => (n0.ExpObject() + v1.GetValue());\n    }\n    , () => "numeric10", () => "9 9 9 ", p => {\n        const n0 = p._GetNode(0);\n        return () => (and(n0.ExpObject(), 0) + " ");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        const n1 = p._GetNode(1);\n        return () => (and(n0.ExpObject(), n1.ExpObject()) + " ");\n    }\n    , () => "incr3", p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => (f0(0) - 50);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 20);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 150);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 90);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 120);\n    }\n    , () => "incr4", () => "bark", () => "kidcry", () => 226, () => 794, p => {\n        const n0 = p._GetNode(0);\n        const n1 = p._GetNode(1);\n        const f2 = p._GetNode(2).GetBoundMethod();\n        const f3 = p._GetNode(3).GetBoundMethod();\n        return () => C3.toDegrees(C3.angleTo(n0.ExpObject(), n1.ExpObject(), f2(0), f3(0)));\n    }\n    , () => 146, () => 382, () => 421, () => 419, () => 398, () => 324, () => 481, () => 423, () => 401, () => 359, () => 411, () => 377, () => "en1", () => 432, () => "en3", () => "en4", () => 141, () => "en5", () => "en6", () => "en7", () => 636, () => 278, () => 681, () => 597, () => 586, () => 157, () => 260, () => 376, () => 459, () => 493, () => 445, () => 239, () => 254, () => 583, () => 394, () => 281, () => 535, () => 277, () => 406, () => 175, () => 498, () => 297, () => 671, () => 615, () => 390, () => 602, () => 553, () => 519, () => 262, () => 191, () => 610, () => 261, () => 568, () => 476, () => 474, () => 556, () => 518, () => 253, () => 647, () => "incr5", () => 45, () => "cry", () => "Don", () => 577, () => 211, () => 249, () => "아이", () => 96, () => "I", () => 92, () => "- 9 9 9 ", () => "numeric13", () => "card", () => "asama", () => "Pick the red color!", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("custom1_78");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("blue");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("purple");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("red");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("custom2_78");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("black");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("yellow");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("orange");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("custom3_78");\n    }\n    , () => 581, () => "A", () => "H", () => "N", p => {\n        const n0 = p._GetNode(0);\n        const f1 = p._GetNode(1).GetBoundMethod();\n        const n2 = p._GetNode(2);\n        return () => (n0.ExpObject() + f1("ABCDEFGHIJKLMNOPQRSTUVWXYZ", n2.ExpObject(), 1));\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => Math.floor((v0.GetValue() \/ 10));\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        const v1 = p._GetNode(1).GetVar();\n        return () => (v0.GetValue() - (v1.GetValue() * 10));\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        const v1 = p._GetNode(1).GetVar();\n        return () => and("X + Y = ", (v0.GetValue() + v1.GetValue()));\n    }\n    , () => 451, () => 414, () => 435, () => 449, () => 466, () => 417, () => 434, () => 413, p => {\n        const v0 = p._GetNode(0).GetVar();\n        const v1 = p._GetNode(1).GetVar();\n        const v2 = p._GetNode(2).GetVar();\n        return () => and(and(v0.GetValue(), " + Y = "), (v1.GetValue() + v2.GetValue()));\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        const v1 = p._GetNode(1).GetVar();\n        const v2 = p._GetNode(2).GetVar();\n        const v3 = p._GetNode(3).GetVar();\n        return () => and((and(and(v0.GetValue(), " + "), v1.GetValue()) + " = "), (v2.GetValue() + v3.GetValue()));\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        const v1 = p._GetNode(1).GetVar();\n        const v2 = p._GetNode(2).GetVar();\n        return () => and((and("X + ", v0.GetValue()) + " = "), (v1.GetValue() + v2.GetValue()));\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        const n1 = p._GetNode(1);\n        return () => (n0.ExpObject() - n1.ExpObject());\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        const n1 = p._GetNode(1);\n        return () => ((n0.ExpObject() + 20) - n1.ExpObject());\n    }\n    , () => "en", () => "578", () => 578, () => "66", () => 66, () => "-5", () => -5, () => "1008", () => 1008, () => "522", () => 522, () => "-459", () => -459, () => "incr6", () => 373, () => 289, () => 447, () => 448, () => 279, () => 469, () => 347, () => 452, () => 345, () => 39, () => "wat", p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (-v0.GetValue());\n    }\n    , () => "incr7", () => "elephant", () => "lion", () => "mice", () => "tree", () => "countt", p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (v0.GetValue() + 2);\n    }\n    , () => 307, () => 515, () => 355, () => 620, () => 680, () => 750, p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("next_levels");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("coming_soon");\n    }\n    , () => 325, () => 178, () => 758, () => 895, () => 490, () => 888, p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => (f0(1) - 60);\n    }\n    , () => "incr8", () => "incr9", () => "4", () => "6", () => "numeric14", p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Hadi düşen elmalardan ", v0.GetValue()) + " tane yakala.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("¡Atrapa ", v0.GetValue()) + " manzanas de las que caen!");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Pegue ", v0.GetValue()) + " maçãs caindo!");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Cattura ", v0.GetValue()) + " mele in caduta!");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Fange ", v0.GetValue()) + " fallende Äpfel!");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Hãy chụp lấy ", v0.GetValue()) + " quả táo đang rơi xuống!");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Attrapez ", v0.GetValue()) + " pommes qui tombent !");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Złap ", v0.GetValue()) + " szt. spadających jabłek!");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Поймай ", v0.GetValue()) + " падающих яблок!");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("떨어지는 사과 ", v0.GetValue()) + "개를 잡으세요!");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("落ちてくるリンゴを", v0.GetValue()) + "つキャッチしましょう");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("จงจับแอปเปิ้ลที่กำลังหล่น ", v0.GetValue()) + " ลูก");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => and(v0.GetValue(), " गिरते सेब पकड़ें!");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Kapj el ", v0.GetValue()) + " hulló almát!");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Chytni ", v0.GetValue()) + " padajících jablek.");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Tangkap ", v0.GetValue()) + " epal yang jatuh!");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("تفاحات متساقطة ", v0.GetValue()) + " التقط");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Tangkap ", v0.GetValue()) + " apel yang jatuh!");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("接住 ", v0.GetValue()) + "  個掉下來的蘋果！");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (and("Catch ", v0.GetValue()) + " Falling Apples");\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (v0.GetValue() % 3);\n    }\n    , p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => f0(100, 600);\n    }\n    , () => 1720, () => 799, () => 270, () => -500, () => 800, () => 90, () => 30, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 2);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        const f1 = p._GetNode(1).GetBoundMethod();\n        const n2 = p._GetNode(2);\n        return () => (n0.ExpInstVar() * f1(n2.ExpObject()));\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (v0.GetValue() - 300);\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        const n1 = p._GetNode(1);\n        return () => (v0.GetValue() + n1.ExpInstVar());\n    }\n    , () => "numeric15", p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 20);\n    }\n    , () => 618, () => 807, () => 501, () => 757, () => 213, () => 396, () => 85, () => 120, () => 530, () => 611, () => 674, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 10);\n    }\n    , () => 513, () => 632, () => 18, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 40);\n    }\n    , () => "numeric12", () => "2", p => {\n        const n0 = p._GetNode(0);\n        return () => ((n0.ExpObject() - 60) % 360);\n    }\n    , () => 59, () => 61, () => 125, () => 89, () => 601, () => 548, () => "3", () => "incr11", () => 105, () => 269, () => 271, () => "R", () => 323, () => 358, () => 274, () => 265, () => 217, () => 116, () => 318, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 15);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("jamaica");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("france");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("madagascar");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("usa");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("mars");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("mordor");\n    }\n    , () => 276, () => 563, () => 525, () => 255, () => 195, () => 163, () => 544, () => 308, () => "first", () => "firstt", p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 110);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 130);\n    }\n    , () => "numeric17", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("out_of_order");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("custom1_149");\n    }\n    , () => "C", () => "S", () => "numeric18", () => 712, () => 242, () => 633, () => 142, () => 686, () => 821, () => 1.6, () => 695, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 10);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("custom1_158");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("custom2_158");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("custom3_158");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("custom4_158");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        const n1 = p._GetNode(1);\n        const f2 = p._GetNode(2).GetBoundMethod();\n        const f3 = p._GetNode(3).GetBoundMethod();\n        return () => C3.distanceTo(n0.ExpObject(), n1.ExpObject(), f2(0), f3(0));\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        const n1 = p._GetNode(1);\n        const n2 = p._GetNode(2);\n        const n3 = p._GetNode(3);\n        return () => C3.distanceTo(n0.ExpObject(), n1.ExpObject(), n2.ExpObject(), n3.ExpObject());\n    }\n    , () => 484, () => 657, () => 667, () => 732, () => 742, () => 805, () => 808, p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpInstVar_Family();\n    }\n    , () => "numeric19", () => "17", () => -300, () => 1020, p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("battle");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpBehavior();\n    }\n    , () => 367, () => "K", () => 60, () => "incr12", p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => (f0(0) - 60);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 720);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 720);\n    }\n    , () => 650, () => 248, () => 660, p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => f0(100, 650);\n    }\n    , () => -150, p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => f0(1, 1.5);\n    }\n    , () => -200, () => -250, () => "Pencere", () => "taş", () => "ventana", () => "piedra", () => "janela", () => 361, () => "pedra", () => 532, () => "finestra", () => "pietra", () => "Fenster", () => "Stein", () => "cửa sổ", () => 495, () => "đá", () => "fenêtre", () => "pierre", () => 564, () => "okno", () => "kamieniem", () => "окно", () => "камнем", () => 455, () => "창문", () => "돌멩이", () => 235, () => " 窓", () => 243, () => "石", () => "หน้าต่าง", () => "ก้อนหิน", () => 487, () => "jendela", () => "batu", () => "窗户", () => "石头", () => "kamenem", () => "ablakot", () => "kővel", () => "खिड़की", () => "पत्थर", () => "النافذة", () => "الحجر", () => "tingkap", () => 552, () => "window", () => 317, () => "stone", () => 565, () => "house", p => {\n        const v0 = p._GetNode(0).GetVar();\n        const n1 = p._GetNode(1);\n        return () => and(v0.GetValue(), n1.ExpObject());\n    }\n    , () => "155", () => "911", () => "190", () => "091", () => "112", () => "113", () => "110", () => "997", () => "102", p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 5);\n    }\n    , () => 140, () => 536, p => {\n        const n0 = p._GetNode(0);\n        return () => ((97 + n0.ExpObject()) - 495);\n    }\n    , () => 653, () => 720, () => 3000, () => 6000, () => "numeric20", () => "Nur", () => 152, () => "Tavşan\\nKüçük Hanım\\nAy\\nGüneş", () => 665, () => "beba", () => "Mula\\nBebita de mamá\\nGeno\\nDuende", () => "dia", () => "Boba\\nLouca como a mãe\\nNa\\nBruxa", () => 301, () => "nata", () => "Scema\\nPazza come la mamma\\nLia\\nStrega", () => "trai", () => 134, () => "Nam\\nNhân\\nNgọc\\nHoàng", () => "mon", () => 193, () => "Yes\\nJa\\nSi\\nDa", () => "nek", () => "Osioł\\nGłupek Junior\\nJa\\nGoblin", () => " Лимо", () => "Карлик\\nЧудо-юдо\\nФи\\nНедолгожитель", () => 131, () => "나귀\\n아빠 닮은 발\\n김\\n고블린", () => "anak", () => "Banaspati\\nLeak\\nKuntil\\nGoblin", () => "fia", () => "Picuri\\nApja fia\\nFehérló\\nManócska", () => "पुत्", () => "गधा\\nउल्लू का पट्ठा\\nसु\\nकाम", () => "son", () => "Donkey\\nFool-Like-His-Father\\nJa\\nGoblin", () => "Tavşan\\nKüçük Hanım\\nAynur\\nGüneş", () => "Mula\\nBebita de mamá\\nGenobeba\\nDuende", () => "Boba\\nLouca como a mãe\\nDiana\\nBruxa", () => "Scema\\nPazza come la mamma\\nNatalia\\nStrega", () => "Nam\\nNhân\\nNgọc Trai\\nHoàng", () => "Yes\\nJa\\nSimon\\nDa", () => "Osioł\\nGłupek Junior\\nJanek\\nGoblin", () => "Карлик\\nЧудо-юдо\\nФилимон\\nНедолгожитель", () => "나귀\\n아빠 닮은 발\\n김아이\\n고블린", () => "Banaspati\\nLeak\\nKuntilanak\\nGoblin", () => "Picuri\\nApja fia\\nFehérlófia\\nManócska", () => "गधा\\nउल्लू का पट्ठा\\nसुपुत्र\\nकाम", () => "Donkey\\nFool-Like-His-Father\\nJason\\nGoblin", p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => (f0(0) - 90);\n    }\n    , p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => (f0(0) + 90);\n    }\n    , () => 790, () => 25, () => 0.05, () => -3000, p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("go");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("new_york");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("new_jersey");\n    }\n    , () => 685, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 140);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 160);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 150);\n    }\n    , () => 485, () => 488, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpInstVar_Family() - 1);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpInstVar_Family() + 1);\n    }\n    , () => -44, () => 44, () => "leafend", p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 175);\n    }\n    , () => "ICA", () => "OLAM", () => "ROMA", () => "THCELHCS", () => "SIAVUAM", () => "ATUMAM", () => "MASUK", () => "KURUB", () => "UAX", () => "ХОРОШ", () => "DAB", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("fight");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 90);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("jump");\n    }\n    , () => 472, () => 176, () => 201.6, () => "numeric21", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("fire");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject(1);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 45);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 135);\n    }\n    , () => 52, () => 22, () => 51, () => 81, () => 21, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 15);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 180);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 110);\n    }\n    , () => 349, () => 402, () => 443, () => 588, () => 114, () => 627, () => 475, () => 453, () => 1.3, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 100);\n    }\n    , () => 110, () => 244, () => 1110, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 270);\n    }\n    , () => 31, () => 75, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 55);\n    }\n    , () => 246, () => 733, () => 412, p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 1);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() - 1);\n    }\n    , () => "ZENGİN OLAYIM", () => "TENER DINERO", () => "FICAR RICO", () => "DIVENTARE RICCO", () => "REICHTUM", () => "LA RICHESSE", () => "WYCZARUJ SKARB", () => "GET RICH", () => "KUYRUĞUM OLSUN", () => "HORTUMUM OLSUN", () => "TENER COLA", () => "TENER CUERNOS", () => "TER UM RABO", () => "TER UM CHIFRE", () => "AVERE LA CODA", () => "AVERE UN CORNO", () => "WARZE", () => "BUCKEL", () => "UNE QUEUE", () => "DES CORNES", () => "WYCZARUJ OGON", () => "WYCZARUJ ROGI", () => "GROW A TAIL", () => "GROW A HORN", () => 510, () => 321, () => 584, () => "incr13", () => "Start", p => {\n        const n0 = p._GetNode(0);\n        const v1 = p._GetNode(1).GetVar();\n        return () => n0.ExpObject((v1.GetValue() + 1));\n    }\n    , () => "language", () => "start", p => {\n        const v0 = p._GetNode(0).GetVar();\n        const v1 = p._GetNode(1).GetVar();\n        return () => and(v0.GetValue(), v1.GetValue());\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("coins");\n    }\n    , () => 127, () => "Functions", () => -1675, () => "forw", () => "alkis", p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => (f0(0) - 200);\n    }\n    , () => 14, p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => f0();\n    }\n    , () => 1281, () => 1914, () => 2312, p => {\n        const n0 = p._GetNode(0);\n        const v1 = p._GetNode(1).GetVar();\n        return () => and(and(n0.ExpObject("language"), "_"), v1.GetValue());\n    }\n    , () => "skipped", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("levelreachedmax");\n    }\n    , () => "levelreachedmax", () => "level", () => "gamedata", p => {\n        const n0 = p._GetNode(0);\n        const v1 = p._GetNode(1).GetVar();\n        return () => and("Level", n0.ExpObject((v1.GetValue() + 1)));\n    }\n    , () => "skippedENC", p => {\n        const n0 = p._GetNode(0);\n        const v1 = p._GetNode(1).GetVar();\n        return () => and(and(n0.ExpObject("skippedENC"), v1.GetValue()), "#");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("levelreachedmaxc");\n    }\n    , () => "levelreachedmaxc", p => {\n        const n0 = p._GetNode(0);\n        const v1 = p._GetNode(1).GetVar();\n        return () => and("Level", n0.ExpObject(v1.GetValue(), 3));\n    }\n    , () => "ui", p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => (f0(0) - 100);\n    }\n    , () => 480, p => {\n        const n0 = p._GetNode(0);\n        const v1 = p._GetNode(1).GetVar();\n        return () => n0.ExpObject(and("question_", v1.GetValue()));\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        const v1 = p._GetNode(1).GetVar();\n        return () => n0.ExpObject(and("hint_", v1.GetValue()));\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        const v1 = p._GetNode(1).GetVar();\n        return () => n0.ExpObject(and("endText_", v1.GetValue()));\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        const v1 = p._GetNode(1).GetVar();\n        return () => n0.ExpObject(v1.GetValue(), 0);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        const v1 = p._GetNode(1).GetVar();\n        return () => n0.ExpObject(v1.GetValue(), 1);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        const v1 = p._GetNode(1).GetVar();\n        return () => n0.ExpObject(v1.GetValue(), 2);\n    }\n    , () => "coins", () => "music", () => "sound", () => "Touch Events", () => "gift", () => -680, () => 900, () => 580, () => "giftdate", () => "X25", () => "watch", () => "x50", () => "skip", () => 1773, p => {\n        const n0 = p._GetNode(0);\n        const n1 = p._GetNode(1);\n        const v2 = p._GetNode(2).GetVar();\n        return () => n0.ExpObject(and(and(n1.ExpObject("language"), "_"), v2.GetValue()));\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        const v1 = p._GetNode(1).GetVar();\n        return () => n0.ExpObject(v1.GetValue());\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        const n1 = p._GetNode(1);\n        return () => and(and(n0.ExpObject("skippedENC"), n1.ExpObject()), "#");\n    }\n    , () => "localization2", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("startScreen_button");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("startScreen_text");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("level_title");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("watch_video_title");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("watch_video_button");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("skip_level_title");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("skip_level_button");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("gift_tomorrow");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("settings_english");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("settings_share");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("nextLevel_next_button");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("submit");\n    }\n    , () => "Kaboulege", () => "PartofMe", () => "SOUND", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("settings_sound");\n    }\n    , () => "MUSIC", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("settings_music");\n    }\n    , () => "SHARE", () => "SUPPORT", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("settings_support");\n    }\n    , () => "LANGUAGE", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("settings_language");\n    }\n    , () => "SETTINGS", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("settings_title");\n    }\n    , () => "LEVELS", p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("levels_title");\n    }\n    , () => "lang", () => 58, p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("giftdate");\n    }\n    , () => "vietnam", () => "russiankab", () => "kore", () => "japan", () => "thai", p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (v0.GetValue() - 4);\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (v0.GetValue() % 5);\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => ((v0.GetValue() - 5) + 1);\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        const v1 = p._GetNode(1).GetVar();\n        return () => ((v0.GetValue() - (v1.GetValue() % 5)) + 1);\n    }\n    , p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => (120 + (180 * f0()));\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        const v1 = p._GetNode(1).GetVar();\n        const f2 = p._GetNode(2).GetBoundMethod();\n        return () => and(v0.GetValue(), (v1.GetValue() + (f2() - 1)));\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        const f1 = p._GetNode(1).GetBoundMethod();\n        return () => (v0.GetValue() + (f1() - 1));\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("language");\n    }\n    , () => "tr-TR", p => {\n        const n0 = p._GetNode(0);\n        const n1 = p._GetNode(1);\n        return () => and("Level", n0.ExpObject((n1.ExpInstVar() + 1)));\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (v0.GetValue() - 5);\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (v0.GetValue() + 5);\n    }\n    , p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        const f1 = p._GetNode(1).GetBoundMethod();\n        return () => f0(f1("Date()"), 16);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("skipped");\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("level");\n    }\n    , () => "update", () => "text", () => "levels", () => "data", p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        const f1 = p._GetNode(1).GetBoundMethod();\n        return () => f0(f1(), 2);\n    }\n    , () => 172, () => 169, () => 177, () => 166, () => 159, () => 165, () => 174, () => 179, p => {\n        const n0 = p._GetNode(0);\n        return () => n0.ExpObject("music");\n    }\n    , () => -760, () => "strings", () => 0.7, () => 54, () => -880, () => -80, p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        const n1 = p._GetNode(1);\n        return () => f0(n1.ExpInstVar());\n    }\n    , p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        const n1 = p._GetNode(1);\n        return () => f0(n1.ExpInstVar_Family());\n    }\n    , p => {\n        const v0 = p._GetNode(0).GetVar();\n        return () => (v0.GetValue() - 2);\n    }\n    , p => {\n        const n0 = p._GetNode(0);\n        return () => (n0.ExpObject() + 300);\n    }\n    , () => 230, () => 950, () => 181, () => 920, () => 187, () => 197, () => 212, () => "chr", p => {\n        const n0 = p._GetNode(0);\n        const n1 = p._GetNode(1);\n        return () => and("Level", n0.ExpObject(n1.ExpInstVar(), 3));\n    }\n    , p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => and(Math.round((f0() * 100)), "%");\n    }\n    , p => {\n        const f0 = p._GetNode(0).GetBoundMethod();\n        return () => ((f0() * 437) + 142);\n    }\n    ];\n\n}\n \n	    \n	    \n	    \n	    \n	<\/script>\n	\n	\n	\n	\n	<script>\n	    \n	    \n	    \n	    self.Box2DWasmModule = function(Box2D) {\n    Box2D = Box2D || {};\n    var Module = Box2D;\n\n    var b;\n    b || (b = eval("(function() { try { return Box2D || {} } catch(e) { return {} } })()"));\n    var aa = {}, ba;\n    for (ba in b)\n        b.hasOwnProperty(ba) && (aa[ba] = b[ba]);\n    var ca = !1\n      , da = !1\n      , ea = !1\n      , fa = !1;\n    if (b.ENVIRONMENT)\n        if ("WEB" === b.ENVIRONMENT)\n            ca = !0;\n        else if ("WORKER" === b.ENVIRONMENT)\n            da = !0;\n        else if ("NODE" === b.ENVIRONMENT)\n            ea = !0;\n        else if ("SHELL" === b.ENVIRONMENT)\n            fa = !0;\n        else\n            throw Error("The provided Module[\'ENVIRONMENT\'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.");\n    else\n        ca = "object" === typeof window,\n        da = "function" === typeof importScripts,\n        ea = "object" === typeof process && "function" === typeof require && !ca && !da,\n        fa = !ca && !ea && !da;\n    if (ea) {\n        b.print || (b.print = console.log);\n        b.printErr || (b.printErr = console.warn);\n        var ga, ha;\n        b.read = function(a, c) {\n            ga || (ga = require("fs"));\n            ha || (ha = require("path"));\n            a = ha.normalize(a);\n            var d = ga.readFileSync(a);\n            return c ? d : d.toString()\n        }\n        ;\n        b.readBinary = function(a) {\n            a = b.read(a, !0);\n            a.buffer || (a = new Uint8Array(a));\n            assert(a.buffer);\n            return a\n        }\n        ;\n        b.load = function(a) {\n            ia(read(a))\n        }\n        ;\n        b.thisProgram || (b.thisProgram = 1 < process.argv.length ? process.argv[1].replace(\/\\\\\/g, "\/") : "unknown-program");\n        b.arguments = process.argv.slice(2);\n        "undefined" !== typeof module && (module.exports = b);\n        process.on("uncaughtException", function(a) {\n            if (!(a instanceof ja))\n                throw a;\n        });\n        b.inspect = function() {\n            return "[Emscripten Module object]"\n        }\n    } else if (fa)\n        b.print || (b.print = print),\n        "undefined" != typeof printErr && (b.printErr = printErr),\n        b.read = "undefined" != typeof read ? read : function() {\n            throw "no read() available";\n        }\n        ,\n        b.readBinary = function(a) {\n            if ("function" === typeof readbuffer)\n                return new Uint8Array(readbuffer(a));\n            a = read(a, "binary");\n            assert("object" === typeof a);\n            return a\n        }\n        ,\n        "undefined" != typeof scriptArgs ? b.arguments = scriptArgs : "undefined" != typeof arguments && (b.arguments = arguments),\n        "function" === typeof quit && (b.quit = function(a) {\n            quit(a)\n        }\n        ),\n        eval("if (typeof gc === \'function\' && gc.toString().indexOf(\'[native code]\') > 0) var gc = undefined");\n    else if (ca || da)\n        b.read = function(a) {\n            var c = new XMLHttpRequest;\n            c.open("GET", a, !1);\n            c.send(null);\n            return c.responseText\n        }\n        ,\n        da && (b.readBinary = function(a) {\n            var c = new XMLHttpRequest;\n            c.open("GET", a, !1);\n            c.responseType = "arraybuffer";\n            c.send(null);\n            return new Uint8Array(c.response)\n        }\n        ),\n        b.readAsync = function(a, c, d) {\n            var e = new XMLHttpRequest;\n            e.open("GET", a, !0);\n            e.responseType = "arraybuffer";\n            e.onload = function() {\n                200 == e.status || 0 == e.status && e.response ? c(e.response) : d()\n            }\n            ;\n            e.onerror = d;\n            e.send(null)\n        }\n        ,\n        "undefined" != typeof arguments && (b.arguments = arguments),\n        "undefined" !== typeof console ? (b.print || (b.print = function(a) {\n            console.log(a)\n        }\n        ),\n        b.printErr || (b.printErr = function(a) {\n            console.warn(a)\n        }\n        )) : b.print || (b.print = function() {}\n        ),\n        da && (b.load = importScripts),\n        "undefined" === typeof b.setWindowTitle && (b.setWindowTitle = function(a) {\n            document.title = a\n        }\n        );\n    else\n        throw "Unknown runtime environment. Where are we?";\n    function ia(a) {\n        eval.call(null, a)\n    }\n    !b.load && b.read && (b.load = function(a) {\n        ia(b.read(a))\n    }\n    );\n    b.print || (b.print = function() {}\n    );\n    b.printErr || (b.printErr = b.print);\n    b.arguments || (b.arguments = []);\n    b.thisProgram || (b.thisProgram = ".\/this.program");\n    b.quit || (b.quit = function(a, c) {\n        throw c;\n    }\n    );\n    b.print = b.print;\n    b.h = b.printErr;\n    b.preRun = [];\n    b.postRun = [];\n    for (ba in aa)\n        aa.hasOwnProperty(ba) && (b[ba] = aa[ba]);\n    var aa = void 0\n      , f = {\n        f: function(a) {\n            return tempRet0 = a\n        },\n        H: function() {\n            return tempRet0\n        },\n        L: function() {\n            return ka\n        },\n        K: function(a) {\n            ka = a\n        },\n        s: function(a) {\n            switch (a) {\n            case "i1":\n            case "i8":\n                return 1;\n            case "i16":\n                return 2;\n            case "i32":\n                return 4;\n            case "i64":\n                return 8;\n            case "float":\n                return 4;\n            case "double":\n                return 8;\n            default:\n                return "*" === a[a.length - 1] ? f.j : "i" === a[0] ? (a = parseInt(a.substr(1)),\n                assert(0 === a % 8),\n                a \/ 8) : 0\n            }\n        },\n        F: function(a) {\n            return Math.max(f.s(a), f.j)\n        },\n        M: 16,\n        aa: function(a, c) {\n            "double" === c || "i64" === c ? a & 7 && (assert(4 === (a & 7)),\n            a += 4) : assert(0 === (a & 3));\n            return a\n        },\n        U: function(a, c, d) {\n            return d || "i64" != a && "double" != a ? a ? Math.min(c || (a ? f.F(a) : 0), f.j) : Math.min(c, 8) : 8\n        },\n        l: function(a, c, d) {\n            return d && d.length ? b["dynCall_" + a].apply(null, [c].concat(d)) : b["dynCall_" + a].call(null, c)\n        },\n        d: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],\n        v: function(a) {\n            for (var c = 0; c < f.d.length; c++)\n                if (!f.d[c])\n                    return f.d[c] = a,\n                    2 * (1 + c);\n            throw "Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.";\n        },\n        J: function(a) {\n            f.d[(a - 2) \/ 2] = null\n        },\n        g: function(a) {\n            f.g.n || (f.g.n = {});\n            f.g.n[a] || (f.g.n[a] = 1,\n            b.h(a))\n        },\n        m: {},\n        W: function(a, c) {\n            assert(c);\n            f.m[c] || (f.m[c] = {});\n            var d = f.m[c];\n            d[a] || (d[a] = 1 === c.length ? function() {\n                return f.l(c, a)\n            }\n            : 2 === c.length ? function(d) {\n                return f.l(c, a, [d])\n            }\n            : function() {\n                return f.l(c, a, Array.prototype.slice.call(arguments))\n            }\n            );\n            return d[a]\n        },\n        V: function() {\n            throw "You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work";\n        },\n        t: function(a) {\n            var c = ka;\n            ka = ka + a | 0;\n            ka = ka + 15 & -16;\n            return c\n        },\n        u: function(a) {\n            var c = la;\n            la = la + a | 0;\n            la = la + 15 & -16;\n            return c\n        },\n        D: function(a) {\n            var c = ma[oa >> 2];\n            a = (c + a + 15 | 0) & -16;\n            ma[oa >> 2] = a;\n            return a >= pa && !qa() ? (ma[oa >> 2] = c,\n            0) : c\n        },\n        p: function(a, c) {\n            return Math.ceil(a \/ (c ? c : 16)) * (c ? c : 16)\n        },\n        $: function(a, c, d) {\n            return d ? +(a >>> 0) + 4294967296 * +(c >>> 0) : +(a >>> 0) + 4294967296 * +(c | 0)\n        },\n        i: 1024,\n        j: 4,\n        N: 0\n    };\n    f.addFunction = f.v;\n    f.removeFunction = f.J;\n    var ra = 0;\n    function assert(a, c) {\n        a || ta("Assertion failed: " + c)\n    }\n    function ua(a) {\n        var c;\n        c = "i32";\n        "*" === c.charAt(c.length - 1) && (c = "i32");\n        switch (c) {\n        case "i1":\n            return va[a >> 0];\n        case "i8":\n            return va[a >> 0];\n        case "i16":\n            return ya[a >> 1];\n        case "i32":\n            return ma[a >> 2];\n        case "i64":\n            return ma[a >> 2];\n        case "float":\n            return za[a >> 2];\n        case "double":\n            return Aa[a >> 3];\n        default:\n            ta("invalid type for setValue: " + c)\n        }\n        return null\n    }\n    function Ba(a, c, d) {\n        var e, g, l;\n        "number" === typeof a ? (g = !0,\n        l = a) : (g = !1,\n        l = a.length);\n        var m = "string" === typeof c ? c : null, D;\n        4 == d ? D = e : D = ["function" === typeof Ca ? Ca : f.u, f.t, f.u, f.D][void 0 === d ? 2 : d](Math.max(l, m ? 1 : c.length));\n        if (g) {\n            e = D;\n            assert(0 == (D & 3));\n            for (a = D + (l & -4); e < a; e += 4)\n                ma[e >> 2] = 0;\n            for (a = D + l; e < a; )\n                va[e++ >> 0] = 0;\n            return D\n        }\n        if ("i8" === m)\n            return a.subarray || a.slice ? Da.set(a, D) : Da.set(new Uint8Array(a), D),\n            D;\n        e = 0;\n        for (var na, wa; e < l; ) {\n            var G = a[e];\n            "function" === typeof G && (G = f.X(G));\n            d = m || c[e];\n            if (0 === d)\n                e++;\n            else {\n                "i64" == d && (d = "i32");\n                g = D + e;\n                var Ga = d\n                  , Ga = Ga || "i8";\n                "*" === Ga.charAt(Ga.length - 1) && (Ga = "i32");\n                switch (Ga) {\n                case "i1":\n                    va[g >> 0] = G;\n                    break;\n                case "i8":\n                    va[g >> 0] = G;\n                    break;\n                case "i16":\n                    ya[g >> 1] = G;\n                    break;\n                case "i32":\n                    ma[g >> 2] = G;\n                    break;\n                case "i64":\n                    tempI64 = [G >>> 0, (tempDouble = G,\n                    1 <= +Ea(tempDouble) ? 0 < tempDouble ? (Fa(+Ha(tempDouble \/ 4294967296), 4294967295) | 0) >>> 0 : ~~+Ia((tempDouble - +(~~tempDouble >>> 0)) \/ 4294967296) >>> 0 : 0)];\n                    ma[g >> 2] = tempI64[0];\n                    ma[g + 4 >> 2] = tempI64[1];\n                    break;\n                case "float":\n                    za[g >> 2] = G;\n                    break;\n                case "double":\n                    Aa[g >> 3] = G;\n                    break;\n                default:\n                    ta("invalid type for setValue: " + Ga)\n                }\n                wa !== d && (na = f.s(d),\n                wa = d);\n                e += na\n            }\n        }\n        return D\n    }\n    function Ja(a) {\n        var c;\n        if (0 === c || !a)\n            return "";\n        for (var d = 0, e, g = 0; ; ) {\n            e = Da[a + g >> 0];\n            d |= e;\n            if (0 == e && !c)\n                break;\n            g++;\n            if (c && g == c)\n                break\n        }\n        c || (c = g);\n        e = "";\n        if (128 > d) {\n            for (; 0 < c; )\n                d = String.fromCharCode.apply(String, Da.subarray(a, a + Math.min(c, 1024))),\n                e = e ? e + d : d,\n                a += 1024,\n                c -= 1024;\n            return e\n        }\n        return b.UTF8ToString(a)\n    }\n    var Ka = "undefined" !== typeof TextDecoder ? new TextDecoder("utf8") : void 0;\n    function La(a, c, d, e) {\n        if (0 < e) {\n            e = d + e - 1;\n            for (var g = 0; g < a.length; ++g) {\n                var l = a.charCodeAt(g);\n                55296 <= l && 57343 >= l && (l = 65536 + ((l & 1023) << 10) | a.charCodeAt(++g) & 1023);\n                if (127 >= l) {\n                    if (d >= e)\n                        break;\n                    c[d++] = l\n                } else {\n                    if (2047 >= l) {\n                        if (d + 1 >= e)\n                            break;\n                        c[d++] = 192 | l >> 6\n                    } else {\n                        if (65535 >= l) {\n                            if (d + 2 >= e)\n                                break;\n                            c[d++] = 224 | l >> 12\n                        } else {\n                            if (2097151 >= l) {\n                                if (d + 3 >= e)\n                                    break;\n                                c[d++] = 240 | l >> 18\n                            } else {\n                                if (67108863 >= l) {\n                                    if (d + 4 >= e)\n                                        break;\n                                    c[d++] = 248 | l >> 24\n                                } else {\n                                    if (d + 5 >= e)\n                                        break;\n                                    c[d++] = 252 | l >> 30;\n                                    c[d++] = 128 | l >> 24 & 63\n                                }\n                                c[d++] = 128 | l >> 18 & 63\n                            }\n                            c[d++] = 128 | l >> 12 & 63\n                        }\n                        c[d++] = 128 | l >> 6 & 63\n                    }\n                    c[d++] = 128 | l & 63\n                }\n            }\n            c[d] = 0\n        }\n    }\n    function Oa(a) {\n        for (var c = 0, d = 0; d < a.length; ++d) {\n            var e = a.charCodeAt(d);\n            55296 <= e && 57343 >= e && (e = 65536 + ((e & 1023) << 10) | a.charCodeAt(++d) & 1023);\n            127 >= e ? ++c : c = 2047 >= e ? c + 2 : 65535 >= e ? c + 3 : 2097151 >= e ? c + 4 : 67108863 >= e ? c + 5 : c + 6\n        }\n        return c\n    }\n    "undefined" !== typeof TextDecoder && new TextDecoder("utf-16le");\n    function Pa(a) {\n        return a.replace(\/__Z[\\w\\d_]+\/g, function(a) {\n            var d;\n            a: {\n                var e = b.___cxa_demangle || b.__cxa_demangle;\n                if (e)\n                    try {\n                        var g = a.substr(1)\n                          , l = Oa(g) + 1\n                          , m = Ca(l);\n                        La(g, Da, m, l);\n                        var D = Ca(4)\n                          , na = e(m, 0, 0, D);\n                        if (0 === ua(D) && na) {\n                            d = Ja(na);\n                            break a\n                        }\n                    } catch (wa) {} finally {\n                        m && Qa(m),\n                        D && Qa(D),\n                        na && Qa(na)\n                    }\n                else\n                    f.g("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling");\n                d = a\n            }\n            return a === d ? a : a + " [" + d + "]"\n        })\n    }\n    function Ra() {\n        var a;\n        a: {\n            a = Error();\n            if (!a.stack) {\n                try {\n                    throw Error(0);\n                } catch (c) {\n                    a = c\n                }\n                if (!a.stack) {\n                    a = "(no stack trace available)";\n                    break a\n                }\n            }\n            a = a.stack.toString()\n        }\n        b.extraStackTrace && (a += "\\n" + b.extraStackTrace());\n        return Pa(a)\n    }\n    var Sa = 65536\n      , Ua = 16777216\n      , Va = 16777216;\n    function Wa(a, c) {\n        0 < a % c && (a += c - a % c);\n        return a\n    }\n    var buffer, va, Da, ya, Xa, ma, Ya, za, Aa;\n    function Za() {\n        b.HEAP8 = va = new Int8Array(buffer);\n        b.HEAP16 = ya = new Int16Array(buffer);\n        b.HEAP32 = ma = new Int32Array(buffer);\n        b.HEAPU8 = Da = new Uint8Array(buffer);\n        b.HEAPU16 = Xa = new Uint16Array(buffer);\n        b.HEAPU32 = Ya = new Uint32Array(buffer);\n        b.HEAPF32 = za = new Float32Array(buffer);\n        b.HEAPF64 = Aa = new Float64Array(buffer)\n    }\n    var $a, la, ab, ka, bb, cb, oa;\n    $a = la = ab = ka = bb = cb = oa = 0;\n    b.reallocBuffer || (b.reallocBuffer = function(a) {\n        var c;\n        try {\n            if (ArrayBuffer.e)\n                c = ArrayBuffer.e(buffer, a);\n            else {\n                var d = va;\n                c = new ArrayBuffer(a);\n                (new Int8Array(c)).set(d)\n            }\n        } catch (e) {\n            return !1\n        }\n        return db(c) ? c : !1\n    }\n    );\n    function qa() {\n        var a = b.usingWasm ? Sa : Ua\n          , c = 2147483648 - a;\n        if (ma[oa >> 2] > c)\n            return !1;\n        var d = pa;\n        for (pa = Math.max(pa, Va); pa < ma[oa >> 2]; )\n            536870912 >= pa ? pa = Wa(2 * pa, a) : pa = Math.min(Wa((3 * pa + 2147483648) \/ 4, a), c);\n        a = b.reallocBuffer(pa);\n        if (!a || a.byteLength != pa)\n            return pa = d,\n            !1;\n        b.buffer = buffer = a;\n        Za();\n        return !0\n    }\n    var eb;\n    try {\n        eb = Function.prototype.call.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get),\n        eb(new ArrayBuffer(4))\n    } catch (fb) {\n        eb = function(a) {\n            return a.byteLength\n        }\n    }\n    var gb = b.TOTAL_STACK || 5242880\n      , pa = b.TOTAL_MEMORY || 16777216;\n    pa < gb && b.h("TOTAL_MEMORY should be larger than TOTAL_STACK, was " + pa + "! (TOTAL_STACK=" + gb + ")");\n    b.buffer ? buffer = b.buffer : "object" === typeof WebAssembly && "function" === typeof WebAssembly.Memory ? (b.wasmMemory = new WebAssembly.Memory({\n        initial: pa \/ Sa\n    }),\n    buffer = b.wasmMemory.buffer) : buffer = new ArrayBuffer(pa);\n    Za();\n    ma[0] = 1668509029;\n    ya[1] = 25459;\n    if (115 !== Da[2] || 99 !== Da[3])\n        throw "Runtime error: expected the system to be little-endian!";\n    b.HEAP = void 0;\n    b.buffer = buffer;\n    b.HEAP8 = va;\n    b.HEAP16 = ya;\n    b.HEAP32 = ma;\n    b.HEAPU8 = Da;\n    b.HEAPU16 = Xa;\n    b.HEAPU32 = Ya;\n    b.HEAPF32 = za;\n    b.HEAPF64 = Aa;\n    function hb(a) {\n        for (; 0 < a.length; ) {\n            var c = a.shift();\n            if ("function" == typeof c)\n                c();\n            else {\n                var d = c.T;\n                "number" === typeof d ? void 0 === c.k ? b.dynCall_v(d) : b.dynCall_vi(d, c.k) : d(void 0 === c.k ? null : c.k)\n            }\n        }\n    }\n    var ib = []\n      , jb = []\n      , kb = []\n      , nb = []\n      , ob = []\n      , pb = !1;\n    function qb() {\n        var a = b.preRun.shift();\n        ib.unshift(a)\n    }\n    function rb(a) {\n        var c = Array(Oa(a) + 1);\n        La(a, c, 0, c.length);\n        return c\n    }\n    Math.imul && -5 === Math.imul(4294967295, 5) || (Math.imul = function(a, c) {\n        var d = a & 65535\n          , e = c & 65535;\n        return d * e + ((a >>> 16) * e + d * (c >>> 16) << 16) | 0\n    }\n    );\n    Math.Y = Math.imul;\n    if (!Math.fround) {\n        var sb = new Float32Array(1);\n        Math.fround = function(a) {\n            sb[0] = a;\n            return sb[0]\n        }\n    }\n    Math.S = Math.fround;\n    Math.clz32 || (Math.clz32 = function(a) {\n        a = a >>> 0;\n        for (var c = 0; 32 > c; c++)\n            if (a & 1 << 31 - c)\n                return c;\n        return 32\n    }\n    );\n    Math.P = Math.clz32;\n    Math.trunc || (Math.trunc = function(a) {\n        return 0 > a ? Math.ceil(a) : Math.floor(a)\n    }\n    );\n    Math.trunc = Math.trunc;\n    var Ea = Math.abs\n      , Ia = Math.ceil\n      , Ha = Math.floor\n      , Fa = Math.min\n      , tb = 0\n      , vb = null\n      , wb = null;\n    function xb() {\n        tb++;\n        b.monitorRunDependencies && b.monitorRunDependencies(tb)\n    }\n    function yb() {\n        tb--;\n        b.monitorRunDependencies && b.monitorRunDependencies(tb);\n        if (0 == tb && (null !== vb && (clearInterval(vb),\n        vb = null),\n        wb)) {\n            var a = wb;\n            wb = null;\n            a()\n        }\n    }\n    b.preloadedImages = {};\n    b.preloadedAudios = {};\n    var zb = null;\n    (function(a) {\n        function c(c) {\n            c = Wa(c, a.usingWasm ? Sa : Ua);\n            var d = a.buffer\n              , e = d.byteLength;\n            if (a.usingWasm)\n                try {\n                    return -1 !== a.wasmMemory.grow((c - e) \/ 65536) ? a.buffer = a.wasmMemory.buffer : null\n                } catch (g) {\n                    return null\n                }\n            else\n                return lb.__growWasmMemory((c - e) \/ 65536),\n                a.buffer !== d ? a.buffer : null\n        }\n        function d(a, c) {\n            var d = Ta;\n            if (0 > a.indexOf("."))\n                d = (d || {})[a];\n            else\n                var e = a.split(".")\n                  , d = (d || {})[e[0]]\n                  , d = (d || {})[e[1]];\n            c && (d = (d || {})[c]);\n            void 0 === d && ta("bad lookupImport to (" + a + ")." + c);\n            return d\n        }\n        function e(c) {\n            var d = a.buffer;\n            c.byteLength < d.byteLength && a.printErr("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here");\n            var d = new Int8Array(d)\n              , e = new Int8Array(c);\n            zb || d.set(e.subarray(a.STATIC_BASE, a.STATIC_BASE + a.STATIC_BUMP), a.STATIC_BASE);\n            e.set(d);\n            b.buffer = buffer = c;\n            Za()\n        }\n        function g() {\n            try {\n                var c;\n                if (a.wasmBinary)\n                    c = a.wasmBinary,\n                    c = new Uint8Array(c);\n                else if (a.readBinary)\n                    c = a.readBinary(G);\n                else\n                    throw "on the web, we need the wasm binary to be preloaded and set on Module[\'wasmBinary\']. emcc.py will do that for you when generating HTML (but not JS)";\n                return c\n            } catch (d) {\n                ta(d)\n            }\n        }\n        function l() {\n            return a.wasmBinary || "function" !== typeof fetch ? new Promise(function(a) {\n                a(g())\n            }\n            ) : fetch(G, {\n                Q: "same-origin"\n            }).then(function(a) {\n                if (!a.ok)\n                    throw "failed to load wasm binary file at \'" + G + "\'";\n                return a.arrayBuffer()\n            })\n        }\n        function m(c, d, e) {\n            if ("function" !== typeof a.asm || a.asm === Ma)\n                a.asmPreload ? a.asm = a.asmPreload : eval(a.read(Ga));\n            return "function" !== typeof a.asm ? (a.printErr("asm evalling did not set the module properly"),\n            !1) : a.asm(c, d, e)\n        }\n        function D(c, d) {\n            function g(c) {\n                lb = c.exports;\n                lb.memory && e(lb.memory);\n                a.asm = lb;\n                a.usingWasm = !0;\n                yb()\n            }\n            if ("object" !== typeof WebAssembly)\n                return a.printErr("no native wasm support detected"),\n                !1;\n            if (!(a.wasmMemory instanceof WebAssembly.Memory))\n                return a.printErr("no native wasm Memory in use"),\n                !1;\n            d.memory = a.wasmMemory;\n            Ta.global = {\n                NaN: NaN,\n                Infinity: Infinity\n            };\n            Ta["global.Math"] = c.Math;\n            Ta.env = d;\n            xb();\n            if (a.instantiateWasm)\n                try {\n                    return a.instantiateWasm(Ta, g)\n                } catch (m) {\n                    return a.printErr("Module.instantiateWasm callback failed with error: " + m),\n                    !1\n                }\n            l().then(function(a) {\n                return WebAssembly.instantiate(a, Ta)\n            }).then(function(a) {\n                g(a.instance)\n            }).catch(function(c) {\n                a.printErr("failed to asynchronously prepare wasm: " + c);\n                ta(c)\n            });\n            return {}\n        }\n        var na = a.wasmJSMethod || "native-wasm";\n        a.wasmJSMethod = na;\n        var wa = a.wasmTextFile || "Box2D_v2.3.1_min.wasm.wast"\n          , G = a.wasmBinaryFile || "Box2D_v2.3.1_min.wasm.wasm"\n          , Ga = a.asmjsCodeFile || "Box2D_v2.3.1_min.wasm.temp.asm.js";\n        "function" === typeof a.locateFile && (wa = a.locateFile(wa),\n        G = a.locateFile(G),\n        Ga = a.locateFile(Ga));\n        var Ta = {\n            global: null,\n            env: null,\n            asm2wasm: {\n                "f64-rem": function(a, c) {\n                    return a % c\n                },\n                "f64-to-int": function(a) {\n                    return a | 0\n                },\n                "i32s-div": function(a, c) {\n                    return (a | 0) \/ (c | 0) | 0\n                },\n                "i32u-div": function(a, c) {\n                    return (a >>> 0) \/ (c >>> 0) >>> 0\n                },\n                "i32s-rem": function(a, c) {\n                    return (a | 0) % (c | 0) | 0\n                },\n                "i32u-rem": function(a, c) {\n                    return (a >>> 0) % (c >>> 0) >>> 0\n                },\n                "debugger": function() {\n                    debugger\n                }\n            },\n            parent: a\n        }\n          , lb = null;\n        a.asmPreload = a.asm;\n        var ub = a.reallocBuffer;\n        a.reallocBuffer = function(a) {\n            return "asmjs" === qc ? ub(a) : c(a)\n        }\n        ;\n        var qc = "";\n        a.asm = function(c, l, G) {\n            if (!l.table) {\n                var Ma = a.wasmTableSize;\n                void 0 === Ma && (Ma = 1024);\n                var mb = a.wasmMaxTableSize;\n                l.table = "object" === typeof WebAssembly && "function" === typeof WebAssembly.Table ? void 0 !== mb ? new WebAssembly.Table({\n                    initial: Ma,\n                    maximum: mb,\n                    element: "anyfunc"\n                }) : new WebAssembly.Table({\n                    initial: Ma,\n                    element: "anyfunc"\n                }) : Array(Ma);\n                a.wasmTable = l.table\n            }\n            l.memoryBase || (l.memoryBase = a.STATIC_BASE);\n            l.tableBase || (l.tableBase = 0);\n            for (var V, Ma = na.split(","), mb = 0; mb < Ma.length; mb++) {\n                var sa = Ma[mb];\n                qc = sa;\n                if ("native-wasm" === sa) {\n                    if (V = D(c, l))\n                        break\n                } else if ("asmjs" === sa) {\n                    if (V = m(c, l, G))\n                        break\n                } else if ("interpret-asm2wasm" === sa || "interpret-s-expr" === sa || "interpret-binary" === sa) {\n                    var Na = c\n                      , xa = l\n                      , ub = G;\n                    if ("function" !== typeof WasmJS)\n                        a.printErr("WasmJS not detected - polyfill not bundled?"),\n                        sa = !1;\n                    else {\n                        V = WasmJS({});\n                        V.outside = a;\n                        V.info = Ta;\n                        V.lookupImport = d;\n                        assert(ub === a.buffer);\n                        Ta.global = Na;\n                        Ta.env = xa;\n                        assert(ub === a.buffer);\n                        xa.memory = ub;\n                        assert(xa.memory instanceof ArrayBuffer);\n                        V.providedTotalMemory = a.buffer.byteLength;\n                        Na = void 0;\n                        Na = "interpret-binary" === sa ? g() : a.read("interpret-asm2wasm" == sa ? Ga : wa);\n                        xa = void 0;\n                        if ("interpret-asm2wasm" == sa)\n                            xa = V._malloc(Na.length + 1),\n                            V.writeAsciiToMemory(Na, xa),\n                            V._load_asm2wasm(xa);\n                        else if ("interpret-s-expr" === sa)\n                            xa = V._malloc(Na.length + 1),\n                            V.writeAsciiToMemory(Na, xa),\n                            V._load_s_expr2wasm(xa);\n                        else if ("interpret-binary" === sa)\n                            xa = V._malloc(Na.length),\n                            V.HEAPU8.set(Na, xa),\n                            V._load_binary2wasm(xa, Na.length);\n                        else\n                            throw "what? " + sa;\n                        V._free(xa);\n                        V._instantiate(xa);\n                        a.newBuffer && (e(a.newBuffer),\n                        a.newBuffer = null);\n                        sa = lb = V.asmExports\n                    }\n                    if (V = sa)\n                        break\n                } else\n                    ta("bad method: " + sa)\n            }\n            if (!V)\n                throw "no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https:\/\/github.com\/kripken\/emscripten\/wiki\/WebAssembly#binaryen-methods";\n            return V\n        }\n        ;\n        var Ma = a.asm\n    }\n    )(b);\n    var Ab = [function(a, c) {\n        var d = b.getCache(b.JSDestructionListener)[a];\n        if (!d.hasOwnProperty("SayGoodbyeJoint"))\n            throw "a JSImplementation must implement all functions, you forgot JSDestructionListener::SayGoodbyeJoint.";\n        d.SayGoodbyeJoint(c)\n    }\n    , function(a, c) {\n        var d = b.getCache(b.JSDestructionListener)[a];\n        if (!d.hasOwnProperty("SayGoodbyeFixture"))\n            throw "a JSImplementation must implement all functions, you forgot JSDestructionListener::SayGoodbyeFixture.";\n        d.SayGoodbyeFixture(c)\n    }\n    , function(a, c) {\n        var d = b.getCache(b.JSQueryCallback)[a];\n        if (!d.hasOwnProperty("ReportFixture"))\n            throw "a JSImplementation must implement all functions, you forgot JSQueryCallback::ReportFixture.";\n        return d.ReportFixture(c)\n    }\n    , function(a, c, d, e, g) {\n        a = b.getCache(b.JSRayCastCallback)[a];\n        if (!a.hasOwnProperty("ReportFixture"))\n            throw "a JSImplementation must implement all functions, you forgot JSRayCastCallback::ReportFixture.";\n        return a.ReportFixture(c, d, e, g)\n    }\n    , function(a, c) {\n        var d = b.getCache(b.JSContactListener)[a];\n        if (!d.hasOwnProperty("BeginContact"))\n            throw "a JSImplementation must implement all functions, you forgot JSContactListener::BeginContact.";\n        d.BeginContact(c)\n    }\n    , function(a, c) {\n        var d = b.getCache(b.JSContactListener)[a];\n        if (!d.hasOwnProperty("EndContact"))\n            throw "a JSImplementation must implement all functions, you forgot JSContactListener::EndContact.";\n        d.EndContact(c)\n    }\n    , function(a, c, d) {\n        a = b.getCache(b.JSContactListener)[a];\n        if (!a.hasOwnProperty("PreSolve"))\n            throw "a JSImplementation must implement all functions, you forgot JSContactListener::PreSolve.";\n        a.PreSolve(c, d)\n    }\n    , function(a, c, d) {\n        a = b.getCache(b.JSContactListener)[a];\n        if (!a.hasOwnProperty("PostSolve"))\n            throw "a JSImplementation must implement all functions, you forgot JSContactListener::PostSolve.";\n        a.PostSolve(c, d)\n    }\n    , function(a, c, d) {\n        a = b.getCache(b.JSContactFilter)[a];\n        if (!a.hasOwnProperty("ShouldCollide"))\n            throw "a JSImplementation must implement all functions, you forgot JSContactFilter::ShouldCollide.";\n        return a.ShouldCollide(c, d)\n    }\n    , function(a, c, d, e) {\n        a = b.getCache(b.JSDraw)[a];\n        if (!a.hasOwnProperty("DrawPolygon"))\n            throw "a JSImplementation must implement all functions, you forgot JSDraw::DrawPolygon.";\n        a.DrawPolygon(c, d, e)\n    }\n    , function(a, c, d, e) {\n        a = b.getCache(b.JSDraw)[a];\n        if (!a.hasOwnProperty("DrawSolidPolygon"))\n            throw "a JSImplementation must implement all functions, you forgot JSDraw::DrawSolidPolygon.";\n        a.DrawSolidPolygon(c, d, e)\n    }\n    , function(a, c, d, e) {\n        a = b.getCache(b.JSDraw)[a];\n        if (!a.hasOwnProperty("DrawCircle"))\n            throw "a JSImplementation must implement all functions, you forgot JSDraw::DrawCircle.";\n        a.DrawCircle(c, d, e)\n    }\n    , function(a, c, d, e, g) {\n        a = b.getCache(b.JSDraw)[a];\n        if (!a.hasOwnProperty("DrawSolidCircle"))\n            throw "a JSImplementation must implement all functions, you forgot JSDraw::DrawSolidCircle.";\n        a.DrawSolidCircle(c, d, e, g)\n    }\n    , function(a, c, d, e) {\n        a = b.getCache(b.JSDraw)[a];\n        if (!a.hasOwnProperty("DrawSegment"))\n            throw "a JSImplementation must implement all functions, you forgot JSDraw::DrawSegment.";\n        a.DrawSegment(c, d, e)\n    }\n    , function(a, c) {\n        var d = b.getCache(b.JSDraw)[a];\n        if (!d.hasOwnProperty("DrawTransform"))\n            throw "a JSImplementation must implement all functions, you forgot JSDraw::DrawTransform.";\n        d.DrawTransform(c)\n    }\n    ];\n    $a = f.i;\n    la = $a + 23264;\n    jb.push();\n    zb = 0 <= b.wasmJSMethod.indexOf("asmjs") || 0 <= b.wasmJSMethod.indexOf("interpret-asm2wasm") ? "Box2D_v2.3.1_min.wasm.js.mem" : null;\n    b.STATIC_BASE = $a;\n    b.STATIC_BUMP = 23264;\n    var Bb = la;\n    la += 16;\n    b._memset = Cb;\n    function Db() {\n        return !!Db.e\n    }\n    var Eb = 0\n      , Fb = []\n      , Gb = {};\n    function Hb(a, c) {\n        Hb.e || (Hb.e = {});\n        a in Hb.e || (b.dynCall_v(c),\n        Hb.e[a] = 1)\n    }\n    b._memcpy = Ib;\n    var Jb = 0;\n    function Kb() {\n        Jb += 4;\n        return ma[Jb - 4 >> 2]\n    }\n    var Lb = {}\n      , Mb = {};\n    b._sbrk = Nb;\n    var Ob = 1;\n    function Pb() {\n        var a = Eb;\n        if (!a)\n            return (f.f(0),\n            0) | 0;\n        var c = Gb[a]\n          , d = c.type;\n        if (!d)\n            return (f.f(0),\n            a) | 0;\n        var e = Array.prototype.slice.call(arguments);\n        b.___cxa_is_pointer_type(d);\n        Pb.buffer || (Pb.buffer = Ca(4));\n        ma[Pb.buffer >> 2] = a;\n        for (var a = Pb.buffer, g = 0; g < e.length; g++)\n            if (e[g] && b.___cxa_can_catch(e[g], d, a))\n                return a = ma[a >> 2],\n                c.w = a,\n                (f.f(e[g]),\n                a) | 0;\n        a = ma[a >> 2];\n        return (f.f(d),\n        a) | 0\n    }\n    b._llvm_bswap_i32 = Qb;\n    function Rb(a, c) {\n        Jb = c;\n        try {\n            var d = Kb()\n              , e = Kb()\n              , g = Kb()\n              , l = 0;\n            Rb.buffer || (Rb.e = [null, [], []],\n            Rb.q = function(a, c) {\n                var d = Rb.e[a];\n                assert(d);\n                if (0 === c || 10 === c) {\n                    var e = 1 === a ? b.print : b.printErr, g;\n                    a: {\n                        for (var l = g = 0; d[l]; )\n                            ++l;\n                        if (16 < l - g && d.subarray && Ka)\n                            g = Ka.decode(d.subarray(g, l));\n                        else\n                            for (var m, D, G, na, wa, V, l = ""; ; ) {\n                                m = d[g++];\n                                if (!m) {\n                                    g = l;\n                                    break a\n                                }\n                                m & 128 ? (D = d[g++] & 63,\n                                192 == (m & 224) ? l += String.fromCharCode((m & 31) << 6 | D) : (G = d[g++] & 63,\n                                224 == (m & 240) ? m = (m & 15) << 12 | D << 6 | G : (na = d[g++] & 63,\n                                240 == (m & 248) ? m = (m & 7) << 18 | D << 12 | G << 6 | na : (wa = d[g++] & 63,\n                                248 == (m & 252) ? m = (m & 3) << 24 | D << 18 | G << 12 | na << 6 | wa : (V = d[g++] & 63,\n                                m = (m & 1) << 30 | D << 24 | G << 18 | na << 12 | wa << 6 | V))),\n                                65536 > m ? l += String.fromCharCode(m) : (m -= 65536,\n                                l += String.fromCharCode(55296 | m >> 10, 56320 | m & 1023)))) : l += String.fromCharCode(m)\n                            }\n                    }\n                    e(g);\n                    d.length = 0\n                } else\n                    d.push(c)\n            }\n            );\n            for (var m = 0; m < g; m++) {\n                for (var D = ma[e + 8 * m >> 2], na = ma[e + (8 * m + 4) >> 2], wa = 0; wa < na; wa++)\n                    Rb.q(d, Da[D + wa]);\n                l += na\n            }\n            return l\n        } catch (G) {\n            return "undefined" !== typeof FS && G instanceof FS.o || ta(G),\n            -G.r\n        }\n    }\n    nb.push(function() {\n        var a = b._fflush;\n        a && a(0);\n        if (a = Rb.q) {\n            var c = Rb.e;\n            c[1].length && a(1, 10);\n            c[2].length && a(2, 10)\n        }\n    });\n    oa = Ba(1, "i32", 2);\n    ab = ka = f.p(la);\n    bb = ab + gb;\n    cb = f.p(bb);\n    ma[oa >> 2] = cb;\n    b.wasmTableSize = 1152;\n    b.wasmMaxTableSize = 1152;\n    b.A = {\n        Math: Math,\n        Int8Array: Int8Array,\n        Int16Array: Int16Array,\n        Int32Array: Int32Array,\n        Uint8Array: Uint8Array,\n        Uint16Array: Uint16Array,\n        Uint32Array: Uint32Array,\n        Float32Array: Float32Array,\n        Float64Array: Float64Array,\n        NaN: NaN,\n        Infinity: Infinity,\n        byteLength: eb\n    };\n    b.B = {\n        abort: ta,\n        assert: assert,\n        enlargeMemory: qa,\n        getTotalMemory: function() {\n            return pa\n        },\n        abortOnCannotGrowMemory: function() {\n            ta("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value " + pa + ", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")\n        },\n        invoke_iiii: function(a, c, d, e) {\n            try {\n                return b.dynCall_iiii(a, c, d, e)\n            } catch (g) {\n                if ("number" !== typeof g && "longjmp" !== g)\n                    throw g;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_iiii: function(a, c, d, e) {\n            return f.d[a](c, d, e)\n        },\n        invoke_viifii: function(a, c, d, e, g, l) {\n            try {\n                b.dynCall_viifii(a, c, d, e, g, l)\n            } catch (m) {\n                if ("number" !== typeof m && "longjmp" !== m)\n                    throw m;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_viifii: function(a, c, d, e, g, l) {\n            f.d[a](c, d, e, g, l)\n        },\n        invoke_viiiii: function(a, c, d, e, g, l) {\n            try {\n                b.dynCall_viiiii(a, c, d, e, g, l)\n            } catch (m) {\n                if ("number" !== typeof m && "longjmp" !== m)\n                    throw m;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_viiiii: function(a, c, d, e, g, l) {\n            f.d[a](c, d, e, g, l)\n        },\n        invoke_vi: function(a, c) {\n            try {\n                b.dynCall_vi(a, c)\n            } catch (d) {\n                if ("number" !== typeof d && "longjmp" !== d)\n                    throw d;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_vi: function(a, c) {\n            f.d[a](c)\n        },\n        invoke_vii: function(a, c, d) {\n            try {\n                b.dynCall_vii(a, c, d)\n            } catch (e) {\n                if ("number" !== typeof e && "longjmp" !== e)\n                    throw e;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_vii: function(a, c, d) {\n            f.d[a](c, d)\n        },\n        invoke_ii: function(a, c) {\n            try {\n                return b.dynCall_ii(a, c)\n            } catch (d) {\n                if ("number" !== typeof d && "longjmp" !== d)\n                    throw d;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_ii: function(a, c) {\n            return f.d[a](c)\n        },\n        invoke_fif: function(a, c, d) {\n            try {\n                return b.dynCall_fif(a, c, d)\n            } catch (e) {\n                if ("number" !== typeof e && "longjmp" !== e)\n                    throw e;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_fif: function(a, c, d) {\n            return f.d[a](c, d)\n        },\n        invoke_viii: function(a, c, d, e) {\n            try {\n                b.dynCall_viii(a, c, d, e)\n            } catch (g) {\n                if ("number" !== typeof g && "longjmp" !== g)\n                    throw g;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_viii: function(a, c, d, e) {\n            f.d[a](c, d, e)\n        },\n        invoke_viifi: function(a, c, d, e, g) {\n            try {\n                b.dynCall_viifi(a, c, d, e, g)\n            } catch (l) {\n                if ("number" !== typeof l && "longjmp" !== l)\n                    throw l;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_viifi: function(a, c, d, e, g) {\n            f.d[a](c, d, e, g)\n        },\n        invoke_v: function(a) {\n            try {\n                b.dynCall_v(a)\n            } catch (c) {\n                if ("number" !== typeof c && "longjmp" !== c)\n                    throw c;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_v: function(a) {\n            f.d[a]()\n        },\n        invoke_viif: function(a, c, d, e) {\n            try {\n                b.dynCall_viif(a, c, d, e)\n            } catch (g) {\n                if ("number" !== typeof g && "longjmp" !== g)\n                    throw g;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_viif: function(a, c, d, e) {\n            f.d[a](c, d, e)\n        },\n        invoke_viiiiii: function(a, c, d, e, g, l, m) {\n            try {\n                b.dynCall_viiiiii(a, c, d, e, g, l, m)\n            } catch (D) {\n                if ("number" !== typeof D && "longjmp" !== D)\n                    throw D;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_viiiiii: function(a, c, d, e, g, l, m) {\n            f.d[a](c, d, e, g, l, m)\n        },\n        invoke_iii: function(a, c, d) {\n            try {\n                return b.dynCall_iii(a, c, d)\n            } catch (e) {\n                if ("number" !== typeof e && "longjmp" !== e)\n                    throw e;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_iii: function(a, c, d) {\n            return f.d[a](c, d)\n        },\n        invoke_iiiiii: function(a, c, d, e, g, l) {\n            try {\n                return b.dynCall_iiiiii(a, c, d, e, g, l)\n            } catch (m) {\n                if ("number" !== typeof m && "longjmp" !== m)\n                    throw m;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_iiiiii: function(a, c, d, e, g, l) {\n            return f.d[a](c, d, e, g, l)\n        },\n        invoke_fiiiif: function(a, c, d, e, g, l) {\n            try {\n                return b.dynCall_fiiiif(a, c, d, e, g, l)\n            } catch (m) {\n                if ("number" !== typeof m && "longjmp" !== m)\n                    throw m;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_fiiiif: function(a, c, d, e, g, l) {\n            return f.d[a](c, d, e, g, l)\n        },\n        invoke_viiii: function(a, c, d, e, g) {\n            try {\n                b.dynCall_viiii(a, c, d, e, g)\n            } catch (l) {\n                if ("number" !== typeof l && "longjmp" !== l)\n                    throw l;\n                b.setThrew(1, 0)\n            }\n        },\n        jsCall_viiii: function(a, c, d, e, g) {\n            f.d[a](c, d, e, g)\n        },\n        _emscripten_asm_const_iiiii: function(a, c, d, e, g) {\n            return Ab[a](c, d, e, g)\n        },\n        _emscripten_asm_const_diiiid: function(a, c, d, e, g, l) {\n            return Ab[a](c, d, e, g, l)\n        },\n        _pthread_key_create: function(a) {\n            if (0 == a)\n                return 22;\n            ma[a >> 2] = Ob;\n            Mb[Ob] = 0;\n            Ob++;\n            return 0\n        },\n        _abort: function() {\n            b.abort()\n        },\n        ___gxx_personality_v0: function() {},\n        _emscripten_asm_const_iiidii: function(a, c, d, e, g, l) {\n            return Ab[a](c, d, e, g, l)\n        },\n        ___assert_fail: function(a, c, d, e) {\n            ra = !0;\n            throw "Assertion failed: " + Ja(a) + ", at: " + [c ? Ja(c) : "unknown filename", d, e ? Ja(e) : "unknown function"] + " at " + Ra();\n        },\n        __ZSt18uncaught_exceptionv: Db,\n        ___setErrNo: function(a) {\n            b.___errno_location && (ma[b.___errno_location() >> 2] = a);\n            return a\n        },\n        ___cxa_begin_catch: function(a) {\n            var c = Gb[a];\n            c && !c.C && (c.C = !0,\n            Db.e--);\n            c && (c.da = !1);\n            Fb.push(a);\n            a: {\n                if (a && !Gb[a])\n                    for (var d in Gb)\n                        if (Gb[d].w === a) {\n                            c = d;\n                            break a\n                        }\n                c = a\n            }\n            c && Gb[c].ba++;\n            return a\n        },\n        _emscripten_memcpy_big: function(a, c, d) {\n            Da.set(Da.subarray(c, c + d), a);\n            return a\n        },\n        ___resumeException: function(a) {\n            Eb || (Eb = a);\n            throw a + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";\n        },\n        ___cxa_find_matching_catch: Pb,\n        _pthread_getspecific: function(a) {\n            return Mb[a] || 0\n        },\n        _pthread_once: Hb,\n        ___syscall54: function(a, c) {\n            Jb = c;\n            return 0\n        },\n        _emscripten_asm_const_iii: function(a, c, d) {\n            return Ab[a](c, d)\n        },\n        _emscripten_asm_const_iiidi: function(a, c, d, e, g) {\n            return Ab[a](c, d, e, g)\n        },\n        _pthread_setspecific: function(a, c) {\n            if (!(a in Mb))\n                return 22;\n            Mb[a] = c;\n            return 0\n        },\n        _emscripten_asm_const_iiii: function(a, c, d, e) {\n            return Ab[a](c, d, e)\n        },\n        ___syscall6: function(a, c) {\n            Jb = c;\n            try {\n                var d = Lb.G();\n                FS.close(d);\n                return 0\n            } catch (e) {\n                return "undefined" !== typeof FS && e instanceof FS.o || ta(e),\n                -e.r\n            }\n        },\n        ___syscall140: function(a, c) {\n            Jb = c;\n            try {\n                var d = Lb.G();\n                Kb();\n                var e = Kb()\n                  , g = Kb()\n                  , l = Kb();\n                FS.Z(d, e, l);\n                ma[g >> 2] = d.position;\n                d.I && 0 === e && 0 === l && (d.I = null);\n                return 0\n            } catch (m) {\n                return "undefined" !== typeof FS && m instanceof FS.o || ta(m),\n                -m.r\n            }\n        },\n        ___cxa_pure_virtual: function() {\n            ra = !0;\n            throw "Pure virtual function called!";\n        },\n        ___syscall146: Rb,\n        DYNAMICTOP_PTR: oa,\n        tempDoublePtr: Bb,\n        ABORT: ra,\n        STACKTOP: ka,\n        STACK_MAX: bb\n    };\n    var Sb = b.asm(b.A, b.B, buffer);\n    b.asm = Sb;\n    var Tb = b._emscripten_bind_b2WheelJoint_GetSpringDampingRatio_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetSpringDampingRatio_0.apply(null, arguments)\n    }\n      , Ub = b._emscripten_bind_b2ContactEdge_set_next_1 = function() {\n        return b.asm._emscripten_bind_b2ContactEdge_set_next_1.apply(null, arguments)\n    }\n      , Vb = b._emscripten_bind_b2ChainShape_get_m_count_0 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_get_m_count_0.apply(null, arguments)\n    }\n      , Wb = b._emscripten_bind_b2PrismaticJointDef_get_motorSpeed_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_motorSpeed_0.apply(null, arguments)\n    }\n      , Xb = b._emscripten_bind_b2PulleyJoint_SetUserData_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_SetUserData_1.apply(null, arguments)\n    }\n      , Yb = b._emscripten_bind_b2Shape_ComputeAABB_3 = function() {\n        return b.asm._emscripten_bind_b2Shape_ComputeAABB_3.apply(null, arguments)\n    }\n      , Zb = b._emscripten_bind_b2FrictionJointDef_set_userData_1 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_set_userData_1.apply(null, arguments)\n    }\n      , $b = b._emscripten_bind_b2MouseJoint_IsActive_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_IsActive_0.apply(null, arguments)\n    }\n      , ac = b._emscripten_bind_b2World_IsLocked_0 = function() {\n        return b.asm._emscripten_bind_b2World_IsLocked_0.apply(null, arguments)\n    }\n      , bc = b._emscripten_bind_b2Draw_GetFlags_0 = function() {\n        return b.asm._emscripten_bind_b2Draw_GetFlags_0.apply(null, arguments)\n    }\n      , cc = b._emscripten_bind_b2FrictionJoint_IsActive_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_IsActive_0.apply(null, arguments)\n    }\n      , dc = b._emscripten_bind_b2Color_set_g_1 = function() {\n        return b.asm._emscripten_bind_b2Color_set_g_1.apply(null, arguments)\n    }\n      , ec = b._emscripten_bind_b2PolygonShape_RayCast_4 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_RayCast_4.apply(null, arguments)\n    }\n      , fc = b._emscripten_bind_b2World_GetTreeBalance_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetTreeBalance_0.apply(null, arguments)\n    }\n      , gc = b._emscripten_bind_b2ChainShape_get_m_vertices_0 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_get_m_vertices_0.apply(null, arguments)\n    }\n      , hc = b._emscripten_bind_JSDraw_DrawSolidCircle_4 = function() {\n        return b.asm._emscripten_bind_JSDraw_DrawSolidCircle_4.apply(null, arguments)\n    }\n      , ic = b._emscripten_bind_b2RevoluteJoint_GetLocalAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetLocalAnchorA_0.apply(null, arguments)\n    }\n      , jc = b._emscripten_bind_b2FixtureDef_get_filter_0 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_get_filter_0.apply(null, arguments)\n    }\n      , kc = b._emscripten_bind_b2FrictionJointDef_get_type_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_get_type_0.apply(null, arguments)\n    }\n      , lc = b._emscripten_bind_b2MotorJointDef_set_type_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_set_type_1.apply(null, arguments)\n    }\n      , mc = b._emscripten_bind_b2FixtureDef_set_userData_1 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_set_userData_1.apply(null, arguments)\n    }\n      , nc = b._emscripten_bind_b2EdgeShape_set_m_hasVertex3_1 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_set_m_hasVertex3_1.apply(null, arguments)\n    }\n      , oc = b._emscripten_bind_b2JointEdge_set_joint_1 = function() {\n        return b.asm._emscripten_bind_b2JointEdge_set_joint_1.apply(null, arguments)\n    }\n      , pc = b._emscripten_bind_b2Fixture___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2Fixture___destroy___0.apply(null, arguments)\n    }\n      , rc = b._emscripten_bind_b2World_SetWarmStarting_1 = function() {\n        return b.asm._emscripten_bind_b2World_SetWarmStarting_1.apply(null, arguments)\n    }\n      , sc = b._emscripten_bind_JSDraw_DrawCircle_3 = function() {\n        return b.asm._emscripten_bind_JSDraw_DrawCircle_3.apply(null, arguments)\n    }\n      , tc = b._emscripten_bind_b2WeldJoint_IsActive_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_IsActive_0.apply(null, arguments)\n    }\n      , uc = b._emscripten_bind_b2DestructionListener___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2DestructionListener___destroy___0.apply(null, arguments)\n    }\n      , vc = b._emscripten_bind_b2BodyDef_set_type_1 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_set_type_1.apply(null, arguments)\n    }\n      , wc = b._emscripten_bind_b2ChainShape_ComputeAABB_3 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_ComputeAABB_3.apply(null, arguments)\n    }\n      , xc = b._emscripten_bind_b2PulleyJoint_GetUserData_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetUserData_0.apply(null, arguments)\n    }\n      , yc = b._emscripten_bind_b2WeldJoint_GetReactionTorque_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_GetReactionTorque_1.apply(null, arguments)\n    }\n      , zc = b._emscripten_bind_b2MotorJointDef_get_maxForce_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_get_maxForce_0.apply(null, arguments)\n    }\n      , Ac = b._emscripten_bind_b2DistanceJointDef_get_userData_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_get_userData_0.apply(null, arguments)\n    }\n      , Bc = b._emscripten_bind_b2BodyDef_get_position_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_get_position_0.apply(null, arguments)\n    }\n      , Cc = b._emscripten_bind_b2RevoluteJointDef_set_userData_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_set_userData_1.apply(null, arguments)\n    }\n      , Dc = b._emscripten_bind_b2WorldManifold_b2WorldManifold_0 = function() {\n        return b.asm._emscripten_bind_b2WorldManifold_b2WorldManifold_0.apply(null, arguments)\n    }\n      , Ec = b._emscripten_bind_b2WheelJointDef_get_collideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_get_collideConnected_0.apply(null, arguments)\n    }\n      , Fc = b._emscripten_bind_b2MouseJointDef_set_userData_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_set_userData_1.apply(null, arguments)\n    }\n    ;\n    b.stackSave = function() {\n        return b.asm.stackSave.apply(null, arguments)\n    }\n    ;\n    var Gc = b._emscripten_bind_b2FixtureDef_set_restitution_1 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_set_restitution_1.apply(null, arguments)\n    }\n      , Hc = b._emscripten_bind_b2RevoluteJoint_GetUserData_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetUserData_0.apply(null, arguments)\n    }\n      , Ic = b._emscripten_bind_b2Mat33_get_ey_0 = function() {\n        return b.asm._emscripten_bind_b2Mat33_get_ey_0.apply(null, arguments)\n    }\n      , Jc = b._emscripten_bind_b2MouseJoint_GetCollideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_GetCollideConnected_0.apply(null, arguments)\n    }\n      , Kc = b._emscripten_bind_b2World_GetGravity_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetGravity_0.apply(null, arguments)\n    }\n      , Lc = b._emscripten_bind_b2Mat33_set_ey_1 = function() {\n        return b.asm._emscripten_bind_b2Mat33_set_ey_1.apply(null, arguments)\n    }\n      , Mc = b._emscripten_bind_b2Profile_get_broadphase_0 = function() {\n        return b.asm._emscripten_bind_b2Profile_get_broadphase_0.apply(null, arguments)\n    }\n      , Nc = b._emscripten_bind_b2PulleyJointDef_get_bodyA_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_get_bodyA_0.apply(null, arguments)\n    }\n      , Oc = b._emscripten_bind_b2PrismaticJoint_SetLimits_2 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_SetLimits_2.apply(null, arguments)\n    }\n      , Pc = b._emscripten_bind_b2PulleyJointDef_get_localAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_get_localAnchorA_0.apply(null, arguments)\n    }\n      , Qc = b._emscripten_bind_b2DistanceJoint_GetAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetAnchorA_0.apply(null, arguments)\n    }\n      , Rc = b._emscripten_bind_b2DistanceJointDef_set_userData_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_set_userData_1.apply(null, arguments)\n    }\n      , Sc = b._emscripten_bind_b2DistanceJointDef_set_dampingRatio_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_set_dampingRatio_1.apply(null, arguments)\n    }\n      , Tc = b._emscripten_bind_b2RopeJointDef_set_collideConnected_1 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_set_collideConnected_1.apply(null, arguments)\n    }\n      , Uc = b._emscripten_bind_b2ChainShape_set_m_nextVertex_1 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_set_m_nextVertex_1.apply(null, arguments)\n    }\n      , Vc = b._emscripten_bind_JSContactListener_EndContact_1 = function() {\n        return b.asm._emscripten_bind_JSContactListener_EndContact_1.apply(null, arguments)\n    }\n      , Wc = b._emscripten_bind_b2MassData_set_mass_1 = function() {\n        return b.asm._emscripten_bind_b2MassData_set_mass_1.apply(null, arguments)\n    }\n      , Xc = b._emscripten_bind_b2Vec3_get_x_0 = function() {\n        return b.asm._emscripten_bind_b2Vec3_get_x_0.apply(null, arguments)\n    }\n      , Yc = b._emscripten_bind_b2ChainShape_CreateChain_2 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_CreateChain_2.apply(null, arguments)\n    }\n      , Zc = b._emscripten_bind_b2RopeJoint_GetUserData_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_GetUserData_0.apply(null, arguments)\n    }\n      , $c = b._emscripten_bind_b2World_DestroyBody_1 = function() {\n        return b.asm._emscripten_bind_b2World_DestroyBody_1.apply(null, arguments)\n    }\n      , ad = b._emscripten_bind_b2Profile_get_solvePosition_0 = function() {\n        return b.asm._emscripten_bind_b2Profile_get_solvePosition_0.apply(null, arguments)\n    }\n      , bd = b._emscripten_bind_b2Shape_RayCast_4 = function() {\n        return b.asm._emscripten_bind_b2Shape_RayCast_4.apply(null, arguments)\n    }\n      , cd = b._emscripten_bind_b2PulleyJoint_GetGroundAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetGroundAnchorA_0.apply(null, arguments)\n    }\n      , dd = b._emscripten_bind_b2Mat33___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2Mat33___destroy___0.apply(null, arguments)\n    }\n      , ed = b._emscripten_bind_b2GearJoint_GetReactionTorque_1 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_GetReactionTorque_1.apply(null, arguments)\n    }\n      , fd = b._emscripten_bind_b2WeldJointDef_set_collideConnected_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_set_collideConnected_1.apply(null, arguments)\n    }\n      , gd = b._emscripten_bind_b2JointDef_get_collideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2JointDef_get_collideConnected_0.apply(null, arguments)\n    }\n    ;\n    b.getTempRet0 = function() {\n        return b.asm.getTempRet0.apply(null, arguments)\n    }\n    ;\n    var hd = b._emscripten_bind_b2FrictionJointDef_get_maxTorque_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_get_maxTorque_0.apply(null, arguments)\n    }\n      , id = b._emscripten_bind_JSQueryCallback_JSQueryCallback_0 = function() {\n        return b.asm._emscripten_bind_JSQueryCallback_JSQueryCallback_0.apply(null, arguments)\n    }\n      , jd = b._emscripten_bind_b2World_SetAutoClearForces_1 = function() {\n        return b.asm._emscripten_bind_b2World_SetAutoClearForces_1.apply(null, arguments)\n    }\n      , kd = b._emscripten_bind_b2PrismaticJointDef_set_lowerTranslation_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_lowerTranslation_1.apply(null, arguments)\n    }\n      , ld = b._emscripten_bind_b2Contact_GetTangentSpeed_0 = function() {\n        return b.asm._emscripten_bind_b2Contact_GetTangentSpeed_0.apply(null, arguments)\n    }\n      , md = b._emscripten_bind_b2BodyDef_set_position_1 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_set_position_1.apply(null, arguments)\n    }\n      , nd = b._emscripten_bind_b2Transform_get_q_0 = function() {\n        return b.asm._emscripten_bind_b2Transform_get_q_0.apply(null, arguments)\n    }\n      , od = b._emscripten_bind_b2PolygonShape_set_m_count_1 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_set_m_count_1.apply(null, arguments)\n    }\n      , pd = b._emscripten_bind_b2Contact_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2Contact_GetNext_0.apply(null, arguments)\n    }\n      , qd = b._emscripten_bind_b2MotorJointDef_set_userData_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_set_userData_1.apply(null, arguments)\n    }\n      , rd = b._emscripten_bind_b2GearJoint_GetJoint1_0 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_GetJoint1_0.apply(null, arguments)\n    }\n      , sd = b._emscripten_bind_b2World_GetProxyCount_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetProxyCount_0.apply(null, arguments)\n    }\n      , td = b._emscripten_bind_b2MotorJoint_SetMaxTorque_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_SetMaxTorque_1.apply(null, arguments)\n    }\n      , ud = b._emscripten_bind_b2GearJoint_GetAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_GetAnchorA_0.apply(null, arguments)\n    }\n      , vd = b._emscripten_bind_b2MouseJointDef_set_bodyA_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_set_bodyA_1.apply(null, arguments)\n    }\n      , wd = b._emscripten_bind_b2World_SetContactListener_1 = function() {\n        return b.asm._emscripten_bind_b2World_SetContactListener_1.apply(null, arguments)\n    }\n      , xd = b._emscripten_bind_b2Body_IsAwake_0 = function() {\n        return b.asm._emscripten_bind_b2Body_IsAwake_0.apply(null, arguments)\n    }\n      , yd = b._emscripten_bind_b2JointEdge_set_other_1 = function() {\n        return b.asm._emscripten_bind_b2JointEdge_set_other_1.apply(null, arguments)\n    }\n      , zd = b._emscripten_bind_b2MouseJointDef_set_target_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_set_target_1.apply(null, arguments)\n    }\n      , db = b._emscripten_replace_memory = function() {\n        return b.asm._emscripten_replace_memory.apply(null, arguments)\n    }\n      , Ad = b._emscripten_bind_b2MotorJoint_SetCorrectionFactor_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_SetCorrectionFactor_1.apply(null, arguments)\n    }\n      , Bd = b._emscripten_bind_b2FixtureDef_get_density_0 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_get_density_0.apply(null, arguments)\n    }\n      , Cd = b._emscripten_bind_b2GearJoint_GetRatio_0 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_GetRatio_0.apply(null, arguments)\n    }\n      , Dd = b._emscripten_bind_b2PrismaticJointDef_get_upperTranslation_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_upperTranslation_0.apply(null, arguments)\n    }\n      , Ed = b._emscripten_bind_b2RevoluteJoint_GetReferenceAngle_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetReferenceAngle_0.apply(null, arguments)\n    }\n      , Fd = b._emscripten_bind_b2MotorJointDef_get_collideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_get_collideConnected_0.apply(null, arguments)\n    }\n      , Gd = b._emscripten_enum_b2ManifoldType_e_circles = function() {\n        return b.asm._emscripten_enum_b2ManifoldType_e_circles.apply(null, arguments)\n    }\n      , Hd = b._emscripten_bind_b2PulleyJointDef_set_localAnchorB_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_set_localAnchorB_1.apply(null, arguments)\n    }\n      , Id = b._emscripten_bind_b2RevoluteJointDef_Initialize_3 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_Initialize_3.apply(null, arguments)\n    }\n      , Jd = b._emscripten_bind_b2FixtureDef_get_userData_0 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_get_userData_0.apply(null, arguments)\n    }\n      , Kd = b._emscripten_bind_b2DistanceJoint_GetUserData_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetUserData_0.apply(null, arguments)\n    }\n      , Ld = b._emscripten_bind_b2FrictionJointDef_set_collideConnected_1 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_set_collideConnected_1.apply(null, arguments)\n    }\n      , Md = b._emscripten_bind_b2PrismaticJointDef_get_lowerTranslation_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_lowerTranslation_0.apply(null, arguments)\n    }\n      , Nd = b._emscripten_bind_b2GearJoint_GetCollideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_GetCollideConnected_0.apply(null, arguments)\n    }\n      , Od = b._emscripten_bind_b2Filter_b2Filter_0 = function() {\n        return b.asm._emscripten_bind_b2Filter_b2Filter_0.apply(null, arguments)\n    }\n      , Pd = b._emscripten_bind_b2MouseJointDef_set_type_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_set_type_1.apply(null, arguments)\n    }\n      , Qd = b._emscripten_bind_b2Body_ApplyAngularImpulse_2 = function() {\n        return b.asm._emscripten_bind_b2Body_ApplyAngularImpulse_2.apply(null, arguments)\n    }\n      , Rd = b._emscripten_enum_b2JointType_e_frictionJoint = function() {\n        return b.asm._emscripten_enum_b2JointType_e_frictionJoint.apply(null, arguments)\n    }\n      , Sd = b._emscripten_bind_b2RayCastOutput_set_fraction_1 = function() {\n        return b.asm._emscripten_bind_b2RayCastOutput_set_fraction_1.apply(null, arguments)\n    }\n      , Td = b._emscripten_bind_b2Color_set_r_1 = function() {\n        return b.asm._emscripten_bind_b2Color_set_r_1.apply(null, arguments)\n    }\n      , Ud = b._emscripten_bind_b2DistanceJointDef_get_length_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_get_length_0.apply(null, arguments)\n    }\n      , Vd = b._emscripten_bind_b2PulleyJoint_GetBodyB_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetBodyB_0.apply(null, arguments)\n    }\n      , Wd = b._emscripten_bind_b2WheelJointDef_set_type_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_set_type_1.apply(null, arguments)\n    }\n      , Xd = b._emscripten_bind_b2World_GetTreeQuality_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetTreeQuality_0.apply(null, arguments)\n    }\n      , Yd = b._emscripten_bind_b2BodyDef_set_gravityScale_1 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_set_gravityScale_1.apply(null, arguments)\n    }\n      , Zd = b._emscripten_bind_b2RopeJointDef_set_bodyB_1 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_set_bodyB_1.apply(null, arguments)\n    }\n      , $d = b._emscripten_bind_b2PrismaticJoint_GetLowerLimit_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetLowerLimit_0.apply(null, arguments)\n    }\n      , ae = b._emscripten_bind_b2AABB_get_lowerBound_0 = function() {\n        return b.asm._emscripten_bind_b2AABB_get_lowerBound_0.apply(null, arguments)\n    }\n      , be = b._emscripten_bind_b2WheelJoint_SetMotorSpeed_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_SetMotorSpeed_1.apply(null, arguments)\n    }\n      , ce = b._emscripten_bind_b2PrismaticJointDef_get_referenceAngle_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_referenceAngle_0.apply(null, arguments)\n    }\n      , de = b._emscripten_bind_b2Body_SetMassData_1 = function() {\n        return b.asm._emscripten_bind_b2Body_SetMassData_1.apply(null, arguments)\n    }\n      , ee = b._emscripten_bind_b2BodyDef_get_angularVelocity_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_get_angularVelocity_0.apply(null, arguments)\n    }\n      , fe = b._emscripten_bind_b2WeldJoint_SetDampingRatio_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_SetDampingRatio_1.apply(null, arguments)\n    }\n      , ge = b._emscripten_bind_b2PrismaticJointDef___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef___destroy___0.apply(null, arguments)\n    }\n      , he = b._emscripten_bind_b2Contact_IsTouching_0 = function() {\n        return b.asm._emscripten_bind_b2Contact_IsTouching_0.apply(null, arguments)\n    }\n      , ie = b._emscripten_bind_b2Draw_SetFlags_1 = function() {\n        return b.asm._emscripten_bind_b2Draw_SetFlags_1.apply(null, arguments)\n    }\n      , je = b._emscripten_bind_b2AABB_Contains_1 = function() {\n        return b.asm._emscripten_bind_b2AABB_Contains_1.apply(null, arguments)\n    }\n      , ke = b._emscripten_bind_b2DistanceJoint_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetNext_0.apply(null, arguments)\n    }\n      , le = b._emscripten_bind_b2EdgeShape_set_m_radius_1 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_set_m_radius_1.apply(null, arguments)\n    }\n      , me = b._emscripten_bind_b2DistanceJointDef_get_dampingRatio_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_get_dampingRatio_0.apply(null, arguments)\n    }\n      , ne = b._emscripten_bind_b2DistanceJoint_GetLocalAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetLocalAnchorA_0.apply(null, arguments)\n    }\n      , oe = b._emscripten_bind_b2PrismaticJoint_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetType_0.apply(null, arguments)\n    }\n      , pe = b._emscripten_bind_b2Fixture_GetRestitution_0 = function() {\n        return b.asm._emscripten_bind_b2Fixture_GetRestitution_0.apply(null, arguments)\n    }\n      , qe = b._emscripten_bind_b2Transform_set_q_1 = function() {\n        return b.asm._emscripten_bind_b2Transform_set_q_1.apply(null, arguments)\n    }\n      , re = b._emscripten_bind_b2PolygonShape___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape___destroy___0.apply(null, arguments)\n    }\n      , se = b._emscripten_bind_b2AABB_get_upperBound_0 = function() {\n        return b.asm._emscripten_bind_b2AABB_get_upperBound_0.apply(null, arguments)\n    }\n      , te = b._emscripten_bind_b2Transform___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2Transform___destroy___0.apply(null, arguments)\n    }\n      , ue = b._emscripten_bind_b2Body_GetLinearVelocity_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetLinearVelocity_0.apply(null, arguments)\n    }\n      , ve = b._emscripten_bind_b2CircleShape_set_m_radius_1 = function() {\n        return b.asm._emscripten_bind_b2CircleShape_set_m_radius_1.apply(null, arguments)\n    }\n      , we = b._emscripten_bind_b2EdgeShape_set_m_hasVertex0_1 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_set_m_hasVertex0_1.apply(null, arguments)\n    }\n      , xe = b._emscripten_bind_b2Contact_GetWorldManifold_1 = function() {\n        return b.asm._emscripten_bind_b2Contact_GetWorldManifold_1.apply(null, arguments)\n    }\n      , ye = b._emscripten_bind_b2RopeJoint_GetMaxLength_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_GetMaxLength_0.apply(null, arguments)\n    }\n      , ze = b._emscripten_bind_b2GearJoint_GetUserData_0 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_GetUserData_0.apply(null, arguments)\n    }\n      , Ae = b._emscripten_bind_b2MotorJoint_GetCollideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetCollideConnected_0.apply(null, arguments)\n    }\n      , Be = b._emscripten_bind_b2GearJointDef_set_type_1 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_set_type_1.apply(null, arguments)\n    }\n      , Ce = b._emscripten_bind_b2DistanceJoint_SetDampingRatio_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_SetDampingRatio_1.apply(null, arguments)\n    }\n      , De = b._emscripten_bind_b2Contact_GetFixtureA_0 = function() {\n        return b.asm._emscripten_bind_b2Contact_GetFixtureA_0.apply(null, arguments)\n    }\n      , Ee = b._emscripten_bind_b2PulleyJointDef_get_ratio_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_get_ratio_0.apply(null, arguments)\n    }\n      , Fe = b._emscripten_bind_b2PrismaticJointDef_get_localAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_localAnchorB_0.apply(null, arguments)\n    }\n      , Ge = b._emscripten_bind_b2CircleShape_set_m_type_1 = function() {\n        return b.asm._emscripten_bind_b2CircleShape_set_m_type_1.apply(null, arguments)\n    }\n      , He = b._emscripten_bind_b2DistanceJointDef_set_localAnchorA_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_set_localAnchorA_1.apply(null, arguments)\n    }\n      , Ie = b._emscripten_bind_b2RopeJoint_GetAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_GetAnchorB_0.apply(null, arguments)\n    }\n      , Je = b._emscripten_bind_b2AABB_set_upperBound_1 = function() {\n        return b.asm._emscripten_bind_b2AABB_set_upperBound_1.apply(null, arguments)\n    }\n      , Ke = b._emscripten_bind_JSRayCastCallback_ReportFixture_4 = function() {\n        return b.asm._emscripten_bind_JSRayCastCallback_ReportFixture_4.apply(null, arguments)\n    }\n      , Le = b._emscripten_bind_b2ContactImpulse___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2ContactImpulse___destroy___0.apply(null, arguments)\n    }\n      , Me = b._emscripten_bind_b2FrictionJointDef_get_localAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_get_localAnchorB_0.apply(null, arguments)\n    }\n      , Ne = b._emscripten_bind_b2PulleyJointDef_set_lengthB_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_set_lengthB_1.apply(null, arguments)\n    }\n      , Oe = b._emscripten_bind_b2RayCastInput___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2RayCastInput___destroy___0.apply(null, arguments)\n    }\n      , Pe = b._emscripten_bind_b2Body_ApplyForceToCenter_2 = function() {\n        return b.asm._emscripten_bind_b2Body_ApplyForceToCenter_2.apply(null, arguments)\n    }\n      , Qe = b._emscripten_bind_JSDestructionListener_JSDestructionListener_0 = function() {\n        return b.asm._emscripten_bind_JSDestructionListener_JSDestructionListener_0.apply(null, arguments)\n    }\n      , Re = b._emscripten_bind_b2WheelJointDef_set_localAnchorA_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_set_localAnchorA_1.apply(null, arguments)\n    }\n      , Se = b._emscripten_bind_b2FrictionJoint_GetBodyB_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_GetBodyB_0.apply(null, arguments)\n    }\n      , Te = b._emscripten_bind_b2WeldJointDef_set_bodyA_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_set_bodyA_1.apply(null, arguments)\n    }\n      , Ue = b._emscripten_bind_b2DistanceJoint_GetBodyB_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetBodyB_0.apply(null, arguments)\n    }\n      , Ve = b._emscripten_enum_b2JointType_e_wheelJoint = function() {\n        return b.asm._emscripten_enum_b2JointType_e_wheelJoint.apply(null, arguments)\n    }\n      , We = b._emscripten_bind_b2JointDef___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2JointDef___destroy___0.apply(null, arguments)\n    }\n      , Xe = b._emscripten_bind_b2ContactEdge___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2ContactEdge___destroy___0.apply(null, arguments)\n    }\n      , Ye = b._emscripten_bind_b2Filter_get_groupIndex_0 = function() {\n        return b.asm._emscripten_bind_b2Filter_get_groupIndex_0.apply(null, arguments)\n    }\n      , Ze = b._emscripten_bind_b2FrictionJointDef_get_localAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_get_localAnchorA_0.apply(null, arguments)\n    }\n      , $e = b._emscripten_bind_b2CircleShape_GetChildCount_0 = function() {\n        return b.asm._emscripten_bind_b2CircleShape_GetChildCount_0.apply(null, arguments)\n    }\n      , af = b._emscripten_bind_b2BodyDef_get_bullet_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_get_bullet_0.apply(null, arguments)\n    }\n      , bf = b._emscripten_bind_b2Color_set_b_1 = function() {\n        return b.asm._emscripten_bind_b2Color_set_b_1.apply(null, arguments)\n    }\n      , cf = b._emscripten_bind_b2Mat33_get_ez_0 = function() {\n        return b.asm._emscripten_bind_b2Mat33_get_ez_0.apply(null, arguments)\n    }\n      , df = b._emscripten_bind_b2MassData_get_center_0 = function() {\n        return b.asm._emscripten_bind_b2MassData_get_center_0.apply(null, arguments)\n    }\n      , ef = b._emscripten_bind_b2WeldJoint_GetBodyB_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_GetBodyB_0.apply(null, arguments)\n    }\n      , ff = b._emscripten_bind_b2WheelJoint_GetReactionForce_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetReactionForce_1.apply(null, arguments)\n    }\n      , gf = b._emscripten_bind_b2World_SetSubStepping_1 = function() {\n        return b.asm._emscripten_bind_b2World_SetSubStepping_1.apply(null, arguments)\n    }\n      , hf = b._emscripten_bind_b2Vec2_op_add_1 = function() {\n        return b.asm._emscripten_bind_b2Vec2_op_add_1.apply(null, arguments)\n    }\n      , jf = b._emscripten_bind_JSDraw_DrawSegment_3 = function() {\n        return b.asm._emscripten_bind_JSDraw_DrawSegment_3.apply(null, arguments)\n    }\n      , kf = b._emscripten_bind_b2Joint_GetCollideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2Joint_GetCollideConnected_0.apply(null, arguments)\n    }\n      , lf = b._emscripten_bind_b2MotorJoint_GetReactionTorque_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetReactionTorque_1.apply(null, arguments)\n    }\n      , mf = b._emscripten_bind_b2FrictionJointDef_get_bodyB_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_get_bodyB_0.apply(null, arguments)\n    }\n      , nf = b._emscripten_bind_b2WheelJointDef___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef___destroy___0.apply(null, arguments)\n    }\n      , of = b._emscripten_bind_b2BodyDef_get_gravityScale_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_get_gravityScale_0.apply(null, arguments)\n    }\n      , pf = b._emscripten_bind_b2Vec3_SetZero_0 = function() {\n        return b.asm._emscripten_bind_b2Vec3_SetZero_0.apply(null, arguments)\n    }\n      , qf = b._emscripten_enum_b2JointType_e_pulleyJoint = function() {\n        return b.asm._emscripten_enum_b2JointType_e_pulleyJoint.apply(null, arguments)\n    }\n      , rf = b._emscripten_bind_b2ChainShape_get_m_nextVertex_0 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_get_m_nextVertex_0.apply(null, arguments)\n    }\n      , sf = b._emscripten_bind_b2Contact_SetEnabled_1 = function() {\n        return b.asm._emscripten_bind_b2Contact_SetEnabled_1.apply(null, arguments)\n    }\n      , tf = b._emscripten_bind_b2Shape_set_m_radius_1 = function() {\n        return b.asm._emscripten_bind_b2Shape_set_m_radius_1.apply(null, arguments)\n    }\n      , uf = b._emscripten_bind_b2World_SetDebugDraw_1 = function() {\n        return b.asm._emscripten_bind_b2World_SetDebugDraw_1.apply(null, arguments)\n    }\n      , vf = b._emscripten_bind_b2ContactID_set_key_1 = function() {\n        return b.asm._emscripten_bind_b2ContactID_set_key_1.apply(null, arguments)\n    }\n      , Ca = b._malloc = function() {\n        return b.asm._malloc.apply(null, arguments)\n    }\n      , wf = b._emscripten_bind_b2WheelJoint_GetMaxMotorTorque_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetMaxMotorTorque_0.apply(null, arguments)\n    }\n      , xf = b._emscripten_bind_b2Vec2_Normalize_0 = function() {\n        return b.asm._emscripten_bind_b2Vec2_Normalize_0.apply(null, arguments)\n    }\n      , yf = b._emscripten_bind_b2WheelJoint_GetJointSpeed_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetJointSpeed_0.apply(null, arguments)\n    }\n      , zf = b._emscripten_bind_b2FrictionJointDef_set_localAnchorA_1 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_set_localAnchorA_1.apply(null, arguments)\n    }\n      , Af = b._emscripten_bind_b2ChainShape_set_m_vertices_1 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_set_m_vertices_1.apply(null, arguments)\n    }\n      , Bf = b._emscripten_bind_JSRayCastCallback_JSRayCastCallback_0 = function() {\n        return b.asm._emscripten_bind_JSRayCastCallback_JSRayCastCallback_0.apply(null, arguments)\n    }\n      , Cf = b._emscripten_bind_b2RayCastInput_set_p2_1 = function() {\n        return b.asm._emscripten_bind_b2RayCastInput_set_p2_1.apply(null, arguments)\n    }\n      , Df = b._emscripten_bind_b2RevoluteJointDef_get_motorSpeed_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_get_motorSpeed_0.apply(null, arguments)\n    }\n      , Ef = b._emscripten_bind_b2Manifold_get_pointCount_0 = function() {\n        return b.asm._emscripten_bind_b2Manifold_get_pointCount_0.apply(null, arguments)\n    }\n      , Ff = b._emscripten_bind_b2RayCastOutput_get_normal_0 = function() {\n        return b.asm._emscripten_bind_b2RayCastOutput_get_normal_0.apply(null, arguments)\n    }\n      , Gf = b._emscripten_bind_b2WeldJoint_GetBodyA_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_GetBodyA_0.apply(null, arguments)\n    }\n      , Hf = b._emscripten_enum_b2DrawFlag_e_jointBit = function() {\n        return b.asm._emscripten_enum_b2DrawFlag_e_jointBit.apply(null, arguments)\n    }\n      , If = b._emscripten_bind_b2FixtureDef_get_isSensor_0 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_get_isSensor_0.apply(null, arguments)\n    }\n      , Jf = b._emscripten_bind_b2PrismaticJointDef_Initialize_4 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_Initialize_4.apply(null, arguments)\n    }\n      , Kf = b._emscripten_bind_b2PulleyJointDef_set_bodyB_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_set_bodyB_1.apply(null, arguments)\n    }\n      , Lf = b._emscripten_bind_b2WheelJoint_EnableMotor_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_EnableMotor_1.apply(null, arguments)\n    }\n      , Mf = b._emscripten_bind_b2RevoluteJoint_GetJointSpeed_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetJointSpeed_0.apply(null, arguments)\n    }\n      , Nf = b._emscripten_bind_JSDraw_DrawSolidPolygon_3 = function() {\n        return b.asm._emscripten_bind_JSDraw_DrawSolidPolygon_3.apply(null, arguments)\n    }\n      , Of = b._emscripten_bind_b2Rot_Set_1 = function() {\n        return b.asm._emscripten_bind_b2Rot_Set_1.apply(null, arguments)\n    }\n      , Pf = b._emscripten_bind_b2RevoluteJoint_GetJointAngle_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetJointAngle_0.apply(null, arguments)\n    }\n      , Qf = b._emscripten_bind_JSDraw___destroy___0 = function() {\n        return b.asm._emscripten_bind_JSDraw___destroy___0.apply(null, arguments)\n    }\n      , Rf = b._emscripten_bind_b2MouseJointDef___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef___destroy___0.apply(null, arguments)\n    }\n      , Sf = b._emscripten_bind_b2Mat33_Solve22_1 = function() {\n        return b.asm._emscripten_bind_b2Mat33_Solve22_1.apply(null, arguments)\n    }\n      , Tf = b._emscripten_bind_b2Profile_set_solvePosition_1 = function() {\n        return b.asm._emscripten_bind_b2Profile_set_solvePosition_1.apply(null, arguments)\n    }\n      , Uf = b._emscripten_bind_b2ContactFilter___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2ContactFilter___destroy___0.apply(null, arguments)\n    }\n      , Vf = b._emscripten_bind_b2WheelJoint_GetLocalAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetLocalAnchorA_0.apply(null, arguments)\n    }\n      , Wf = b._emscripten_bind_b2ChainShape_set_m_hasPrevVertex_1 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_set_m_hasPrevVertex_1.apply(null, arguments)\n    }\n      , Xf = b._emscripten_bind_b2Joint_SetUserData_1 = function() {\n        return b.asm._emscripten_bind_b2Joint_SetUserData_1.apply(null, arguments)\n    }\n      , Yf = b._emscripten_bind_b2DistanceJoint_SetUserData_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_SetUserData_1.apply(null, arguments)\n    }\n      , Zf = b._emscripten_bind_b2PrismaticJoint___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint___destroy___0.apply(null, arguments)\n    }\n      , $f = b._emscripten_bind_b2RopeJointDef_set_bodyA_1 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_set_bodyA_1.apply(null, arguments)\n    }\n      , ag = b._emscripten_bind_b2GearJoint___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2GearJoint___destroy___0.apply(null, arguments)\n    }\n      , bg = b._emscripten_bind_b2PrismaticJoint_GetJointTranslation_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetJointTranslation_0.apply(null, arguments)\n    }\n      , cg = b._emscripten_bind_b2ManifoldPoint_get_id_0 = function() {\n        return b.asm._emscripten_bind_b2ManifoldPoint_get_id_0.apply(null, arguments)\n    }\n      , dg = b._emscripten_bind_b2CircleShape_get_m_radius_0 = function() {\n        return b.asm._emscripten_bind_b2CircleShape_get_m_radius_0.apply(null, arguments)\n    }\n      , eg = b._emscripten_bind_b2PrismaticJoint_GetMotorSpeed_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetMotorSpeed_0.apply(null, arguments)\n    }\n      , fg = b._emscripten_bind_b2PulleyJoint_GetGroundAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetGroundAnchorB_0.apply(null, arguments)\n    }\n      , gg = b._emscripten_bind_b2Vec3_op_add_1 = function() {\n        return b.asm._emscripten_bind_b2Vec3_op_add_1.apply(null, arguments)\n    }\n      , hg = b._emscripten_bind_b2FrictionJoint_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_GetType_0.apply(null, arguments)\n    }\n      , ig = b._emscripten_bind_b2MouseJoint_GetMaxForce_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_GetMaxForce_0.apply(null, arguments)\n    }\n      , jg = b._emscripten_bind_b2MouseJoint_SetTarget_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_SetTarget_1.apply(null, arguments)\n    }\n      , kg = b._emscripten_bind_b2MouseJointDef_get_dampingRatio_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_get_dampingRatio_0.apply(null, arguments)\n    }\n      , lg = b._emscripten_bind_b2RevoluteJoint_GetMotorSpeed_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetMotorSpeed_0.apply(null, arguments)\n    }\n      , mg = b._emscripten_bind_b2ChainShape_set_m_type_1 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_set_m_type_1.apply(null, arguments)\n    }\n      , ng = b._emscripten_bind_b2RevoluteJointDef_set_bodyB_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_set_bodyB_1.apply(null, arguments)\n    }\n      , og = b._emscripten_bind_b2Rot_GetXAxis_0 = function() {\n        return b.asm._emscripten_bind_b2Rot_GetXAxis_0.apply(null, arguments)\n    }\n      , pg = b._emscripten_bind_b2Mat33_b2Mat33_0 = function() {\n        return b.asm._emscripten_bind_b2Mat33_b2Mat33_0.apply(null, arguments)\n    }\n      , qg = b._emscripten_bind_b2MouseJointDef_get_bodyB_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_get_bodyB_0.apply(null, arguments)\n    }\n      , rg = b._emscripten_bind_b2Body_GetWorldVector_1 = function() {\n        return b.asm._emscripten_bind_b2Body_GetWorldVector_1.apply(null, arguments)\n    }\n      , sg = b._emscripten_bind_b2WeldJointDef_get_frequencyHz_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_get_frequencyHz_0.apply(null, arguments)\n    }\n      , tg = b._emscripten_bind_b2GearJointDef_set_ratio_1 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_set_ratio_1.apply(null, arguments)\n    }\n      , ug = b._emscripten_bind_b2Manifold___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2Manifold___destroy___0.apply(null, arguments)\n    }\n      , vg = b._emscripten_bind_b2PulleyJointDef_set_lengthA_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_set_lengthA_1.apply(null, arguments)\n    }\n      , wg = b._emscripten_bind_b2Contact_IsEnabled_0 = function() {\n        return b.asm._emscripten_bind_b2Contact_IsEnabled_0.apply(null, arguments)\n    }\n    ;\n    b.stackRestore = function() {\n        return b.asm.stackRestore.apply(null, arguments)\n    }\n    ;\n    var xg = b._emscripten_bind_b2World_CreateJoint_1 = function() {\n        return b.asm._emscripten_bind_b2World_CreateJoint_1.apply(null, arguments)\n    }\n      , yg = b._emscripten_bind_b2PulleyJointDef_set_ratio_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_set_ratio_1.apply(null, arguments)\n    }\n      , zg = b._emscripten_bind_b2JointEdge_set_prev_1 = function() {\n        return b.asm._emscripten_bind_b2JointEdge_set_prev_1.apply(null, arguments)\n    }\n      , Ag = b._emscripten_bind_b2PrismaticJoint_GetReactionTorque_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetReactionTorque_1.apply(null, arguments)\n    }\n      , Bg = b._emscripten_bind_b2Body_GetLocalPoint_1 = function() {\n        return b.asm._emscripten_bind_b2Body_GetLocalPoint_1.apply(null, arguments)\n    }\n      , Cg = b._emscripten_bind_b2PrismaticJoint_GetCollideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetCollideConnected_0.apply(null, arguments)\n    }\n      , Dg = b._emscripten_bind_b2DistanceJoint_IsActive_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_IsActive_0.apply(null, arguments)\n    }\n      , Eg = b._emscripten_bind_b2RopeJoint_GetLimitState_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_GetLimitState_0.apply(null, arguments)\n    }\n      , Fg = b._emscripten_bind_b2Profile_get_solveTOI_0 = function() {\n        return b.asm._emscripten_bind_b2Profile_get_solveTOI_0.apply(null, arguments)\n    }\n      , Gg = b._emscripten_bind_b2Vec2_b2Vec2_0 = function() {\n        return b.asm._emscripten_bind_b2Vec2_b2Vec2_0.apply(null, arguments)\n    }\n      , Hg = b._emscripten_bind_b2DistanceJoint_GetAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetAnchorB_0.apply(null, arguments)\n    }\n      , Ig = b._emscripten_bind_b2WheelJointDef_get_maxMotorTorque_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_get_maxMotorTorque_0.apply(null, arguments)\n    }\n      , Jg = b._emscripten_bind_b2Vec2_op_sub_1 = function() {\n        return b.asm._emscripten_bind_b2Vec2_op_sub_1.apply(null, arguments)\n    }\n      , Kg = b._emscripten_bind_b2CircleShape_get_m_p_0 = function() {\n        return b.asm._emscripten_bind_b2CircleShape_get_m_p_0.apply(null, arguments)\n    }\n      , Lg = b._emscripten_bind_b2ContactFeature_get_indexA_0 = function() {\n        return b.asm._emscripten_bind_b2ContactFeature_get_indexA_0.apply(null, arguments)\n    }\n      , Mg = b._emscripten_bind_b2MotorJointDef_b2MotorJointDef_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_b2MotorJointDef_0.apply(null, arguments)\n    }\n      , Ng = b._emscripten_bind_b2RevoluteJoint_EnableLimit_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_EnableLimit_1.apply(null, arguments)\n    }\n      , Og = b._emscripten_bind_b2ContactEdge_get_next_0 = function() {\n        return b.asm._emscripten_bind_b2ContactEdge_get_next_0.apply(null, arguments)\n    }\n      , Pg = b._emscripten_bind_b2AABB_GetPerimeter_0 = function() {\n        return b.asm._emscripten_bind_b2AABB_GetPerimeter_0.apply(null, arguments)\n    }\n      , Qg = b._emscripten_bind_b2RevoluteJoint_GetCollideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetCollideConnected_0.apply(null, arguments)\n    }\n      , Rg = b._emscripten_bind_b2Mat33_get_ex_0 = function() {\n        return b.asm._emscripten_bind_b2Mat33_get_ex_0.apply(null, arguments)\n    }\n      , Sg = b._emscripten_bind_b2Body_GetPosition_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetPosition_0.apply(null, arguments)\n    }\n      , Tg = b._emscripten_bind_b2Profile___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2Profile___destroy___0.apply(null, arguments)\n    }\n      , Ug = b._emscripten_bind_b2ContactEdge_get_prev_0 = function() {\n        return b.asm._emscripten_bind_b2ContactEdge_get_prev_0.apply(null, arguments)\n    }\n      , Vg = b._emscripten_bind_b2DistanceJoint_SetFrequency_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_SetFrequency_1.apply(null, arguments)\n    }\n      , Wg = b._emscripten_bind_b2Fixture_GetBody_0 = function() {\n        return b.asm._emscripten_bind_b2Fixture_GetBody_0.apply(null, arguments)\n    }\n      , Xg = b._emscripten_bind_b2ContactImpulse_set_count_1 = function() {\n        return b.asm._emscripten_bind_b2ContactImpulse_set_count_1.apply(null, arguments)\n    }\n      , Yg = b._emscripten_bind_b2FixtureDef_set_shape_1 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_set_shape_1.apply(null, arguments)\n    }\n      , Zg = b._emscripten_bind_b2PulleyJointDef_get_bodyB_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_get_bodyB_0.apply(null, arguments)\n    }\n      , $g = b._emscripten_bind_b2ChainShape_GetChildCount_0 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_GetChildCount_0.apply(null, arguments)\n    }\n      , ah = b._emscripten_bind_b2CircleShape_b2CircleShape_0 = function() {\n        return b.asm._emscripten_bind_b2CircleShape_b2CircleShape_0.apply(null, arguments)\n    }\n      , bh = b._emscripten_bind_b2RevoluteJoint_GetReactionTorque_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetReactionTorque_1.apply(null, arguments)\n    }\n      , ch = b._emscripten_bind_b2Fixture_SetDensity_1 = function() {\n        return b.asm._emscripten_bind_b2Fixture_SetDensity_1.apply(null, arguments)\n    }\n      , dh = b._emscripten_bind_b2ChainShape_get_m_prevVertex_0 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_get_m_prevVertex_0.apply(null, arguments)\n    }\n      , eh = b._emscripten_bind_b2AABB_GetExtents_0 = function() {\n        return b.asm._emscripten_bind_b2AABB_GetExtents_0.apply(null, arguments)\n    }\n      , fh = b._emscripten_bind_b2World_ClearForces_0 = function() {\n        return b.asm._emscripten_bind_b2World_ClearForces_0.apply(null, arguments)\n    }\n      , gh = b._emscripten_bind_b2Vec3___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2Vec3___destroy___0.apply(null, arguments)\n    }\n      , hh = b._emscripten_bind_b2WheelJointDef_set_userData_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_set_userData_1.apply(null, arguments)\n    }\n      , ih = b._emscripten_bind_b2WeldJoint_SetFrequency_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_SetFrequency_1.apply(null, arguments)\n    }\n      , jh = b._emscripten_bind_JSContactListener_PreSolve_2 = function() {\n        return b.asm._emscripten_bind_JSContactListener_PreSolve_2.apply(null, arguments)\n    }\n      , kh = b._emscripten_bind_b2Body_SetFixedRotation_1 = function() {\n        return b.asm._emscripten_bind_b2Body_SetFixedRotation_1.apply(null, arguments)\n    }\n      , lh = b._emscripten_bind_b2RayCastOutput_set_normal_1 = function() {\n        return b.asm._emscripten_bind_b2RayCastOutput_set_normal_1.apply(null, arguments)\n    }\n      , mh = b._emscripten_bind_b2DistanceJoint_GetDampingRatio_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetDampingRatio_0.apply(null, arguments)\n    }\n      , nh = b._emscripten_bind_b2RevoluteJoint_SetMaxMotorTorque_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_SetMaxMotorTorque_1.apply(null, arguments)\n    }\n      , oh = b._emscripten_bind_b2RevoluteJoint_EnableMotor_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_EnableMotor_1.apply(null, arguments)\n    }\n      , ph = b._emscripten_bind_b2Contact_GetChildIndexB_0 = function() {\n        return b.asm._emscripten_bind_b2Contact_GetChildIndexB_0.apply(null, arguments)\n    }\n      , qh = b._emscripten_bind_b2MouseJointDef_set_bodyB_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_set_bodyB_1.apply(null, arguments)\n    }\n      , rh = b._emscripten_bind_b2CircleShape_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2CircleShape_GetType_0.apply(null, arguments)\n    }\n      , sh = b._emscripten_bind_b2PolygonShape_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_GetType_0.apply(null, arguments)\n    }\n      , th = b._emscripten_bind_b2PrismaticJointDef_set_referenceAngle_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_referenceAngle_1.apply(null, arguments)\n    }\n      , uh = b._emscripten_bind_b2RopeJointDef_get_collideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_get_collideConnected_0.apply(null, arguments)\n    }\n      , vh = b._emscripten_bind_b2FixtureDef_set_filter_1 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_set_filter_1.apply(null, arguments)\n    }\n      , wh = b._emscripten_bind_b2Body_ApplyTorque_2 = function() {\n        return b.asm._emscripten_bind_b2Body_ApplyTorque_2.apply(null, arguments)\n    }\n      , xh = b._emscripten_bind_b2RevoluteJoint___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint___destroy___0.apply(null, arguments)\n    }\n      , yh = b._emscripten_bind_b2FrictionJointDef_get_userData_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_get_userData_0.apply(null, arguments)\n    }\n      , zh = b._emscripten_bind_b2RayCastCallback___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2RayCastCallback___destroy___0.apply(null, arguments)\n    }\n      , Ah = b._emscripten_bind_b2RevoluteJointDef_set_bodyA_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_set_bodyA_1.apply(null, arguments)\n    }\n      , Bh = b._emscripten_bind_b2MotorJoint_SetUserData_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_SetUserData_1.apply(null, arguments)\n    }\n      , Ch = b._emscripten_bind_b2PrismaticJoint_GetLocalAxisA_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetLocalAxisA_0.apply(null, arguments)\n    }\n      , Dh = b._emscripten_bind_b2MotorJoint_GetBodyB_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetBodyB_0.apply(null, arguments)\n    }\n      , Eh = b._emscripten_bind_b2Transform_Set_2 = function() {\n        return b.asm._emscripten_bind_b2Transform_Set_2.apply(null, arguments)\n    }\n      , Fh = b._emscripten_bind_b2MotorJoint_GetBodyA_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetBodyA_0.apply(null, arguments)\n    }\n    ;\n    b.stackAlloc = function() {\n        return b.asm.stackAlloc.apply(null, arguments)\n    }\n    ;\n    var Gh = b._emscripten_bind_b2Draw_AppendFlags_1 = function() {\n        return b.asm._emscripten_bind_b2Draw_AppendFlags_1.apply(null, arguments)\n    }\n      , Hh = b._emscripten_bind_b2EdgeShape_GetChildCount_0 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_GetChildCount_0.apply(null, arguments)\n    }\n      , Ih = b._emscripten_bind_b2Contact_ResetFriction_0 = function() {\n        return b.asm._emscripten_bind_b2Contact_ResetFriction_0.apply(null, arguments)\n    }\n      , Jh = b._emscripten_bind_b2Profile_set_solveTOI_1 = function() {\n        return b.asm._emscripten_bind_b2Profile_set_solveTOI_1.apply(null, arguments)\n    }\n      , Kh = b._emscripten_bind_b2PrismaticJointDef_set_type_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_type_1.apply(null, arguments)\n    }\n      , Lh = b._emscripten_bind_b2AABB_GetCenter_0 = function() {\n        return b.asm._emscripten_bind_b2AABB_GetCenter_0.apply(null, arguments)\n    }\n      , Mh = b._emscripten_bind_b2WheelJoint_SetSpringFrequencyHz_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_SetSpringFrequencyHz_1.apply(null, arguments)\n    }\n      , Nh = b._emscripten_bind_b2FrictionJointDef___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef___destroy___0.apply(null, arguments)\n    }\n      , Oh = b._emscripten_bind_b2PrismaticJoint_GetReactionForce_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetReactionForce_1.apply(null, arguments)\n    }\n      , Ph = b._emscripten_bind_b2Transform_b2Transform_0 = function() {\n        return b.asm._emscripten_bind_b2Transform_b2Transform_0.apply(null, arguments)\n    }\n      , Qh = b._emscripten_enum_b2LimitState_e_equalLimits = function() {\n        return b.asm._emscripten_enum_b2LimitState_e_equalLimits.apply(null, arguments)\n    }\n      , Rh = b._emscripten_bind_b2ManifoldPoint_set_normalImpulse_1 = function() {\n        return b.asm._emscripten_bind_b2ManifoldPoint_set_normalImpulse_1.apply(null, arguments)\n    }\n      , Sh = b._emscripten_bind_b2Body_IsFixedRotation_0 = function() {\n        return b.asm._emscripten_bind_b2Body_IsFixedRotation_0.apply(null, arguments)\n    }\n      , Th = b._emscripten_enum_b2DrawFlag_e_shapeBit = function() {\n        return b.asm._emscripten_enum_b2DrawFlag_e_shapeBit.apply(null, arguments)\n    }\n      , Uh = b._emscripten_bind_b2Contact_GetFriction_0 = function() {\n        return b.asm._emscripten_bind_b2Contact_GetFriction_0.apply(null, arguments)\n    }\n      , Vh = b._emscripten_bind_b2Body_GetContactList_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetContactList_0.apply(null, arguments)\n    }\n      , Wh = b._emscripten_bind_b2DistanceJointDef_set_length_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_set_length_1.apply(null, arguments)\n    }\n      , Xh = b._emscripten_bind_b2DistanceJoint_GetLocalAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetLocalAnchorB_0.apply(null, arguments)\n    }\n      , Yh = b._emscripten_bind_b2FrictionJoint_GetLocalAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_GetLocalAnchorB_0.apply(null, arguments)\n    }\n      , Zh = b._emscripten_bind_b2World_b2World_1 = function() {\n        return b.asm._emscripten_bind_b2World_b2World_1.apply(null, arguments)\n    }\n      , $h = b._emscripten_bind_b2PrismaticJoint_IsLimitEnabled_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_IsLimitEnabled_0.apply(null, arguments)\n    }\n      , ai = b._emscripten_bind_b2DistanceJointDef_get_type_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_get_type_0.apply(null, arguments)\n    }\n      , bi = b._emscripten_bind_b2Draw_ClearFlags_1 = function() {\n        return b.asm._emscripten_bind_b2Draw_ClearFlags_1.apply(null, arguments)\n    }\n      , ci = b._emscripten_bind_b2Body_SetAngularDamping_1 = function() {\n        return b.asm._emscripten_bind_b2Body_SetAngularDamping_1.apply(null, arguments)\n    }\n      , di = b._emscripten_bind_b2Body_IsActive_0 = function() {\n        return b.asm._emscripten_bind_b2Body_IsActive_0.apply(null, arguments)\n    }\n      , ei = b._emscripten_bind_b2Contact_ResetRestitution_0 = function() {\n        return b.asm._emscripten_bind_b2Contact_ResetRestitution_0.apply(null, arguments)\n    }\n      , fi = b._emscripten_bind_b2World_GetAllowSleeping_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetAllowSleeping_0.apply(null, arguments)\n    }\n      , gi = b._emscripten_bind_b2ManifoldPoint_b2ManifoldPoint_0 = function() {\n        return b.asm._emscripten_bind_b2ManifoldPoint_b2ManifoldPoint_0.apply(null, arguments)\n    }\n      , hi = b._emscripten_bind_b2EdgeShape_set_m_type_1 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_set_m_type_1.apply(null, arguments)\n    }\n      , ii = b._emscripten_enum_b2JointType_e_unknownJoint = function() {\n        return b.asm._emscripten_enum_b2JointType_e_unknownJoint.apply(null, arguments)\n    }\n      , ji = b._emscripten_bind_b2RevoluteJointDef_set_enableMotor_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_set_enableMotor_1.apply(null, arguments)\n    }\n      , ki = b._emscripten_bind_b2PulleyJoint_IsActive_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_IsActive_0.apply(null, arguments)\n    }\n      , li = b._emscripten_bind_b2MouseJoint_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_GetNext_0.apply(null, arguments)\n    }\n      , mi = b._emscripten_bind_b2RevoluteJoint_SetUserData_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_SetUserData_1.apply(null, arguments)\n    }\n      , ni = b._emscripten_bind_b2Manifold_get_localPoint_0 = function() {\n        return b.asm._emscripten_bind_b2Manifold_get_localPoint_0.apply(null, arguments)\n    }\n      , oi = b._emscripten_bind_b2PulleyJointDef_get_lengthB_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_get_lengthB_0.apply(null, arguments)\n    }\n      , pi = b._emscripten_bind_b2WeldJoint_SetUserData_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_SetUserData_1.apply(null, arguments)\n    }\n      , qi = b._emscripten_bind_b2ChainShape_CreateLoop_2 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_CreateLoop_2.apply(null, arguments)\n    }\n      , ri = b._emscripten_bind_b2GearJointDef_get_joint1_0 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_get_joint1_0.apply(null, arguments)\n    }\n      , si = b._emscripten_bind_b2PrismaticJoint_GetMotorForce_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetMotorForce_1.apply(null, arguments)\n    }\n      , ti = b._emscripten_bind_b2Body_SetUserData_1 = function() {\n        return b.asm._emscripten_bind_b2Body_SetUserData_1.apply(null, arguments)\n    }\n      , ui = b._emscripten_bind_b2GearJoint_IsActive_0 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_IsActive_0.apply(null, arguments)\n    }\n      , vi = b._emscripten_bind_b2EdgeShape_get_m_vertex0_0 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_get_m_vertex0_0.apply(null, arguments)\n    }\n      , wi = b._emscripten_enum_b2JointType_e_revoluteJoint = function() {\n        return b.asm._emscripten_enum_b2JointType_e_revoluteJoint.apply(null, arguments)\n    }\n      , xi = b._emscripten_bind_b2Vec2_get_x_0 = function() {\n        return b.asm._emscripten_bind_b2Vec2_get_x_0.apply(null, arguments)\n    }\n      , yi = b._emscripten_bind_b2WeldJointDef_get_collideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_get_collideConnected_0.apply(null, arguments)\n    }\n      , zi = b._emscripten_bind_b2FrictionJoint_GetMaxTorque_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_GetMaxTorque_0.apply(null, arguments)\n    }\n      , Ai = b._emscripten_bind_b2EdgeShape_RayCast_4 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_RayCast_4.apply(null, arguments)\n    }\n      , Bi = b._emscripten_bind_b2BodyDef_set_allowSleep_1 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_set_allowSleep_1.apply(null, arguments)\n    }\n      , Ci = b._emscripten_bind_b2PulleyJoint_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetType_0.apply(null, arguments)\n    }\n      , Di = b._emscripten_bind_b2WeldJointDef_set_localAnchorA_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_set_localAnchorA_1.apply(null, arguments)\n    }\n      , Ei = b._emscripten_bind_b2Profile_set_step_1 = function() {\n        return b.asm._emscripten_bind_b2Profile_set_step_1.apply(null, arguments)\n    }\n      , Fi = b._emscripten_bind_b2ContactEdge_set_other_1 = function() {\n        return b.asm._emscripten_bind_b2ContactEdge_set_other_1.apply(null, arguments)\n    }\n      , Gi = b._emscripten_bind_b2PulleyJoint_GetCurrentLengthB_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetCurrentLengthB_0.apply(null, arguments)\n    }\n      , Hi = b._emscripten_bind_b2Vec2_op_mul_1 = function() {\n        return b.asm._emscripten_bind_b2Vec2_op_mul_1.apply(null, arguments)\n    }\n      , Ii = b._emscripten_bind_b2PrismaticJointDef_get_localAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_localAnchorA_0.apply(null, arguments)\n    }\n      , Ji = b._emscripten_bind_b2EdgeShape___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape___destroy___0.apply(null, arguments)\n    }\n      , Ki = b._emscripten_bind_b2PolygonShape_get_m_count_0 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_get_m_count_0.apply(null, arguments)\n    }\n      , Li = b._emscripten_bind_b2RopeJoint_GetAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_GetAnchorA_0.apply(null, arguments)\n    }\n      , Mi = b._emscripten_bind_b2DistanceJointDef_get_bodyA_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_get_bodyA_0.apply(null, arguments)\n    }\n      , Ni = b._emscripten_bind_b2AABB_Combine_2 = function() {\n        return b.asm._emscripten_bind_b2AABB_Combine_2.apply(null, arguments)\n    }\n      , Oi = b._emscripten_bind_b2ManifoldPoint_set_tangentImpulse_1 = function() {\n        return b.asm._emscripten_bind_b2ManifoldPoint_set_tangentImpulse_1.apply(null, arguments)\n    }\n      , Pi = b._emscripten_bind_b2BodyDef_get_allowSleep_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_get_allowSleep_0.apply(null, arguments)\n    }\n      , Qi = b._emscripten_bind_b2ContactEdge_get_other_0 = function() {\n        return b.asm._emscripten_bind_b2ContactEdge_get_other_0.apply(null, arguments)\n    }\n      , Ri = b._emscripten_bind_b2RopeJoint_GetLocalAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_GetLocalAnchorB_0.apply(null, arguments)\n    }\n      , Si = b._emscripten_bind_b2PulleyJointDef___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef___destroy___0.apply(null, arguments)\n    }\n      , Ti = b._emscripten_bind_b2MouseJoint_GetBodyB_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_GetBodyB_0.apply(null, arguments)\n    }\n      , Ui = b._emscripten_bind_b2PolygonShape_TestPoint_2 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_TestPoint_2.apply(null, arguments)\n    }\n      , Vi = b._emscripten_bind_b2JointEdge_get_other_0 = function() {\n        return b.asm._emscripten_bind_b2JointEdge_get_other_0.apply(null, arguments)\n    }\n      , Wi = b._emscripten_bind_b2PolygonShape_b2PolygonShape_0 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_b2PolygonShape_0.apply(null, arguments)\n    }\n      , Xi = b._emscripten_bind_b2PolygonShape_Set_2 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_Set_2.apply(null, arguments)\n    }\n      , Yi = b._emscripten_bind_b2GearJoint_GetReactionForce_1 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_GetReactionForce_1.apply(null, arguments)\n    }\n      , Zi = b._emscripten_bind_b2DistanceJointDef_get_localAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_get_localAnchorA_0.apply(null, arguments)\n    }\n      , $i = b._emscripten_bind_b2Fixture_SetUserData_1 = function() {\n        return b.asm._emscripten_bind_b2Fixture_SetUserData_1.apply(null, arguments)\n    }\n      , aj = b._emscripten_bind_b2Contact_SetTangentSpeed_1 = function() {\n        return b.asm._emscripten_bind_b2Contact_SetTangentSpeed_1.apply(null, arguments)\n    }\n      , bj = b._emscripten_bind_b2PrismaticJointDef_b2PrismaticJointDef_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_b2PrismaticJointDef_0.apply(null, arguments)\n    }\n      , cj = b._emscripten_bind_b2BodyDef_get_active_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_get_active_0.apply(null, arguments)\n    }\n      , dj = b._emscripten_bind_b2Body_GetAngularVelocity_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetAngularVelocity_0.apply(null, arguments)\n    }\n      , ej = b._emscripten_bind_b2CircleShape_set_m_p_1 = function() {\n        return b.asm._emscripten_bind_b2CircleShape_set_m_p_1.apply(null, arguments)\n    }\n      , fj = b._emscripten_bind_b2Draw___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2Draw___destroy___0.apply(null, arguments)\n    }\n      , gj = b._emscripten_bind_b2WheelJointDef_Initialize_4 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_Initialize_4.apply(null, arguments)\n    }\n      , hj = b._emscripten_bind_b2WeldJointDef_set_dampingRatio_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_set_dampingRatio_1.apply(null, arguments)\n    }\n      , ij = b._emscripten_bind_b2ChainShape_b2ChainShape_0 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_b2ChainShape_0.apply(null, arguments)\n    }\n      , jj = b._emscripten_bind_b2Joint_GetAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2Joint_GetAnchorB_0.apply(null, arguments)\n    }\n      , kj = b._emscripten_bind_b2PrismaticJointDef_get_userData_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_userData_0.apply(null, arguments)\n    }\n      , lj = b._emscripten_bind_b2MotorJoint_GetMaxForce_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetMaxForce_0.apply(null, arguments)\n    }\n      , mj = b._emscripten_bind_b2RevoluteJoint_GetBodyA_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetBodyA_0.apply(null, arguments)\n    }\n      , nj = b._emscripten_bind_b2ContactID_set_cf_1 = function() {\n        return b.asm._emscripten_bind_b2ContactID_set_cf_1.apply(null, arguments)\n    }\n      , oj = b._emscripten_bind_b2Body_GetGravityScale_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetGravityScale_0.apply(null, arguments)\n    }\n      , pj = b._emscripten_bind_b2Vec3_Set_3 = function() {\n        return b.asm._emscripten_bind_b2Vec3_Set_3.apply(null, arguments)\n    }\n      , qj = b._emscripten_bind_b2RevoluteJointDef_set_localAnchorA_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_set_localAnchorA_1.apply(null, arguments)\n    }\n      , rj = b._emscripten_bind_b2FrictionJointDef_set_localAnchorB_1 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_set_localAnchorB_1.apply(null, arguments)\n    }\n      , sj = b._emscripten_bind_b2PulleyJoint_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetNext_0.apply(null, arguments)\n    }\n      , tj = b._emscripten_bind_b2ChainShape_get_m_type_0 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_get_m_type_0.apply(null, arguments)\n    }\n      , uj = b._emscripten_bind_b2PulleyJointDef_get_groundAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_get_groundAnchorB_0.apply(null, arguments)\n    }\n      , vj = b._emscripten_bind_JSDraw_DrawTransform_1 = function() {\n        return b.asm._emscripten_bind_JSDraw_DrawTransform_1.apply(null, arguments)\n    }\n      , wj = b._emscripten_bind_b2GearJointDef_get_bodyA_0 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_get_bodyA_0.apply(null, arguments)\n    }\n      , xj = b._emscripten_bind_b2DistanceJointDef_set_frequencyHz_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_set_frequencyHz_1.apply(null, arguments)\n    }\n      , yj = b._emscripten_bind_b2RevoluteJointDef_get_localAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_get_localAnchorB_0.apply(null, arguments)\n    }\n      , zj = b._emscripten_bind_b2RevoluteJointDef_get_referenceAngle_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_get_referenceAngle_0.apply(null, arguments)\n    }\n      , Aj = b._emscripten_bind_JSContactFilter___destroy___0 = function() {\n        return b.asm._emscripten_bind_JSContactFilter___destroy___0.apply(null, arguments)\n    }\n      , Bj = b._emscripten_bind_b2RevoluteJointDef_get_enableMotor_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_get_enableMotor_0.apply(null, arguments)\n    }\n      , Cb = b._memset = function() {\n        return b.asm._memset.apply(null, arguments)\n    }\n      , Cj = b._emscripten_bind_b2PolygonShape_get_m_radius_0 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_get_m_radius_0.apply(null, arguments)\n    }\n      , Dj = b._emscripten_enum_b2BodyType_b2_kinematicBody = function() {\n        return b.asm._emscripten_enum_b2BodyType_b2_kinematicBody.apply(null, arguments)\n    }\n      , Ej = b._emscripten_bind_b2Rot_set_s_1 = function() {\n        return b.asm._emscripten_bind_b2Rot_set_s_1.apply(null, arguments)\n    }\n      , Fj = b._emscripten_enum_b2ManifoldType_e_faceA = function() {\n        return b.asm._emscripten_enum_b2ManifoldType_e_faceA.apply(null, arguments)\n    }\n      , Gj = b._emscripten_enum_b2ManifoldType_e_faceB = function() {\n        return b.asm._emscripten_enum_b2ManifoldType_e_faceB.apply(null, arguments)\n    }\n      , Hj = b._emscripten_bind_b2RevoluteJointDef_get_bodyB_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_get_bodyB_0.apply(null, arguments)\n    }\n      , Ij = b._emscripten_bind_b2FixtureDef_b2FixtureDef_0 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_b2FixtureDef_0.apply(null, arguments)\n    }\n      , Jj = b._emscripten_bind_b2PrismaticJoint_SetUserData_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_SetUserData_1.apply(null, arguments)\n    }\n      , Kj = b._emscripten_bind_b2WorldManifold_set_points_2 = function() {\n        return b.asm._emscripten_bind_b2WorldManifold_set_points_2.apply(null, arguments)\n    }\n      , Lj = b._emscripten_bind_b2EdgeShape_get_m_hasVertex3_0 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_get_m_hasVertex3_0.apply(null, arguments)\n    }\n      , Mj = b._emscripten_enum_b2ShapeType_e_edge = function() {\n        return b.asm._emscripten_enum_b2ShapeType_e_edge.apply(null, arguments)\n    }\n      , Nj = b._emscripten_bind_b2RevoluteJoint_GetMaxMotorTorque_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetMaxMotorTorque_0.apply(null, arguments)\n    }\n      , Oj = b._emscripten_bind_b2BodyDef_set_active_1 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_set_active_1.apply(null, arguments)\n    }\n      , Pj = b._emscripten_bind_b2EdgeShape_Set_2 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_Set_2.apply(null, arguments)\n    }\n      , Qj = b._emscripten_bind_b2FixtureDef_set_isSensor_1 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_set_isSensor_1.apply(null, arguments)\n    }\n      , Rj = b._emscripten_bind_b2Body_GetWorldPoint_1 = function() {\n        return b.asm._emscripten_bind_b2Body_GetWorldPoint_1.apply(null, arguments)\n    }\n      , Sj = b._emscripten_bind_b2ManifoldPoint_get_normalImpulse_0 = function() {\n        return b.asm._emscripten_bind_b2ManifoldPoint_get_normalImpulse_0.apply(null, arguments)\n    }\n      , Tj = b._emscripten_bind_JSContactFilter_ShouldCollide_2 = function() {\n        return b.asm._emscripten_bind_JSContactFilter_ShouldCollide_2.apply(null, arguments)\n    }\n      , Uj = b._emscripten_bind_b2Joint_GetReactionTorque_1 = function() {\n        return b.asm._emscripten_bind_b2Joint_GetReactionTorque_1.apply(null, arguments)\n    }\n      , Vj = b._emscripten_bind_b2RevoluteJointDef_set_type_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_set_type_1.apply(null, arguments)\n    }\n      , Wj = b._emscripten_bind_b2RayCastInput_set_p1_1 = function() {\n        return b.asm._emscripten_bind_b2RayCastInput_set_p1_1.apply(null, arguments)\n    }\n      , Xj = b._emscripten_bind_b2RopeJointDef_b2RopeJointDef_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_b2RopeJointDef_0.apply(null, arguments)\n    }\n      , Yj = b._emscripten_bind_b2BodyDef_get_linearDamping_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_get_linearDamping_0.apply(null, arguments)\n    }\n      , Zj = b._emscripten_bind_b2World_Step_3 = function() {\n        return b.asm._emscripten_bind_b2World_Step_3.apply(null, arguments)\n    }\n      , ak = b._emscripten_bind_b2CircleShape_RayCast_4 = function() {\n        return b.asm._emscripten_bind_b2CircleShape_RayCast_4.apply(null, arguments)\n    }\n      , bk = b._emscripten_bind_b2Profile_get_step_0 = function() {\n        return b.asm._emscripten_bind_b2Profile_get_step_0.apply(null, arguments)\n    }\n      , ck = b._emscripten_bind_b2AABB_RayCast_2 = function() {\n        return b.asm._emscripten_bind_b2AABB_RayCast_2.apply(null, arguments)\n    }\n      , dk = b._emscripten_bind_b2Mat22_SetZero_0 = function() {\n        return b.asm._emscripten_bind_b2Mat22_SetZero_0.apply(null, arguments)\n    }\n    ;\n    b.setTempRet0 = function() {\n        return b.asm.setTempRet0.apply(null, arguments)\n    }\n    ;\n    var ek = b._emscripten_bind_b2DistanceJoint_GetLength_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetLength_0.apply(null, arguments)\n    }\n      , fk = b._emscripten_bind_b2PulleyJoint_GetLengthB_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetLengthB_0.apply(null, arguments)\n    }\n      , gk = b._emscripten_bind_b2PrismaticJoint_GetUpperLimit_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetUpperLimit_0.apply(null, arguments)\n    }\n      , hk = b._emscripten_bind_b2WorldManifold_set_separations_2 = function() {\n        return b.asm._emscripten_bind_b2WorldManifold_set_separations_2.apply(null, arguments)\n    }\n      , ik = b._emscripten_bind_b2WheelJoint_SetMaxMotorTorque_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_SetMaxMotorTorque_1.apply(null, arguments)\n    }\n      , jk = b._emscripten_bind_b2MotorJoint_GetUserData_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetUserData_0.apply(null, arguments)\n    }\n      , kk = b._emscripten_bind_b2FrictionJoint_GetReactionTorque_1 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_GetReactionTorque_1.apply(null, arguments)\n    }\n      , lk = b._emscripten_bind_b2Shape_get_m_type_0 = function() {\n        return b.asm._emscripten_bind_b2Shape_get_m_type_0.apply(null, arguments)\n    }\n      , mk = b._emscripten_bind_b2MouseJoint_SetDampingRatio_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_SetDampingRatio_1.apply(null, arguments)\n    }\n      , nk = b._emscripten_bind_b2World_GetAutoClearForces_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetAutoClearForces_0.apply(null, arguments)\n    }\n      , ok = b._emscripten_bind_b2WorldManifold_set_normal_1 = function() {\n        return b.asm._emscripten_bind_b2WorldManifold_set_normal_1.apply(null, arguments)\n    }\n      , pk = b._emscripten_enum_b2ShapeType_e_circle = function() {\n        return b.asm._emscripten_enum_b2ShapeType_e_circle.apply(null, arguments)\n    }\n      , qk = b._emscripten_bind_b2BodyDef_set_fixedRotation_1 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_set_fixedRotation_1.apply(null, arguments)\n    }\n      , rk = b._emscripten_bind_b2Vec2_b2Vec2_2 = function() {\n        return b.asm._emscripten_bind_b2Vec2_b2Vec2_2.apply(null, arguments)\n    }\n      , sk = b._emscripten_bind_b2Manifold_get_type_0 = function() {\n        return b.asm._emscripten_bind_b2Manifold_get_type_0.apply(null, arguments)\n    }\n      , tk = b._emscripten_bind_b2Body_Dump_0 = function() {\n        return b.asm._emscripten_bind_b2Body_Dump_0.apply(null, arguments)\n    }\n      , uk = b._emscripten_bind_b2RevoluteJoint_GetLowerLimit_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetLowerLimit_0.apply(null, arguments)\n    }\n      , vk = b._emscripten_bind_b2Body_GetWorldCenter_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetWorldCenter_0.apply(null, arguments)\n    }\n      , wk = b._emscripten_bind_b2WheelJointDef_set_maxMotorTorque_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_set_maxMotorTorque_1.apply(null, arguments)\n    }\n      , xk = b._emscripten_bind_b2BodyDef_set_linearVelocity_1 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_set_linearVelocity_1.apply(null, arguments)\n    }\n      , yk = b._emscripten_bind_b2JointDef_set_collideConnected_1 = function() {\n        return b.asm._emscripten_bind_b2JointDef_set_collideConnected_1.apply(null, arguments)\n    }\n      , zk = b._emscripten_bind_b2MotorJoint___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint___destroy___0.apply(null, arguments)\n    }\n      , Ak = b._emscripten_bind_b2Body_GetUserData_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetUserData_0.apply(null, arguments)\n    }\n      , Bk = b._emscripten_bind_b2Body_GetAngularDamping_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetAngularDamping_0.apply(null, arguments)\n    }\n      , Ck = b._emscripten_bind_b2Fixture_RayCast_3 = function() {\n        return b.asm._emscripten_bind_b2Fixture_RayCast_3.apply(null, arguments)\n    }\n      , Dk = b._emscripten_bind_b2JointDef_set_bodyA_1 = function() {\n        return b.asm._emscripten_bind_b2JointDef_set_bodyA_1.apply(null, arguments)\n    }\n      , Ek = b._emscripten_bind_b2GearJointDef_get_collideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_get_collideConnected_0.apply(null, arguments)\n    }\n      , Fk = b._emscripten_bind_b2RopeJointDef_get_maxLength_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_get_maxLength_0.apply(null, arguments)\n    }\n      , Gk = b._emscripten_bind_b2MouseJointDef_get_bodyA_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_get_bodyA_0.apply(null, arguments)\n    }\n      , Hk = b._emscripten_bind_b2Body_SetBullet_1 = function() {\n        return b.asm._emscripten_bind_b2Body_SetBullet_1.apply(null, arguments)\n    }\n      , Ik = b._emscripten_bind_b2DistanceJoint_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetType_0.apply(null, arguments)\n    }\n      , Jk = b._emscripten_bind_b2FixtureDef_get_restitution_0 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_get_restitution_0.apply(null, arguments)\n    }\n      , Kk = b._emscripten_bind_b2Fixture_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2Fixture_GetType_0.apply(null, arguments)\n    }\n      , Lk = b._emscripten_bind_b2WheelJointDef_set_enableMotor_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_set_enableMotor_1.apply(null, arguments)\n    }\n      , Mk = b._emscripten_bind_b2RevoluteJoint_GetBodyB_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetBodyB_0.apply(null, arguments)\n    }\n      , Nk = b._emscripten_bind_b2Profile_set_solveInit_1 = function() {\n        return b.asm._emscripten_bind_b2Profile_set_solveInit_1.apply(null, arguments)\n    }\n      , Ok = b._emscripten_bind_b2RopeJointDef_set_type_1 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_set_type_1.apply(null, arguments)\n    }\n      , Pk = b._emscripten_bind_b2PrismaticJointDef_get_bodyB_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_bodyB_0.apply(null, arguments)\n    }\n      , Qk = b._emscripten_bind_b2GearJoint_GetJoint2_0 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_GetJoint2_0.apply(null, arguments)\n    }\n      , Rk = b._emscripten_bind_b2PulleyJointDef_get_userData_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_get_userData_0.apply(null, arguments)\n    }\n      , Sk = b._emscripten_bind_b2PrismaticJointDef_set_bodyB_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_bodyB_1.apply(null, arguments)\n    }\n      , Tk = b._emscripten_bind_b2FrictionJointDef_b2FrictionJointDef_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_b2FrictionJointDef_0.apply(null, arguments)\n    }\n      , Uk = b._emscripten_bind_b2PulleyJoint_GetCurrentLengthA_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetCurrentLengthA_0.apply(null, arguments)\n    }\n      , Vk = b._emscripten_bind_b2Manifold_get_localNormal_0 = function() {\n        return b.asm._emscripten_bind_b2Manifold_get_localNormal_0.apply(null, arguments)\n    }\n      , Wk = b._emscripten_bind_b2Vec3_b2Vec3_0 = function() {\n        return b.asm._emscripten_bind_b2Vec3_b2Vec3_0.apply(null, arguments)\n    }\n      , Xk = b._emscripten_bind_b2Body_SetSleepingAllowed_1 = function() {\n        return b.asm._emscripten_bind_b2Body_SetSleepingAllowed_1.apply(null, arguments)\n    }\n      , Yk = b._emscripten_bind_b2DistanceJoint___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint___destroy___0.apply(null, arguments)\n    }\n      , Zk = b._emscripten_bind_b2PrismaticJoint_GetAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetAnchorA_0.apply(null, arguments)\n    }\n      , $k = b._emscripten_bind_b2Manifold_set_pointCount_1 = function() {\n        return b.asm._emscripten_bind_b2Manifold_set_pointCount_1.apply(null, arguments)\n    }\n      , al = b._emscripten_bind_b2PrismaticJoint_IsMotorEnabled_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_IsMotorEnabled_0.apply(null, arguments)\n    }\n      , bl = b._emscripten_bind_b2WeldJoint_GetFrequency_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_GetFrequency_0.apply(null, arguments)\n    }\n      , cl = b._emscripten_bind_b2Joint_GetUserData_0 = function() {\n        return b.asm._emscripten_bind_b2Joint_GetUserData_0.apply(null, arguments)\n    }\n      , dl = b._emscripten_bind_b2WorldManifold_get_points_1 = function() {\n        return b.asm._emscripten_bind_b2WorldManifold_get_points_1.apply(null, arguments)\n    }\n      , el = b._emscripten_bind_b2RevoluteJointDef_get_lowerAngle_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_get_lowerAngle_0.apply(null, arguments)\n    }\n      , fl = b._emscripten_bind_b2Manifold_set_type_1 = function() {\n        return b.asm._emscripten_bind_b2Manifold_set_type_1.apply(null, arguments)\n    }\n      , gl = b._emscripten_bind_b2Vec3_b2Vec3_3 = function() {\n        return b.asm._emscripten_bind_b2Vec3_b2Vec3_3.apply(null, arguments)\n    }\n      , hl = b._emscripten_bind_b2RopeJointDef_set_maxLength_1 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_set_maxLength_1.apply(null, arguments)\n    }\n      , il = b._emscripten_bind_b2ChainShape_TestPoint_2 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_TestPoint_2.apply(null, arguments)\n    }\n      , jl = b._emscripten_bind_b2PrismaticJoint_GetReferenceAngle_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetReferenceAngle_0.apply(null, arguments)\n    }\n      , kl = b._emscripten_bind_b2RayCastInput_get_p2_0 = function() {\n        return b.asm._emscripten_bind_b2RayCastInput_get_p2_0.apply(null, arguments)\n    }\n      , ll = b._emscripten_bind_b2BodyDef_set_angle_1 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_set_angle_1.apply(null, arguments)\n    }\n      , ml = b._emscripten_bind_b2WeldJoint_GetUserData_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_GetUserData_0.apply(null, arguments)\n    }\n      , nl = b._emscripten_bind_b2WheelJointDef_get_localAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_get_localAnchorA_0.apply(null, arguments)\n    }\n      , ol = b._emscripten_bind_b2PulleyJointDef_set_type_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_set_type_1.apply(null, arguments)\n    }\n      , pl = b._emscripten_bind_b2Body_IsBullet_0 = function() {\n        return b.asm._emscripten_bind_b2Body_IsBullet_0.apply(null, arguments)\n    }\n      , ql = b._emscripten_bind_b2MotorJointDef_set_bodyA_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_set_bodyA_1.apply(null, arguments)\n    }\n      , rl = b._emscripten_bind_b2Fixture_TestPoint_1 = function() {\n        return b.asm._emscripten_bind_b2Fixture_TestPoint_1.apply(null, arguments)\n    }\n      , sl = b._emscripten_bind_b2Mat33_GetSymInverse33_1 = function() {\n        return b.asm._emscripten_bind_b2Mat33_GetSymInverse33_1.apply(null, arguments)\n    }\n      , tl = b._emscripten_bind_JSDraw_DrawPolygon_3 = function() {\n        return b.asm._emscripten_bind_JSDraw_DrawPolygon_3.apply(null, arguments)\n    }\n      , ul = b._emscripten_bind_b2PolygonShape_ComputeMass_2 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_ComputeMass_2.apply(null, arguments)\n    }\n      , vl = b._emscripten_bind_b2PrismaticJoint_EnableMotor_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_EnableMotor_1.apply(null, arguments)\n    }\n      , wl = b._emscripten_bind_b2PrismaticJointDef_set_upperTranslation_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_upperTranslation_1.apply(null, arguments)\n    }\n      , xl = b._emscripten_bind_b2MouseJoint_SetFrequency_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_SetFrequency_1.apply(null, arguments)\n    }\n      , yl = b._emscripten_bind_b2EdgeShape_get_m_vertex1_0 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_get_m_vertex1_0.apply(null, arguments)\n    }\n      , zl = b._emscripten_bind_b2BodyDef_set_awake_1 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_set_awake_1.apply(null, arguments)\n    }\n      , Al = b._emscripten_bind_b2Vec2_get_y_0 = function() {\n        return b.asm._emscripten_bind_b2Vec2_get_y_0.apply(null, arguments)\n    }\n      , Bl = b._emscripten_bind_b2Filter_set_categoryBits_1 = function() {\n        return b.asm._emscripten_bind_b2Filter_set_categoryBits_1.apply(null, arguments)\n    }\n      , Cl = b._emscripten_bind_b2Body_CreateFixture_2 = function() {\n        return b.asm._emscripten_bind_b2Body_CreateFixture_2.apply(null, arguments)\n    }\n      , Dl = b._emscripten_bind_b2Body_SetActive_1 = function() {\n        return b.asm._emscripten_bind_b2Body_SetActive_1.apply(null, arguments)\n    }\n      , El = b._emscripten_bind_b2ContactFeature_get_indexB_0 = function() {\n        return b.asm._emscripten_bind_b2ContactFeature_get_indexB_0.apply(null, arguments)\n    }\n      , Fl = b._emscripten_bind_b2Fixture_GetUserData_0 = function() {\n        return b.asm._emscripten_bind_b2Fixture_GetUserData_0.apply(null, arguments)\n    }\n      , Gl = b._emscripten_bind_b2PolygonShape_ComputeAABB_3 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_ComputeAABB_3.apply(null, arguments)\n    }\n      , Hl = b._emscripten_bind_b2ContactFeature_get_typeA_0 = function() {\n        return b.asm._emscripten_bind_b2ContactFeature_get_typeA_0.apply(null, arguments)\n    }\n      , Il = b._emscripten_bind_b2MouseJointDef_set_maxForce_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_set_maxForce_1.apply(null, arguments)\n    }\n      , Jl = b._emscripten_bind_b2PrismaticJoint_GetLocalAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetLocalAnchorA_0.apply(null, arguments)\n    }\n      , Kl = b._emscripten_bind_b2EdgeShape_TestPoint_2 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_TestPoint_2.apply(null, arguments)\n    }\n      , Ll = b._emscripten_bind_b2WorldManifold_Initialize_5 = function() {\n        return b.asm._emscripten_bind_b2WorldManifold_Initialize_5.apply(null, arguments)\n    }\n      , Ml = b._emscripten_bind_b2PolygonShape_get_m_centroid_0 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_get_m_centroid_0.apply(null, arguments)\n    }\n      , Nl = b._emscripten_bind_b2ChainShape___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2ChainShape___destroy___0.apply(null, arguments)\n    }\n      , Ol = b._emscripten_bind_b2GearJoint_SetUserData_1 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_SetUserData_1.apply(null, arguments)\n    }\n      , Pl = b._emscripten_bind_b2Vec3_set_z_1 = function() {\n        return b.asm._emscripten_bind_b2Vec3_set_z_1.apply(null, arguments)\n    }\n      , Ql = b._emscripten_bind_b2PrismaticJointDef_set_enableLimit_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_enableLimit_1.apply(null, arguments)\n    }\n      , Rl = b._emscripten_bind_b2DistanceJoint_GetFrequency_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetFrequency_0.apply(null, arguments)\n    }\n      , Sl = b._emscripten_bind_b2PrismaticJointDef_get_collideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_collideConnected_0.apply(null, arguments)\n    }\n      , Tl = b._emscripten_bind_b2Body_SetGravityScale_1 = function() {\n        return b.asm._emscripten_bind_b2Body_SetGravityScale_1.apply(null, arguments)\n    }\n      , Ul = b._emscripten_enum_b2ContactFeatureType_e_face = function() {\n        return b.asm._emscripten_enum_b2ContactFeatureType_e_face.apply(null, arguments)\n    }\n      , Vl = b._emscripten_bind_b2RevoluteJoint_GetUpperLimit_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetUpperLimit_0.apply(null, arguments)\n    }\n      , Wl = b._emscripten_bind_b2PulleyJointDef_get_lengthA_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_get_lengthA_0.apply(null, arguments)\n    }\n      , Xl = b._emscripten_bind_b2Vec3_set_x_1 = function() {\n        return b.asm._emscripten_bind_b2Vec3_set_x_1.apply(null, arguments)\n    }\n      , Yl = b._emscripten_bind_b2PulleyJointDef_get_type_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_get_type_0.apply(null, arguments)\n    }\n      , Zl = b._emscripten_bind_JSDestructionListener_SayGoodbyeJoint_1 = function() {\n        return b.asm._emscripten_bind_JSDestructionListener_SayGoodbyeJoint_1.apply(null, arguments)\n    }\n      , $l = b._emscripten_bind_b2Shape___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2Shape___destroy___0.apply(null, arguments)\n    }\n      , am = b._emscripten_bind_b2Joint_GetReactionForce_1 = function() {\n        return b.asm._emscripten_bind_b2Joint_GetReactionForce_1.apply(null, arguments)\n    }\n      , bm = b._emscripten_bind_b2FixtureDef_set_friction_1 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_set_friction_1.apply(null, arguments)\n    }\n      , cm = b._emscripten_bind_b2ContactID___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2ContactID___destroy___0.apply(null, arguments)\n    }\n      , dm = b._emscripten_bind_b2EdgeShape_get_m_hasVertex0_0 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_get_m_hasVertex0_0.apply(null, arguments)\n    }\n      , em = b._emscripten_bind_b2World_GetBodyCount_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetBodyCount_0.apply(null, arguments)\n    }\n      , fm = b._emscripten_bind_b2JointEdge_get_prev_0 = function() {\n        return b.asm._emscripten_bind_b2JointEdge_get_prev_0.apply(null, arguments)\n    }\n      , gm = b._emscripten_bind_b2MotorJointDef_get_linearOffset_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_get_linearOffset_0.apply(null, arguments)\n    }\n      , hm = b._emscripten_bind_b2MotorJointDef_Initialize_2 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_Initialize_2.apply(null, arguments)\n    }\n      , im = b._emscripten_bind_b2PrismaticJoint_GetAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetAnchorB_0.apply(null, arguments)\n    }\n      , jm = b._emscripten_bind_b2Body_SetLinearVelocity_1 = function() {\n        return b.asm._emscripten_bind_b2Body_SetLinearVelocity_1.apply(null, arguments)\n    }\n      , km = b._emscripten_enum_b2BodyType_b2_staticBody = function() {\n        return b.asm._emscripten_enum_b2BodyType_b2_staticBody.apply(null, arguments)\n    }\n      , lm = b._emscripten_bind_b2RevoluteJointDef_set_upperAngle_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_set_upperAngle_1.apply(null, arguments)\n    }\n      , mm = b._emscripten_bind_b2RevoluteJointDef_get_type_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_get_type_0.apply(null, arguments)\n    }\n      , nm = b._emscripten_bind_b2GearJointDef_get_type_0 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_get_type_0.apply(null, arguments)\n    }\n      , om = b._emscripten_bind_b2ChainShape_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_GetType_0.apply(null, arguments)\n    }\n      , pm = b._emscripten_bind_b2RayCastInput_get_maxFraction_0 = function() {\n        return b.asm._emscripten_bind_b2RayCastInput_get_maxFraction_0.apply(null, arguments)\n    }\n      , qm = b._emscripten_bind_b2GearJoint_GetBodyA_0 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_GetBodyA_0.apply(null, arguments)\n    }\n      , rm = b._emscripten_bind_b2Body_GetLocalVector_1 = function() {\n        return b.asm._emscripten_bind_b2Body_GetLocalVector_1.apply(null, arguments)\n    }\n      , sm = b._emscripten_bind_b2PrismaticJoint_EnableLimit_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_EnableLimit_1.apply(null, arguments)\n    }\n      , tm = b._emscripten_bind_b2FrictionJointDef_get_maxForce_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_get_maxForce_0.apply(null, arguments)\n    }\n      , um = b._emscripten_bind_b2BodyDef_set_angularVelocity_1 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_set_angularVelocity_1.apply(null, arguments)\n    }\n      , wm = b._emscripten_bind_b2Body_SetLinearDamping_1 = function() {\n        return b.asm._emscripten_bind_b2Body_SetLinearDamping_1.apply(null, arguments)\n    }\n      , xm = b._emscripten_bind_b2WheelJoint_GetBodyB_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetBodyB_0.apply(null, arguments)\n    }\n      , ym = b._emscripten_bind_b2GearJointDef_get_joint2_0 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_get_joint2_0.apply(null, arguments)\n    }\n      , zm = b._emscripten_bind_b2PrismaticJoint_IsActive_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_IsActive_0.apply(null, arguments)\n    }\n      , Am = b._emscripten_bind_b2Vec3_get_z_0 = function() {\n        return b.asm._emscripten_bind_b2Vec3_get_z_0.apply(null, arguments)\n    }\n      , Bm = b._emscripten_bind_b2Filter_get_categoryBits_0 = function() {\n        return b.asm._emscripten_bind_b2Filter_get_categoryBits_0.apply(null, arguments)\n    }\n      , Cm = b._emscripten_bind_b2Color_get_r_0 = function() {\n        return b.asm._emscripten_bind_b2Color_get_r_0.apply(null, arguments)\n    }\n      , Dm = b._emscripten_enum_b2JointType_e_weldJoint = function() {\n        return b.asm._emscripten_enum_b2JointType_e_weldJoint.apply(null, arguments)\n    }\n      , Em = b._emscripten_bind_b2World_SetContinuousPhysics_1 = function() {\n        return b.asm._emscripten_bind_b2World_SetContinuousPhysics_1.apply(null, arguments)\n    }\n      , Fm = b._emscripten_bind_b2MouseJointDef_get_target_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_get_target_0.apply(null, arguments)\n    }\n      , Gm = b._emscripten_bind_b2Body_SetTransform_2 = function() {\n        return b.asm._emscripten_bind_b2Body_SetTransform_2.apply(null, arguments)\n    }\n      , Hm = b._emscripten_bind_b2PulleyJointDef_set_userData_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_set_userData_1.apply(null, arguments)\n    }\n      , Im = b._emscripten_bind_b2FrictionJointDef_set_maxForce_1 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_set_maxForce_1.apply(null, arguments)\n    }\n      , Jm = b._emscripten_bind_b2DistanceJointDef_b2DistanceJointDef_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_b2DistanceJointDef_0.apply(null, arguments)\n    }\n      , Km = b._emscripten_bind_b2BodyDef_get_type_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_get_type_0.apply(null, arguments)\n    }\n      , Lm = b._emscripten_bind_b2Mat33_GetInverse22_1 = function() {\n        return b.asm._emscripten_bind_b2Mat33_GetInverse22_1.apply(null, arguments)\n    }\n      , Mm = b._emscripten_bind_b2PulleyJoint_GetAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetAnchorB_0.apply(null, arguments)\n    }\n      , Nm = b._emscripten_bind_b2WheelJoint_GetReactionTorque_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetReactionTorque_1.apply(null, arguments)\n    }\n      , Om = b._emscripten_bind_b2RevoluteJointDef_b2RevoluteJointDef_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_b2RevoluteJointDef_0.apply(null, arguments)\n    }\n      , Pm = b._emscripten_bind_b2ContactFeature_set_typeA_1 = function() {\n        return b.asm._emscripten_bind_b2ContactFeature_set_typeA_1.apply(null, arguments)\n    }\n      , Qm = b._emscripten_bind_b2Fixture_Dump_1 = function() {\n        return b.asm._emscripten_bind_b2Fixture_Dump_1.apply(null, arguments)\n    }\n      , Rm = b._emscripten_bind_b2RevoluteJointDef_get_enableLimit_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_get_enableLimit_0.apply(null, arguments)\n    }\n      , Sm = b._emscripten_bind_b2Manifold_set_localPoint_1 = function() {\n        return b.asm._emscripten_bind_b2Manifold_set_localPoint_1.apply(null, arguments)\n    }\n      , Tm = b._emscripten_bind_b2JointDef_get_userData_0 = function() {\n        return b.asm._emscripten_bind_b2JointDef_get_userData_0.apply(null, arguments)\n    }\n      , Um = b._emscripten_bind_b2BodyDef_set_bullet_1 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_set_bullet_1.apply(null, arguments)\n    }\n      , Vm = b._emscripten_bind_b2WorldManifold___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2WorldManifold___destroy___0.apply(null, arguments)\n    }\n      , Wm = b._emscripten_bind_b2RayCastOutput___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2RayCastOutput___destroy___0.apply(null, arguments)\n    }\n      , Xm = b._emscripten_bind_JSContactListener___destroy___0 = function() {\n        return b.asm._emscripten_bind_JSContactListener___destroy___0.apply(null, arguments)\n    }\n      , Ym = b._emscripten_bind_b2World_DrawDebugData_0 = function() {\n        return b.asm._emscripten_bind_b2World_DrawDebugData_0.apply(null, arguments)\n    }\n    ;\n    b.___cxa_can_catch = function() {\n        return b.asm.___cxa_can_catch.apply(null, arguments)\n    }\n    ;\n    var Zm = b._emscripten_bind_b2RopeJointDef_get_localAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_get_localAnchorA_0.apply(null, arguments)\n    }\n      , $m = b._emscripten_bind_b2Profile_set_solveVelocity_1 = function() {\n        return b.asm._emscripten_bind_b2Profile_set_solveVelocity_1.apply(null, arguments)\n    }\n      , an = b._emscripten_bind_b2GearJointDef_get_userData_0 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_get_userData_0.apply(null, arguments)\n    }\n      , bn = b._emscripten_bind_b2Filter_set_groupIndex_1 = function() {\n        return b.asm._emscripten_bind_b2Filter_set_groupIndex_1.apply(null, arguments)\n    }\n      , cn = b._emscripten_bind_b2JointDef_b2JointDef_0 = function() {\n        return b.asm._emscripten_bind_b2JointDef_b2JointDef_0.apply(null, arguments)\n    }\n      , dn = b._emscripten_bind_b2Rot_set_c_1 = function() {\n        return b.asm._emscripten_bind_b2Rot_set_c_1.apply(null, arguments)\n    }\n      , en = b._emscripten_bind_b2GearJointDef_b2GearJointDef_0 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_b2GearJointDef_0.apply(null, arguments)\n    }\n      , fn = b._emscripten_bind_b2JointDef_get_bodyB_0 = function() {\n        return b.asm._emscripten_bind_b2JointDef_get_bodyB_0.apply(null, arguments)\n    }\n      , gn = b._emscripten_bind_b2DistanceJoint_GetReactionForce_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetReactionForce_1.apply(null, arguments)\n    }\n      , hn = b._emscripten_bind_b2PrismaticJoint_GetJointSpeed_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetJointSpeed_0.apply(null, arguments)\n    }\n      , jn = b._emscripten_bind_b2MouseJointDef_set_frequencyHz_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_set_frequencyHz_1.apply(null, arguments)\n    }\n      , kn = b._emscripten_bind_b2PulleyJointDef_get_groundAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_get_groundAnchorA_0.apply(null, arguments)\n    }\n      , ln = b._emscripten_bind_b2Joint_GetAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2Joint_GetAnchorA_0.apply(null, arguments)\n    }\n      , mn = b._emscripten_bind_b2Contact_GetRestitution_0 = function() {\n        return b.asm._emscripten_bind_b2Contact_GetRestitution_0.apply(null, arguments)\n    }\n      , nn = b._emscripten_bind_b2ContactEdge_get_contact_0 = function() {\n        return b.asm._emscripten_bind_b2ContactEdge_get_contact_0.apply(null, arguments)\n    }\n      , on = b._emscripten_bind_b2RevoluteJointDef_get_userData_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_get_userData_0.apply(null, arguments)\n    }\n      , pn = b._emscripten_bind_b2Body_ResetMassData_0 = function() {\n        return b.asm._emscripten_bind_b2Body_ResetMassData_0.apply(null, arguments)\n    }\n      , qn = b._emscripten_bind_b2Fixture_GetAABB_1 = function() {\n        return b.asm._emscripten_bind_b2Fixture_GetAABB_1.apply(null, arguments)\n    }\n      , rn = b._emscripten_bind_b2PrismaticJointDef_set_collideConnected_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_collideConnected_1.apply(null, arguments)\n    }\n      , sn = b._emscripten_bind_b2Body_GetMassData_1 = function() {\n        return b.asm._emscripten_bind_b2Body_GetMassData_1.apply(null, arguments)\n    }\n      , tn = b._emscripten_bind_b2RevoluteJointDef_get_localAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_get_localAnchorA_0.apply(null, arguments)\n    }\n      , un = b._emscripten_bind_b2EdgeShape_ComputeMass_2 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_ComputeMass_2.apply(null, arguments)\n    }\n      , vn = b._emscripten_bind_b2GearJointDef_get_bodyB_0 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_get_bodyB_0.apply(null, arguments)\n    }\n      , wn = b._emscripten_enum_b2LimitState_e_atLowerLimit = function() {\n        return b.asm._emscripten_enum_b2LimitState_e_atLowerLimit.apply(null, arguments)\n    }\n      , xn = b._emscripten_bind_b2ManifoldPoint_set_id_1 = function() {\n        return b.asm._emscripten_bind_b2ManifoldPoint_set_id_1.apply(null, arguments)\n    }\n      , yn = b._emscripten_bind_b2WheelJointDef_get_bodyB_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_get_bodyB_0.apply(null, arguments)\n    }\n      , zn = b._emscripten_bind_b2WeldJoint_GetLocalAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_GetLocalAnchorB_0.apply(null, arguments)\n    }\n      , An = b._emscripten_bind_b2RevoluteJointDef_set_localAnchorB_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_set_localAnchorB_1.apply(null, arguments)\n    }\n      , Bn = b._emscripten_bind_b2Body_DestroyFixture_1 = function() {\n        return b.asm._emscripten_bind_b2Body_DestroyFixture_1.apply(null, arguments)\n    }\n      , Cn = b._emscripten_bind_b2Profile_set_broadphase_1 = function() {\n        return b.asm._emscripten_bind_b2Profile_set_broadphase_1.apply(null, arguments)\n    }\n      , Dn = b._emscripten_bind_b2WheelJointDef_get_localAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_get_localAnchorB_0.apply(null, arguments)\n    }\n      , En = b._emscripten_bind_b2ContactImpulse_get_count_0 = function() {\n        return b.asm._emscripten_bind_b2ContactImpulse_get_count_0.apply(null, arguments)\n    }\n      , Fn = b._emscripten_bind_b2World_GetJointCount_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetJointCount_0.apply(null, arguments)\n    }\n      , Gn = b._emscripten_bind_b2WheelJoint_GetMotorSpeed_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetMotorSpeed_0.apply(null, arguments)\n    }\n      , Hn = b._emscripten_bind_b2WheelJointDef_get_dampingRatio_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_get_dampingRatio_0.apply(null, arguments)\n    }\n      , In = b._emscripten_bind_b2RayCastOutput_get_fraction_0 = function() {\n        return b.asm._emscripten_bind_b2RayCastOutput_get_fraction_0.apply(null, arguments)\n    }\n      , Jn = b._emscripten_bind_b2AABB___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2AABB___destroy___0.apply(null, arguments)\n    }\n      , Kn = b._emscripten_bind_b2GearJoint_SetRatio_1 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_SetRatio_1.apply(null, arguments)\n    }\n      , Ln = b._emscripten_bind_b2Body_ApplyLinearImpulse_3 = function() {\n        return b.asm._emscripten_bind_b2Body_ApplyLinearImpulse_3.apply(null, arguments)\n    }\n      , Mn = b._emscripten_bind_b2Filter___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2Filter___destroy___0.apply(null, arguments)\n    }\n      , Nn = b._emscripten_bind_b2RopeJointDef_get_userData_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_get_userData_0.apply(null, arguments)\n    }\n    ;\n    b.___cxa_is_pointer_type = function() {\n        return b.asm.___cxa_is_pointer_type.apply(null, arguments)\n    }\n    ;\n    var On = b._emscripten_bind_b2BodyDef_get_fixedRotation_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_get_fixedRotation_0.apply(null, arguments)\n    }\n      , Pn = b._emscripten_bind_b2PrismaticJointDef_set_motorSpeed_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_motorSpeed_1.apply(null, arguments)\n    }\n      , Qn = b._emscripten_bind_b2ChainShape_SetPrevVertex_1 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_SetPrevVertex_1.apply(null, arguments)\n    }\n      , Rn = b._emscripten_bind_b2MotorJoint_IsActive_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_IsActive_0.apply(null, arguments)\n    }\n      , Sn = b._emscripten_bind_b2MouseJoint_GetReactionTorque_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_GetReactionTorque_1.apply(null, arguments)\n    }\n      , Tn = b._emscripten_bind_b2DistanceJointDef_set_collideConnected_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_set_collideConnected_1.apply(null, arguments)\n    }\n      , Un = b._emscripten_bind_b2WheelJoint_GetUserData_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetUserData_0.apply(null, arguments)\n    }\n      , Vn = b._emscripten_bind_b2Vec3_op_sub_1 = function() {\n        return b.asm._emscripten_bind_b2Vec3_op_sub_1.apply(null, arguments)\n    }\n      , Wn = b._emscripten_bind_b2WheelJoint_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetNext_0.apply(null, arguments)\n    }\n      , Xn = b._emscripten_bind_b2Shape_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2Shape_GetType_0.apply(null, arguments)\n    }\n      , Yn = b._emscripten_bind_b2AABB_IsValid_0 = function() {\n        return b.asm._emscripten_bind_b2AABB_IsValid_0.apply(null, arguments)\n    }\n      , Zn = b._emscripten_bind_b2WheelJoint_GetBodyA_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetBodyA_0.apply(null, arguments)\n    }\n      , $n = b._emscripten_enum_b2ShapeType_e_chain = function() {\n        return b.asm._emscripten_enum_b2ShapeType_e_chain.apply(null, arguments)\n    }\n      , ao = b._emscripten_bind_b2PulleyJoint_GetLengthA_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetLengthA_0.apply(null, arguments)\n    }\n      , bo = b._emscripten_bind_b2DistanceJointDef_get_frequencyHz_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_get_frequencyHz_0.apply(null, arguments)\n    }\n      , co = b._emscripten_bind_b2RevoluteJoint_SetMotorSpeed_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_SetMotorSpeed_1.apply(null, arguments)\n    }\n      , eo = b._emscripten_bind_b2World___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2World___destroy___0.apply(null, arguments)\n    }\n      , fo = b._emscripten_bind_b2ChainShape_set_m_prevVertex_1 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_set_m_prevVertex_1.apply(null, arguments)\n    }\n      , go = b._emscripten_bind_b2ChainShape_get_m_hasNextVertex_0 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_get_m_hasNextVertex_0.apply(null, arguments)\n    }\n      , ho = b._emscripten_bind_b2ChainShape_SetNextVertex_1 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_SetNextVertex_1.apply(null, arguments)\n    }\n      , io = b._emscripten_bind_b2Body_SetType_1 = function() {\n        return b.asm._emscripten_bind_b2Body_SetType_1.apply(null, arguments)\n    }\n      , jo = b._emscripten_bind_b2Body_GetMass_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetMass_0.apply(null, arguments)\n    }\n      , ko = b._emscripten_bind_b2Rot_b2Rot_0 = function() {\n        return b.asm._emscripten_bind_b2Rot_b2Rot_0.apply(null, arguments)\n    }\n      , lo = b._emscripten_bind_b2Rot_b2Rot_1 = function() {\n        return b.asm._emscripten_bind_b2Rot_b2Rot_1.apply(null, arguments)\n    }\n      , mo = b._emscripten_enum_b2JointType_e_distanceJoint = function() {\n        return b.asm._emscripten_enum_b2JointType_e_distanceJoint.apply(null, arguments)\n    }\n      , no = b._emscripten_bind_b2WheelJoint_SetSpringDampingRatio_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_SetSpringDampingRatio_1.apply(null, arguments)\n    }\n      , oo = b._emscripten_bind_b2MouseJoint_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_GetType_0.apply(null, arguments)\n    }\n      , po = b._emscripten_bind_b2MouseJoint_GetTarget_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_GetTarget_0.apply(null, arguments)\n    }\n      , qo = b._emscripten_bind_JSQueryCallback___destroy___0 = function() {\n        return b.asm._emscripten_bind_JSQueryCallback___destroy___0.apply(null, arguments)\n    }\n      , ro = b._emscripten_bind_b2Fixture_Refilter_0 = function() {\n        return b.asm._emscripten_bind_b2Fixture_Refilter_0.apply(null, arguments)\n    }\n      , so = b._emscripten_bind_b2RevoluteJointDef_set_lowerAngle_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_set_lowerAngle_1.apply(null, arguments)\n    }\n      , to = b._emscripten_bind_b2JointEdge___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2JointEdge___destroy___0.apply(null, arguments)\n    }\n      , uo = b._emscripten_bind_b2PulleyJoint_GetRatio_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetRatio_0.apply(null, arguments)\n    }\n      , vo = b._emscripten_bind_JSContactListener_BeginContact_1 = function() {\n        return b.asm._emscripten_bind_JSContactListener_BeginContact_1.apply(null, arguments)\n    }\n      , wo = b._emscripten_bind_b2MotorJointDef_set_linearOffset_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_set_linearOffset_1.apply(null, arguments)\n    }\n      , xo = b._emscripten_enum_b2JointType_e_motorJoint = function() {\n        return b.asm._emscripten_enum_b2JointType_e_motorJoint.apply(null, arguments)\n    }\n      , yo = b._emscripten_bind_b2EdgeShape_get_m_vertex2_0 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_get_m_vertex2_0.apply(null, arguments)\n    }\n      , zo = b._emscripten_bind_b2JointEdge_get_next_0 = function() {\n        return b.asm._emscripten_bind_b2JointEdge_get_next_0.apply(null, arguments)\n    }\n      , Ao = b._emscripten_bind_b2RayCastInput_set_maxFraction_1 = function() {\n        return b.asm._emscripten_bind_b2RayCastInput_set_maxFraction_1.apply(null, arguments)\n    }\n      , Bo = b._emscripten_bind_b2MouseJoint_GetBodyA_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_GetBodyA_0.apply(null, arguments)\n    }\n      , Co = b._emscripten_bind_b2BodyDef_get_awake_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_get_awake_0.apply(null, arguments)\n    }\n      , Do = b._emscripten_bind_b2AABB_b2AABB_0 = function() {\n        return b.asm._emscripten_bind_b2AABB_b2AABB_0.apply(null, arguments)\n    }\n      , Eo = b._emscripten_bind_b2Fixture_SetFriction_1 = function() {\n        return b.asm._emscripten_bind_b2Fixture_SetFriction_1.apply(null, arguments)\n    }\n      , Fo = b._emscripten_enum_b2DrawFlag_e_centerOfMassBit = function() {\n        return b.asm._emscripten_enum_b2DrawFlag_e_centerOfMassBit.apply(null, arguments)\n    }\n      , Go = b._emscripten_bind_b2World_CreateBody_1 = function() {\n        return b.asm._emscripten_bind_b2World_CreateBody_1.apply(null, arguments)\n    }\n      , Ho = b._emscripten_bind_b2RopeJointDef_set_userData_1 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_set_userData_1.apply(null, arguments)\n    }\n      , Io = b._emscripten_bind_b2WeldJoint_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_GetNext_0.apply(null, arguments)\n    }\n      , Jo = b._emscripten_bind_b2WeldJoint_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_GetType_0.apply(null, arguments)\n    }\n      , Ko = b._emscripten_enum_b2ContactFeatureType_e_vertex = function() {\n        return b.asm._emscripten_enum_b2ContactFeatureType_e_vertex.apply(null, arguments)\n    }\n      , Lo = b._emscripten_bind_b2Rot___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2Rot___destroy___0.apply(null, arguments)\n    }\n      , Mo = b._emscripten_bind_b2Filter_get_maskBits_0 = function() {\n        return b.asm._emscripten_bind_b2Filter_get_maskBits_0.apply(null, arguments)\n    }\n      , No = b._emscripten_bind_b2Mat22_get_ex_0 = function() {\n        return b.asm._emscripten_bind_b2Mat22_get_ex_0.apply(null, arguments)\n    }\n      , Oo = b._emscripten_bind_b2Body_GetFixtureList_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetFixtureList_0.apply(null, arguments)\n    }\n      , Po = b._emscripten_bind_b2PulleyJoint___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint___destroy___0.apply(null, arguments)\n    }\n      , Qo = b._emscripten_bind_b2MouseJointDef_set_dampingRatio_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_set_dampingRatio_1.apply(null, arguments)\n    }\n      , Ro = b._emscripten_bind_JSRayCastCallback___destroy___0 = function() {\n        return b.asm._emscripten_bind_JSRayCastCallback___destroy___0.apply(null, arguments)\n    }\n      , So = b._emscripten_bind_b2ContactListener___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2ContactListener___destroy___0.apply(null, arguments)\n    }\n      , To = b._emscripten_bind_b2PrismaticJointDef_set_localAnchorB_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_localAnchorB_1.apply(null, arguments)\n    }\n    ;\n    b.establishStackSpace = function() {\n        return b.asm.establishStackSpace.apply(null, arguments)\n    }\n    ;\n    var Uo = b._emscripten_bind_b2FrictionJoint___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint___destroy___0.apply(null, arguments)\n    }\n      , Vo = b._emscripten_bind_b2WeldJoint_Dump_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_Dump_0.apply(null, arguments)\n    }\n      , Wo = b._emscripten_bind_b2MotorJoint_SetMaxForce_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_SetMaxForce_1.apply(null, arguments)\n    }\n      , Xo = b._emscripten_bind_b2MouseJoint_GetFrequency_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_GetFrequency_0.apply(null, arguments)\n    }\n      , Yo = b._emscripten_bind_b2FrictionJoint_GetLocalAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_GetLocalAnchorA_0.apply(null, arguments)\n    }\n      , Zo = b._emscripten_bind_b2RevoluteJointDef_set_collideConnected_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_set_collideConnected_1.apply(null, arguments)\n    }\n      , $o = b._emscripten_bind_b2GearJointDef_set_collideConnected_1 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_set_collideConnected_1.apply(null, arguments)\n    }\n      , ap = b._emscripten_bind_b2Vec2_IsValid_0 = function() {\n        return b.asm._emscripten_bind_b2Vec2_IsValid_0.apply(null, arguments)\n    }\n      , bp = b._emscripten_bind_b2PrismaticJointDef_set_bodyA_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_bodyA_1.apply(null, arguments)\n    }\n      , cp = b._emscripten_bind_b2World_GetWarmStarting_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetWarmStarting_0.apply(null, arguments)\n    }\n      , dp = b._emscripten_bind_b2RevoluteJointDef_set_enableLimit_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_set_enableLimit_1.apply(null, arguments)\n    }\n      , ep = b._emscripten_bind_b2WeldJointDef___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef___destroy___0.apply(null, arguments)\n    }\n      , fp = b._emscripten_bind_b2Mat22_Solve_1 = function() {\n        return b.asm._emscripten_bind_b2Mat22_Solve_1.apply(null, arguments)\n    }\n      , gp = b._emscripten_bind_b2Color_get_g_0 = function() {\n        return b.asm._emscripten_bind_b2Color_get_g_0.apply(null, arguments)\n    }\n      , hp = b._emscripten_bind_VoidPtr___destroy___0 = function() {\n        return b.asm._emscripten_bind_VoidPtr___destroy___0.apply(null, arguments)\n    }\n      , ip = b._emscripten_bind_b2RopeJoint_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_GetNext_0.apply(null, arguments)\n    }\n      , jp = b._emscripten_bind_b2EdgeShape_get_m_type_0 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_get_m_type_0.apply(null, arguments)\n    }\n      , kp = b._emscripten_bind_b2PolygonShape_GetChildCount_0 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_GetChildCount_0.apply(null, arguments)\n    }\n      , lp = b._emscripten_bind_b2GearJointDef_get_ratio_0 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_get_ratio_0.apply(null, arguments)\n    }\n      , mp = b._emscripten_bind_b2Mat33_Solve33_1 = function() {\n        return b.asm._emscripten_bind_b2Mat33_Solve33_1.apply(null, arguments)\n    }\n      , np = b._emscripten_bind_b2WeldJointDef_set_userData_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_set_userData_1.apply(null, arguments)\n    }\n      , op = b._emscripten_bind_b2PrismaticJoint_GetLocalAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetLocalAnchorB_0.apply(null, arguments)\n    }\n      , pp = b._emscripten_bind_b2RevoluteJointDef___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef___destroy___0.apply(null, arguments)\n    }\n      , qp = b._emscripten_bind_b2MotorJointDef_get_correctionFactor_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_get_correctionFactor_0.apply(null, arguments)\n    }\n      , rp = b._emscripten_bind_b2ContactFeature_get_typeB_0 = function() {\n        return b.asm._emscripten_bind_b2ContactFeature_get_typeB_0.apply(null, arguments)\n    }\n      , sp = b._emscripten_bind_b2ContactID_get_key_0 = function() {\n        return b.asm._emscripten_bind_b2ContactID_get_key_0.apply(null, arguments)\n    }\n      , tp = b._emscripten_bind_b2MotorJoint_GetReactionForce_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetReactionForce_1.apply(null, arguments)\n    }\n      , up = b._emscripten_bind_b2Rot_GetAngle_0 = function() {\n        return b.asm._emscripten_bind_b2Rot_GetAngle_0.apply(null, arguments)\n    }\n      , vp = b._emscripten_bind_b2World_SetAllowSleeping_1 = function() {\n        return b.asm._emscripten_bind_b2World_SetAllowSleeping_1.apply(null, arguments)\n    }\n      , wp = b._emscripten_bind_b2RopeJoint_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_GetType_0.apply(null, arguments)\n    }\n      , xp = b._emscripten_bind_b2MotorJoint_SetAngularOffset_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_SetAngularOffset_1.apply(null, arguments)\n    }\n      , yp = b._emscripten_bind_b2MotorJoint_GetLinearOffset_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetLinearOffset_0.apply(null, arguments)\n    }\n      , zp = b._emscripten_bind_b2FrictionJoint_GetCollideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_GetCollideConnected_0.apply(null, arguments)\n    }\n      , Ap = b._emscripten_bind_b2WheelJointDef_set_motorSpeed_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_set_motorSpeed_1.apply(null, arguments)\n    }\n      , Bp = b._emscripten_bind_b2MotorJoint_GetAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetAnchorA_0.apply(null, arguments)\n    }\n      , Cp = b._emscripten_bind_b2Fixture_GetDensity_0 = function() {\n        return b.asm._emscripten_bind_b2Fixture_GetDensity_0.apply(null, arguments)\n    }\n      , Dp = b._emscripten_bind_b2MouseJointDef_get_type_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_get_type_0.apply(null, arguments)\n    }\n      , Ep = b._emscripten_bind_b2Vec2_Set_2 = function() {\n        return b.asm._emscripten_bind_b2Vec2_Set_2.apply(null, arguments)\n    }\n      , Fp = b._emscripten_bind_b2WeldJointDef_get_type_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_get_type_0.apply(null, arguments)\n    }\n      , Gp = b._emscripten_bind_b2MouseJointDef_b2MouseJointDef_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_b2MouseJointDef_0.apply(null, arguments)\n    }\n      , Hp = b._emscripten_bind_b2Rot_get_s_0 = function() {\n        return b.asm._emscripten_bind_b2Rot_get_s_0.apply(null, arguments)\n    }\n      , Ip = b._emscripten_bind_b2FrictionJoint_SetMaxTorque_1 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_SetMaxTorque_1.apply(null, arguments)\n    }\n      , Jp = b._emscripten_bind_b2MouseJointDef_get_frequencyHz_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_get_frequencyHz_0.apply(null, arguments)\n    }\n      , Kp = b._emscripten_bind_b2FrictionJoint_SetUserData_1 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_SetUserData_1.apply(null, arguments)\n    }\n      , Lp = b._emscripten_bind_b2RayCastInput_get_p1_0 = function() {\n        return b.asm._emscripten_bind_b2RayCastInput_get_p1_0.apply(null, arguments)\n    }\n      , Mp = b._emscripten_bind_b2DistanceJointDef_get_collideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_get_collideConnected_0.apply(null, arguments)\n    }\n      , Np = b._emscripten_bind_b2RevoluteJointDef_set_referenceAngle_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_set_referenceAngle_1.apply(null, arguments)\n    }\n      , Op = b._emscripten_bind_b2ContactFeature___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2ContactFeature___destroy___0.apply(null, arguments)\n    }\n      , Pp = b._emscripten_bind_b2Color___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2Color___destroy___0.apply(null, arguments)\n    }\n      , Qp = b._emscripten_bind_b2DistanceJointDef_set_bodyB_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_set_bodyB_1.apply(null, arguments)\n    }\n      , Rp = b._emscripten_bind_b2ChainShape_get_m_hasPrevVertex_0 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_get_m_hasPrevVertex_0.apply(null, arguments)\n    }\n      , Sp = b._emscripten_bind_b2PulleyJointDef_b2PulleyJointDef_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_b2PulleyJointDef_0.apply(null, arguments)\n    }\n      , Tp = b._emscripten_bind_b2RevoluteJoint_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetType_0.apply(null, arguments)\n    }\n      , Up = b._emscripten_bind_b2MassData_b2MassData_0 = function() {\n        return b.asm._emscripten_bind_b2MassData_b2MassData_0.apply(null, arguments)\n    }\n      , Vp = b._emscripten_bind_b2Vec3_set_y_1 = function() {\n        return b.asm._emscripten_bind_b2Vec3_set_y_1.apply(null, arguments)\n    }\n      , Wp = b._emscripten_bind_b2BodyDef_set_angularDamping_1 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_set_angularDamping_1.apply(null, arguments)\n    }\n      , Xp = b._emscripten_bind_b2AABB_Combine_1 = function() {\n        return b.asm._emscripten_bind_b2AABB_Combine_1.apply(null, arguments)\n    }\n      , Yp = b._emscripten_bind_b2WheelJointDef_set_bodyB_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_set_bodyB_1.apply(null, arguments)\n    }\n      , Zp = b._emscripten_bind_b2PrismaticJoint_GetBodyA_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetBodyA_0.apply(null, arguments)\n    }\n      , $p = b._emscripten_bind_b2PrismaticJoint_GetMaxMotorForce_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetMaxMotorForce_0.apply(null, arguments)\n    }\n      , aq = b._emscripten_bind_b2RevoluteJointDef_get_upperAngle_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_get_upperAngle_0.apply(null, arguments)\n    }\n      , bq = b._emscripten_bind_b2Body_IsSleepingAllowed_0 = function() {\n        return b.asm._emscripten_bind_b2Body_IsSleepingAllowed_0.apply(null, arguments)\n    }\n      , cq = b._emscripten_bind_b2MotorJoint_GetCorrectionFactor_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetCorrectionFactor_0.apply(null, arguments)\n    }\n      , dq = b._emscripten_bind_b2Profile_get_solve_0 = function() {\n        return b.asm._emscripten_bind_b2Profile_get_solve_0.apply(null, arguments)\n    }\n      , eq = b._emscripten_bind_JSDestructionListener_SayGoodbyeFixture_1 = function() {\n        return b.asm._emscripten_bind_JSDestructionListener_SayGoodbyeFixture_1.apply(null, arguments)\n    }\n      , fq = b._emscripten_bind_b2PolygonShape_GetVertexCount_0 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_GetVertexCount_0.apply(null, arguments)\n    }\n      , gq = b._emscripten_bind_b2Rot_get_c_0 = function() {\n        return b.asm._emscripten_bind_b2Rot_get_c_0.apply(null, arguments)\n    }\n      , hq = b._emscripten_bind_b2AABB_set_lowerBound_1 = function() {\n        return b.asm._emscripten_bind_b2AABB_set_lowerBound_1.apply(null, arguments)\n    }\n      , iq = b._emscripten_bind_b2Fixture_SetFilterData_1 = function() {\n        return b.asm._emscripten_bind_b2Fixture_SetFilterData_1.apply(null, arguments)\n    }\n      , jq = b._emscripten_bind_b2MouseJoint_SetMaxForce_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_SetMaxForce_1.apply(null, arguments)\n    }\n      , kq = b._emscripten_bind_b2WheelJoint_IsMotorEnabled_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_IsMotorEnabled_0.apply(null, arguments)\n    }\n      , lq = b._emscripten_bind_b2JointDef_set_userData_1 = function() {\n        return b.asm._emscripten_bind_b2JointDef_set_userData_1.apply(null, arguments)\n    }\n      , mq = b._emscripten_bind_b2ManifoldPoint_get_tangentImpulse_0 = function() {\n        return b.asm._emscripten_bind_b2ManifoldPoint_get_tangentImpulse_0.apply(null, arguments)\n    }\n      , nq = b._emscripten_bind_b2RevoluteJointDef_get_maxMotorTorque_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_get_maxMotorTorque_0.apply(null, arguments)\n    }\n      , oq = b._emscripten_bind_b2WeldJointDef_get_dampingRatio_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_get_dampingRatio_0.apply(null, arguments)\n    }\n      , pq = b._emscripten_bind_b2Rot_SetIdentity_0 = function() {\n        return b.asm._emscripten_bind_b2Rot_SetIdentity_0.apply(null, arguments)\n    }\n      , qq = b._emscripten_bind_b2EdgeShape_b2EdgeShape_0 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_b2EdgeShape_0.apply(null, arguments)\n    }\n      , rq = b._emscripten_bind_b2FrictionJoint_GetReactionForce_1 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_GetReactionForce_1.apply(null, arguments)\n    }\n      , sq = b._emscripten_bind_b2MouseJoint_GetUserData_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_GetUserData_0.apply(null, arguments)\n    }\n      , tq = b._emscripten_bind_b2DistanceJointDef_set_type_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_set_type_1.apply(null, arguments)\n    }\n      , uq = b._emscripten_bind_b2WeldJoint_GetAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_GetAnchorA_0.apply(null, arguments)\n    }\n      , vq = b._emscripten_bind_b2WeldJoint___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint___destroy___0.apply(null, arguments)\n    }\n      , wq = b._emscripten_bind_b2Manifold_b2Manifold_0 = function() {\n        return b.asm._emscripten_bind_b2Manifold_b2Manifold_0.apply(null, arguments)\n    }\n      , xq = b._emscripten_bind_JSContactListener_PostSolve_2 = function() {\n        return b.asm._emscripten_bind_JSContactListener_PostSolve_2.apply(null, arguments)\n    }\n      , yq = b._emscripten_bind_b2PulleyJoint_GetBodyA_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetBodyA_0.apply(null, arguments)\n    }\n      , zq = b._emscripten_bind_b2RopeJointDef_get_type_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_get_type_0.apply(null, arguments)\n    }\n      , Aq = b._emscripten_bind_b2CircleShape_ComputeMass_2 = function() {\n        return b.asm._emscripten_bind_b2CircleShape_ComputeMass_2.apply(null, arguments)\n    }\n      , Bq = b._emscripten_bind_b2DistanceJointDef_get_localAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_get_localAnchorB_0.apply(null, arguments)\n    }\n      , Cq = b._emscripten_bind_b2GearJointDef___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef___destroy___0.apply(null, arguments)\n    }\n      , Dq = b._emscripten_bind_b2PulleyJointDef_set_localAnchorA_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_set_localAnchorA_1.apply(null, arguments)\n    }\n      , Eq = b._emscripten_enum_b2BodyType_b2_dynamicBody = function() {\n        return b.asm._emscripten_enum_b2BodyType_b2_dynamicBody.apply(null, arguments)\n    }\n      , Fq = b._emscripten_bind_b2CircleShape_TestPoint_2 = function() {\n        return b.asm._emscripten_bind_b2CircleShape_TestPoint_2.apply(null, arguments)\n    }\n      , Gq = b._emscripten_bind_b2MotorJointDef_get_maxTorque_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_get_maxTorque_0.apply(null, arguments)\n    }\n      , Hq = b._emscripten_bind_b2Body_GetLinearVelocityFromLocalPoint_1 = function() {\n        return b.asm._emscripten_bind_b2Body_GetLinearVelocityFromLocalPoint_1.apply(null, arguments)\n    }\n      , Iq = b._emscripten_bind_b2FrictionJointDef_set_bodyB_1 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_set_bodyB_1.apply(null, arguments)\n    }\n      , Jq = b._emscripten_bind_b2MouseJoint_GetAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_GetAnchorB_0.apply(null, arguments)\n    }\n      , Kq = b._emscripten_bind_b2RopeJointDef_get_localAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_get_localAnchorB_0.apply(null, arguments)\n    }\n      , Lq = b._emscripten_bind_b2GearJoint_GetBodyB_0 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_GetBodyB_0.apply(null, arguments)\n    }\n      , Mq = b._emscripten_bind_b2ChainShape_Clear_0 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_Clear_0.apply(null, arguments)\n    }\n      , Nq = b._emscripten_bind_b2CircleShape___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2CircleShape___destroy___0.apply(null, arguments)\n    }\n      , Oq = b._emscripten_bind_b2MotorJoint_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetType_0.apply(null, arguments)\n    }\n      , Pq = b._emscripten_bind_b2World_GetContactCount_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetContactCount_0.apply(null, arguments)\n    }\n      , Qq = b._emscripten_bind_b2Contact_SetRestitution_1 = function() {\n        return b.asm._emscripten_bind_b2Contact_SetRestitution_1.apply(null, arguments)\n    }\n      , Rq = b._emscripten_bind_b2BodyDef_get_angularDamping_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_get_angularDamping_0.apply(null, arguments)\n    }\n      , Sq = b._emscripten_bind_b2EdgeShape_get_m_vertex3_0 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_get_m_vertex3_0.apply(null, arguments)\n    }\n      , Tq = b._emscripten_bind_b2MassData_set_center_1 = function() {\n        return b.asm._emscripten_bind_b2MassData_set_center_1.apply(null, arguments)\n    }\n      , Uq = b._emscripten_bind_b2Transform_SetIdentity_0 = function() {\n        return b.asm._emscripten_bind_b2Transform_SetIdentity_0.apply(null, arguments)\n    }\n      , Vq = b._emscripten_bind_b2GearJointDef_set_joint1_1 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_set_joint1_1.apply(null, arguments)\n    }\n      , Wq = b._emscripten_bind_b2EdgeShape_set_m_vertex2_1 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_set_m_vertex2_1.apply(null, arguments)\n    }\n      , Xq = b._emscripten_bind_b2Contact_SetFriction_1 = function() {\n        return b.asm._emscripten_bind_b2Contact_SetFriction_1.apply(null, arguments)\n    }\n      , Yq = b._emscripten_bind_b2MouseJointDef_set_collideConnected_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_set_collideConnected_1.apply(null, arguments)\n    }\n      , Zq = b._emscripten_bind_b2ContactFeature_set_indexB_1 = function() {\n        return b.asm._emscripten_bind_b2ContactFeature_set_indexB_1.apply(null, arguments)\n    }\n      , $q = b._emscripten_bind_b2Body_GetLinearVelocityFromWorldPoint_1 = function() {\n        return b.asm._emscripten_bind_b2Body_GetLinearVelocityFromWorldPoint_1.apply(null, arguments)\n    }\n      , ar = b._emscripten_bind_b2WeldJoint_GetCollideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_GetCollideConnected_0.apply(null, arguments)\n    }\n      , br = b._emscripten_bind_b2Mat22_GetInverse_0 = function() {\n        return b.asm._emscripten_bind_b2Mat22_GetInverse_0.apply(null, arguments)\n    }\n      , cr = b._emscripten_bind_b2WheelJointDef_set_frequencyHz_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_set_frequencyHz_1.apply(null, arguments)\n    }\n      , dr = b._emscripten_bind_b2World_GetSubStepping_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetSubStepping_0.apply(null, arguments)\n    }\n      , er = b._emscripten_bind_b2Rot_GetYAxis_0 = function() {\n        return b.asm._emscripten_bind_b2Rot_GetYAxis_0.apply(null, arguments)\n    }\n    ;\n    b._emscripten_get_global_libc = function() {\n        return b.asm._emscripten_get_global_libc.apply(null, arguments)\n    }\n    ;\n    var fr = b._emscripten_bind_b2WheelJointDef_get_localAxisA_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_get_localAxisA_0.apply(null, arguments)\n    }\n      , gr = b._emscripten_bind_b2RopeJoint_GetBodyB_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_GetBodyB_0.apply(null, arguments)\n    }\n      , hr = b._emscripten_bind_b2EdgeShape_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_GetType_0.apply(null, arguments)\n    }\n      , ir = b._emscripten_bind_b2Mat22_set_ex_1 = function() {\n        return b.asm._emscripten_bind_b2Mat22_set_ex_1.apply(null, arguments)\n    }\n      , jr = b._emscripten_bind_b2ManifoldPoint___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2ManifoldPoint___destroy___0.apply(null, arguments)\n    }\n      , kr = b._emscripten_enum_b2JointType_e_prismaticJoint = function() {\n        return b.asm._emscripten_enum_b2JointType_e_prismaticJoint.apply(null, arguments)\n    }\n      , lr = b._emscripten_bind_b2WeldJointDef_get_referenceAngle_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_get_referenceAngle_0.apply(null, arguments)\n    }\n      , mr = b._emscripten_bind_b2Vec2_Length_0 = function() {\n        return b.asm._emscripten_bind_b2Vec2_Length_0.apply(null, arguments)\n    }\n      , nr = b._emscripten_bind_b2Vec2_SetZero_0 = function() {\n        return b.asm._emscripten_bind_b2Vec2_SetZero_0.apply(null, arguments)\n    }\n      , or = b._emscripten_bind_b2RopeJoint___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint___destroy___0.apply(null, arguments)\n    }\n      , pr = b._emscripten_bind_b2World_DestroyJoint_1 = function() {\n        return b.asm._emscripten_bind_b2World_DestroyJoint_1.apply(null, arguments)\n    }\n      , qr = b._emscripten_bind_b2JointDef_set_bodyB_1 = function() {\n        return b.asm._emscripten_bind_b2JointDef_set_bodyB_1.apply(null, arguments)\n    }\n      , rr = b._emscripten_bind_b2Mat22_Set_2 = function() {\n        return b.asm._emscripten_bind_b2Mat22_Set_2.apply(null, arguments)\n    }\n      , sr = b._emscripten_bind_b2JointEdge_set_next_1 = function() {\n        return b.asm._emscripten_bind_b2JointEdge_set_next_1.apply(null, arguments)\n    }\n      , tr = b._emscripten_bind_b2WeldJoint_GetAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_GetAnchorB_0.apply(null, arguments)\n    }\n      , ur = b._emscripten_enum_b2DrawFlag_e_aabbBit = function() {\n        return b.asm._emscripten_enum_b2DrawFlag_e_aabbBit.apply(null, arguments)\n    }\n      , vr = b._emscripten_bind_b2EdgeShape_ComputeAABB_3 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_ComputeAABB_3.apply(null, arguments)\n    }\n      , wr = b._emscripten_bind_b2PolygonShape_set_m_centroid_1 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_set_m_centroid_1.apply(null, arguments)\n    }\n      , xr = b._emscripten_bind_b2WheelJointDef_set_collideConnected_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_set_collideConnected_1.apply(null, arguments)\n    }\n      , yr = b._emscripten_bind_b2World_GetJointList_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetJointList_0.apply(null, arguments)\n    }\n      , zr = b._emscripten_bind_b2MotorJointDef_get_type_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_get_type_0.apply(null, arguments)\n    }\n      , Ar = b._emscripten_bind_b2RopeJoint_GetLocalAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_GetLocalAnchorA_0.apply(null, arguments)\n    }\n      , Br = b._emscripten_bind_b2BodyDef_set_linearDamping_1 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_set_linearDamping_1.apply(null, arguments)\n    }\n      , Cr = b._emscripten_bind_b2FrictionJoint_GetUserData_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_GetUserData_0.apply(null, arguments)\n    }\n      , Dr = b._emscripten_bind_b2Shape_TestPoint_2 = function() {\n        return b.asm._emscripten_bind_b2Shape_TestPoint_2.apply(null, arguments)\n    }\n      , Er = b._emscripten_bind_b2Manifold_set_localNormal_1 = function() {\n        return b.asm._emscripten_bind_b2Manifold_set_localNormal_1.apply(null, arguments)\n    }\n      , Fr = b._emscripten_bind_b2JointDef_get_bodyA_0 = function() {\n        return b.asm._emscripten_bind_b2JointDef_get_bodyA_0.apply(null, arguments)\n    }\n      , Gr = b._emscripten_bind_b2Body_GetLinearDamping_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetLinearDamping_0.apply(null, arguments)\n    }\n      , Hr = b._emscripten_bind_b2WeldJointDef_set_frequencyHz_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_set_frequencyHz_1.apply(null, arguments)\n    }\n      , Ir = b._emscripten_bind_b2BodyDef_set_userData_1 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_set_userData_1.apply(null, arguments)\n    }\n      , Jr = b._emscripten_bind_b2PrismaticJointDef_set_enableMotor_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_enableMotor_1.apply(null, arguments)\n    }\n      , Kr = b._emscripten_bind_b2Vec2_Skew_0 = function() {\n        return b.asm._emscripten_bind_b2Vec2_Skew_0.apply(null, arguments)\n    }\n      , Lr = b._emscripten_bind_b2MouseJoint_GetDampingRatio_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_GetDampingRatio_0.apply(null, arguments)\n    }\n      , Mr = b._emscripten_bind_b2RevoluteJoint_GetAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetAnchorA_0.apply(null, arguments)\n    }\n      , Nr = b._emscripten_bind_b2ContactFeature_set_typeB_1 = function() {\n        return b.asm._emscripten_bind_b2ContactFeature_set_typeB_1.apply(null, arguments)\n    }\n      , Or = b._emscripten_bind_b2WheelJoint_GetAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetAnchorA_0.apply(null, arguments)\n    }\n      , Pr = b._emscripten_bind_b2MotorJoint_GetMaxTorque_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetMaxTorque_0.apply(null, arguments)\n    }\n    ;\n    b.setThrew = function() {\n        return b.asm.setThrew.apply(null, arguments)\n    }\n    ;\n    var Qr = b._emscripten_bind_b2PrismaticJointDef_set_userData_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_userData_1.apply(null, arguments)\n    }\n      , Rr = b._emscripten_bind_b2FrictionJointDef_set_type_1 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_set_type_1.apply(null, arguments)\n    }\n      , Sr = b._emscripten_bind_b2FrictionJointDef_Initialize_3 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_Initialize_3.apply(null, arguments)\n    }\n      , Nb = b._sbrk = function() {\n        return b.asm._sbrk.apply(null, arguments)\n    }\n      , Tr = b._emscripten_bind_b2FrictionJointDef_get_collideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_get_collideConnected_0.apply(null, arguments)\n    }\n      , Ib = b._memcpy = function() {\n        return b.asm._memcpy.apply(null, arguments)\n    }\n      , Ur = b._emscripten_bind_b2FrictionJoint_GetAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_GetAnchorA_0.apply(null, arguments)\n    }\n      , Vr = b._emscripten_enum_b2DrawFlag_e_pairBit = function() {\n        return b.asm._emscripten_enum_b2DrawFlag_e_pairBit.apply(null, arguments)\n    }\n      , Wr = b._emscripten_bind_b2MassData_get_I_0 = function() {\n        return b.asm._emscripten_bind_b2MassData_get_I_0.apply(null, arguments)\n    }\n      , Xr = b._emscripten_bind_b2WheelJointDef_get_motorSpeed_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_get_motorSpeed_0.apply(null, arguments)\n    }\n      , Yr = b._emscripten_bind_b2Filter_set_maskBits_1 = function() {\n        return b.asm._emscripten_bind_b2Filter_set_maskBits_1.apply(null, arguments)\n    }\n      , Zr = b._emscripten_bind_b2WheelJoint_GetCollideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetCollideConnected_0.apply(null, arguments)\n    }\n      , $r = b._emscripten_bind_b2EdgeShape_get_m_radius_0 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_get_m_radius_0.apply(null, arguments)\n    }\n      , as = b._emscripten_bind_b2World_GetTreeHeight_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetTreeHeight_0.apply(null, arguments)\n    }\n      , bs = b._emscripten_bind_b2Mat22_b2Mat22_2 = function() {\n        return b.asm._emscripten_bind_b2Mat22_b2Mat22_2.apply(null, arguments)\n    }\n      , cs = b._emscripten_bind_b2PrismaticJoint_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetNext_0.apply(null, arguments)\n    }\n      , ds = b._emscripten_bind_b2Mat22_b2Mat22_0 = function() {\n        return b.asm._emscripten_bind_b2Mat22_b2Mat22_0.apply(null, arguments)\n    }\n      , es = b._emscripten_bind_b2PrismaticJointDef_get_bodyA_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_bodyA_0.apply(null, arguments)\n    }\n      , gs = b._emscripten_bind_b2RopeJointDef_set_localAnchorA_1 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_set_localAnchorA_1.apply(null, arguments)\n    }\n      , hs = b._emscripten_bind_b2ChainShape_set_m_hasNextVertex_1 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_set_m_hasNextVertex_1.apply(null, arguments)\n    }\n      , is = b._emscripten_bind_b2Mat22_set_ey_1 = function() {\n        return b.asm._emscripten_bind_b2Mat22_set_ey_1.apply(null, arguments)\n    }\n      , js = b._emscripten_bind_b2MotorJointDef_set_angularOffset_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_set_angularOffset_1.apply(null, arguments)\n    }\n      , ks = b._emscripten_bind_b2CircleShape_get_m_type_0 = function() {\n        return b.asm._emscripten_bind_b2CircleShape_get_m_type_0.apply(null, arguments)\n    }\n      , ls = b._emscripten_bind_b2Body_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetType_0.apply(null, arguments)\n    }\n      , ms = b._emscripten_bind_b2ContactEdge_b2ContactEdge_0 = function() {\n        return b.asm._emscripten_bind_b2ContactEdge_b2ContactEdge_0.apply(null, arguments)\n    }\n      , ns = b._emscripten_bind_b2BodyDef___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef___destroy___0.apply(null, arguments)\n    }\n      , ps = b._emscripten_bind_b2FrictionJointDef_set_maxTorque_1 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_set_maxTorque_1.apply(null, arguments)\n    }\n      , Qa = b._free = function() {\n        return b.asm._free.apply(null, arguments)\n    }\n      , qs = b._emscripten_bind_b2PulleyJointDef_set_groundAnchorB_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_set_groundAnchorB_1.apply(null, arguments)\n    }\n      , rs = b._emscripten_bind_b2RevoluteJointDef_get_collideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_get_collideConnected_0.apply(null, arguments)\n    }\n      , ss = b._emscripten_bind_b2DistanceJointDef_set_bodyA_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_set_bodyA_1.apply(null, arguments)\n    }\n    ;\n    b.runPostSets = function() {\n        return b.asm.runPostSets.apply(null, arguments)\n    }\n    ;\n    var ts = b._emscripten_bind_b2RevoluteJoint_SetLimits_2 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_SetLimits_2.apply(null, arguments)\n    }\n      , us = b._emscripten_bind_b2WeldJointDef_set_type_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_set_type_1.apply(null, arguments)\n    }\n      , vs = b._emscripten_bind_b2MotorJointDef___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef___destroy___0.apply(null, arguments)\n    }\n      , xs = b._emscripten_bind_b2FrictionJoint_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_GetNext_0.apply(null, arguments)\n    }\n      , ys = b._emscripten_bind_b2Shape_set_m_type_1 = function() {\n        return b.asm._emscripten_bind_b2Shape_set_m_type_1.apply(null, arguments)\n    }\n      , zs = b._emscripten_bind_b2WheelJoint_GetJointTranslation_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetJointTranslation_0.apply(null, arguments)\n    }\n      , As = b._emscripten_bind_b2WheelJoint_GetMotorTorque_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetMotorTorque_1.apply(null, arguments)\n    }\n      , Bs = b._emscripten_bind_b2RopeJoint_SetUserData_1 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_SetUserData_1.apply(null, arguments)\n    }\n      , Cs = b._emscripten_bind_b2RopeJointDef___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef___destroy___0.apply(null, arguments)\n    }\n      , Ds = b._emscripten_bind_b2WheelJoint_IsActive_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_IsActive_0.apply(null, arguments)\n    }\n      , Es = b._emscripten_bind_b2PrismaticJointDef_get_enableMotor_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_enableMotor_0.apply(null, arguments)\n    }\n      , Fs = b._emscripten_bind_b2MotorJointDef_set_bodyB_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_set_bodyB_1.apply(null, arguments)\n    }\n      , Gs = b._emscripten_bind_JSDestructionListener___destroy___0 = function() {\n        return b.asm._emscripten_bind_JSDestructionListener___destroy___0.apply(null, arguments)\n    }\n      , Hs = b._emscripten_bind_b2Transform_b2Transform_2 = function() {\n        return b.asm._emscripten_bind_b2Transform_b2Transform_2.apply(null, arguments)\n    }\n      , Is = b._emscripten_bind_b2WeldJoint_GetReactionForce_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_GetReactionForce_1.apply(null, arguments)\n    }\n      , Js = b._emscripten_bind_b2ChainShape_RayCast_4 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_RayCast_4.apply(null, arguments)\n    }\n      , Ks = b._emscripten_bind_b2Vec2_set_y_1 = function() {\n        return b.asm._emscripten_bind_b2Vec2_set_y_1.apply(null, arguments)\n    }\n      , Ls = b._emscripten_bind_b2PrismaticJoint_SetMotorSpeed_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_SetMotorSpeed_1.apply(null, arguments)\n    }\n      , Ms = b._emscripten_bind_b2ContactID_get_cf_0 = function() {\n        return b.asm._emscripten_bind_b2ContactID_get_cf_0.apply(null, arguments)\n    }\n      , Ns = b._emscripten_bind_b2DistanceJointDef_Initialize_4 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_Initialize_4.apply(null, arguments)\n    }\n      , Os = b._emscripten_bind_b2ChainShape_get_m_radius_0 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_get_m_radius_0.apply(null, arguments)\n    }\n      , Ps = b._emscripten_bind_b2WeldJointDef_set_localAnchorB_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_set_localAnchorB_1.apply(null, arguments)\n    }\n      , Qs = b._emscripten_bind_b2ChainShape_set_m_radius_1 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_set_m_radius_1.apply(null, arguments)\n    }\n      , Rs = b._emscripten_bind_b2DistanceJoint_GetReactionTorque_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetReactionTorque_1.apply(null, arguments)\n    }\n      , Ss = b._emscripten_bind_b2World_Dump_0 = function() {\n        return b.asm._emscripten_bind_b2World_Dump_0.apply(null, arguments)\n    }\n      , Ts = b._emscripten_bind_b2RevoluteJoint_GetLocalAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetLocalAnchorB_0.apply(null, arguments)\n    }\n      , Us = b._emscripten_bind_JSContactFilter_JSContactFilter_0 = function() {\n        return b.asm._emscripten_bind_JSContactFilter_JSContactFilter_0.apply(null, arguments)\n    }\n      , Vs = b._emscripten_bind_b2Profile_set_solve_1 = function() {\n        return b.asm._emscripten_bind_b2Profile_set_solve_1.apply(null, arguments)\n    }\n      , Ws = b._emscripten_bind_b2FixtureDef_set_density_1 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_set_density_1.apply(null, arguments)\n    }\n      , Xs = b._emscripten_bind_b2WeldJoint_GetDampingRatio_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_GetDampingRatio_0.apply(null, arguments)\n    }\n      , Ys = b._emscripten_bind_b2Color_get_b_0 = function() {\n        return b.asm._emscripten_bind_b2Color_get_b_0.apply(null, arguments)\n    }\n      , Zs = b._emscripten_bind_b2MouseJointDef_get_userData_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_get_userData_0.apply(null, arguments)\n    }\n      , $s = b._emscripten_bind_b2CircleShape_ComputeAABB_3 = function() {\n        return b.asm._emscripten_bind_b2CircleShape_ComputeAABB_3.apply(null, arguments)\n    }\n      , at = b._emscripten_bind_b2RopeJoint_GetReactionForce_1 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_GetReactionForce_1.apply(null, arguments)\n    }\n      , bt = b._emscripten_bind_b2PrismaticJointDef_get_enableLimit_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_enableLimit_0.apply(null, arguments)\n    }\n      , ct = b._emscripten_bind_b2ManifoldPoint_set_localPoint_1 = function() {\n        return b.asm._emscripten_bind_b2ManifoldPoint_set_localPoint_1.apply(null, arguments)\n    }\n      , dt = b._emscripten_bind_b2Fixture_GetFilterData_0 = function() {\n        return b.asm._emscripten_bind_b2Fixture_GetFilterData_0.apply(null, arguments)\n    }\n      , et = b._emscripten_bind_b2World_GetBodyList_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetBodyList_0.apply(null, arguments)\n    }\n      , ft = b._emscripten_bind_b2Body_GetJointList_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetJointList_0.apply(null, arguments)\n    }\n      , gt = b._emscripten_bind_b2Joint_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2Joint_GetNext_0.apply(null, arguments)\n    }\n      , ht = b._emscripten_bind_b2Joint_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2Joint_GetType_0.apply(null, arguments)\n    }\n      , it = b._emscripten_bind_b2World_RayCast_3 = function() {\n        return b.asm._emscripten_bind_b2World_RayCast_3.apply(null, arguments)\n    }\n      , jt = b._emscripten_bind_b2MassData_set_I_1 = function() {\n        return b.asm._emscripten_bind_b2MassData_set_I_1.apply(null, arguments)\n    }\n      , kt = b._emscripten_bind_b2MassData___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2MassData___destroy___0.apply(null, arguments)\n    }\n      , lt = b._emscripten_bind_b2Profile_get_collide_0 = function() {\n        return b.asm._emscripten_bind_b2Profile_get_collide_0.apply(null, arguments)\n    }\n      , mt = b._emscripten_bind_b2Color_b2Color_3 = function() {\n        return b.asm._emscripten_bind_b2Color_b2Color_3.apply(null, arguments)\n    }\n      , nt = b._emscripten_bind_b2Color_b2Color_0 = function() {\n        return b.asm._emscripten_bind_b2Color_b2Color_0.apply(null, arguments)\n    }\n      , ot = b._emscripten_bind_b2WheelJointDef_get_frequencyHz_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_get_frequencyHz_0.apply(null, arguments)\n    }\n      , pt = b._emscripten_bind_b2WeldJointDef_Initialize_3 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_Initialize_3.apply(null, arguments)\n    }\n      , qt = b._emscripten_bind_b2RevoluteJoint_GetMotorTorque_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetMotorTorque_1.apply(null, arguments)\n    }\n      , rt = b._emscripten_enum_b2JointType_e_gearJoint = function() {\n        return b.asm._emscripten_enum_b2JointType_e_gearJoint.apply(null, arguments)\n    }\n      , st = b._emscripten_bind_b2FixtureDef_get_friction_0 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_get_friction_0.apply(null, arguments)\n    }\n      , tt = b._emscripten_bind_b2PrismaticJointDef_set_localAnchorA_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_localAnchorA_1.apply(null, arguments)\n    }\n      , ut = b._emscripten_bind_b2Contact_GetManifold_0 = function() {\n        return b.asm._emscripten_bind_b2Contact_GetManifold_0.apply(null, arguments)\n    }\n      , vt = b._emscripten_bind_b2QueryCallback___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2QueryCallback___destroy___0.apply(null, arguments)\n    }\n      , wt = b._emscripten_bind_b2WeldJointDef_get_localAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_get_localAnchorA_0.apply(null, arguments)\n    }\n      , xt = b._emscripten_bind_b2MouseJoint_SetUserData_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_SetUserData_1.apply(null, arguments)\n    }\n      , yt = b._emscripten_bind_b2MotorJointDef_set_correctionFactor_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_set_correctionFactor_1.apply(null, arguments)\n    }\n      , zt = b._emscripten_bind_b2ChainShape_GetChildEdge_2 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_GetChildEdge_2.apply(null, arguments)\n    }\n      , At = b._emscripten_enum_b2JointType_e_mouseJoint = function() {\n        return b.asm._emscripten_enum_b2JointType_e_mouseJoint.apply(null, arguments)\n    }\n      , Bt = b._emscripten_bind_b2MotorJointDef_get_angularOffset_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_get_angularOffset_0.apply(null, arguments)\n    }\n      , Ct = b._emscripten_bind_b2WheelJoint_SetUserData_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_SetUserData_1.apply(null, arguments)\n    }\n      , Dt = b._emscripten_bind_b2Body_ApplyForce_3 = function() {\n        return b.asm._emscripten_bind_b2Body_ApplyForce_3.apply(null, arguments)\n    }\n      , Et = b._emscripten_bind_b2ChainShape_set_m_count_1 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_set_m_count_1.apply(null, arguments)\n    }\n      , Ft = b._emscripten_bind_b2DistanceJoint_GetCollideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetCollideConnected_0.apply(null, arguments)\n    }\n      , Gt = b._emscripten_bind_b2RevoluteJoint_IsMotorEnabled_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_IsMotorEnabled_0.apply(null, arguments)\n    }\n      , Ht = b._emscripten_bind_b2PolygonShape_GetVertex_1 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_GetVertex_1.apply(null, arguments)\n    }\n      , It = b._emscripten_bind_b2World_SetGravity_1 = function() {\n        return b.asm._emscripten_bind_b2World_SetGravity_1.apply(null, arguments)\n    }\n      , Jt = b._emscripten_bind_b2MouseJointDef_get_collideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_get_collideConnected_0.apply(null, arguments)\n    }\n      , Qb = b._llvm_bswap_i32 = function() {\n        return b.asm._llvm_bswap_i32.apply(null, arguments)\n    }\n      , Kt = b._emscripten_bind_b2Fixture_SetRestitution_1 = function() {\n        return b.asm._emscripten_bind_b2Fixture_SetRestitution_1.apply(null, arguments)\n    }\n      , Lt = b._emscripten_bind_b2Body_GetTransform_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetTransform_0.apply(null, arguments)\n    }\n      , Mt = b._emscripten_enum_b2ShapeType_e_typeCount = function() {\n        return b.asm._emscripten_enum_b2ShapeType_e_typeCount.apply(null, arguments)\n    }\n      , Nt = b._emscripten_bind_b2Mat33_set_ex_1 = function() {\n        return b.asm._emscripten_bind_b2Mat33_set_ex_1.apply(null, arguments)\n    }\n      , Ot = b._emscripten_bind_b2PulleyJointDef_get_localAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_get_localAnchorB_0.apply(null, arguments)\n    }\n      , Pt = b._emscripten_bind_b2RevoluteJointDef_get_bodyA_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_get_bodyA_0.apply(null, arguments)\n    }\n      , Qt = b._emscripten_bind_b2PrismaticJoint_GetBodyB_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetBodyB_0.apply(null, arguments)\n    }\n      , Rt = b._emscripten_bind_b2WheelJointDef_set_bodyA_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_set_bodyA_1.apply(null, arguments)\n    }\n      , St = b._emscripten_bind_b2MotorJointDef_set_maxForce_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_set_maxForce_1.apply(null, arguments)\n    }\n      , Tt = b._emscripten_bind_b2BodyDef_get_angle_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_get_angle_0.apply(null, arguments)\n    }\n      , Ut = b._emscripten_bind_b2FixtureDef_get_shape_0 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef_get_shape_0.apply(null, arguments)\n    }\n      , Vt = b._emscripten_bind_b2Body_SetAngularVelocity_1 = function() {\n        return b.asm._emscripten_bind_b2Body_SetAngularVelocity_1.apply(null, arguments)\n    }\n      , Wt = b._emscripten_bind_b2WeldJointDef_get_userData_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_get_userData_0.apply(null, arguments)\n    }\n      , Xt = b._emscripten_bind_b2FrictionJoint_SetMaxForce_1 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_SetMaxForce_1.apply(null, arguments)\n    }\n      , Yt = b._emscripten_bind_b2Mat33_b2Mat33_3 = function() {\n        return b.asm._emscripten_bind_b2Mat33_b2Mat33_3.apply(null, arguments)\n    }\n      , Zt = b._emscripten_bind_b2Vec3_get_y_0 = function() {\n        return b.asm._emscripten_bind_b2Vec3_get_y_0.apply(null, arguments)\n    }\n      , $t = b._emscripten_bind_b2JointDef_get_type_0 = function() {\n        return b.asm._emscripten_bind_b2JointDef_get_type_0.apply(null, arguments)\n    }\n      , au = b._emscripten_bind_JSQueryCallback_ReportFixture_1 = function() {\n        return b.asm._emscripten_bind_JSQueryCallback_ReportFixture_1.apply(null, arguments)\n    }\n      , bu = b._emscripten_bind_b2PulleyJoint_GetCollideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetCollideConnected_0.apply(null, arguments)\n    }\n      , cu = b._emscripten_bind_b2Body_CreateFixture_1 = function() {\n        return b.asm._emscripten_bind_b2Body_CreateFixture_1.apply(null, arguments)\n    }\n      , du = b._emscripten_bind_JSDraw_JSDraw_0 = function() {\n        return b.asm._emscripten_bind_JSDraw_JSDraw_0.apply(null, arguments)\n    }\n      , eu = b._emscripten_bind_b2MouseJoint_GetAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_GetAnchorA_0.apply(null, arguments)\n    }\n      , fu = b._emscripten_bind_b2Transform_get_p_0 = function() {\n        return b.asm._emscripten_bind_b2Transform_get_p_0.apply(null, arguments)\n    }\n      , gu = b._emscripten_bind_b2WorldManifold_get_normal_0 = function() {\n        return b.asm._emscripten_bind_b2WorldManifold_get_normal_0.apply(null, arguments)\n    }\n      , hu = b._emscripten_bind_b2World_GetProfile_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetProfile_0.apply(null, arguments)\n    }\n      , iu = b._emscripten_bind_b2DistanceJointDef___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef___destroy___0.apply(null, arguments)\n    }\n      , ju = b._emscripten_bind_b2GearJointDef_set_bodyA_1 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_set_bodyA_1.apply(null, arguments)\n    }\n      , ku = b._emscripten_bind_b2JointDef_set_type_1 = function() {\n        return b.asm._emscripten_bind_b2JointDef_set_type_1.apply(null, arguments)\n    }\n      , lu = b._emscripten_bind_b2ContactEdge_set_contact_1 = function() {\n        return b.asm._emscripten_bind_b2ContactEdge_set_contact_1.apply(null, arguments)\n    }\n      , mu = b._emscripten_bind_b2MotorJointDef_get_userData_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_get_userData_0.apply(null, arguments)\n    }\n      , nu = b._emscripten_bind_b2World_GetContactList_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetContactList_0.apply(null, arguments)\n    }\n      , ou = b._emscripten_bind_b2Mat33_set_ez_1 = function() {\n        return b.asm._emscripten_bind_b2Mat33_set_ez_1.apply(null, arguments)\n    }\n      , pu = b._emscripten_bind_b2JointEdge_b2JointEdge_0 = function() {\n        return b.asm._emscripten_bind_b2JointEdge_b2JointEdge_0.apply(null, arguments)\n    }\n      , qu = b._emscripten_bind_b2FrictionJointDef_get_bodyA_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_get_bodyA_0.apply(null, arguments)\n    }\n      , ru = b._emscripten_bind_b2WheelJointDef_get_type_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_get_type_0.apply(null, arguments)\n    }\n      , su = b._emscripten_bind_b2RevoluteJoint_GetReactionForce_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetReactionForce_1.apply(null, arguments)\n    }\n      , tu = b._emscripten_bind_b2PulleyJointDef_set_collideConnected_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_set_collideConnected_1.apply(null, arguments)\n    }\n      , uu = b._emscripten_bind_b2RopeJoint_GetCollideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_GetCollideConnected_0.apply(null, arguments)\n    }\n      , vu = b._emscripten_bind_b2GearJointDef_set_joint2_1 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_set_joint2_1.apply(null, arguments)\n    }\n      , wu = b._emscripten_bind_b2EdgeShape_set_m_vertex3_1 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_set_m_vertex3_1.apply(null, arguments)\n    }\n      , xu = b._emscripten_bind_b2GearJoint_GetAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_GetAnchorB_0.apply(null, arguments)\n    }\n      , yu = b._emscripten_bind_b2RopeJoint_IsActive_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_IsActive_0.apply(null, arguments)\n    }\n      , zu = b._emscripten_bind_b2Fixture_GetFriction_0 = function() {\n        return b.asm._emscripten_bind_b2Fixture_GetFriction_0.apply(null, arguments)\n    }\n      , Au = b._emscripten_bind_b2Fixture_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2Fixture_GetNext_0.apply(null, arguments)\n    }\n      , Bu = b._emscripten_bind_b2RopeJointDef_get_bodyA_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_get_bodyA_0.apply(null, arguments)\n    }\n      , Cu = b._emscripten_bind_b2WeldJointDef_get_localAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_get_localAnchorB_0.apply(null, arguments)\n    }\n      , Du = b._emscripten_bind_b2WeldJointDef_set_referenceAngle_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_set_referenceAngle_1.apply(null, arguments)\n    }\n      , Eu = b._emscripten_bind_b2DistanceJointDef_set_localAnchorB_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_set_localAnchorB_1.apply(null, arguments)\n    }\n      , Fu = b._emscripten_bind_b2Mat33_SetZero_0 = function() {\n        return b.asm._emscripten_bind_b2Mat33_SetZero_0.apply(null, arguments)\n    }\n      , Gu = b._emscripten_bind_b2MotorJointDef_get_bodyB_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_get_bodyB_0.apply(null, arguments)\n    }\n      , Hu = b._emscripten_bind_b2WheelJointDef_b2WheelJointDef_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_b2WheelJointDef_0.apply(null, arguments)\n    }\n      , Iu = b._emscripten_bind_b2PrismaticJointDef_get_localAxisA_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_localAxisA_0.apply(null, arguments)\n    }\n      , Ju = b._emscripten_bind_b2Mat22_get_ey_0 = function() {\n        return b.asm._emscripten_bind_b2Mat22_get_ey_0.apply(null, arguments)\n    }\n      , Ku = b._emscripten_bind_b2Mat22_SetIdentity_0 = function() {\n        return b.asm._emscripten_bind_b2Mat22_SetIdentity_0.apply(null, arguments)\n    }\n      , Lu = b._emscripten_bind_b2Joint_IsActive_0 = function() {\n        return b.asm._emscripten_bind_b2Joint_IsActive_0.apply(null, arguments)\n    }\n      , Mu = b._emscripten_bind_b2PulleyJoint_GetReactionForce_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetReactionForce_1.apply(null, arguments)\n    }\n      , Nu = b._emscripten_bind_b2Shape_get_m_radius_0 = function() {\n        return b.asm._emscripten_bind_b2Shape_get_m_radius_0.apply(null, arguments)\n    }\n      , Ou = b._emscripten_bind_b2Mat22_b2Mat22_4 = function() {\n        return b.asm._emscripten_bind_b2Mat22_b2Mat22_4.apply(null, arguments)\n    }\n      , Pu = b._emscripten_bind_b2PrismaticJointDef_set_localAxisA_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_localAxisA_1.apply(null, arguments)\n    }\n      , Qu = b._emscripten_bind_b2PolygonShape_SetAsBox_4 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_SetAsBox_4.apply(null, arguments)\n    }\n      , Ru = b._emscripten_bind_b2EdgeShape_set_m_vertex1_1 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_set_m_vertex1_1.apply(null, arguments)\n    }\n      , Su = b._emscripten_bind_b2Body_GetWorld_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetWorld_0.apply(null, arguments)\n    }\n      , Tu = b._emscripten_enum_b2LimitState_e_inactiveLimit = function() {\n        return b.asm._emscripten_enum_b2LimitState_e_inactiveLimit.apply(null, arguments)\n    }\n      , Uu = b._emscripten_bind_b2Vec2_set_x_1 = function() {\n        return b.asm._emscripten_bind_b2Vec2_set_x_1.apply(null, arguments)\n    }\n      , Vu = b._emscripten_bind_b2Body_SetAwake_1 = function() {\n        return b.asm._emscripten_bind_b2Body_SetAwake_1.apply(null, arguments)\n    }\n      , Wu = b._emscripten_bind_b2WeldJoint_GetLocalAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJoint_GetLocalAnchorA_0.apply(null, arguments)\n    }\n      , Xu = b._emscripten_bind_b2Vec2___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2Vec2___destroy___0.apply(null, arguments)\n    }\n      , Yu = b._emscripten_enum_b2ShapeType_e_polygon = function() {\n        return b.asm._emscripten_enum_b2ShapeType_e_polygon.apply(null, arguments)\n    }\n      , Zu = b._emscripten_bind_b2Body_GetInertia_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetInertia_0.apply(null, arguments)\n    }\n      , $u = b._emscripten_bind_b2PulleyJoint_GetAnchorA_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetAnchorA_0.apply(null, arguments)\n    }\n      , av = b._emscripten_bind_b2BodyDef_get_linearVelocity_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_get_linearVelocity_0.apply(null, arguments)\n    }\n      , bv = b._emscripten_bind_b2DistanceJointDef_get_bodyB_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJointDef_get_bodyB_0.apply(null, arguments)\n    }\n      , cv = b._emscripten_bind_b2Mat22___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2Mat22___destroy___0.apply(null, arguments)\n    }\n      , dv = b._emscripten_bind_b2RevoluteJoint_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetNext_0.apply(null, arguments)\n    }\n      , ev = b._emscripten_bind_b2WeldJointDef_get_bodyA_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_get_bodyA_0.apply(null, arguments)\n    }\n      , fv = b._emscripten_bind_b2MotorJoint_GetAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetAnchorB_0.apply(null, arguments)\n    }\n      , gv = b._emscripten_bind_b2Fixture_GetShape_0 = function() {\n        return b.asm._emscripten_bind_b2Fixture_GetShape_0.apply(null, arguments)\n    }\n      , hv = b._emscripten_bind_b2PulleyJoint_GetReactionTorque_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJoint_GetReactionTorque_1.apply(null, arguments)\n    }\n      , iv = b._emscripten_bind_b2Vec3_op_mul_1 = function() {\n        return b.asm._emscripten_bind_b2Vec3_op_mul_1.apply(null, arguments)\n    }\n      , jv = b._emscripten_bind_b2PolygonShape_set_m_type_1 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_set_m_type_1.apply(null, arguments)\n    }\n      , kv = b._emscripten_bind_b2WheelJoint_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetType_0.apply(null, arguments)\n    }\n      , lv = b._emscripten_bind_b2MotorJoint_GetAngularOffset_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetAngularOffset_0.apply(null, arguments)\n    }\n      , mv = b._emscripten_bind_b2RevoluteJoint_IsActive_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_IsActive_0.apply(null, arguments)\n    }\n      , nv = b._emscripten_bind_b2GearJoint_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_GetNext_0.apply(null, arguments)\n    }\n      , ov = b._emscripten_bind_b2MouseJointDef_get_maxForce_0 = function() {\n        return b.asm._emscripten_bind_b2MouseJointDef_get_maxForce_0.apply(null, arguments)\n    }\n      , pv = b._emscripten_bind_b2DestructionListenerWrapper___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2DestructionListenerWrapper___destroy___0.apply(null, arguments)\n    }\n      , qv = b._emscripten_bind_b2PrismaticJointDef_set_maxMotorForce_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_set_maxMotorForce_1.apply(null, arguments)\n    }\n      , rv = b._emscripten_bind_b2WheelJoint_GetLocalAxisA_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetLocalAxisA_0.apply(null, arguments)\n    }\n      , sv = b._emscripten_bind_b2Body_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetNext_0.apply(null, arguments)\n    }\n      , tv = b._emscripten_bind_b2MouseJoint_GetReactionForce_1 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint_GetReactionForce_1.apply(null, arguments)\n    }\n      , uv = b._emscripten_bind_b2RopeJoint_GetBodyA_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_GetBodyA_0.apply(null, arguments)\n    }\n      , vv = b._emscripten_bind_b2ContactFeature_set_indexA_1 = function() {\n        return b.asm._emscripten_bind_b2ContactFeature_set_indexA_1.apply(null, arguments)\n    }\n      , wv = b._emscripten_bind_b2Profile_get_solveInit_0 = function() {\n        return b.asm._emscripten_bind_b2Profile_get_solveInit_0.apply(null, arguments)\n    }\n      , xv = b._emscripten_bind_b2Fixture_IsSensor_0 = function() {\n        return b.asm._emscripten_bind_b2Fixture_IsSensor_0.apply(null, arguments)\n    }\n      , yv = b._emscripten_bind_b2FrictionJoint_GetAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_GetAnchorB_0.apply(null, arguments)\n    }\n      , zv = b._emscripten_bind_b2World_QueryAABB_2 = function() {\n        return b.asm._emscripten_bind_b2World_QueryAABB_2.apply(null, arguments)\n    }\n      , Av = b._emscripten_bind_b2Profile_set_collide_1 = function() {\n        return b.asm._emscripten_bind_b2Profile_set_collide_1.apply(null, arguments)\n    }\n      , Bv = b._emscripten_bind_b2BodyDef_get_userData_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_get_userData_0.apply(null, arguments)\n    }\n      , Cv = b._emscripten_bind_b2MotorJoint_SetLinearOffset_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_SetLinearOffset_1.apply(null, arguments)\n    }\n      , Dv = b._emscripten_bind_b2FrictionJoint_GetMaxForce_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_GetMaxForce_0.apply(null, arguments)\n    }\n      , Ev = b._emscripten_bind_b2WheelJointDef_get_userData_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_get_userData_0.apply(null, arguments)\n    }\n      , Fv = b._emscripten_bind_b2RevoluteJoint_IsLimitEnabled_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_IsLimitEnabled_0.apply(null, arguments)\n    }\n      , Gv = b._emscripten_bind_b2World_SetDestructionListener_1 = function() {\n        return b.asm._emscripten_bind_b2World_SetDestructionListener_1.apply(null, arguments)\n    }\n      , Hv = b._emscripten_bind_b2RevoluteJointDef_set_maxMotorTorque_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_set_maxMotorTorque_1.apply(null, arguments)\n    }\n      , Iv = b._emscripten_bind_b2WeldJointDef_set_bodyB_1 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_set_bodyB_1.apply(null, arguments)\n    }\n      , Jv = b._emscripten_bind_b2Transform_set_p_1 = function() {\n        return b.asm._emscripten_bind_b2Transform_set_p_1.apply(null, arguments)\n    }\n      , Kv = b._emscripten_bind_b2DistanceJoint_SetLength_1 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_SetLength_1.apply(null, arguments)\n    }\n      , Lv = b._emscripten_bind_b2ManifoldPoint_get_localPoint_0 = function() {\n        return b.asm._emscripten_bind_b2ManifoldPoint_get_localPoint_0.apply(null, arguments)\n    }\n      , Mv = b._emscripten_bind_b2JointEdge_get_joint_0 = function() {\n        return b.asm._emscripten_bind_b2JointEdge_get_joint_0.apply(null, arguments)\n    }\n      , Nv = b._emscripten_bind_b2Body_GetLocalCenter_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetLocalCenter_0.apply(null, arguments)\n    }\n      , Ov = b._emscripten_bind_b2FixtureDef___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2FixtureDef___destroy___0.apply(null, arguments)\n    }\n      , Pv = b._emscripten_bind_b2MouseJoint___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2MouseJoint___destroy___0.apply(null, arguments)\n    }\n      , Qv = b._emscripten_enum_b2JointType_e_ropeJoint = function() {\n        return b.asm._emscripten_enum_b2JointType_e_ropeJoint.apply(null, arguments)\n    }\n      , Rv = b._emscripten_bind_b2Profile_get_solveVelocity_0 = function() {\n        return b.asm._emscripten_bind_b2Profile_get_solveVelocity_0.apply(null, arguments)\n    }\n      , Sv = b._emscripten_bind_b2WeldJointDef_get_bodyB_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_get_bodyB_0.apply(null, arguments)\n    }\n      , Tv = b._emscripten_bind_b2World_GetContinuousPhysics_0 = function() {\n        return b.asm._emscripten_bind_b2World_GetContinuousPhysics_0.apply(null, arguments)\n    }\n      , Uv = b._emscripten_bind_b2Joint_GetBodyA_0 = function() {\n        return b.asm._emscripten_bind_b2Joint_GetBodyA_0.apply(null, arguments)\n    }\n      , Vv = b._emscripten_bind_b2MotorJointDef_set_maxTorque_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_set_maxTorque_1.apply(null, arguments)\n    }\n      , Wv = b._emscripten_bind_b2PulleyJointDef_Initialize_7 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_Initialize_7.apply(null, arguments)\n    }\n      , Xv = b._emscripten_bind_b2GearJointDef_set_bodyB_1 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_set_bodyB_1.apply(null, arguments)\n    }\n      , Yv = b._emscripten_bind_b2RopeJoint_GetReactionTorque_1 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_GetReactionTorque_1.apply(null, arguments)\n    }\n      , Zv = b._emscripten_bind_b2WheelJointDef_set_dampingRatio_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_set_dampingRatio_1.apply(null, arguments)\n    }\n      , $v = b._emscripten_bind_b2GearJoint_GetType_0 = function() {\n        return b.asm._emscripten_bind_b2GearJoint_GetType_0.apply(null, arguments)\n    }\n      , aw = b._emscripten_bind_b2MotorJoint_GetNext_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJoint_GetNext_0.apply(null, arguments)\n    }\n      , bw = b._emscripten_bind_b2EdgeShape_set_m_vertex0_1 = function() {\n        return b.asm._emscripten_bind_b2EdgeShape_set_m_vertex0_1.apply(null, arguments)\n    }\n      , cw = b._emscripten_bind_b2RevoluteJoint_GetAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJoint_GetAnchorB_0.apply(null, arguments)\n    }\n      , dw = b._emscripten_bind_b2RopeJointDef_set_localAnchorB_1 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_set_localAnchorB_1.apply(null, arguments)\n    }\n      , ew = b._emscripten_bind_b2PrismaticJoint_GetUserData_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_GetUserData_0.apply(null, arguments)\n    }\n      , fw = b._emscripten_bind_b2GearJointDef_set_userData_1 = function() {\n        return b.asm._emscripten_bind_b2GearJointDef_set_userData_1.apply(null, arguments)\n    }\n      , gw = b._emscripten_bind_b2Fixture_SetSensor_1 = function() {\n        return b.asm._emscripten_bind_b2Fixture_SetSensor_1.apply(null, arguments)\n    }\n      , hw = b._emscripten_bind_b2MotorJointDef_set_collideConnected_1 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_set_collideConnected_1.apply(null, arguments)\n    }\n      , iw = b._emscripten_bind_b2Contact_GetFixtureB_0 = function() {\n        return b.asm._emscripten_bind_b2Contact_GetFixtureB_0.apply(null, arguments)\n    }\n      , jw = b._emscripten_bind_b2ChainShape_ComputeMass_2 = function() {\n        return b.asm._emscripten_bind_b2ChainShape_ComputeMass_2.apply(null, arguments)\n    }\n      , kw = b._emscripten_bind_b2WeldJointDef_b2WeldJointDef_0 = function() {\n        return b.asm._emscripten_bind_b2WeldJointDef_b2WeldJointDef_0.apply(null, arguments)\n    }\n      , lw = b._emscripten_bind_b2Contact_GetChildIndexA_0 = function() {\n        return b.asm._emscripten_bind_b2Contact_GetChildIndexA_0.apply(null, arguments)\n    }\n      , mw = b._emscripten_bind_b2RopeJointDef_get_bodyB_0 = function() {\n        return b.asm._emscripten_bind_b2RopeJointDef_get_bodyB_0.apply(null, arguments)\n    }\n      , nw = b._emscripten_bind_b2BodyDef_b2BodyDef_0 = function() {\n        return b.asm._emscripten_bind_b2BodyDef_b2BodyDef_0.apply(null, arguments)\n    }\n      , ow = b._emscripten_bind_b2MassData_get_mass_0 = function() {\n        return b.asm._emscripten_bind_b2MassData_get_mass_0.apply(null, arguments)\n    }\n      , pw = b._emscripten_bind_b2WorldManifold_get_separations_1 = function() {\n        return b.asm._emscripten_bind_b2WorldManifold_get_separations_1.apply(null, arguments)\n    }\n      , qw = b._emscripten_bind_b2Joint_GetBodyB_0 = function() {\n        return b.asm._emscripten_bind_b2Joint_GetBodyB_0.apply(null, arguments)\n    }\n      , rw = b._emscripten_bind_b2Shape_GetChildCount_0 = function() {\n        return b.asm._emscripten_bind_b2Shape_GetChildCount_0.apply(null, arguments)\n    }\n      , sw = b._emscripten_bind_b2WheelJointDef_set_localAxisA_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_set_localAxisA_1.apply(null, arguments)\n    }\n      , tw = b._emscripten_bind_b2Joint_Dump_0 = function() {\n        return b.asm._emscripten_bind_b2Joint_Dump_0.apply(null, arguments)\n    }\n      , uw = b._emscripten_bind_b2World_SetContactFilter_1 = function() {\n        return b.asm._emscripten_bind_b2World_SetContactFilter_1.apply(null, arguments)\n    }\n      , vw = b._emscripten_bind_b2RevoluteJointDef_set_motorSpeed_1 = function() {\n        return b.asm._emscripten_bind_b2RevoluteJointDef_set_motorSpeed_1.apply(null, arguments)\n    }\n      , ww = b._emscripten_bind_b2MotorJointDef_get_bodyA_0 = function() {\n        return b.asm._emscripten_bind_b2MotorJointDef_get_bodyA_0.apply(null, arguments)\n    }\n      , xw = b._emscripten_bind_b2WheelJointDef_get_enableMotor_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_get_enableMotor_0.apply(null, arguments)\n    }\n      , yw = b._emscripten_bind_b2Vec2_LengthSquared_0 = function() {\n        return b.asm._emscripten_bind_b2Vec2_LengthSquared_0.apply(null, arguments)\n    }\n      , zw = b._emscripten_bind_b2FrictionJointDef_set_bodyA_1 = function() {\n        return b.asm._emscripten_bind_b2FrictionJointDef_set_bodyA_1.apply(null, arguments)\n    }\n      , Aw = b._emscripten_bind_b2WheelJoint_GetSpringFrequencyHz_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetSpringFrequencyHz_0.apply(null, arguments)\n    }\n      , Bw = b._emscripten_bind_b2ContactEdge_set_prev_1 = function() {\n        return b.asm._emscripten_bind_b2ContactEdge_set_prev_1.apply(null, arguments)\n    }\n      , Cw = b._emscripten_bind_b2Shape_ComputeMass_2 = function() {\n        return b.asm._emscripten_bind_b2Shape_ComputeMass_2.apply(null, arguments)\n    }\n      , Dw = b._emscripten_bind_b2FrictionJoint_GetBodyA_0 = function() {\n        return b.asm._emscripten_bind_b2FrictionJoint_GetBodyA_0.apply(null, arguments)\n    }\n      , Ew = b._emscripten_bind_b2WheelJointDef_set_localAnchorB_1 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_set_localAnchorB_1.apply(null, arguments)\n    }\n      , Fw = b._emscripten_bind_b2Body_GetAngle_0 = function() {\n        return b.asm._emscripten_bind_b2Body_GetAngle_0.apply(null, arguments)\n    }\n      , Gw = b._emscripten_bind_b2PrismaticJointDef_get_maxMotorForce_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_maxMotorForce_0.apply(null, arguments)\n    }\n      , Hw = b._emscripten_bind_b2DistanceJoint_GetBodyA_0 = function() {\n        return b.asm._emscripten_bind_b2DistanceJoint_GetBodyA_0.apply(null, arguments)\n    }\n      , Iw = b._emscripten_bind_b2WheelJoint_GetLocalAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetLocalAnchorB_0.apply(null, arguments)\n    }\n      , Jw = b._emscripten_bind_b2PulleyJointDef_set_bodyA_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_set_bodyA_1.apply(null, arguments)\n    }\n      , Kw = b._emscripten_bind_b2WheelJoint_GetAnchorB_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint_GetAnchorB_0.apply(null, arguments)\n    }\n      , Lw = b._emscripten_bind_b2PolygonShape_SetAsBox_2 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_SetAsBox_2.apply(null, arguments)\n    }\n      , Mw = b._emscripten_bind_b2PrismaticJointDef_get_type_0 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJointDef_get_type_0.apply(null, arguments)\n    }\n      , Nw = b._emscripten_bind_b2Color_Set_3 = function() {\n        return b.asm._emscripten_bind_b2Color_Set_3.apply(null, arguments)\n    }\n      , Ow = b._emscripten_bind_b2WheelJointDef_get_bodyA_0 = function() {\n        return b.asm._emscripten_bind_b2WheelJointDef_get_bodyA_0.apply(null, arguments)\n    }\n      , Pw = b._emscripten_enum_b2LimitState_e_atUpperLimit = function() {\n        return b.asm._emscripten_enum_b2LimitState_e_atUpperLimit.apply(null, arguments)\n    }\n      , Qw = b._emscripten_bind_b2PulleyJointDef_set_groundAnchorA_1 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_set_groundAnchorA_1.apply(null, arguments)\n    }\n      , Rw = b._emscripten_bind_b2PolygonShape_get_m_type_0 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_get_m_type_0.apply(null, arguments)\n    }\n      , Sw = b._emscripten_bind_b2PrismaticJoint_SetMaxMotorForce_1 = function() {\n        return b.asm._emscripten_bind_b2PrismaticJoint_SetMaxMotorForce_1.apply(null, arguments)\n    }\n      , Tw = b._emscripten_bind_b2PulleyJointDef_get_collideConnected_0 = function() {\n        return b.asm._emscripten_bind_b2PulleyJointDef_get_collideConnected_0.apply(null, arguments)\n    }\n      , Uw = b._emscripten_bind_JSContactListener_JSContactListener_0 = function() {\n        return b.asm._emscripten_bind_JSContactListener_JSContactListener_0.apply(null, arguments)\n    }\n      , Vw = b._emscripten_bind_b2WheelJoint___destroy___0 = function() {\n        return b.asm._emscripten_bind_b2WheelJoint___destroy___0.apply(null, arguments)\n    }\n      , Ww = b._emscripten_bind_b2PolygonShape_set_m_radius_1 = function() {\n        return b.asm._emscripten_bind_b2PolygonShape_set_m_radius_1.apply(null, arguments)\n    }\n      , Xw = b._emscripten_bind_b2Fixture_GetMassData_1 = function() {\n        return b.asm._emscripten_bind_b2Fixture_GetMassData_1.apply(null, arguments)\n    }\n      , Yw = b._emscripten_bind_b2RopeJoint_SetMaxLength_1 = function() {\n        return b.asm._emscripten_bind_b2RopeJoint_SetMaxLength_1.apply(null, arguments)\n    }\n    ;\n    b.dynCall_iiii = function() {\n        return b.asm.dynCall_iiii.apply(null, arguments)\n    }\n    ;\n    b.dynCall_viifii = function() {\n        return b.asm.dynCall_viifii.apply(null, arguments)\n    }\n    ;\n    b.dynCall_viiiii = function() {\n        return b.asm.dynCall_viiiii.apply(null, arguments)\n    }\n    ;\n    b.dynCall_vi = function() {\n        return b.asm.dynCall_vi.apply(null, arguments)\n    }\n    ;\n    b.dynCall_vii = function() {\n        return b.asm.dynCall_vii.apply(null, arguments)\n    }\n    ;\n    b.dynCall_ii = function() {\n        return b.asm.dynCall_ii.apply(null, arguments)\n    }\n    ;\n    b.dynCall_fif = function() {\n        return b.asm.dynCall_fif.apply(null, arguments)\n    }\n    ;\n    b.dynCall_viii = function() {\n        return b.asm.dynCall_viii.apply(null, arguments)\n    }\n    ;\n    b.dynCall_viifi = function() {\n        return b.asm.dynCall_viifi.apply(null, arguments)\n    }\n    ;\n    b.dynCall_v = function() {\n        return b.asm.dynCall_v.apply(null, arguments)\n    }\n    ;\n    b.dynCall_viif = function() {\n        return b.asm.dynCall_viif.apply(null, arguments)\n    }\n    ;\n    b.dynCall_viiiiii = function() {\n        return b.asm.dynCall_viiiiii.apply(null, arguments)\n    }\n    ;\n    b.dynCall_iii = function() {\n        return b.asm.dynCall_iii.apply(null, arguments)\n    }\n    ;\n    b.dynCall_iiiiii = function() {\n        return b.asm.dynCall_iiiiii.apply(null, arguments)\n    }\n    ;\n    b.dynCall_fiiiif = function() {\n        return b.asm.dynCall_fiiiif.apply(null, arguments)\n    }\n    ;\n    b.dynCall_viiii = function() {\n        return b.asm.dynCall_viiii.apply(null, arguments)\n    }\n    ;\n    f.t = b.stackAlloc;\n    f.L = b.stackSave;\n    f.K = b.stackRestore;\n    f.R = b.establishStackSpace;\n    f.f = b.setTempRet0;\n    f.H = b.getTempRet0;\n    b.asm = Sb;\n    if (zb)\n        if ("function" === typeof b.locateFile ? zb = b.locateFile(zb) : b.memoryInitializerPrefixURL && (zb = b.memoryInitializerPrefixURL + zb),\n        ea || fa) {\n            var Zw = b.readBinary(zb);\n            Da.set(Zw, f.i)\n        } else {\n            var ax = function() {\n                b.readAsync(zb, $w, function() {\n                    throw "could not load memory initializer " + zb;\n                })\n            };\n            xb();\n            var $w = function(a) {\n                a.byteLength && (a = new Uint8Array(a));\n                Da.set(a, f.i);\n                b.memoryInitializerRequest && delete b.memoryInitializerRequest.response;\n                yb()\n            };\n            if (b.memoryInitializerRequest) {\n                var bx = function() {\n                    var a = b.memoryInitializerRequest;\n                    200 !== a.status && 0 !== a.status ? (console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + a.status + ", retrying " + zb),\n                    ax()) : $w(a.response)\n                };\n                b.memoryInitializerRequest.response ? setTimeout(bx, 0) : b.memoryInitializerRequest.addEventListener("load", bx)\n            } else\n                ax()\n        }\n    b.then = function(a) {\n        if (b.calledRun)\n            a(b);\n        else {\n            var c = b.onRuntimeInitialized;\n            b.onRuntimeInitialized = function() {\n                c && c();\n                a(b)\n            }\n        }\n        return b\n    }\n    ;\n    function ja(a) {\n        this.name = "ExitStatus";\n        this.message = "Program terminated with exit(" + a + ")";\n        this.status = a\n    }\n    ja.prototype = Error();\n    ja.prototype.constructor = ja;\n    var cx = null\n      , wb = function dx() {\n        b.calledRun || ex();\n        b.calledRun || (wb = dx)\n    };\n    b.callMain = b.O = function(a) {\n        function c() {\n            for (var a = 0; 3 > a; a++)\n                e.push(0)\n        }\n        a = a || [];\n        pb || (pb = !0,\n        hb(jb));\n        var d = a.length + 1\n          , e = [Ba(rb(b.thisProgram), "i8", 0)];\n        c();\n        for (var g = 0; g < d - 1; g += 1)\n            e.push(Ba(rb(a[g]), "i8", 0)),\n            c();\n        e.push(0);\n        e = Ba(e, "i32", 0);\n        try {\n            var l = b._main(d, e, 0);\n            fx(l, !0)\n        } catch (m) {\n            m instanceof ja || ("SimulateInfiniteLoop" == m ? b.noExitRuntime = !0 : ((a = m) && "object" === typeof m && m.stack && (a = [m, m.stack]),\n            b.h("exception thrown: " + a),\n            b.quit(1, m)))\n        } finally {}\n    }\n    ;\n    function ex(a) {\n        function c() {\n            if (!b.calledRun && (b.calledRun = !0,\n            !ra)) {\n                pb || (pb = !0,\n                hb(jb));\n                hb(kb);\n                if (b.onRuntimeInitialized)\n                    b.onRuntimeInitialized();\n                b._main && gx && b.callMain(a);\n                if (b.postRun)\n                    for ("function" == typeof b.postRun && (b.postRun = [b.postRun]); b.postRun.length; ) {\n                        var c = b.postRun.shift();\n                        ob.unshift(c)\n                    }\n                hb(ob)\n            }\n        }\n        a = a || b.arguments;\n        null === cx && (cx = Date.now());\n        if (!(0 < tb)) {\n            if (b.preRun)\n                for ("function" == typeof b.preRun && (b.preRun = [b.preRun]); b.preRun.length; )\n                    qb();\n            hb(ib);\n            0 < tb || b.calledRun || (b.setStatus ? (b.setStatus("Running..."),\n            setTimeout(function() {\n                setTimeout(function() {\n                    b.setStatus("")\n                }, 1);\n                c()\n            }, 1)) : c())\n        }\n    }\n    b.run = b.run = ex;\n    function fx(a, c) {\n        if (!c || !b.noExitRuntime) {\n            if (!b.noExitRuntime && (ra = !0,\n            ka = void 0,\n            hb(nb),\n            b.onExit))\n                b.onExit(a);\n            ea && process.exit(a);\n            b.quit(a, new ja(a))\n        }\n    }\n    b.exit = b.exit = fx;\n    var hx = [];\n    function ta(a) {\n        if (b.onAbort)\n            b.onAbort(a);\n        void 0 !== a ? (b.print(a),\n        b.h(a),\n        a = JSON.stringify(a)) : a = "";\n        ra = !0;\n        var c = "abort(" + a + ") at " + Ra() + "\\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";\n        hx && hx.forEach(function(d) {\n            c = d(c, a)\n        });\n        throw c;\n    }\n    b.abort = b.abort = ta;\n    if (b.preInit)\n        for ("function" == typeof b.preInit && (b.preInit = [b.preInit]); 0 < b.preInit.length; )\n            b.preInit.pop()();\n    var gx = !0;\n    b.noInitialRun && (gx = !1);\n    b.noExitRuntime = !0;\n    ex();\n    function h() {}\n    h.prototype = Object.create(h.prototype);\n    h.prototype.constructor = h;\n    h.prototype.b = h;\n    h.c = {};\n    b.WrapperObject = h;\n    function k(a) {\n        return (a || h).c\n    }\n    b.getCache = k;\n    function n(a, c) {\n        var d = k(c)\n          , e = d[a];\n        if (e)\n            return e;\n        e = Object.create((c || h).prototype);\n        e.a = a;\n        return d[a] = e\n    }\n    b.wrapPointer = n;\n    b.castObject = function(a, c) {\n        return n(a.a, c)\n    }\n    ;\n    b.NULL = n(0);\n    b.destroy = function(a) {\n        if (!a.__destroy__)\n            throw "Error: Cannot destroy object. (Did you create it yourself?)";\n        a.__destroy__();\n        delete k(a.b)[a.a]\n    }\n    ;\n    b.compare = function(a, c) {\n        return a.a === c.a\n    }\n    ;\n    b.getPointer = function(a) {\n        return a.a\n    }\n    ;\n    b.getClass = function(a) {\n        return a.b\n    }\n    ;\n    var ix = 0\n      , jx = 0\n      , kx = []\n      , lx = 0;\n    function mx() {\n        if (lx) {\n            for (var a = 0; a < kx.length; a++)\n                b._free(kx[a]);\n            kx.length = 0;\n            b._free(ix);\n            ix = 0;\n            jx += lx;\n            lx = 0\n        }\n        ix || (jx += 128,\n        ix = b._malloc(jx),\n        assert(ix))\n    }\n    function nx() {\n        throw "cannot construct a b2DestructionListenerWrapper, no constructor in IDL";\n    }\n    nx.prototype = Object.create(h.prototype);\n    nx.prototype.constructor = nx;\n    nx.prototype.b = nx;\n    nx.c = {};\n    b.b2DestructionListenerWrapper = nx;\n    nx.prototype.__destroy__ = function() {\n        pv(this.a)\n    }\n    ;\n    function ox() {\n        throw "cannot construct a b2Draw, no constructor in IDL";\n    }\n    ox.prototype = Object.create(h.prototype);\n    ox.prototype.constructor = ox;\n    ox.prototype.b = ox;\n    ox.c = {};\n    b.b2Draw = ox;\n    ox.prototype.SetFlags = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ie(c, a)\n    }\n    ;\n    ox.prototype.GetFlags = function() {\n        return bc(this.a)\n    }\n    ;\n    ox.prototype.AppendFlags = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Gh(c, a)\n    }\n    ;\n    ox.prototype.ClearFlags = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        bi(c, a)\n    }\n    ;\n    ox.prototype.__destroy__ = function() {\n        fj(this.a)\n    }\n    ;\n    function p() {\n        throw "cannot construct a b2Joint, no constructor in IDL";\n    }\n    p.prototype = Object.create(h.prototype);\n    p.prototype.constructor = p;\n    p.prototype.b = p;\n    p.c = {};\n    b.b2Joint = p;\n    p.prototype.GetType = function() {\n        return ht(this.a)\n    }\n    ;\n    p.prototype.GetBodyA = function() {\n        return n(Uv(this.a), q)\n    }\n    ;\n    p.prototype.GetBodyB = function() {\n        return n(qw(this.a), q)\n    }\n    ;\n    p.prototype.GetAnchorA = function() {\n        return n(ln(this.a), r)\n    }\n    ;\n    p.prototype.GetAnchorB = function() {\n        return n(jj(this.a), r)\n    }\n    ;\n    p.prototype.GetReactionForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(am(c, a), r)\n    }\n    ;\n    p.prototype.GetReactionTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return Uj(c, a)\n    }\n    ;\n    p.prototype.GetNext = function() {\n        return n(gt(this.a), p)\n    }\n    ;\n    p.prototype.GetUserData = function() {\n        return cl(this.a)\n    }\n    ;\n    p.prototype.SetUserData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Xf(c, a)\n    }\n    ;\n    p.prototype.IsActive = function() {\n        return !!Lu(this.a)\n    }\n    ;\n    p.prototype.GetCollideConnected = function() {\n        return !!kf(this.a)\n    }\n    ;\n    p.prototype.Dump = function() {\n        tw(this.a)\n    }\n    ;\n    function px() {\n        throw "cannot construct a b2RayCastCallback, no constructor in IDL";\n    }\n    px.prototype = Object.create(h.prototype);\n    px.prototype.constructor = px;\n    px.prototype.b = px;\n    px.c = {};\n    b.b2RayCastCallback = px;\n    px.prototype.__destroy__ = function() {\n        zh(this.a)\n    }\n    ;\n    function qx() {\n        throw "cannot construct a b2ContactListener, no constructor in IDL";\n    }\n    qx.prototype = Object.create(h.prototype);\n    qx.prototype.constructor = qx;\n    qx.prototype.b = qx;\n    qx.c = {};\n    b.b2ContactListener = qx;\n    qx.prototype.__destroy__ = function() {\n        So(this.a)\n    }\n    ;\n    function rx() {\n        throw "cannot construct a b2QueryCallback, no constructor in IDL";\n    }\n    rx.prototype = Object.create(h.prototype);\n    rx.prototype.constructor = rx;\n    rx.prototype.b = rx;\n    rx.c = {};\n    b.b2QueryCallback = rx;\n    rx.prototype.__destroy__ = function() {\n        vt(this.a)\n    }\n    ;\n    function t() {\n        this.a = cn();\n        k(t)[this.a] = this\n    }\n    t.prototype = Object.create(h.prototype);\n    t.prototype.constructor = t;\n    t.prototype.b = t;\n    t.c = {};\n    b.b2JointDef = t;\n    t.prototype.get_type = function() {\n        return $t(this.a)\n    }\n    ;\n    t.prototype.set_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ku(c, a)\n    }\n    ;\n    t.prototype.get_userData = function() {\n        return Tm(this.a)\n    }\n    ;\n    t.prototype.set_userData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        lq(c, a)\n    }\n    ;\n    t.prototype.get_bodyA = function() {\n        return n(Fr(this.a), q)\n    }\n    ;\n    t.prototype.set_bodyA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Dk(c, a)\n    }\n    ;\n    t.prototype.get_bodyB = function() {\n        return n(fn(this.a), q)\n    }\n    ;\n    t.prototype.set_bodyB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        qr(c, a)\n    }\n    ;\n    t.prototype.get_collideConnected = function() {\n        return !!gd(this.a)\n    }\n    ;\n    t.prototype.set_collideConnected = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        yk(c, a)\n    }\n    ;\n    t.prototype.__destroy__ = function() {\n        We(this.a)\n    }\n    ;\n    function sx() {\n        throw "cannot construct a b2Shape, no constructor in IDL";\n    }\n    sx.prototype = Object.create(h.prototype);\n    sx.prototype.constructor = sx;\n    sx.prototype.b = sx;\n    sx.c = {};\n    b.b2Shape = sx;\n    sx.prototype.GetType = function() {\n        return Xn(this.a)\n    }\n    ;\n    sx.prototype.GetChildCount = function() {\n        return rw(this.a)\n    }\n    ;\n    sx.prototype.TestPoint = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        return !!Dr(d, a, c)\n    }\n    ;\n    sx.prototype.RayCast = function(a, c, d, e) {\n        var g = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        e && "object" === typeof e && (e = e.a);\n        return !!bd(g, a, c, d, e)\n    }\n    ;\n    sx.prototype.ComputeAABB = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        Yb(e, a, c, d)\n    }\n    ;\n    sx.prototype.ComputeMass = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        Cw(d, a, c)\n    }\n    ;\n    sx.prototype.get_m_type = function() {\n        return lk(this.a)\n    }\n    ;\n    sx.prototype.set_m_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ys(c, a)\n    }\n    ;\n    sx.prototype.get_m_radius = function() {\n        return Nu(this.a)\n    }\n    ;\n    sx.prototype.set_m_radius = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        tf(c, a)\n    }\n    ;\n    sx.prototype.__destroy__ = function() {\n        $l(this.a)\n    }\n    ;\n    function tx() {\n        throw "cannot construct a b2ContactFilter, no constructor in IDL";\n    }\n    tx.prototype = Object.create(h.prototype);\n    tx.prototype.constructor = tx;\n    tx.prototype.b = tx;\n    tx.c = {};\n    b.b2ContactFilter = tx;\n    tx.prototype.__destroy__ = function() {\n        Uf(this.a)\n    }\n    ;\n    function ux() {\n        this.a = Qe();\n        k(ux)[this.a] = this\n    }\n    ux.prototype = Object.create(nx.prototype);\n    ux.prototype.constructor = ux;\n    ux.prototype.b = ux;\n    ux.c = {};\n    b.JSDestructionListener = ux;\n    ux.prototype.SayGoodbyeJoint = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Zl(c, a)\n    }\n    ;\n    ux.prototype.SayGoodbyeFixture = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        eq(c, a)\n    }\n    ;\n    ux.prototype.__destroy__ = function() {\n        Gs(this.a)\n    }\n    ;\n    function vx() {\n        throw "cannot construct a b2ContactImpulse, no constructor in IDL";\n    }\n    vx.prototype = Object.create(h.prototype);\n    vx.prototype.constructor = vx;\n    vx.prototype.b = vx;\n    vx.c = {};\n    b.b2ContactImpulse = vx;\n    vx.prototype.get_count = function() {\n        return En(this.a)\n    }\n    ;\n    vx.prototype.set_count = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Xg(c, a)\n    }\n    ;\n    vx.prototype.__destroy__ = function() {\n        Le(this.a)\n    }\n    ;\n    function u() {\n        throw "cannot construct a b2DistanceJoint, no constructor in IDL";\n    }\n    u.prototype = Object.create(p.prototype);\n    u.prototype.constructor = u;\n    u.prototype.b = u;\n    u.c = {};\n    b.b2DistanceJoint = u;\n    u.prototype.GetLocalAnchorA = function() {\n        return n(ne(this.a), r)\n    }\n    ;\n    u.prototype.GetLocalAnchorB = function() {\n        return n(Xh(this.a), r)\n    }\n    ;\n    u.prototype.SetLength = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Kv(c, a)\n    }\n    ;\n    u.prototype.GetLength = function() {\n        return ek(this.a)\n    }\n    ;\n    u.prototype.SetFrequency = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Vg(c, a)\n    }\n    ;\n    u.prototype.GetFrequency = function() {\n        return Rl(this.a)\n    }\n    ;\n    u.prototype.SetDampingRatio = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ce(c, a)\n    }\n    ;\n    u.prototype.GetDampingRatio = function() {\n        return mh(this.a)\n    }\n    ;\n    u.prototype.GetType = function() {\n        return Ik(this.a)\n    }\n    ;\n    u.prototype.GetBodyA = function() {\n        return n(Hw(this.a), q)\n    }\n    ;\n    u.prototype.GetBodyB = function() {\n        return n(Ue(this.a), q)\n    }\n    ;\n    u.prototype.GetAnchorA = function() {\n        return n(Qc(this.a), r)\n    }\n    ;\n    u.prototype.GetAnchorB = function() {\n        return n(Hg(this.a), r)\n    }\n    ;\n    u.prototype.GetReactionForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(gn(c, a), r)\n    }\n    ;\n    u.prototype.GetReactionTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return Rs(c, a)\n    }\n    ;\n    u.prototype.GetNext = function() {\n        return n(ke(this.a), p)\n    }\n    ;\n    u.prototype.GetUserData = function() {\n        return Kd(this.a)\n    }\n    ;\n    u.prototype.SetUserData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Yf(c, a)\n    }\n    ;\n    u.prototype.IsActive = function() {\n        return !!Dg(this.a)\n    }\n    ;\n    u.prototype.GetCollideConnected = function() {\n        return !!Ft(this.a)\n    }\n    ;\n    u.prototype.__destroy__ = function() {\n        Yk(this.a)\n    }\n    ;\n    function wx(a, c, d) {\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        this.a = void 0 === a ? pg() : void 0 === c ? _emscripten_bind_b2Mat33_b2Mat33_1(a) : void 0 === d ? _emscripten_bind_b2Mat33_b2Mat33_2(a, c) : Yt(a, c, d);\n        k(wx)[this.a] = this\n    }\n    wx.prototype = Object.create(h.prototype);\n    wx.prototype.constructor = wx;\n    wx.prototype.b = wx;\n    wx.c = {};\n    b.b2Mat33 = wx;\n    wx.prototype.SetZero = function() {\n        Fu(this.a)\n    }\n    ;\n    wx.prototype.Solve33 = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(mp(c, a), xx)\n    }\n    ;\n    wx.prototype.Solve22 = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(Sf(c, a), r)\n    }\n    ;\n    wx.prototype.GetInverse22 = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Lm(c, a)\n    }\n    ;\n    wx.prototype.GetSymInverse33 = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        sl(c, a)\n    }\n    ;\n    wx.prototype.get_ex = function() {\n        return n(Rg(this.a), xx)\n    }\n    ;\n    wx.prototype.set_ex = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Nt(c, a)\n    }\n    ;\n    wx.prototype.get_ey = function() {\n        return n(Ic(this.a), xx)\n    }\n    ;\n    wx.prototype.set_ey = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Lc(c, a)\n    }\n    ;\n    wx.prototype.get_ez = function() {\n        return n(cf(this.a), xx)\n    }\n    ;\n    wx.prototype.set_ez = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ou(c, a)\n    }\n    ;\n    wx.prototype.__destroy__ = function() {\n        dd(this.a)\n    }\n    ;\n    function v() {\n        throw "cannot construct a b2Fixture, no constructor in IDL";\n    }\n    v.prototype = Object.create(h.prototype);\n    v.prototype.constructor = v;\n    v.prototype.b = v;\n    v.c = {};\n    b.b2Fixture = v;\n    v.prototype.GetType = function() {\n        return Kk(this.a)\n    }\n    ;\n    v.prototype.GetShape = function() {\n        return n(gv(this.a), sx)\n    }\n    ;\n    v.prototype.SetSensor = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        gw(c, a)\n    }\n    ;\n    v.prototype.IsSensor = function() {\n        return !!xv(this.a)\n    }\n    ;\n    v.prototype.SetFilterData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        iq(c, a)\n    }\n    ;\n    v.prototype.GetFilterData = function() {\n        return n(dt(this.a), yx)\n    }\n    ;\n    v.prototype.Refilter = function() {\n        ro(this.a)\n    }\n    ;\n    v.prototype.GetBody = function() {\n        return n(Wg(this.a), q)\n    }\n    ;\n    v.prototype.GetNext = function() {\n        return n(Au(this.a), v)\n    }\n    ;\n    v.prototype.GetUserData = function() {\n        return Fl(this.a)\n    }\n    ;\n    v.prototype.SetUserData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        $i(c, a)\n    }\n    ;\n    v.prototype.TestPoint = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return !!rl(c, a)\n    }\n    ;\n    v.prototype.RayCast = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        return !!Ck(e, a, c, d)\n    }\n    ;\n    v.prototype.GetMassData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Xw(c, a)\n    }\n    ;\n    v.prototype.SetDensity = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ch(c, a)\n    }\n    ;\n    v.prototype.GetDensity = function() {\n        return Cp(this.a)\n    }\n    ;\n    v.prototype.GetFriction = function() {\n        return zu(this.a)\n    }\n    ;\n    v.prototype.SetFriction = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Eo(c, a)\n    }\n    ;\n    v.prototype.GetRestitution = function() {\n        return pe(this.a)\n    }\n    ;\n    v.prototype.SetRestitution = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Kt(c, a)\n    }\n    ;\n    v.prototype.GetAABB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(qn(c, a), zx)\n    }\n    ;\n    v.prototype.Dump = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Qm(c, a)\n    }\n    ;\n    v.prototype.__destroy__ = function() {\n        pc(this.a)\n    }\n    ;\n    function yx() {\n        this.a = Od();\n        k(yx)[this.a] = this\n    }\n    yx.prototype = Object.create(h.prototype);\n    yx.prototype.constructor = yx;\n    yx.prototype.b = yx;\n    yx.c = {};\n    b.b2Filter = yx;\n    yx.prototype.get_categoryBits = function() {\n        return Bm(this.a)\n    }\n    ;\n    yx.prototype.set_categoryBits = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Bl(c, a)\n    }\n    ;\n    yx.prototype.get_maskBits = function() {\n        return Mo(this.a)\n    }\n    ;\n    yx.prototype.set_maskBits = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Yr(c, a)\n    }\n    ;\n    yx.prototype.get_groupIndex = function() {\n        return Ye(this.a)\n    }\n    ;\n    yx.prototype.set_groupIndex = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        bn(c, a)\n    }\n    ;\n    yx.prototype.__destroy__ = function() {\n        Mn(this.a)\n    }\n    ;\n    function Ax() {\n        this.a = id();\n        k(Ax)[this.a] = this\n    }\n    Ax.prototype = Object.create(rx.prototype);\n    Ax.prototype.constructor = Ax;\n    Ax.prototype.b = Ax;\n    Ax.c = {};\n    b.JSQueryCallback = Ax;\n    Ax.prototype.ReportFixture = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return !!au(c, a)\n    }\n    ;\n    Ax.prototype.__destroy__ = function() {\n        qo(this.a)\n    }\n    ;\n    function w() {\n        throw "cannot construct a b2MouseJoint, no constructor in IDL";\n    }\n    w.prototype = Object.create(p.prototype);\n    w.prototype.constructor = w;\n    w.prototype.b = w;\n    w.c = {};\n    b.b2MouseJoint = w;\n    w.prototype.SetTarget = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        jg(c, a)\n    }\n    ;\n    w.prototype.GetTarget = function() {\n        return n(po(this.a), r)\n    }\n    ;\n    w.prototype.SetMaxForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        jq(c, a)\n    }\n    ;\n    w.prototype.GetMaxForce = function() {\n        return ig(this.a)\n    }\n    ;\n    w.prototype.SetFrequency = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        xl(c, a)\n    }\n    ;\n    w.prototype.GetFrequency = function() {\n        return Xo(this.a)\n    }\n    ;\n    w.prototype.SetDampingRatio = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        mk(c, a)\n    }\n    ;\n    w.prototype.GetDampingRatio = function() {\n        return Lr(this.a)\n    }\n    ;\n    w.prototype.GetType = function() {\n        return oo(this.a)\n    }\n    ;\n    w.prototype.GetBodyA = function() {\n        return n(Bo(this.a), q)\n    }\n    ;\n    w.prototype.GetBodyB = function() {\n        return n(Ti(this.a), q)\n    }\n    ;\n    w.prototype.GetAnchorA = function() {\n        return n(eu(this.a), r)\n    }\n    ;\n    w.prototype.GetAnchorB = function() {\n        return n(Jq(this.a), r)\n    }\n    ;\n    w.prototype.GetReactionForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(tv(c, a), r)\n    }\n    ;\n    w.prototype.GetReactionTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return Sn(c, a)\n    }\n    ;\n    w.prototype.GetNext = function() {\n        return n(li(this.a), p)\n    }\n    ;\n    w.prototype.GetUserData = function() {\n        return sq(this.a)\n    }\n    ;\n    w.prototype.SetUserData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        xt(c, a)\n    }\n    ;\n    w.prototype.IsActive = function() {\n        return !!$b(this.a)\n    }\n    ;\n    w.prototype.GetCollideConnected = function() {\n        return !!Jc(this.a)\n    }\n    ;\n    w.prototype.__destroy__ = function() {\n        Pv(this.a)\n    }\n    ;\n    function Bx(a) {\n        a && "object" === typeof a && (a = a.a);\n        this.a = void 0 === a ? ko() : lo(a);\n        k(Bx)[this.a] = this\n    }\n    Bx.prototype = Object.create(h.prototype);\n    Bx.prototype.constructor = Bx;\n    Bx.prototype.b = Bx;\n    Bx.c = {};\n    b.b2Rot = Bx;\n    Bx.prototype.Set = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Of(c, a)\n    }\n    ;\n    Bx.prototype.SetIdentity = function() {\n        pq(this.a)\n    }\n    ;\n    Bx.prototype.GetAngle = function() {\n        return up(this.a)\n    }\n    ;\n    Bx.prototype.GetXAxis = function() {\n        return n(og(this.a), r)\n    }\n    ;\n    Bx.prototype.GetYAxis = function() {\n        return n(er(this.a), r)\n    }\n    ;\n    Bx.prototype.get_s = function() {\n        return Hp(this.a)\n    }\n    ;\n    Bx.prototype.set_s = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ej(c, a)\n    }\n    ;\n    Bx.prototype.get_c = function() {\n        return gq(this.a)\n    }\n    ;\n    Bx.prototype.set_c = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        dn(c, a)\n    }\n    ;\n    Bx.prototype.__destroy__ = function() {\n        Lo(this.a)\n    }\n    ;\n    function x() {\n        throw "cannot construct a b2MotorJoint, no constructor in IDL";\n    }\n    x.prototype = Object.create(p.prototype);\n    x.prototype.constructor = x;\n    x.prototype.b = x;\n    x.c = {};\n    b.b2MotorJoint = x;\n    x.prototype.SetLinearOffset = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Cv(c, a)\n    }\n    ;\n    x.prototype.GetLinearOffset = function() {\n        return n(yp(this.a), r)\n    }\n    ;\n    x.prototype.SetAngularOffset = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        xp(c, a)\n    }\n    ;\n    x.prototype.GetAngularOffset = function() {\n        return lv(this.a)\n    }\n    ;\n    x.prototype.SetMaxForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Wo(c, a)\n    }\n    ;\n    x.prototype.GetMaxForce = function() {\n        return lj(this.a)\n    }\n    ;\n    x.prototype.SetMaxTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        td(c, a)\n    }\n    ;\n    x.prototype.GetMaxTorque = function() {\n        return Pr(this.a)\n    }\n    ;\n    x.prototype.SetCorrectionFactor = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ad(c, a)\n    }\n    ;\n    x.prototype.GetCorrectionFactor = function() {\n        return cq(this.a)\n    }\n    ;\n    x.prototype.GetType = function() {\n        return Oq(this.a)\n    }\n    ;\n    x.prototype.GetBodyA = function() {\n        return n(Fh(this.a), q)\n    }\n    ;\n    x.prototype.GetBodyB = function() {\n        return n(Dh(this.a), q)\n    }\n    ;\n    x.prototype.GetAnchorA = function() {\n        return n(Bp(this.a), r)\n    }\n    ;\n    x.prototype.GetAnchorB = function() {\n        return n(fv(this.a), r)\n    }\n    ;\n    x.prototype.GetReactionForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(tp(c, a), r)\n    }\n    ;\n    x.prototype.GetReactionTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return lf(c, a)\n    }\n    ;\n    x.prototype.GetNext = function() {\n        return n(aw(this.a), p)\n    }\n    ;\n    x.prototype.GetUserData = function() {\n        return jk(this.a)\n    }\n    ;\n    x.prototype.SetUserData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Bh(c, a)\n    }\n    ;\n    x.prototype.IsActive = function() {\n        return !!Rn(this.a)\n    }\n    ;\n    x.prototype.GetCollideConnected = function() {\n        return !!Ae(this.a)\n    }\n    ;\n    x.prototype.__destroy__ = function() {\n        zk(this.a)\n    }\n    ;\n    function y() {\n        throw "cannot construct a b2Profile, no constructor in IDL";\n    }\n    y.prototype = Object.create(h.prototype);\n    y.prototype.constructor = y;\n    y.prototype.b = y;\n    y.c = {};\n    b.b2Profile = y;\n    y.prototype.get_step = function() {\n        return bk(this.a)\n    }\n    ;\n    y.prototype.set_step = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ei(c, a)\n    }\n    ;\n    y.prototype.get_collide = function() {\n        return lt(this.a)\n    }\n    ;\n    y.prototype.set_collide = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Av(c, a)\n    }\n    ;\n    y.prototype.get_solve = function() {\n        return dq(this.a)\n    }\n    ;\n    y.prototype.set_solve = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Vs(c, a)\n    }\n    ;\n    y.prototype.get_solveInit = function() {\n        return wv(this.a)\n    }\n    ;\n    y.prototype.set_solveInit = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Nk(c, a)\n    }\n    ;\n    y.prototype.get_solveVelocity = function() {\n        return Rv(this.a)\n    }\n    ;\n    y.prototype.set_solveVelocity = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        $m(c, a)\n    }\n    ;\n    y.prototype.get_solvePosition = function() {\n        return ad(this.a)\n    }\n    ;\n    y.prototype.set_solvePosition = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Tf(c, a)\n    }\n    ;\n    y.prototype.get_broadphase = function() {\n        return Mc(this.a)\n    }\n    ;\n    y.prototype.set_broadphase = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Cn(c, a)\n    }\n    ;\n    y.prototype.get_solveTOI = function() {\n        return Fg(this.a)\n    }\n    ;\n    y.prototype.set_solveTOI = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Jh(c, a)\n    }\n    ;\n    y.prototype.__destroy__ = function() {\n        Tg(this.a)\n    }\n    ;\n    function Cx() {\n        throw "cannot construct a VoidPtr, no constructor in IDL";\n    }\n    Cx.prototype = Object.create(h.prototype);\n    Cx.prototype.constructor = Cx;\n    Cx.prototype.b = Cx;\n    Cx.c = {};\n    b.VoidPtr = Cx;\n    Cx.prototype.__destroy__ = function() {\n        hp(this.a)\n    }\n    ;\n    function z() {\n        this.a = nw();\n        k(z)[this.a] = this\n    }\n    z.prototype = Object.create(h.prototype);\n    z.prototype.constructor = z;\n    z.prototype.b = z;\n    z.c = {};\n    b.b2BodyDef = z;\n    z.prototype.get_type = function() {\n        return Km(this.a)\n    }\n    ;\n    z.prototype.set_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        vc(c, a)\n    }\n    ;\n    z.prototype.get_position = function() {\n        return n(Bc(this.a), r)\n    }\n    ;\n    z.prototype.set_position = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        md(c, a)\n    }\n    ;\n    z.prototype.get_angle = function() {\n        return Tt(this.a)\n    }\n    ;\n    z.prototype.set_angle = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ll(c, a)\n    }\n    ;\n    z.prototype.get_linearVelocity = function() {\n        return n(av(this.a), r)\n    }\n    ;\n    z.prototype.set_linearVelocity = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        xk(c, a)\n    }\n    ;\n    z.prototype.get_angularVelocity = function() {\n        return ee(this.a)\n    }\n    ;\n    z.prototype.set_angularVelocity = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        um(c, a)\n    }\n    ;\n    z.prototype.get_linearDamping = function() {\n        return Yj(this.a)\n    }\n    ;\n    z.prototype.set_linearDamping = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Br(c, a)\n    }\n    ;\n    z.prototype.get_angularDamping = function() {\n        return Rq(this.a)\n    }\n    ;\n    z.prototype.set_angularDamping = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Wp(c, a)\n    }\n    ;\n    z.prototype.get_allowSleep = function() {\n        return !!Pi(this.a)\n    }\n    ;\n    z.prototype.set_allowSleep = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Bi(c, a)\n    }\n    ;\n    z.prototype.get_awake = function() {\n        return !!Co(this.a)\n    }\n    ;\n    z.prototype.set_awake = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        zl(c, a)\n    }\n    ;\n    z.prototype.get_fixedRotation = function() {\n        return !!On(this.a)\n    }\n    ;\n    z.prototype.set_fixedRotation = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        qk(c, a)\n    }\n    ;\n    z.prototype.get_bullet = function() {\n        return !!af(this.a)\n    }\n    ;\n    z.prototype.set_bullet = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Um(c, a)\n    }\n    ;\n    z.prototype.get_active = function() {\n        return !!cj(this.a)\n    }\n    ;\n    z.prototype.set_active = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Oj(c, a)\n    }\n    ;\n    z.prototype.get_userData = function() {\n        return Bv(this.a)\n    }\n    ;\n    z.prototype.set_userData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ir(c, a)\n    }\n    ;\n    z.prototype.get_gravityScale = function() {\n        return of(this.a)\n    }\n    ;\n    z.prototype.set_gravityScale = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Yd(c, a)\n    }\n    ;\n    z.prototype.__destroy__ = function() {\n        ns(this.a)\n    }\n    ;\n    function Dx() {\n        this.a = Bf();\n        k(Dx)[this.a] = this\n    }\n    Dx.prototype = Object.create(px.prototype);\n    Dx.prototype.constructor = Dx;\n    Dx.prototype.b = Dx;\n    Dx.c = {};\n    b.JSRayCastCallback = Dx;\n    Dx.prototype.ReportFixture = function(a, c, d, e) {\n        var g = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        e && "object" === typeof e && (e = e.a);\n        return Ke(g, a, c, d, e)\n    }\n    ;\n    Dx.prototype.__destroy__ = function() {\n        Ro(this.a)\n    }\n    ;\n    function Ex() {\n        throw "cannot construct a b2ContactFeature, no constructor in IDL";\n    }\n    Ex.prototype = Object.create(h.prototype);\n    Ex.prototype.constructor = Ex;\n    Ex.prototype.b = Ex;\n    Ex.c = {};\n    b.b2ContactFeature = Ex;\n    Ex.prototype.get_indexA = function() {\n        return Lg(this.a)\n    }\n    ;\n    Ex.prototype.set_indexA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        vv(c, a)\n    }\n    ;\n    Ex.prototype.get_indexB = function() {\n        return El(this.a)\n    }\n    ;\n    Ex.prototype.set_indexB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Zq(c, a)\n    }\n    ;\n    Ex.prototype.get_typeA = function() {\n        return Hl(this.a)\n    }\n    ;\n    Ex.prototype.set_typeA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Pm(c, a)\n    }\n    ;\n    Ex.prototype.get_typeB = function() {\n        return rp(this.a)\n    }\n    ;\n    Ex.prototype.set_typeB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Nr(c, a)\n    }\n    ;\n    Ex.prototype.__destroy__ = function() {\n        Op(this.a)\n    }\n    ;\n    function r(a, c) {\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        this.a = void 0 === a ? Gg() : void 0 === c ? _emscripten_bind_b2Vec2_b2Vec2_1(a) : rk(a, c);\n        k(r)[this.a] = this\n    }\n    r.prototype = Object.create(h.prototype);\n    r.prototype.constructor = r;\n    r.prototype.b = r;\n    r.c = {};\n    b.b2Vec2 = r;\n    r.prototype.SetZero = function() {\n        nr(this.a)\n    }\n    ;\n    r.prototype.Set = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        Ep(d, a, c)\n    }\n    ;\n    r.prototype.op_add = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        hf(c, a)\n    }\n    ;\n    r.prototype.op_sub = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Jg(c, a)\n    }\n    ;\n    r.prototype.op_mul = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Hi(c, a)\n    }\n    ;\n    r.prototype.Length = function() {\n        return mr(this.a)\n    }\n    ;\n    r.prototype.LengthSquared = function() {\n        return yw(this.a)\n    }\n    ;\n    r.prototype.Normalize = function() {\n        return xf(this.a)\n    }\n    ;\n    r.prototype.IsValid = function() {\n        return !!ap(this.a)\n    }\n    ;\n    r.prototype.Skew = function() {\n        return n(Kr(this.a), r)\n    }\n    ;\n    r.prototype.get_x = function() {\n        return xi(this.a)\n    }\n    ;\n    r.prototype.set_x = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Uu(c, a)\n    }\n    ;\n    r.prototype.get_y = function() {\n        return Al(this.a)\n    }\n    ;\n    r.prototype.set_y = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ks(c, a)\n    }\n    ;\n    r.prototype.__destroy__ = function() {\n        Xu(this.a)\n    }\n    ;\n    function xx(a, c, d) {\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        this.a = void 0 === a ? Wk() : void 0 === c ? _emscripten_bind_b2Vec3_b2Vec3_1(a) : void 0 === d ? _emscripten_bind_b2Vec3_b2Vec3_2(a, c) : gl(a, c, d);\n        k(xx)[this.a] = this\n    }\n    xx.prototype = Object.create(h.prototype);\n    xx.prototype.constructor = xx;\n    xx.prototype.b = xx;\n    xx.c = {};\n    b.b2Vec3 = xx;\n    xx.prototype.SetZero = function() {\n        pf(this.a)\n    }\n    ;\n    xx.prototype.Set = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        pj(e, a, c, d)\n    }\n    ;\n    xx.prototype.op_add = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        gg(c, a)\n    }\n    ;\n    xx.prototype.op_sub = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Vn(c, a)\n    }\n    ;\n    xx.prototype.op_mul = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        iv(c, a)\n    }\n    ;\n    xx.prototype.get_x = function() {\n        return Xc(this.a)\n    }\n    ;\n    xx.prototype.set_x = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Xl(c, a)\n    }\n    ;\n    xx.prototype.get_y = function() {\n        return Zt(this.a)\n    }\n    ;\n    xx.prototype.set_y = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Vp(c, a)\n    }\n    ;\n    xx.prototype.get_z = function() {\n        return Am(this.a)\n    }\n    ;\n    xx.prototype.set_z = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Pl(c, a)\n    }\n    ;\n    xx.prototype.__destroy__ = function() {\n        gh(this.a)\n    }\n    ;\n    function zx() {\n        this.a = Do();\n        k(zx)[this.a] = this\n    }\n    zx.prototype = Object.create(h.prototype);\n    zx.prototype.constructor = zx;\n    zx.prototype.b = zx;\n    zx.c = {};\n    b.b2AABB = zx;\n    zx.prototype.IsValid = function() {\n        return !!Yn(this.a)\n    }\n    ;\n    zx.prototype.GetCenter = function() {\n        return n(Lh(this.a), r)\n    }\n    ;\n    zx.prototype.GetExtents = function() {\n        return n(eh(this.a), r)\n    }\n    ;\n    zx.prototype.GetPerimeter = function() {\n        return Pg(this.a)\n    }\n    ;\n    zx.prototype.Combine = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        void 0 === c ? Xp(d, a) : Ni(d, a, c)\n    }\n    ;\n    zx.prototype.Contains = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return !!je(c, a)\n    }\n    ;\n    zx.prototype.RayCast = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        return !!ck(d, a, c)\n    }\n    ;\n    zx.prototype.get_lowerBound = function() {\n        return n(ae(this.a), r)\n    }\n    ;\n    zx.prototype.set_lowerBound = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        hq(c, a)\n    }\n    ;\n    zx.prototype.get_upperBound = function() {\n        return n(se(this.a), r)\n    }\n    ;\n    zx.prototype.set_upperBound = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Je(c, a)\n    }\n    ;\n    zx.prototype.__destroy__ = function() {\n        Jn(this.a)\n    }\n    ;\n    function Fx() {\n        this.a = Ij();\n        k(Fx)[this.a] = this\n    }\n    Fx.prototype = Object.create(h.prototype);\n    Fx.prototype.constructor = Fx;\n    Fx.prototype.b = Fx;\n    Fx.c = {};\n    b.b2FixtureDef = Fx;\n    Fx.prototype.get_shape = function() {\n        return n(Ut(this.a), sx)\n    }\n    ;\n    Fx.prototype.set_shape = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Yg(c, a)\n    }\n    ;\n    Fx.prototype.get_userData = function() {\n        return Jd(this.a)\n    }\n    ;\n    Fx.prototype.set_userData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        mc(c, a)\n    }\n    ;\n    Fx.prototype.get_friction = function() {\n        return st(this.a)\n    }\n    ;\n    Fx.prototype.set_friction = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        bm(c, a)\n    }\n    ;\n    Fx.prototype.get_restitution = function() {\n        return Jk(this.a)\n    }\n    ;\n    Fx.prototype.set_restitution = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Gc(c, a)\n    }\n    ;\n    Fx.prototype.get_density = function() {\n        return Bd(this.a)\n    }\n    ;\n    Fx.prototype.set_density = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ws(c, a)\n    }\n    ;\n    Fx.prototype.get_isSensor = function() {\n        return !!If(this.a)\n    }\n    ;\n    Fx.prototype.set_isSensor = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Qj(c, a)\n    }\n    ;\n    Fx.prototype.get_filter = function() {\n        return n(jc(this.a), yx)\n    }\n    ;\n    Fx.prototype.set_filter = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        vh(c, a)\n    }\n    ;\n    Fx.prototype.__destroy__ = function() {\n        Ov(this.a)\n    }\n    ;\n    function A() {\n        this.a = Tk();\n        k(A)[this.a] = this\n    }\n    A.prototype = Object.create(t.prototype);\n    A.prototype.constructor = A;\n    A.prototype.b = A;\n    A.c = {};\n    b.b2FrictionJointDef = A;\n    A.prototype.Initialize = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        Sr(e, a, c, d)\n    }\n    ;\n    A.prototype.get_localAnchorA = function() {\n        return n(Ze(this.a), r)\n    }\n    ;\n    A.prototype.set_localAnchorA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        zf(c, a)\n    }\n    ;\n    A.prototype.get_localAnchorB = function() {\n        return n(Me(this.a), r)\n    }\n    ;\n    A.prototype.set_localAnchorB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        rj(c, a)\n    }\n    ;\n    A.prototype.get_maxForce = function() {\n        return tm(this.a)\n    }\n    ;\n    A.prototype.set_maxForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Im(c, a)\n    }\n    ;\n    A.prototype.get_maxTorque = function() {\n        return hd(this.a)\n    }\n    ;\n    A.prototype.set_maxTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ps(c, a)\n    }\n    ;\n    A.prototype.get_type = function() {\n        return kc(this.a)\n    }\n    ;\n    A.prototype.set_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Rr(c, a)\n    }\n    ;\n    A.prototype.get_userData = function() {\n        return yh(this.a)\n    }\n    ;\n    A.prototype.set_userData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Zb(c, a)\n    }\n    ;\n    A.prototype.get_bodyA = function() {\n        return n(qu(this.a), q)\n    }\n    ;\n    A.prototype.set_bodyA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        zw(c, a)\n    }\n    ;\n    A.prototype.get_bodyB = function() {\n        return n(mf(this.a), q)\n    }\n    ;\n    A.prototype.set_bodyB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Iq(c, a)\n    }\n    ;\n    A.prototype.get_collideConnected = function() {\n        return !!Tr(this.a)\n    }\n    ;\n    A.prototype.set_collideConnected = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ld(c, a)\n    }\n    ;\n    A.prototype.__destroy__ = function() {\n        Nh(this.a)\n    }\n    ;\n    function Gx() {\n        this.a = wq();\n        k(Gx)[this.a] = this\n    }\n    Gx.prototype = Object.create(h.prototype);\n    Gx.prototype.constructor = Gx;\n    Gx.prototype.b = Gx;\n    Gx.c = {};\n    b.b2Manifold = Gx;\n    Gx.prototype.get_localNormal = function() {\n        return n(Vk(this.a), r)\n    }\n    ;\n    Gx.prototype.set_localNormal = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Er(c, a)\n    }\n    ;\n    Gx.prototype.get_localPoint = function() {\n        return n(ni(this.a), r)\n    }\n    ;\n    Gx.prototype.set_localPoint = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Sm(c, a)\n    }\n    ;\n    Gx.prototype.get_type = function() {\n        return sk(this.a)\n    }\n    ;\n    Gx.prototype.set_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        fl(c, a)\n    }\n    ;\n    Gx.prototype.get_pointCount = function() {\n        return Ef(this.a)\n    }\n    ;\n    Gx.prototype.set_pointCount = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        $k(c, a)\n    }\n    ;\n    Gx.prototype.__destroy__ = function() {\n        ug(this.a)\n    }\n    ;\n    function Hx() {\n        this.a = Dc();\n        k(Hx)[this.a] = this\n    }\n    Hx.prototype = Object.create(h.prototype);\n    Hx.prototype.constructor = Hx;\n    Hx.prototype.b = Hx;\n    Hx.c = {};\n    b.b2WorldManifold = Hx;\n    Hx.prototype.Initialize = function(a, c, d, e, g) {\n        var l = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        e && "object" === typeof e && (e = e.a);\n        g && "object" === typeof g && (g = g.a);\n        Ll(l, a, c, d, e, g)\n    }\n    ;\n    Hx.prototype.get_normal = function() {\n        return n(gu(this.a), r)\n    }\n    ;\n    Hx.prototype.set_normal = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ok(c, a)\n    }\n    ;\n    Hx.prototype.get_points = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(dl(c, a), r)\n    }\n    ;\n    Hx.prototype.set_points = function(a, c) {\n        var d = this.a;\n        mx();\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        Kj(d, a, c)\n    }\n    ;\n    Hx.prototype.get_separations = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return pw(c, a)\n    }\n    ;\n    Hx.prototype.set_separations = function(a, c) {\n        var d = this.a;\n        mx();\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        hk(d, a, c)\n    }\n    ;\n    Hx.prototype.__destroy__ = function() {\n        Vm(this.a)\n    }\n    ;\n    function B() {\n        this.a = bj();\n        k(B)[this.a] = this\n    }\n    B.prototype = Object.create(t.prototype);\n    B.prototype.constructor = B;\n    B.prototype.b = B;\n    B.c = {};\n    b.b2PrismaticJointDef = B;\n    B.prototype.Initialize = function(a, c, d, e) {\n        var g = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        e && "object" === typeof e && (e = e.a);\n        Jf(g, a, c, d, e)\n    }\n    ;\n    B.prototype.get_localAnchorA = function() {\n        return n(Ii(this.a), r)\n    }\n    ;\n    B.prototype.set_localAnchorA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        tt(c, a)\n    }\n    ;\n    B.prototype.get_localAnchorB = function() {\n        return n(Fe(this.a), r)\n    }\n    ;\n    B.prototype.set_localAnchorB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        To(c, a)\n    }\n    ;\n    B.prototype.get_localAxisA = function() {\n        return n(Iu(this.a), r)\n    }\n    ;\n    B.prototype.set_localAxisA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Pu(c, a)\n    }\n    ;\n    B.prototype.get_referenceAngle = function() {\n        return ce(this.a)\n    }\n    ;\n    B.prototype.set_referenceAngle = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        th(c, a)\n    }\n    ;\n    B.prototype.get_enableLimit = function() {\n        return !!bt(this.a)\n    }\n    ;\n    B.prototype.set_enableLimit = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ql(c, a)\n    }\n    ;\n    B.prototype.get_lowerTranslation = function() {\n        return Md(this.a)\n    }\n    ;\n    B.prototype.set_lowerTranslation = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        kd(c, a)\n    }\n    ;\n    B.prototype.get_upperTranslation = function() {\n        return Dd(this.a)\n    }\n    ;\n    B.prototype.set_upperTranslation = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        wl(c, a)\n    }\n    ;\n    B.prototype.get_enableMotor = function() {\n        return !!Es(this.a)\n    }\n    ;\n    B.prototype.set_enableMotor = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Jr(c, a)\n    }\n    ;\n    B.prototype.get_maxMotorForce = function() {\n        return Gw(this.a)\n    }\n    ;\n    B.prototype.set_maxMotorForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        qv(c, a)\n    }\n    ;\n    B.prototype.get_motorSpeed = function() {\n        return Wb(this.a)\n    }\n    ;\n    B.prototype.set_motorSpeed = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Pn(c, a)\n    }\n    ;\n    B.prototype.get_type = function() {\n        return Mw(this.a)\n    }\n    ;\n    B.prototype.set_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Kh(c, a)\n    }\n    ;\n    B.prototype.get_userData = function() {\n        return kj(this.a)\n    }\n    ;\n    B.prototype.set_userData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Qr(c, a)\n    }\n    ;\n    B.prototype.get_bodyA = function() {\n        return n(es(this.a), q)\n    }\n    ;\n    B.prototype.set_bodyA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        bp(c, a)\n    }\n    ;\n    B.prototype.get_bodyB = function() {\n        return n(Pk(this.a), q)\n    }\n    ;\n    B.prototype.set_bodyB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Sk(c, a)\n    }\n    ;\n    B.prototype.get_collideConnected = function() {\n        return !!Sl(this.a)\n    }\n    ;\n    B.prototype.set_collideConnected = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        rn(c, a)\n    }\n    ;\n    B.prototype.__destroy__ = function() {\n        ge(this.a)\n    }\n    ;\n    function C(a) {\n        a && "object" === typeof a && (a = a.a);\n        this.a = Zh(a);\n        k(C)[this.a] = this\n    }\n    C.prototype = Object.create(h.prototype);\n    C.prototype.constructor = C;\n    C.prototype.b = C;\n    C.c = {};\n    b.b2World = C;\n    C.prototype.SetDestructionListener = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Gv(c, a)\n    }\n    ;\n    C.prototype.SetContactFilter = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        uw(c, a)\n    }\n    ;\n    C.prototype.SetContactListener = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        wd(c, a)\n    }\n    ;\n    C.prototype.SetDebugDraw = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        uf(c, a)\n    }\n    ;\n    C.prototype.CreateBody = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(Go(c, a), q)\n    }\n    ;\n    C.prototype.DestroyBody = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        $c(c, a)\n    }\n    ;\n    C.prototype.CreateJoint = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(xg(c, a), p)\n    }\n    ;\n    C.prototype.DestroyJoint = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        pr(c, a)\n    }\n    ;\n    C.prototype.Step = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        Zj(e, a, c, d)\n    }\n    ;\n    C.prototype.ClearForces = function() {\n        fh(this.a)\n    }\n    ;\n    C.prototype.DrawDebugData = function() {\n        Ym(this.a)\n    }\n    ;\n    C.prototype.QueryAABB = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        zv(d, a, c)\n    }\n    ;\n    C.prototype.RayCast = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        it(e, a, c, d)\n    }\n    ;\n    C.prototype.GetBodyList = function() {\n        return n(et(this.a), q)\n    }\n    ;\n    C.prototype.GetJointList = function() {\n        return n(yr(this.a), p)\n    }\n    ;\n    C.prototype.GetContactList = function() {\n        return n(nu(this.a), E)\n    }\n    ;\n    C.prototype.SetAllowSleeping = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        vp(c, a)\n    }\n    ;\n    C.prototype.GetAllowSleeping = function() {\n        return !!fi(this.a)\n    }\n    ;\n    C.prototype.SetWarmStarting = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        rc(c, a)\n    }\n    ;\n    C.prototype.GetWarmStarting = function() {\n        return !!cp(this.a)\n    }\n    ;\n    C.prototype.SetContinuousPhysics = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Em(c, a)\n    }\n    ;\n    C.prototype.GetContinuousPhysics = function() {\n        return !!Tv(this.a)\n    }\n    ;\n    C.prototype.SetSubStepping = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        gf(c, a)\n    }\n    ;\n    C.prototype.GetSubStepping = function() {\n        return !!dr(this.a)\n    }\n    ;\n    C.prototype.GetProxyCount = function() {\n        return sd(this.a)\n    }\n    ;\n    C.prototype.GetBodyCount = function() {\n        return em(this.a)\n    }\n    ;\n    C.prototype.GetJointCount = function() {\n        return Fn(this.a)\n    }\n    ;\n    C.prototype.GetContactCount = function() {\n        return Pq(this.a)\n    }\n    ;\n    C.prototype.GetTreeHeight = function() {\n        return as(this.a)\n    }\n    ;\n    C.prototype.GetTreeBalance = function() {\n        return fc(this.a)\n    }\n    ;\n    C.prototype.GetTreeQuality = function() {\n        return Xd(this.a)\n    }\n    ;\n    C.prototype.SetGravity = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        It(c, a)\n    }\n    ;\n    C.prototype.GetGravity = function() {\n        return n(Kc(this.a), r)\n    }\n    ;\n    C.prototype.IsLocked = function() {\n        return !!ac(this.a)\n    }\n    ;\n    C.prototype.SetAutoClearForces = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        jd(c, a)\n    }\n    ;\n    C.prototype.GetAutoClearForces = function() {\n        return !!nk(this.a)\n    }\n    ;\n    C.prototype.GetProfile = function() {\n        return n(hu(this.a), y)\n    }\n    ;\n    C.prototype.Dump = function() {\n        Ss(this.a)\n    }\n    ;\n    C.prototype.__destroy__ = function() {\n        eo(this.a)\n    }\n    ;\n    function F() {\n        throw "cannot construct a b2PrismaticJoint, no constructor in IDL";\n    }\n    F.prototype = Object.create(p.prototype);\n    F.prototype.constructor = F;\n    F.prototype.b = F;\n    F.c = {};\n    b.b2PrismaticJoint = F;\n    F.prototype.GetLocalAnchorA = function() {\n        return n(Jl(this.a), r)\n    }\n    ;\n    F.prototype.GetLocalAnchorB = function() {\n        return n(op(this.a), r)\n    }\n    ;\n    F.prototype.GetLocalAxisA = function() {\n        return n(Ch(this.a), r)\n    }\n    ;\n    F.prototype.GetReferenceAngle = function() {\n        return jl(this.a)\n    }\n    ;\n    F.prototype.GetJointTranslation = function() {\n        return bg(this.a)\n    }\n    ;\n    F.prototype.GetJointSpeed = function() {\n        return hn(this.a)\n    }\n    ;\n    F.prototype.IsLimitEnabled = function() {\n        return !!$h(this.a)\n    }\n    ;\n    F.prototype.EnableLimit = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        sm(c, a)\n    }\n    ;\n    F.prototype.GetLowerLimit = function() {\n        return $d(this.a)\n    }\n    ;\n    F.prototype.GetUpperLimit = function() {\n        return gk(this.a)\n    }\n    ;\n    F.prototype.SetLimits = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        Oc(d, a, c)\n    }\n    ;\n    F.prototype.IsMotorEnabled = function() {\n        return !!al(this.a)\n    }\n    ;\n    F.prototype.EnableMotor = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        vl(c, a)\n    }\n    ;\n    F.prototype.SetMotorSpeed = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ls(c, a)\n    }\n    ;\n    F.prototype.GetMotorSpeed = function() {\n        return eg(this.a)\n    }\n    ;\n    F.prototype.SetMaxMotorForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Sw(c, a)\n    }\n    ;\n    F.prototype.GetMaxMotorForce = function() {\n        return $p(this.a)\n    }\n    ;\n    F.prototype.GetMotorForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return si(c, a)\n    }\n    ;\n    F.prototype.GetType = function() {\n        return oe(this.a)\n    }\n    ;\n    F.prototype.GetBodyA = function() {\n        return n(Zp(this.a), q)\n    }\n    ;\n    F.prototype.GetBodyB = function() {\n        return n(Qt(this.a), q)\n    }\n    ;\n    F.prototype.GetAnchorA = function() {\n        return n(Zk(this.a), r)\n    }\n    ;\n    F.prototype.GetAnchorB = function() {\n        return n(im(this.a), r)\n    }\n    ;\n    F.prototype.GetReactionForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(Oh(c, a), r)\n    }\n    ;\n    F.prototype.GetReactionTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return Ag(c, a)\n    }\n    ;\n    F.prototype.GetNext = function() {\n        return n(cs(this.a), p)\n    }\n    ;\n    F.prototype.GetUserData = function() {\n        return ew(this.a)\n    }\n    ;\n    F.prototype.SetUserData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Jj(c, a)\n    }\n    ;\n    F.prototype.IsActive = function() {\n        return !!zm(this.a)\n    }\n    ;\n    F.prototype.GetCollideConnected = function() {\n        return !!Cg(this.a)\n    }\n    ;\n    F.prototype.__destroy__ = function() {\n        Zf(this.a)\n    }\n    ;\n    function Ix() {\n        throw "cannot construct a b2RayCastOutput, no constructor in IDL";\n    }\n    Ix.prototype = Object.create(h.prototype);\n    Ix.prototype.constructor = Ix;\n    Ix.prototype.b = Ix;\n    Ix.c = {};\n    b.b2RayCastOutput = Ix;\n    Ix.prototype.get_normal = function() {\n        return n(Ff(this.a), r)\n    }\n    ;\n    Ix.prototype.set_normal = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        lh(c, a)\n    }\n    ;\n    Ix.prototype.get_fraction = function() {\n        return In(this.a)\n    }\n    ;\n    Ix.prototype.set_fraction = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Sd(c, a)\n    }\n    ;\n    Ix.prototype.__destroy__ = function() {\n        Wm(this.a)\n    }\n    ;\n    function Jx() {\n        throw "cannot construct a b2ContactID, no constructor in IDL";\n    }\n    Jx.prototype = Object.create(h.prototype);\n    Jx.prototype.constructor = Jx;\n    Jx.prototype.b = Jx;\n    Jx.c = {};\n    b.b2ContactID = Jx;\n    Jx.prototype.get_cf = function() {\n        return n(Ms(this.a), Ex)\n    }\n    ;\n    Jx.prototype.set_cf = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        nj(c, a)\n    }\n    ;\n    Jx.prototype.get_key = function() {\n        return sp(this.a)\n    }\n    ;\n    Jx.prototype.set_key = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        vf(c, a)\n    }\n    ;\n    Jx.prototype.__destroy__ = function() {\n        cm(this.a)\n    }\n    ;\n    function Kx() {\n        this.a = Uw();\n        k(Kx)[this.a] = this\n    }\n    Kx.prototype = Object.create(qx.prototype);\n    Kx.prototype.constructor = Kx;\n    Kx.prototype.b = Kx;\n    Kx.c = {};\n    b.JSContactListener = Kx;\n    Kx.prototype.BeginContact = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        vo(c, a)\n    }\n    ;\n    Kx.prototype.EndContact = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Vc(c, a)\n    }\n    ;\n    Kx.prototype.PreSolve = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        jh(d, a, c)\n    }\n    ;\n    Kx.prototype.PostSolve = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        xq(d, a, c)\n    }\n    ;\n    Kx.prototype.__destroy__ = function() {\n        Xm(this.a)\n    }\n    ;\n    function Lx(a, c, d, e) {\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        e && "object" === typeof e && (e = e.a);\n        this.a = void 0 === a ? ds() : void 0 === c ? _emscripten_bind_b2Mat22_b2Mat22_1(a) : void 0 === d ? bs(a, c) : void 0 === e ? _emscripten_bind_b2Mat22_b2Mat22_3(a, c, d) : Ou(a, c, d, e);\n        k(Lx)[this.a] = this\n    }\n    Lx.prototype = Object.create(h.prototype);\n    Lx.prototype.constructor = Lx;\n    Lx.prototype.b = Lx;\n    Lx.c = {};\n    b.b2Mat22 = Lx;\n    Lx.prototype.Set = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        rr(d, a, c)\n    }\n    ;\n    Lx.prototype.SetIdentity = function() {\n        Ku(this.a)\n    }\n    ;\n    Lx.prototype.SetZero = function() {\n        dk(this.a)\n    }\n    ;\n    Lx.prototype.GetInverse = function() {\n        return n(br(this.a), Lx)\n    }\n    ;\n    Lx.prototype.Solve = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(fp(c, a), r)\n    }\n    ;\n    Lx.prototype.get_ex = function() {\n        return n(No(this.a), r)\n    }\n    ;\n    Lx.prototype.set_ex = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ir(c, a)\n    }\n    ;\n    Lx.prototype.get_ey = function() {\n        return n(Ju(this.a), r)\n    }\n    ;\n    Lx.prototype.set_ey = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        is(c, a)\n    }\n    ;\n    Lx.prototype.__destroy__ = function() {\n        cv(this.a)\n    }\n    ;\n    function H() {\n        this.a = Hu();\n        k(H)[this.a] = this\n    }\n    H.prototype = Object.create(t.prototype);\n    H.prototype.constructor = H;\n    H.prototype.b = H;\n    H.c = {};\n    b.b2WheelJointDef = H;\n    H.prototype.Initialize = function(a, c, d, e) {\n        var g = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        e && "object" === typeof e && (e = e.a);\n        gj(g, a, c, d, e)\n    }\n    ;\n    H.prototype.get_localAnchorA = function() {\n        return n(nl(this.a), r)\n    }\n    ;\n    H.prototype.set_localAnchorA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Re(c, a)\n    }\n    ;\n    H.prototype.get_localAnchorB = function() {\n        return n(Dn(this.a), r)\n    }\n    ;\n    H.prototype.set_localAnchorB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ew(c, a)\n    }\n    ;\n    H.prototype.get_localAxisA = function() {\n        return n(fr(this.a), r)\n    }\n    ;\n    H.prototype.set_localAxisA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        sw(c, a)\n    }\n    ;\n    H.prototype.get_enableMotor = function() {\n        return !!xw(this.a)\n    }\n    ;\n    H.prototype.set_enableMotor = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Lk(c, a)\n    }\n    ;\n    H.prototype.get_maxMotorTorque = function() {\n        return Ig(this.a)\n    }\n    ;\n    H.prototype.set_maxMotorTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        wk(c, a)\n    }\n    ;\n    H.prototype.get_motorSpeed = function() {\n        return Xr(this.a)\n    }\n    ;\n    H.prototype.set_motorSpeed = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ap(c, a)\n    }\n    ;\n    H.prototype.get_frequencyHz = function() {\n        return ot(this.a)\n    }\n    ;\n    H.prototype.set_frequencyHz = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        cr(c, a)\n    }\n    ;\n    H.prototype.get_dampingRatio = function() {\n        return Hn(this.a)\n    }\n    ;\n    H.prototype.set_dampingRatio = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Zv(c, a)\n    }\n    ;\n    H.prototype.get_type = function() {\n        return ru(this.a)\n    }\n    ;\n    H.prototype.set_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Wd(c, a)\n    }\n    ;\n    H.prototype.get_userData = function() {\n        return Ev(this.a)\n    }\n    ;\n    H.prototype.set_userData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        hh(c, a)\n    }\n    ;\n    H.prototype.get_bodyA = function() {\n        return n(Ow(this.a), q)\n    }\n    ;\n    H.prototype.set_bodyA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Rt(c, a)\n    }\n    ;\n    H.prototype.get_bodyB = function() {\n        return n(yn(this.a), q)\n    }\n    ;\n    H.prototype.set_bodyB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Yp(c, a)\n    }\n    ;\n    H.prototype.get_collideConnected = function() {\n        return !!Ec(this.a)\n    }\n    ;\n    H.prototype.set_collideConnected = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        xr(c, a)\n    }\n    ;\n    H.prototype.__destroy__ = function() {\n        nf(this.a)\n    }\n    ;\n    function Mx() {\n        this.a = ah();\n        k(Mx)[this.a] = this\n    }\n    Mx.prototype = Object.create(sx.prototype);\n    Mx.prototype.constructor = Mx;\n    Mx.prototype.b = Mx;\n    Mx.c = {};\n    b.b2CircleShape = Mx;\n    Mx.prototype.GetType = function() {\n        return rh(this.a)\n    }\n    ;\n    Mx.prototype.GetChildCount = function() {\n        return $e(this.a)\n    }\n    ;\n    Mx.prototype.TestPoint = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        return !!Fq(d, a, c)\n    }\n    ;\n    Mx.prototype.RayCast = function(a, c, d, e) {\n        var g = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        e && "object" === typeof e && (e = e.a);\n        return !!ak(g, a, c, d, e)\n    }\n    ;\n    Mx.prototype.ComputeAABB = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        $s(e, a, c, d)\n    }\n    ;\n    Mx.prototype.ComputeMass = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        Aq(d, a, c)\n    }\n    ;\n    Mx.prototype.get_m_p = function() {\n        return n(Kg(this.a), r)\n    }\n    ;\n    Mx.prototype.set_m_p = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ej(c, a)\n    }\n    ;\n    Mx.prototype.get_m_type = function() {\n        return ks(this.a)\n    }\n    ;\n    Mx.prototype.set_m_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ge(c, a)\n    }\n    ;\n    Mx.prototype.get_m_radius = function() {\n        return dg(this.a)\n    }\n    ;\n    Mx.prototype.set_m_radius = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ve(c, a)\n    }\n    ;\n    Mx.prototype.__destroy__ = function() {\n        Nq(this.a)\n    }\n    ;\n    function I() {\n        this.a = kw();\n        k(I)[this.a] = this\n    }\n    I.prototype = Object.create(t.prototype);\n    I.prototype.constructor = I;\n    I.prototype.b = I;\n    I.c = {};\n    b.b2WeldJointDef = I;\n    I.prototype.Initialize = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        pt(e, a, c, d)\n    }\n    ;\n    I.prototype.get_localAnchorA = function() {\n        return n(wt(this.a), r)\n    }\n    ;\n    I.prototype.set_localAnchorA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Di(c, a)\n    }\n    ;\n    I.prototype.get_localAnchorB = function() {\n        return n(Cu(this.a), r)\n    }\n    ;\n    I.prototype.set_localAnchorB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ps(c, a)\n    }\n    ;\n    I.prototype.get_referenceAngle = function() {\n        return lr(this.a)\n    }\n    ;\n    I.prototype.set_referenceAngle = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Du(c, a)\n    }\n    ;\n    I.prototype.get_frequencyHz = function() {\n        return sg(this.a)\n    }\n    ;\n    I.prototype.set_frequencyHz = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Hr(c, a)\n    }\n    ;\n    I.prototype.get_dampingRatio = function() {\n        return oq(this.a)\n    }\n    ;\n    I.prototype.set_dampingRatio = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        hj(c, a)\n    }\n    ;\n    I.prototype.get_type = function() {\n        return Fp(this.a)\n    }\n    ;\n    I.prototype.set_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        us(c, a)\n    }\n    ;\n    I.prototype.get_userData = function() {\n        return Wt(this.a)\n    }\n    ;\n    I.prototype.set_userData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        np(c, a)\n    }\n    ;\n    I.prototype.get_bodyA = function() {\n        return n(ev(this.a), q)\n    }\n    ;\n    I.prototype.set_bodyA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Te(c, a)\n    }\n    ;\n    I.prototype.get_bodyB = function() {\n        return n(Sv(this.a), q)\n    }\n    ;\n    I.prototype.set_bodyB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Iv(c, a)\n    }\n    ;\n    I.prototype.get_collideConnected = function() {\n        return !!yi(this.a)\n    }\n    ;\n    I.prototype.set_collideConnected = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        fd(c, a)\n    }\n    ;\n    I.prototype.__destroy__ = function() {\n        ep(this.a)\n    }\n    ;\n    function Nx() {\n        this.a = Up();\n        k(Nx)[this.a] = this\n    }\n    Nx.prototype = Object.create(h.prototype);\n    Nx.prototype.constructor = Nx;\n    Nx.prototype.b = Nx;\n    Nx.c = {};\n    b.b2MassData = Nx;\n    Nx.prototype.get_mass = function() {\n        return ow(this.a)\n    }\n    ;\n    Nx.prototype.set_mass = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Wc(c, a)\n    }\n    ;\n    Nx.prototype.get_center = function() {\n        return n(df(this.a), r)\n    }\n    ;\n    Nx.prototype.set_center = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Tq(c, a)\n    }\n    ;\n    Nx.prototype.get_I = function() {\n        return Wr(this.a)\n    }\n    ;\n    Nx.prototype.set_I = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        jt(c, a)\n    }\n    ;\n    Nx.prototype.__destroy__ = function() {\n        kt(this.a)\n    }\n    ;\n    function Ox() {\n        throw "cannot construct a b2GearJoint, no constructor in IDL";\n    }\n    Ox.prototype = Object.create(p.prototype);\n    Ox.prototype.constructor = Ox;\n    Ox.prototype.b = Ox;\n    Ox.c = {};\n    b.b2GearJoint = Ox;\n    Ox.prototype.GetJoint1 = function() {\n        return n(rd(this.a), p)\n    }\n    ;\n    Ox.prototype.GetJoint2 = function() {\n        return n(Qk(this.a), p)\n    }\n    ;\n    Ox.prototype.SetRatio = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Kn(c, a)\n    }\n    ;\n    Ox.prototype.GetRatio = function() {\n        return Cd(this.a)\n    }\n    ;\n    Ox.prototype.GetType = function() {\n        return $v(this.a)\n    }\n    ;\n    Ox.prototype.GetBodyA = function() {\n        return n(qm(this.a), q)\n    }\n    ;\n    Ox.prototype.GetBodyB = function() {\n        return n(Lq(this.a), q)\n    }\n    ;\n    Ox.prototype.GetAnchorA = function() {\n        return n(ud(this.a), r)\n    }\n    ;\n    Ox.prototype.GetAnchorB = function() {\n        return n(xu(this.a), r)\n    }\n    ;\n    Ox.prototype.GetReactionForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(Yi(c, a), r)\n    }\n    ;\n    Ox.prototype.GetReactionTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return ed(c, a)\n    }\n    ;\n    Ox.prototype.GetNext = function() {\n        return n(nv(this.a), p)\n    }\n    ;\n    Ox.prototype.GetUserData = function() {\n        return ze(this.a)\n    }\n    ;\n    Ox.prototype.SetUserData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ol(c, a)\n    }\n    ;\n    Ox.prototype.IsActive = function() {\n        return !!ui(this.a)\n    }\n    ;\n    Ox.prototype.GetCollideConnected = function() {\n        return !!Nd(this.a)\n    }\n    ;\n    Ox.prototype.__destroy__ = function() {\n        ag(this.a)\n    }\n    ;\n    function J() {\n        throw "cannot construct a b2WeldJoint, no constructor in IDL";\n    }\n    J.prototype = Object.create(p.prototype);\n    J.prototype.constructor = J;\n    J.prototype.b = J;\n    J.c = {};\n    b.b2WeldJoint = J;\n    J.prototype.GetLocalAnchorA = function() {\n        return n(Wu(this.a), r)\n    }\n    ;\n    J.prototype.GetLocalAnchorB = function() {\n        return n(zn(this.a), r)\n    }\n    ;\n    J.prototype.SetFrequency = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ih(c, a)\n    }\n    ;\n    J.prototype.GetFrequency = function() {\n        return bl(this.a)\n    }\n    ;\n    J.prototype.SetDampingRatio = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        fe(c, a)\n    }\n    ;\n    J.prototype.GetDampingRatio = function() {\n        return Xs(this.a)\n    }\n    ;\n    J.prototype.Dump = function() {\n        Vo(this.a)\n    }\n    ;\n    J.prototype.GetType = function() {\n        return Jo(this.a)\n    }\n    ;\n    J.prototype.GetBodyA = function() {\n        return n(Gf(this.a), q)\n    }\n    ;\n    J.prototype.GetBodyB = function() {\n        return n(ef(this.a), q)\n    }\n    ;\n    J.prototype.GetAnchorA = function() {\n        return n(uq(this.a), r)\n    }\n    ;\n    J.prototype.GetAnchorB = function() {\n        return n(tr(this.a), r)\n    }\n    ;\n    J.prototype.GetReactionForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(Is(c, a), r)\n    }\n    ;\n    J.prototype.GetReactionTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return yc(c, a)\n    }\n    ;\n    J.prototype.GetNext = function() {\n        return n(Io(this.a), p)\n    }\n    ;\n    J.prototype.GetUserData = function() {\n        return ml(this.a)\n    }\n    ;\n    J.prototype.SetUserData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        pi(c, a)\n    }\n    ;\n    J.prototype.IsActive = function() {\n        return !!tc(this.a)\n    }\n    ;\n    J.prototype.GetCollideConnected = function() {\n        return !!ar(this.a)\n    }\n    ;\n    J.prototype.__destroy__ = function() {\n        vq(this.a)\n    }\n    ;\n    function Px() {\n        this.a = pu();\n        k(Px)[this.a] = this\n    }\n    Px.prototype = Object.create(h.prototype);\n    Px.prototype.constructor = Px;\n    Px.prototype.b = Px;\n    Px.c = {};\n    b.b2JointEdge = Px;\n    Px.prototype.get_other = function() {\n        return n(Vi(this.a), q)\n    }\n    ;\n    Px.prototype.set_other = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        yd(c, a)\n    }\n    ;\n    Px.prototype.get_joint = function() {\n        return n(Mv(this.a), p)\n    }\n    ;\n    Px.prototype.set_joint = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        oc(c, a)\n    }\n    ;\n    Px.prototype.get_prev = function() {\n        return n(fm(this.a), Px)\n    }\n    ;\n    Px.prototype.set_prev = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        zg(c, a)\n    }\n    ;\n    Px.prototype.get_next = function() {\n        return n(zo(this.a), Px)\n    }\n    ;\n    Px.prototype.set_next = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        sr(c, a)\n    }\n    ;\n    Px.prototype.__destroy__ = function() {\n        to(this.a)\n    }\n    ;\n    function K() {\n        this.a = Sp();\n        k(K)[this.a] = this\n    }\n    K.prototype = Object.create(t.prototype);\n    K.prototype.constructor = K;\n    K.prototype.b = K;\n    K.c = {};\n    b.b2PulleyJointDef = K;\n    K.prototype.Initialize = function(a, c, d, e, g, l, m) {\n        var D = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        e && "object" === typeof e && (e = e.a);\n        g && "object" === typeof g && (g = g.a);\n        l && "object" === typeof l && (l = l.a);\n        m && "object" === typeof m && (m = m.a);\n        Wv(D, a, c, d, e, g, l, m)\n    }\n    ;\n    K.prototype.get_groundAnchorA = function() {\n        return n(kn(this.a), r)\n    }\n    ;\n    K.prototype.set_groundAnchorA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Qw(c, a)\n    }\n    ;\n    K.prototype.get_groundAnchorB = function() {\n        return n(uj(this.a), r)\n    }\n    ;\n    K.prototype.set_groundAnchorB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        qs(c, a)\n    }\n    ;\n    K.prototype.get_localAnchorA = function() {\n        return n(Pc(this.a), r)\n    }\n    ;\n    K.prototype.set_localAnchorA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Dq(c, a)\n    }\n    ;\n    K.prototype.get_localAnchorB = function() {\n        return n(Ot(this.a), r)\n    }\n    ;\n    K.prototype.set_localAnchorB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Hd(c, a)\n    }\n    ;\n    K.prototype.get_lengthA = function() {\n        return Wl(this.a)\n    }\n    ;\n    K.prototype.set_lengthA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        vg(c, a)\n    }\n    ;\n    K.prototype.get_lengthB = function() {\n        return oi(this.a)\n    }\n    ;\n    K.prototype.set_lengthB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ne(c, a)\n    }\n    ;\n    K.prototype.get_ratio = function() {\n        return Ee(this.a)\n    }\n    ;\n    K.prototype.set_ratio = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        yg(c, a)\n    }\n    ;\n    K.prototype.get_type = function() {\n        return Yl(this.a)\n    }\n    ;\n    K.prototype.set_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ol(c, a)\n    }\n    ;\n    K.prototype.get_userData = function() {\n        return Rk(this.a)\n    }\n    ;\n    K.prototype.set_userData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Hm(c, a)\n    }\n    ;\n    K.prototype.get_bodyA = function() {\n        return n(Nc(this.a), q)\n    }\n    ;\n    K.prototype.set_bodyA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Jw(c, a)\n    }\n    ;\n    K.prototype.get_bodyB = function() {\n        return n(Zg(this.a), q)\n    }\n    ;\n    K.prototype.set_bodyB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Kf(c, a)\n    }\n    ;\n    K.prototype.get_collideConnected = function() {\n        return !!Tw(this.a)\n    }\n    ;\n    K.prototype.set_collideConnected = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        tu(c, a)\n    }\n    ;\n    K.prototype.__destroy__ = function() {\n        Si(this.a)\n    }\n    ;\n    function Qx() {\n        this.a = gi();\n        k(Qx)[this.a] = this\n    }\n    Qx.prototype = Object.create(h.prototype);\n    Qx.prototype.constructor = Qx;\n    Qx.prototype.b = Qx;\n    Qx.c = {};\n    b.b2ManifoldPoint = Qx;\n    Qx.prototype.get_localPoint = function() {\n        return n(Lv(this.a), r)\n    }\n    ;\n    Qx.prototype.set_localPoint = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ct(c, a)\n    }\n    ;\n    Qx.prototype.get_normalImpulse = function() {\n        return Sj(this.a)\n    }\n    ;\n    Qx.prototype.set_normalImpulse = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Rh(c, a)\n    }\n    ;\n    Qx.prototype.get_tangentImpulse = function() {\n        return mq(this.a)\n    }\n    ;\n    Qx.prototype.set_tangentImpulse = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Oi(c, a)\n    }\n    ;\n    Qx.prototype.get_id = function() {\n        return n(cg(this.a), Jx)\n    }\n    ;\n    Qx.prototype.set_id = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        xn(c, a)\n    }\n    ;\n    Qx.prototype.__destroy__ = function() {\n        jr(this.a)\n    }\n    ;\n    function Rx(a, c) {\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        this.a = void 0 === a ? Ph() : void 0 === c ? _emscripten_bind_b2Transform_b2Transform_1(a) : Hs(a, c);\n        k(Rx)[this.a] = this\n    }\n    Rx.prototype = Object.create(h.prototype);\n    Rx.prototype.constructor = Rx;\n    Rx.prototype.b = Rx;\n    Rx.c = {};\n    b.b2Transform = Rx;\n    Rx.prototype.SetIdentity = function() {\n        Uq(this.a)\n    }\n    ;\n    Rx.prototype.Set = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        Eh(d, a, c)\n    }\n    ;\n    Rx.prototype.get_p = function() {\n        return n(fu(this.a), r)\n    }\n    ;\n    Rx.prototype.set_p = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Jv(c, a)\n    }\n    ;\n    Rx.prototype.get_q = function() {\n        return n(nd(this.a), Bx)\n    }\n    ;\n    Rx.prototype.set_q = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        qe(c, a)\n    }\n    ;\n    Rx.prototype.__destroy__ = function() {\n        te(this.a)\n    }\n    ;\n    function L() {\n        this.a = ij();\n        k(L)[this.a] = this\n    }\n    L.prototype = Object.create(sx.prototype);\n    L.prototype.constructor = L;\n    L.prototype.b = L;\n    L.c = {};\n    b.b2ChainShape = L;\n    L.prototype.Clear = function() {\n        Mq(this.a)\n    }\n    ;\n    L.prototype.CreateLoop = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        qi(d, a, c)\n    }\n    ;\n    L.prototype.CreateChain = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        Yc(d, a, c)\n    }\n    ;\n    L.prototype.SetPrevVertex = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Qn(c, a)\n    }\n    ;\n    L.prototype.SetNextVertex = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ho(c, a)\n    }\n    ;\n    L.prototype.GetChildEdge = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        zt(d, a, c)\n    }\n    ;\n    L.prototype.GetType = function() {\n        return om(this.a)\n    }\n    ;\n    L.prototype.GetChildCount = function() {\n        return $g(this.a)\n    }\n    ;\n    L.prototype.TestPoint = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        return !!il(d, a, c)\n    }\n    ;\n    L.prototype.RayCast = function(a, c, d, e) {\n        var g = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        e && "object" === typeof e && (e = e.a);\n        return !!Js(g, a, c, d, e)\n    }\n    ;\n    L.prototype.ComputeAABB = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        wc(e, a, c, d)\n    }\n    ;\n    L.prototype.ComputeMass = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        jw(d, a, c)\n    }\n    ;\n    L.prototype.get_m_vertices = function() {\n        return n(gc(this.a), r)\n    }\n    ;\n    L.prototype.set_m_vertices = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Af(c, a)\n    }\n    ;\n    L.prototype.get_m_count = function() {\n        return Vb(this.a)\n    }\n    ;\n    L.prototype.set_m_count = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Et(c, a)\n    }\n    ;\n    L.prototype.get_m_prevVertex = function() {\n        return n(dh(this.a), r)\n    }\n    ;\n    L.prototype.set_m_prevVertex = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        fo(c, a)\n    }\n    ;\n    L.prototype.get_m_nextVertex = function() {\n        return n(rf(this.a), r)\n    }\n    ;\n    L.prototype.set_m_nextVertex = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Uc(c, a)\n    }\n    ;\n    L.prototype.get_m_hasPrevVertex = function() {\n        return !!Rp(this.a)\n    }\n    ;\n    L.prototype.set_m_hasPrevVertex = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Wf(c, a)\n    }\n    ;\n    L.prototype.get_m_hasNextVertex = function() {\n        return !!go(this.a)\n    }\n    ;\n    L.prototype.set_m_hasNextVertex = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        hs(c, a)\n    }\n    ;\n    L.prototype.get_m_type = function() {\n        return tj(this.a)\n    }\n    ;\n    L.prototype.set_m_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        mg(c, a)\n    }\n    ;\n    L.prototype.get_m_radius = function() {\n        return Os(this.a)\n    }\n    ;\n    L.prototype.set_m_radius = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Qs(c, a)\n    }\n    ;\n    L.prototype.__destroy__ = function() {\n        Nl(this.a)\n    }\n    ;\n    function Sx(a, c, d) {\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        this.a = void 0 === a ? nt() : void 0 === c ? _emscripten_bind_b2Color_b2Color_1(a) : void 0 === d ? _emscripten_bind_b2Color_b2Color_2(a, c) : mt(a, c, d);\n        k(Sx)[this.a] = this\n    }\n    Sx.prototype = Object.create(h.prototype);\n    Sx.prototype.constructor = Sx;\n    Sx.prototype.b = Sx;\n    Sx.c = {};\n    b.b2Color = Sx;\n    Sx.prototype.Set = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        Nw(e, a, c, d)\n    }\n    ;\n    Sx.prototype.get_r = function() {\n        return Cm(this.a)\n    }\n    ;\n    Sx.prototype.set_r = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Td(c, a)\n    }\n    ;\n    Sx.prototype.get_g = function() {\n        return gp(this.a)\n    }\n    ;\n    Sx.prototype.set_g = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        dc(c, a)\n    }\n    ;\n    Sx.prototype.get_b = function() {\n        return Ys(this.a)\n    }\n    ;\n    Sx.prototype.set_b = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        bf(c, a)\n    }\n    ;\n    Sx.prototype.__destroy__ = function() {\n        Pp(this.a)\n    }\n    ;\n    function M() {\n        throw "cannot construct a b2RopeJoint, no constructor in IDL";\n    }\n    M.prototype = Object.create(p.prototype);\n    M.prototype.constructor = M;\n    M.prototype.b = M;\n    M.c = {};\n    b.b2RopeJoint = M;\n    M.prototype.GetLocalAnchorA = function() {\n        return n(Ar(this.a), r)\n    }\n    ;\n    M.prototype.GetLocalAnchorB = function() {\n        return n(Ri(this.a), r)\n    }\n    ;\n    M.prototype.SetMaxLength = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Yw(c, a)\n    }\n    ;\n    M.prototype.GetMaxLength = function() {\n        return ye(this.a)\n    }\n    ;\n    M.prototype.GetLimitState = function() {\n        return Eg(this.a)\n    }\n    ;\n    M.prototype.GetType = function() {\n        return wp(this.a)\n    }\n    ;\n    M.prototype.GetBodyA = function() {\n        return n(uv(this.a), q)\n    }\n    ;\n    M.prototype.GetBodyB = function() {\n        return n(gr(this.a), q)\n    }\n    ;\n    M.prototype.GetAnchorA = function() {\n        return n(Li(this.a), r)\n    }\n    ;\n    M.prototype.GetAnchorB = function() {\n        return n(Ie(this.a), r)\n    }\n    ;\n    M.prototype.GetReactionForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(at(c, a), r)\n    }\n    ;\n    M.prototype.GetReactionTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return Yv(c, a)\n    }\n    ;\n    M.prototype.GetNext = function() {\n        return n(ip(this.a), p)\n    }\n    ;\n    M.prototype.GetUserData = function() {\n        return Zc(this.a)\n    }\n    ;\n    M.prototype.SetUserData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Bs(c, a)\n    }\n    ;\n    M.prototype.IsActive = function() {\n        return !!yu(this.a)\n    }\n    ;\n    M.prototype.GetCollideConnected = function() {\n        return !!uu(this.a)\n    }\n    ;\n    M.prototype.__destroy__ = function() {\n        or(this.a)\n    }\n    ;\n    function Tx() {\n        throw "cannot construct a b2RayCastInput, no constructor in IDL";\n    }\n    Tx.prototype = Object.create(h.prototype);\n    Tx.prototype.constructor = Tx;\n    Tx.prototype.b = Tx;\n    Tx.c = {};\n    b.b2RayCastInput = Tx;\n    Tx.prototype.get_p1 = function() {\n        return n(Lp(this.a), r)\n    }\n    ;\n    Tx.prototype.set_p1 = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Wj(c, a)\n    }\n    ;\n    Tx.prototype.get_p2 = function() {\n        return n(kl(this.a), r)\n    }\n    ;\n    Tx.prototype.set_p2 = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Cf(c, a)\n    }\n    ;\n    Tx.prototype.get_maxFraction = function() {\n        return pm(this.a)\n    }\n    ;\n    Tx.prototype.set_maxFraction = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ao(c, a)\n    }\n    ;\n    Tx.prototype.__destroy__ = function() {\n        Oe(this.a)\n    }\n    ;\n    function N() {\n        this.a = Wi();\n        k(N)[this.a] = this\n    }\n    N.prototype = Object.create(sx.prototype);\n    N.prototype.constructor = N;\n    N.prototype.b = N;\n    N.c = {};\n    b.b2PolygonShape = N;\n    N.prototype.Set = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        Xi(d, a, c)\n    }\n    ;\n    N.prototype.SetAsBox = function(a, c, d, e) {\n        var g = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        e && "object" === typeof e && (e = e.a);\n        void 0 === d ? Lw(g, a, c) : void 0 === e ? _emscripten_bind_b2PolygonShape_SetAsBox_3(g, a, c, d) : Qu(g, a, c, d, e)\n    }\n    ;\n    N.prototype.GetVertexCount = function() {\n        return fq(this.a)\n    }\n    ;\n    N.prototype.GetVertex = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(Ht(c, a), r)\n    }\n    ;\n    N.prototype.GetType = function() {\n        return sh(this.a)\n    }\n    ;\n    N.prototype.GetChildCount = function() {\n        return kp(this.a)\n    }\n    ;\n    N.prototype.TestPoint = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        return !!Ui(d, a, c)\n    }\n    ;\n    N.prototype.RayCast = function(a, c, d, e) {\n        var g = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        e && "object" === typeof e && (e = e.a);\n        return !!ec(g, a, c, d, e)\n    }\n    ;\n    N.prototype.ComputeAABB = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        Gl(e, a, c, d)\n    }\n    ;\n    N.prototype.ComputeMass = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        ul(d, a, c)\n    }\n    ;\n    N.prototype.get_m_centroid = function() {\n        return n(Ml(this.a), r)\n    }\n    ;\n    N.prototype.set_m_centroid = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        wr(c, a)\n    }\n    ;\n    N.prototype.get_m_count = function() {\n        return Ki(this.a)\n    }\n    ;\n    N.prototype.set_m_count = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        od(c, a)\n    }\n    ;\n    N.prototype.get_m_type = function() {\n        return Rw(this.a)\n    }\n    ;\n    N.prototype.set_m_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        jv(c, a)\n    }\n    ;\n    N.prototype.get_m_radius = function() {\n        return Cj(this.a)\n    }\n    ;\n    N.prototype.set_m_radius = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ww(c, a)\n    }\n    ;\n    N.prototype.__destroy__ = function() {\n        re(this.a)\n    }\n    ;\n    function O() {\n        this.a = qq();\n        k(O)[this.a] = this\n    }\n    O.prototype = Object.create(sx.prototype);\n    O.prototype.constructor = O;\n    O.prototype.b = O;\n    O.c = {};\n    b.b2EdgeShape = O;\n    O.prototype.Set = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        Pj(d, a, c)\n    }\n    ;\n    O.prototype.GetType = function() {\n        return hr(this.a)\n    }\n    ;\n    O.prototype.GetChildCount = function() {\n        return Hh(this.a)\n    }\n    ;\n    O.prototype.TestPoint = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        return !!Kl(d, a, c)\n    }\n    ;\n    O.prototype.RayCast = function(a, c, d, e) {\n        var g = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        e && "object" === typeof e && (e = e.a);\n        return !!Ai(g, a, c, d, e)\n    }\n    ;\n    O.prototype.ComputeAABB = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        vr(e, a, c, d)\n    }\n    ;\n    O.prototype.ComputeMass = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        un(d, a, c)\n    }\n    ;\n    O.prototype.get_m_vertex1 = function() {\n        return n(yl(this.a), r)\n    }\n    ;\n    O.prototype.set_m_vertex1 = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ru(c, a)\n    }\n    ;\n    O.prototype.get_m_vertex2 = function() {\n        return n(yo(this.a), r)\n    }\n    ;\n    O.prototype.set_m_vertex2 = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Wq(c, a)\n    }\n    ;\n    O.prototype.get_m_vertex0 = function() {\n        return n(vi(this.a), r)\n    }\n    ;\n    O.prototype.set_m_vertex0 = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        bw(c, a)\n    }\n    ;\n    O.prototype.get_m_vertex3 = function() {\n        return n(Sq(this.a), r)\n    }\n    ;\n    O.prototype.set_m_vertex3 = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        wu(c, a)\n    }\n    ;\n    O.prototype.get_m_hasVertex0 = function() {\n        return !!dm(this.a)\n    }\n    ;\n    O.prototype.set_m_hasVertex0 = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        we(c, a)\n    }\n    ;\n    O.prototype.get_m_hasVertex3 = function() {\n        return !!Lj(this.a)\n    }\n    ;\n    O.prototype.set_m_hasVertex3 = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        nc(c, a)\n    }\n    ;\n    O.prototype.get_m_type = function() {\n        return jp(this.a)\n    }\n    ;\n    O.prototype.set_m_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        hi(c, a)\n    }\n    ;\n    O.prototype.get_m_radius = function() {\n        return $r(this.a)\n    }\n    ;\n    O.prototype.set_m_radius = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        le(c, a)\n    }\n    ;\n    O.prototype.__destroy__ = function() {\n        Ji(this.a)\n    }\n    ;\n    function Ux() {\n        this.a = Us();\n        k(Ux)[this.a] = this\n    }\n    Ux.prototype = Object.create(tx.prototype);\n    Ux.prototype.constructor = Ux;\n    Ux.prototype.b = Ux;\n    Ux.c = {};\n    b.JSContactFilter = Ux;\n    Ux.prototype.ShouldCollide = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        return !!Tj(d, a, c)\n    }\n    ;\n    Ux.prototype.__destroy__ = function() {\n        Aj(this.a)\n    }\n    ;\n    function P() {\n        this.a = Om();\n        k(P)[this.a] = this\n    }\n    P.prototype = Object.create(t.prototype);\n    P.prototype.constructor = P;\n    P.prototype.b = P;\n    P.c = {};\n    b.b2RevoluteJointDef = P;\n    P.prototype.Initialize = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        Id(e, a, c, d)\n    }\n    ;\n    P.prototype.get_localAnchorA = function() {\n        return n(tn(this.a), r)\n    }\n    ;\n    P.prototype.set_localAnchorA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        qj(c, a)\n    }\n    ;\n    P.prototype.get_localAnchorB = function() {\n        return n(yj(this.a), r)\n    }\n    ;\n    P.prototype.set_localAnchorB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        An(c, a)\n    }\n    ;\n    P.prototype.get_referenceAngle = function() {\n        return zj(this.a)\n    }\n    ;\n    P.prototype.set_referenceAngle = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Np(c, a)\n    }\n    ;\n    P.prototype.get_enableLimit = function() {\n        return !!Rm(this.a)\n    }\n    ;\n    P.prototype.set_enableLimit = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        dp(c, a)\n    }\n    ;\n    P.prototype.get_lowerAngle = function() {\n        return el(this.a)\n    }\n    ;\n    P.prototype.set_lowerAngle = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        so(c, a)\n    }\n    ;\n    P.prototype.get_upperAngle = function() {\n        return aq(this.a)\n    }\n    ;\n    P.prototype.set_upperAngle = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        lm(c, a)\n    }\n    ;\n    P.prototype.get_enableMotor = function() {\n        return !!Bj(this.a)\n    }\n    ;\n    P.prototype.set_enableMotor = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ji(c, a)\n    }\n    ;\n    P.prototype.get_motorSpeed = function() {\n        return Df(this.a)\n    }\n    ;\n    P.prototype.set_motorSpeed = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        vw(c, a)\n    }\n    ;\n    P.prototype.get_maxMotorTorque = function() {\n        return nq(this.a)\n    }\n    ;\n    P.prototype.set_maxMotorTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Hv(c, a)\n    }\n    ;\n    P.prototype.get_type = function() {\n        return mm(this.a)\n    }\n    ;\n    P.prototype.set_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Vj(c, a)\n    }\n    ;\n    P.prototype.get_userData = function() {\n        return on(this.a)\n    }\n    ;\n    P.prototype.set_userData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Cc(c, a)\n    }\n    ;\n    P.prototype.get_bodyA = function() {\n        return n(Pt(this.a), q)\n    }\n    ;\n    P.prototype.set_bodyA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ah(c, a)\n    }\n    ;\n    P.prototype.get_bodyB = function() {\n        return n(Hj(this.a), q)\n    }\n    ;\n    P.prototype.set_bodyB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ng(c, a)\n    }\n    ;\n    P.prototype.get_collideConnected = function() {\n        return !!rs(this.a)\n    }\n    ;\n    P.prototype.set_collideConnected = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Zo(c, a)\n    }\n    ;\n    P.prototype.__destroy__ = function() {\n        pp(this.a)\n    }\n    ;\n    function Vx() {\n        this.a = du();\n        k(Vx)[this.a] = this\n    }\n    Vx.prototype = Object.create(ox.prototype);\n    Vx.prototype.constructor = Vx;\n    Vx.prototype.b = Vx;\n    Vx.c = {};\n    b.JSDraw = Vx;\n    Vx.prototype.DrawPolygon = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        tl(e, a, c, d)\n    }\n    ;\n    Vx.prototype.DrawSolidPolygon = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        Nf(e, a, c, d)\n    }\n    ;\n    Vx.prototype.DrawCircle = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        sc(e, a, c, d)\n    }\n    ;\n    Vx.prototype.DrawSolidCircle = function(a, c, d, e) {\n        var g = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        e && "object" === typeof e && (e = e.a);\n        hc(g, a, c, d, e)\n    }\n    ;\n    Vx.prototype.DrawSegment = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        jf(e, a, c, d)\n    }\n    ;\n    Vx.prototype.DrawTransform = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        vj(c, a)\n    }\n    ;\n    Vx.prototype.__destroy__ = function() {\n        Qf(this.a)\n    }\n    ;\n    function Q() {\n        throw "cannot construct a b2WheelJoint, no constructor in IDL";\n    }\n    Q.prototype = Object.create(p.prototype);\n    Q.prototype.constructor = Q;\n    Q.prototype.b = Q;\n    Q.c = {};\n    b.b2WheelJoint = Q;\n    Q.prototype.GetLocalAnchorA = function() {\n        return n(Vf(this.a), r)\n    }\n    ;\n    Q.prototype.GetLocalAnchorB = function() {\n        return n(Iw(this.a), r)\n    }\n    ;\n    Q.prototype.GetLocalAxisA = function() {\n        return n(rv(this.a), r)\n    }\n    ;\n    Q.prototype.GetJointTranslation = function() {\n        return zs(this.a)\n    }\n    ;\n    Q.prototype.GetJointSpeed = function() {\n        return yf(this.a)\n    }\n    ;\n    Q.prototype.IsMotorEnabled = function() {\n        return !!kq(this.a)\n    }\n    ;\n    Q.prototype.EnableMotor = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Lf(c, a)\n    }\n    ;\n    Q.prototype.SetMotorSpeed = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        be(c, a)\n    }\n    ;\n    Q.prototype.GetMotorSpeed = function() {\n        return Gn(this.a)\n    }\n    ;\n    Q.prototype.SetMaxMotorTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ik(c, a)\n    }\n    ;\n    Q.prototype.GetMaxMotorTorque = function() {\n        return wf(this.a)\n    }\n    ;\n    Q.prototype.GetMotorTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return As(c, a)\n    }\n    ;\n    Q.prototype.SetSpringFrequencyHz = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Mh(c, a)\n    }\n    ;\n    Q.prototype.GetSpringFrequencyHz = function() {\n        return Aw(this.a)\n    }\n    ;\n    Q.prototype.SetSpringDampingRatio = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        no(c, a)\n    }\n    ;\n    Q.prototype.GetSpringDampingRatio = function() {\n        return Tb(this.a)\n    }\n    ;\n    Q.prototype.GetType = function() {\n        return kv(this.a)\n    }\n    ;\n    Q.prototype.GetBodyA = function() {\n        return n(Zn(this.a), q)\n    }\n    ;\n    Q.prototype.GetBodyB = function() {\n        return n(xm(this.a), q)\n    }\n    ;\n    Q.prototype.GetAnchorA = function() {\n        return n(Or(this.a), r)\n    }\n    ;\n    Q.prototype.GetAnchorB = function() {\n        return n(Kw(this.a), r)\n    }\n    ;\n    Q.prototype.GetReactionForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(ff(c, a), r)\n    }\n    ;\n    Q.prototype.GetReactionTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return Nm(c, a)\n    }\n    ;\n    Q.prototype.GetNext = function() {\n        return n(Wn(this.a), p)\n    }\n    ;\n    Q.prototype.GetUserData = function() {\n        return Un(this.a)\n    }\n    ;\n    Q.prototype.SetUserData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ct(c, a)\n    }\n    ;\n    Q.prototype.IsActive = function() {\n        return !!Ds(this.a)\n    }\n    ;\n    Q.prototype.GetCollideConnected = function() {\n        return !!Zr(this.a)\n    }\n    ;\n    Q.prototype.__destroy__ = function() {\n        Vw(this.a)\n    }\n    ;\n    function R() {\n        throw "cannot construct a b2PulleyJoint, no constructor in IDL";\n    }\n    R.prototype = Object.create(p.prototype);\n    R.prototype.constructor = R;\n    R.prototype.b = R;\n    R.c = {};\n    b.b2PulleyJoint = R;\n    R.prototype.GetGroundAnchorA = function() {\n        return n(cd(this.a), r)\n    }\n    ;\n    R.prototype.GetGroundAnchorB = function() {\n        return n(fg(this.a), r)\n    }\n    ;\n    R.prototype.GetLengthA = function() {\n        return ao(this.a)\n    }\n    ;\n    R.prototype.GetLengthB = function() {\n        return fk(this.a)\n    }\n    ;\n    R.prototype.GetRatio = function() {\n        return uo(this.a)\n    }\n    ;\n    R.prototype.GetCurrentLengthA = function() {\n        return Uk(this.a)\n    }\n    ;\n    R.prototype.GetCurrentLengthB = function() {\n        return Gi(this.a)\n    }\n    ;\n    R.prototype.GetType = function() {\n        return Ci(this.a)\n    }\n    ;\n    R.prototype.GetBodyA = function() {\n        return n(yq(this.a), q)\n    }\n    ;\n    R.prototype.GetBodyB = function() {\n        return n(Vd(this.a), q)\n    }\n    ;\n    R.prototype.GetAnchorA = function() {\n        return n($u(this.a), r)\n    }\n    ;\n    R.prototype.GetAnchorB = function() {\n        return n(Mm(this.a), r)\n    }\n    ;\n    R.prototype.GetReactionForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(Mu(c, a), r)\n    }\n    ;\n    R.prototype.GetReactionTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return hv(c, a)\n    }\n    ;\n    R.prototype.GetNext = function() {\n        return n(sj(this.a), p)\n    }\n    ;\n    R.prototype.GetUserData = function() {\n        return xc(this.a)\n    }\n    ;\n    R.prototype.SetUserData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Xb(c, a)\n    }\n    ;\n    R.prototype.IsActive = function() {\n        return !!ki(this.a)\n    }\n    ;\n    R.prototype.GetCollideConnected = function() {\n        return !!bu(this.a)\n    }\n    ;\n    R.prototype.__destroy__ = function() {\n        Po(this.a)\n    }\n    ;\n    function S() {\n        this.a = Gp();\n        k(S)[this.a] = this\n    }\n    S.prototype = Object.create(t.prototype);\n    S.prototype.constructor = S;\n    S.prototype.b = S;\n    S.c = {};\n    b.b2MouseJointDef = S;\n    S.prototype.get_target = function() {\n        return n(Fm(this.a), r)\n    }\n    ;\n    S.prototype.set_target = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        zd(c, a)\n    }\n    ;\n    S.prototype.get_maxForce = function() {\n        return ov(this.a)\n    }\n    ;\n    S.prototype.set_maxForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Il(c, a)\n    }\n    ;\n    S.prototype.get_frequencyHz = function() {\n        return Jp(this.a)\n    }\n    ;\n    S.prototype.set_frequencyHz = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        jn(c, a)\n    }\n    ;\n    S.prototype.get_dampingRatio = function() {\n        return kg(this.a)\n    }\n    ;\n    S.prototype.set_dampingRatio = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Qo(c, a)\n    }\n    ;\n    S.prototype.get_type = function() {\n        return Dp(this.a)\n    }\n    ;\n    S.prototype.set_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Pd(c, a)\n    }\n    ;\n    S.prototype.get_userData = function() {\n        return Zs(this.a)\n    }\n    ;\n    S.prototype.set_userData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Fc(c, a)\n    }\n    ;\n    S.prototype.get_bodyA = function() {\n        return n(Gk(this.a), q)\n    }\n    ;\n    S.prototype.set_bodyA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        vd(c, a)\n    }\n    ;\n    S.prototype.get_bodyB = function() {\n        return n(qg(this.a), q)\n    }\n    ;\n    S.prototype.set_bodyB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        qh(c, a)\n    }\n    ;\n    S.prototype.get_collideConnected = function() {\n        return !!Jt(this.a)\n    }\n    ;\n    S.prototype.set_collideConnected = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Yq(c, a)\n    }\n    ;\n    S.prototype.__destroy__ = function() {\n        Rf(this.a)\n    }\n    ;\n    function E() {\n        throw "cannot construct a b2Contact, no constructor in IDL";\n    }\n    E.prototype = Object.create(h.prototype);\n    E.prototype.constructor = E;\n    E.prototype.b = E;\n    E.c = {};\n    b.b2Contact = E;\n    E.prototype.GetManifold = function() {\n        return n(ut(this.a), Gx)\n    }\n    ;\n    E.prototype.GetWorldManifold = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        xe(c, a)\n    }\n    ;\n    E.prototype.IsTouching = function() {\n        return !!he(this.a)\n    }\n    ;\n    E.prototype.SetEnabled = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        sf(c, a)\n    }\n    ;\n    E.prototype.IsEnabled = function() {\n        return !!wg(this.a)\n    }\n    ;\n    E.prototype.GetNext = function() {\n        return n(pd(this.a), E)\n    }\n    ;\n    E.prototype.GetFixtureA = function() {\n        return n(De(this.a), v)\n    }\n    ;\n    E.prototype.GetChildIndexA = function() {\n        return lw(this.a)\n    }\n    ;\n    E.prototype.GetFixtureB = function() {\n        return n(iw(this.a), v)\n    }\n    ;\n    E.prototype.GetChildIndexB = function() {\n        return ph(this.a)\n    }\n    ;\n    E.prototype.SetFriction = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Xq(c, a)\n    }\n    ;\n    E.prototype.GetFriction = function() {\n        return Uh(this.a)\n    }\n    ;\n    E.prototype.ResetFriction = function() {\n        Ih(this.a)\n    }\n    ;\n    E.prototype.SetRestitution = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Qq(c, a)\n    }\n    ;\n    E.prototype.GetRestitution = function() {\n        return mn(this.a)\n    }\n    ;\n    E.prototype.ResetRestitution = function() {\n        ei(this.a)\n    }\n    ;\n    E.prototype.SetTangentSpeed = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        aj(c, a)\n    }\n    ;\n    E.prototype.GetTangentSpeed = function() {\n        return ld(this.a)\n    }\n    ;\n    function T() {\n        this.a = Jm();\n        k(T)[this.a] = this\n    }\n    T.prototype = Object.create(t.prototype);\n    T.prototype.constructor = T;\n    T.prototype.b = T;\n    T.c = {};\n    b.b2DistanceJointDef = T;\n    T.prototype.Initialize = function(a, c, d, e) {\n        var g = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        e && "object" === typeof e && (e = e.a);\n        Ns(g, a, c, d, e)\n    }\n    ;\n    T.prototype.get_localAnchorA = function() {\n        return n(Zi(this.a), r)\n    }\n    ;\n    T.prototype.set_localAnchorA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        He(c, a)\n    }\n    ;\n    T.prototype.get_localAnchorB = function() {\n        return n(Bq(this.a), r)\n    }\n    ;\n    T.prototype.set_localAnchorB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Eu(c, a)\n    }\n    ;\n    T.prototype.get_length = function() {\n        return Ud(this.a)\n    }\n    ;\n    T.prototype.set_length = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Wh(c, a)\n    }\n    ;\n    T.prototype.get_frequencyHz = function() {\n        return bo(this.a)\n    }\n    ;\n    T.prototype.set_frequencyHz = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        xj(c, a)\n    }\n    ;\n    T.prototype.get_dampingRatio = function() {\n        return me(this.a)\n    }\n    ;\n    T.prototype.set_dampingRatio = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Sc(c, a)\n    }\n    ;\n    T.prototype.get_type = function() {\n        return ai(this.a)\n    }\n    ;\n    T.prototype.set_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        tq(c, a)\n    }\n    ;\n    T.prototype.get_userData = function() {\n        return Ac(this.a)\n    }\n    ;\n    T.prototype.set_userData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Rc(c, a)\n    }\n    ;\n    T.prototype.get_bodyA = function() {\n        return n(Mi(this.a), q)\n    }\n    ;\n    T.prototype.set_bodyA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ss(c, a)\n    }\n    ;\n    T.prototype.get_bodyB = function() {\n        return n(bv(this.a), q)\n    }\n    ;\n    T.prototype.set_bodyB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Qp(c, a)\n    }\n    ;\n    T.prototype.get_collideConnected = function() {\n        return !!Mp(this.a)\n    }\n    ;\n    T.prototype.set_collideConnected = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Tn(c, a)\n    }\n    ;\n    T.prototype.__destroy__ = function() {\n        iu(this.a)\n    }\n    ;\n    function q() {\n        throw "cannot construct a b2Body, no constructor in IDL";\n    }\n    q.prototype = Object.create(h.prototype);\n    q.prototype.constructor = q;\n    q.prototype.b = q;\n    q.c = {};\n    b.b2Body = q;\n    q.prototype.CreateFixture = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        return void 0 === c ? n(cu(d, a), v) : n(Cl(d, a, c), v)\n    }\n    ;\n    q.prototype.DestroyFixture = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Bn(c, a)\n    }\n    ;\n    q.prototype.SetTransform = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        Gm(d, a, c)\n    }\n    ;\n    q.prototype.GetTransform = function() {\n        return n(Lt(this.a), Rx)\n    }\n    ;\n    q.prototype.GetPosition = function() {\n        return n(Sg(this.a), r)\n    }\n    ;\n    q.prototype.GetAngle = function() {\n        return Fw(this.a)\n    }\n    ;\n    q.prototype.GetWorldCenter = function() {\n        return n(vk(this.a), r)\n    }\n    ;\n    q.prototype.GetLocalCenter = function() {\n        return n(Nv(this.a), r)\n    }\n    ;\n    q.prototype.SetLinearVelocity = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        jm(c, a)\n    }\n    ;\n    q.prototype.GetLinearVelocity = function() {\n        return n(ue(this.a), r)\n    }\n    ;\n    q.prototype.SetAngularVelocity = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Vt(c, a)\n    }\n    ;\n    q.prototype.GetAngularVelocity = function() {\n        return dj(this.a)\n    }\n    ;\n    q.prototype.ApplyForce = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        Dt(e, a, c, d)\n    }\n    ;\n    q.prototype.ApplyForceToCenter = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        Pe(d, a, c)\n    }\n    ;\n    q.prototype.ApplyTorque = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        wh(d, a, c)\n    }\n    ;\n    q.prototype.ApplyLinearImpulse = function(a, c, d) {\n        var e = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        d && "object" === typeof d && (d = d.a);\n        Ln(e, a, c, d)\n    }\n    ;\n    q.prototype.ApplyAngularImpulse = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        Qd(d, a, c)\n    }\n    ;\n    q.prototype.GetMass = function() {\n        return jo(this.a)\n    }\n    ;\n    q.prototype.GetInertia = function() {\n        return Zu(this.a)\n    }\n    ;\n    q.prototype.GetMassData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        sn(c, a)\n    }\n    ;\n    q.prototype.SetMassData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        de(c, a)\n    }\n    ;\n    q.prototype.ResetMassData = function() {\n        pn(this.a)\n    }\n    ;\n    q.prototype.GetWorldPoint = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(Rj(c, a), r)\n    }\n    ;\n    q.prototype.GetWorldVector = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(rg(c, a), r)\n    }\n    ;\n    q.prototype.GetLocalPoint = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(Bg(c, a), r)\n    }\n    ;\n    q.prototype.GetLocalVector = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(rm(c, a), r)\n    }\n    ;\n    q.prototype.GetLinearVelocityFromWorldPoint = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n($q(c, a), r)\n    }\n    ;\n    q.prototype.GetLinearVelocityFromLocalPoint = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(Hq(c, a), r)\n    }\n    ;\n    q.prototype.GetLinearDamping = function() {\n        return Gr(this.a)\n    }\n    ;\n    q.prototype.SetLinearDamping = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        wm(c, a)\n    }\n    ;\n    q.prototype.GetAngularDamping = function() {\n        return Bk(this.a)\n    }\n    ;\n    q.prototype.SetAngularDamping = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ci(c, a)\n    }\n    ;\n    q.prototype.GetGravityScale = function() {\n        return oj(this.a)\n    }\n    ;\n    q.prototype.SetGravityScale = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Tl(c, a)\n    }\n    ;\n    q.prototype.SetType = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        io(c, a)\n    }\n    ;\n    q.prototype.GetType = function() {\n        return ls(this.a)\n    }\n    ;\n    q.prototype.SetBullet = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Hk(c, a)\n    }\n    ;\n    q.prototype.IsBullet = function() {\n        return !!pl(this.a)\n    }\n    ;\n    q.prototype.SetSleepingAllowed = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Xk(c, a)\n    }\n    ;\n    q.prototype.IsSleepingAllowed = function() {\n        return !!bq(this.a)\n    }\n    ;\n    q.prototype.SetAwake = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Vu(c, a)\n    }\n    ;\n    q.prototype.IsAwake = function() {\n        return !!xd(this.a)\n    }\n    ;\n    q.prototype.SetActive = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Dl(c, a)\n    }\n    ;\n    q.prototype.IsActive = function() {\n        return !!di(this.a)\n    }\n    ;\n    q.prototype.SetFixedRotation = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        kh(c, a)\n    }\n    ;\n    q.prototype.IsFixedRotation = function() {\n        return !!Sh(this.a)\n    }\n    ;\n    q.prototype.GetFixtureList = function() {\n        return n(Oo(this.a), v)\n    }\n    ;\n    q.prototype.GetJointList = function() {\n        return n(ft(this.a), Px)\n    }\n    ;\n    q.prototype.GetContactList = function() {\n        return n(Vh(this.a), Wx)\n    }\n    ;\n    q.prototype.GetNext = function() {\n        return n(sv(this.a), q)\n    }\n    ;\n    q.prototype.GetUserData = function() {\n        return Ak(this.a)\n    }\n    ;\n    q.prototype.SetUserData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ti(c, a)\n    }\n    ;\n    q.prototype.GetWorld = function() {\n        return n(Su(this.a), C)\n    }\n    ;\n    q.prototype.Dump = function() {\n        tk(this.a)\n    }\n    ;\n    function U() {\n        throw "cannot construct a b2FrictionJoint, no constructor in IDL";\n    }\n    U.prototype = Object.create(p.prototype);\n    U.prototype.constructor = U;\n    U.prototype.b = U;\n    U.c = {};\n    b.b2FrictionJoint = U;\n    U.prototype.GetLocalAnchorA = function() {\n        return n(Yo(this.a), r)\n    }\n    ;\n    U.prototype.GetLocalAnchorB = function() {\n        return n(Yh(this.a), r)\n    }\n    ;\n    U.prototype.SetMaxForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Xt(c, a)\n    }\n    ;\n    U.prototype.GetMaxForce = function() {\n        return Dv(this.a)\n    }\n    ;\n    U.prototype.SetMaxTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ip(c, a)\n    }\n    ;\n    U.prototype.GetMaxTorque = function() {\n        return zi(this.a)\n    }\n    ;\n    U.prototype.GetType = function() {\n        return hg(this.a)\n    }\n    ;\n    U.prototype.GetBodyA = function() {\n        return n(Dw(this.a), q)\n    }\n    ;\n    U.prototype.GetBodyB = function() {\n        return n(Se(this.a), q)\n    }\n    ;\n    U.prototype.GetAnchorA = function() {\n        return n(Ur(this.a), r)\n    }\n    ;\n    U.prototype.GetAnchorB = function() {\n        return n(yv(this.a), r)\n    }\n    ;\n    U.prototype.GetReactionForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(rq(c, a), r)\n    }\n    ;\n    U.prototype.GetReactionTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return kk(c, a)\n    }\n    ;\n    U.prototype.GetNext = function() {\n        return n(xs(this.a), p)\n    }\n    ;\n    U.prototype.GetUserData = function() {\n        return Cr(this.a)\n    }\n    ;\n    U.prototype.SetUserData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Kp(c, a)\n    }\n    ;\n    U.prototype.IsActive = function() {\n        return !!cc(this.a)\n    }\n    ;\n    U.prototype.GetCollideConnected = function() {\n        return !!zp(this.a)\n    }\n    ;\n    U.prototype.__destroy__ = function() {\n        Uo(this.a)\n    }\n    ;\n    function Xx() {\n        throw "cannot construct a b2DestructionListener, no constructor in IDL";\n    }\n    Xx.prototype = Object.create(h.prototype);\n    Xx.prototype.constructor = Xx;\n    Xx.prototype.b = Xx;\n    Xx.c = {};\n    b.b2DestructionListener = Xx;\n    Xx.prototype.__destroy__ = function() {\n        uc(this.a)\n    }\n    ;\n    function W() {\n        this.a = en();\n        k(W)[this.a] = this\n    }\n    W.prototype = Object.create(t.prototype);\n    W.prototype.constructor = W;\n    W.prototype.b = W;\n    W.c = {};\n    b.b2GearJointDef = W;\n    W.prototype.get_joint1 = function() {\n        return n(ri(this.a), p)\n    }\n    ;\n    W.prototype.set_joint1 = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Vq(c, a)\n    }\n    ;\n    W.prototype.get_joint2 = function() {\n        return n(ym(this.a), p)\n    }\n    ;\n    W.prototype.set_joint2 = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        vu(c, a)\n    }\n    ;\n    W.prototype.get_ratio = function() {\n        return lp(this.a)\n    }\n    ;\n    W.prototype.set_ratio = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        tg(c, a)\n    }\n    ;\n    W.prototype.get_type = function() {\n        return nm(this.a)\n    }\n    ;\n    W.prototype.set_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Be(c, a)\n    }\n    ;\n    W.prototype.get_userData = function() {\n        return an(this.a)\n    }\n    ;\n    W.prototype.set_userData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        fw(c, a)\n    }\n    ;\n    W.prototype.get_bodyA = function() {\n        return n(wj(this.a), q)\n    }\n    ;\n    W.prototype.set_bodyA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ju(c, a)\n    }\n    ;\n    W.prototype.get_bodyB = function() {\n        return n(vn(this.a), q)\n    }\n    ;\n    W.prototype.set_bodyB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Xv(c, a)\n    }\n    ;\n    W.prototype.get_collideConnected = function() {\n        return !!Ek(this.a)\n    }\n    ;\n    W.prototype.set_collideConnected = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        $o(c, a)\n    }\n    ;\n    W.prototype.__destroy__ = function() {\n        Cq(this.a)\n    }\n    ;\n    function X() {\n        throw "cannot construct a b2RevoluteJoint, no constructor in IDL";\n    }\n    X.prototype = Object.create(p.prototype);\n    X.prototype.constructor = X;\n    X.prototype.b = X;\n    X.c = {};\n    b.b2RevoluteJoint = X;\n    X.prototype.GetLocalAnchorA = function() {\n        return n(ic(this.a), r)\n    }\n    ;\n    X.prototype.GetLocalAnchorB = function() {\n        return n(Ts(this.a), r)\n    }\n    ;\n    X.prototype.GetReferenceAngle = function() {\n        return Ed(this.a)\n    }\n    ;\n    X.prototype.GetJointAngle = function() {\n        return Pf(this.a)\n    }\n    ;\n    X.prototype.GetJointSpeed = function() {\n        return Mf(this.a)\n    }\n    ;\n    X.prototype.IsLimitEnabled = function() {\n        return !!Fv(this.a)\n    }\n    ;\n    X.prototype.EnableLimit = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ng(c, a)\n    }\n    ;\n    X.prototype.GetLowerLimit = function() {\n        return uk(this.a)\n    }\n    ;\n    X.prototype.GetUpperLimit = function() {\n        return Vl(this.a)\n    }\n    ;\n    X.prototype.SetLimits = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        ts(d, a, c)\n    }\n    ;\n    X.prototype.IsMotorEnabled = function() {\n        return !!Gt(this.a)\n    }\n    ;\n    X.prototype.EnableMotor = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        oh(c, a)\n    }\n    ;\n    X.prototype.SetMotorSpeed = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        co(c, a)\n    }\n    ;\n    X.prototype.GetMotorSpeed = function() {\n        return lg(this.a)\n    }\n    ;\n    X.prototype.SetMaxMotorTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        nh(c, a)\n    }\n    ;\n    X.prototype.GetMaxMotorTorque = function() {\n        return Nj(this.a)\n    }\n    ;\n    X.prototype.GetMotorTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return qt(c, a)\n    }\n    ;\n    X.prototype.GetType = function() {\n        return Tp(this.a)\n    }\n    ;\n    X.prototype.GetBodyA = function() {\n        return n(mj(this.a), q)\n    }\n    ;\n    X.prototype.GetBodyB = function() {\n        return n(Mk(this.a), q)\n    }\n    ;\n    X.prototype.GetAnchorA = function() {\n        return n(Mr(this.a), r)\n    }\n    ;\n    X.prototype.GetAnchorB = function() {\n        return n(cw(this.a), r)\n    }\n    ;\n    X.prototype.GetReactionForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return n(su(c, a), r)\n    }\n    ;\n    X.prototype.GetReactionTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        return bh(c, a)\n    }\n    ;\n    X.prototype.GetNext = function() {\n        return n(dv(this.a), p)\n    }\n    ;\n    X.prototype.GetUserData = function() {\n        return Hc(this.a)\n    }\n    ;\n    X.prototype.SetUserData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        mi(c, a)\n    }\n    ;\n    X.prototype.IsActive = function() {\n        return !!mv(this.a)\n    }\n    ;\n    X.prototype.GetCollideConnected = function() {\n        return !!Qg(this.a)\n    }\n    ;\n    X.prototype.__destroy__ = function() {\n        xh(this.a)\n    }\n    ;\n    function Wx() {\n        this.a = ms();\n        k(Wx)[this.a] = this\n    }\n    Wx.prototype = Object.create(h.prototype);\n    Wx.prototype.constructor = Wx;\n    Wx.prototype.b = Wx;\n    Wx.c = {};\n    b.b2ContactEdge = Wx;\n    Wx.prototype.get_other = function() {\n        return n(Qi(this.a), q)\n    }\n    ;\n    Wx.prototype.set_other = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Fi(c, a)\n    }\n    ;\n    Wx.prototype.get_contact = function() {\n        return n(nn(this.a), E)\n    }\n    ;\n    Wx.prototype.set_contact = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        lu(c, a)\n    }\n    ;\n    Wx.prototype.get_prev = function() {\n        return n(Ug(this.a), Wx)\n    }\n    ;\n    Wx.prototype.set_prev = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Bw(c, a)\n    }\n    ;\n    Wx.prototype.get_next = function() {\n        return n(Og(this.a), Wx)\n    }\n    ;\n    Wx.prototype.set_next = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ub(c, a)\n    }\n    ;\n    Wx.prototype.__destroy__ = function() {\n        Xe(this.a)\n    }\n    ;\n    function Y() {\n        this.a = Xj();\n        k(Y)[this.a] = this\n    }\n    Y.prototype = Object.create(t.prototype);\n    Y.prototype.constructor = Y;\n    Y.prototype.b = Y;\n    Y.c = {};\n    b.b2RopeJointDef = Y;\n    Y.prototype.get_localAnchorA = function() {\n        return n(Zm(this.a), r)\n    }\n    ;\n    Y.prototype.set_localAnchorA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        gs(c, a)\n    }\n    ;\n    Y.prototype.get_localAnchorB = function() {\n        return n(Kq(this.a), r)\n    }\n    ;\n    Y.prototype.set_localAnchorB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        dw(c, a)\n    }\n    ;\n    Y.prototype.get_maxLength = function() {\n        return Fk(this.a)\n    }\n    ;\n    Y.prototype.set_maxLength = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        hl(c, a)\n    }\n    ;\n    Y.prototype.get_type = function() {\n        return zq(this.a)\n    }\n    ;\n    Y.prototype.set_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ok(c, a)\n    }\n    ;\n    Y.prototype.get_userData = function() {\n        return Nn(this.a)\n    }\n    ;\n    Y.prototype.set_userData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Ho(c, a)\n    }\n    ;\n    Y.prototype.get_bodyA = function() {\n        return n(Bu(this.a), q)\n    }\n    ;\n    Y.prototype.set_bodyA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        $f(c, a)\n    }\n    ;\n    Y.prototype.get_bodyB = function() {\n        return n(mw(this.a), q)\n    }\n    ;\n    Y.prototype.set_bodyB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Zd(c, a)\n    }\n    ;\n    Y.prototype.get_collideConnected = function() {\n        return !!uh(this.a)\n    }\n    ;\n    Y.prototype.set_collideConnected = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Tc(c, a)\n    }\n    ;\n    Y.prototype.__destroy__ = function() {\n        Cs(this.a)\n    }\n    ;\n    function Z() {\n        this.a = Mg();\n        k(Z)[this.a] = this\n    }\n    Z.prototype = Object.create(t.prototype);\n    Z.prototype.constructor = Z;\n    Z.prototype.b = Z;\n    Z.c = {};\n    b.b2MotorJointDef = Z;\n    Z.prototype.Initialize = function(a, c) {\n        var d = this.a;\n        a && "object" === typeof a && (a = a.a);\n        c && "object" === typeof c && (c = c.a);\n        hm(d, a, c)\n    }\n    ;\n    Z.prototype.get_linearOffset = function() {\n        return n(gm(this.a), r)\n    }\n    ;\n    Z.prototype.set_linearOffset = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        wo(c, a)\n    }\n    ;\n    Z.prototype.get_angularOffset = function() {\n        return Bt(this.a)\n    }\n    ;\n    Z.prototype.set_angularOffset = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        js(c, a)\n    }\n    ;\n    Z.prototype.get_maxForce = function() {\n        return zc(this.a)\n    }\n    ;\n    Z.prototype.set_maxForce = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        St(c, a)\n    }\n    ;\n    Z.prototype.get_maxTorque = function() {\n        return Gq(this.a)\n    }\n    ;\n    Z.prototype.set_maxTorque = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Vv(c, a)\n    }\n    ;\n    Z.prototype.get_correctionFactor = function() {\n        return qp(this.a)\n    }\n    ;\n    Z.prototype.set_correctionFactor = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        yt(c, a)\n    }\n    ;\n    Z.prototype.get_type = function() {\n        return zr(this.a)\n    }\n    ;\n    Z.prototype.set_type = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        lc(c, a)\n    }\n    ;\n    Z.prototype.get_userData = function() {\n        return mu(this.a)\n    }\n    ;\n    Z.prototype.set_userData = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        qd(c, a)\n    }\n    ;\n    Z.prototype.get_bodyA = function() {\n        return n(ww(this.a), q)\n    }\n    ;\n    Z.prototype.set_bodyA = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        ql(c, a)\n    }\n    ;\n    Z.prototype.get_bodyB = function() {\n        return n(Gu(this.a), q)\n    }\n    ;\n    Z.prototype.set_bodyB = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        Fs(c, a)\n    }\n    ;\n    Z.prototype.get_collideConnected = function() {\n        return !!Fd(this.a)\n    }\n    ;\n    Z.prototype.set_collideConnected = function(a) {\n        var c = this.a;\n        a && "object" === typeof a && (a = a.a);\n        hw(c, a)\n    }\n    ;\n    Z.prototype.__destroy__ = function() {\n        vs(this.a)\n    }\n    ;\n    (function() {\n        function a() {\n            b.b2Shape.e_circle = pk();\n            b.b2Shape.e_edge = Mj();\n            b.b2Shape.e_polygon = Yu();\n            b.b2Shape.e_chain = $n();\n            b.b2Shape.e_typeCount = Mt();\n            b.e_unknownJoint = ii();\n            b.e_revoluteJoint = wi();\n            b.e_prismaticJoint = kr();\n            b.e_distanceJoint = mo();\n            b.e_pulleyJoint = qf();\n            b.e_mouseJoint = At();\n            b.e_gearJoint = rt();\n            b.e_wheelJoint = Ve();\n            b.e_weldJoint = Dm();\n            b.e_frictionJoint = Rd();\n            b.e_ropeJoint = Qv();\n            b.e_motorJoint = xo();\n            b.e_inactiveLimit = Tu();\n            b.e_atLowerLimit = wn();\n            b.e_atUpperLimit = Pw();\n            b.e_equalLimits = Qh();\n            b.b2Manifold.e_circles = Gd();\n            b.b2Manifold.e_faceA = Fj();\n            b.b2Manifold.e_faceB = Gj();\n            b.b2_staticBody = km();\n            b.b2_kinematicBody = Dj();\n            b.b2_dynamicBody = Eq();\n            b.b2Draw.e_shapeBit = Th();\n            b.b2Draw.e_jointBit = Hf();\n            b.b2Draw.e_aabbBit = ur();\n            b.b2Draw.e_pairBit = Vr();\n            b.b2Draw.e_centerOfMassBit = Fo();\n            b.b2ContactFeature.e_vertex = Ko();\n            b.b2ContactFeature.e_face = Ul()\n        }\n        b.calledRun ? a() : kb.unshift(a)\n    }\n    )();\n\n    return Box2D;\n}\n;\n\n	<\/script>\n	\n	<noscript>\n		<div id="notSupportedWrap">\n			<h2 id="notSupportedTitle">This content requires JavaScript<\/h2>\n			<p class="notSupportedMessage">JavaScript appears to be disabled. Please enable it to view this content.<\/p>\n		<\/div>\n	<\/noscript>\n	\n	\n	<script>\n	   \'use strict\';\n(function() {\n    var isKasperskyScriptInjected = !!document.querySelector(\'script[src*="kaspersky"]\');\n    var tmpCanvas = document.createElement("canvas");\n    var hasWebGL = !!tmpCanvas.getContext("webgl");\n    var missingFeatures = [];\n    if (!hasWebGL)\n        missingFeatures.push("WebGL");\n    if (typeof WebAssembly === "undefined")\n        missingFeatures.push("WebAssembly");\n    if (!("noModule"in HTMLScriptElement.prototype))\n        missingFeatures.push("JavaScript Modules");\n    if (missingFeatures.length === 0 && !isKasperskyScriptInjected)\n        window["C3_IsSupported"] = true;\n    else {\n        var msgWrap = document.createElement("div");\n        msgWrap.id = "notSupportedWrap";\n        document.body.appendChild(msgWrap);\n        var msgTitle = document.createElement("h2");\n        msgTitle.id = "notSupportedTitle";\n        if (isKasperskyScriptInjected)\n            msgTitle.textContent = "Kaspersky Internet Security broke this export";\n        else\n            msgTitle.textContent = "Software update needed";\n        msgWrap.appendChild(msgTitle);\n        var msgBody = document.createElement("p");\n        msgBody.className = "notSupportedMessage";\n        var msgText = "This content is not supported because your device\'s software is out-of-date. ";\n        var ua = navigator.userAgent;\n        if (\/android\/i.test(ua))\n            msgText += \'<br><br>On Android, fix this by making sure the <a href="https:\/\/play.google.com\/store\/apps\/details?id=com.google.android.webview">Android System Webview<\/a> app has updates enabled and is up-to-date.\';\n        else if (\/iphone|ipad|ipod\/i.test(ua))\n            msgText += "<br><br>Note: using the <strong>iOS simulator<\/strong> requires <strong>Xcode 12+<\/strong>. Otherwise try testing on a real device instead.";\n        else if (\/msie\/i.test(ua) || \/trident\/i.test(ua) || \/edge\\\/\/i.test(ua))\n            msgText += "<br><br>Note: <strong>Internet Explorer<\/strong> and the <strong>legacy Edge browser<\/strong> are not supported. Try using <a href=\'https:\/\/www.google.com\/chrome\'>Chrome<\/a> or <a href=\'https:\/\/www.mozilla.org\/firefox\'>Firefox<\/a> instead.";\n        else if (isKasperskyScriptInjected)\n            msgText = "It appears a script was added to this export by Kaspersky software. This prevents the exported project from working. Try disabling Kaspersky and exporting again.";\n        else\n            msgText += "Try installing any available software updates. Alternatively try on a different device.";\n        msgText += "<br><br><em>Missing features: " + missingFeatures.join(", ") + "<br>User agent: " + navigator.userAgent + "<\/em>";\n        msgBody.innerHTML = msgText;\n        msgWrap.appendChild(msgBody)\n    }\n}\n)();\n\n	    \n	   \n	<\/script>\n	<script type="module">\n	    \n	    \n	    \'use strict\';\n{\n    class OfflineClient {\n        constructor() {\n            this._broadcastChannel = typeof BroadcastChannel === "undefined" ? null : new BroadcastChannel("offline");\n            this._queuedMessages = [];\n            this._onMessageCallback = null;\n            if (this._broadcastChannel)\n                this._broadcastChannel.onmessage = e => this._OnBroadcastChannelMessage(e)\n        }\n        _OnBroadcastChannelMessage(e) {\n            if (this._onMessageCallback) {\n                this._onMessageCallback(e);\n                return\n            }\n            this._queuedMessages.push(e)\n        }\n        SetMessageCallback(f) {\n            this._onMessageCallback = f;\n            for (let e of this._queuedMessages)\n                this._onMessageCallback(e);\n            this._queuedMessages.length = 0\n        }\n    }\n    window.OfflineClientInfo = new OfflineClient\n}\n;\n	<\/script>\n	<script type="module">\n	    \n	    \n	    \'use strict\';\n{\n    window.DOMHandler = class DOMHandler {\n        constructor(iRuntime, componentId) {\n            this._iRuntime = iRuntime;\n            this._componentId = componentId;\n            this._hasTickCallback = false;\n            this._tickCallback = () => this.Tick()\n        }\n        Attach() {}\n        PostToRuntime(handler, data, dispatchOpts, transferables) {\n            this._iRuntime.PostToRuntimeComponent(this._componentId, handler, data, dispatchOpts, transferables)\n        }\n        PostToRuntimeAsync(handler, data, dispatchOpts, transferables) {\n            return this._iRuntime.PostToRuntimeComponentAsync(this._componentId, handler, data, dispatchOpts, transferables)\n        }\n        _PostToRuntimeMaybeSync(name, data, dispatchOpts) {\n            if (this._iRuntime.UsesWorker())\n                this.PostToRuntime(name, data, dispatchOpts);\n            else\n                this._iRuntime._GetLocalRuntime()["_OnMessageFromDOM"]({\n                    "type": "event",\n                    "component": this._componentId,\n                    "handler": name,\n                    "dispatchOpts": dispatchOpts || null,\n                    "data": data,\n                    "responseId": null\n                })\n        }\n        AddRuntimeMessageHandler(handler, func) {\n            this._iRuntime.AddRuntimeComponentMessageHandler(this._componentId, handler, func)\n        }\n        AddRuntimeMessageHandlers(list) {\n            for (const [handler,func] of list)\n                this.AddRuntimeMessageHandler(handler, func)\n        }\n        GetRuntimeInterface() {\n            return this._iRuntime\n        }\n        GetComponentID() {\n            return this._componentId\n        }\n        _StartTicking() {\n            if (this._hasTickCallback)\n                return;\n            this._iRuntime._AddRAFCallback(this._tickCallback);\n            this._hasTickCallback = true\n        }\n        _StopTicking() {\n            if (!this._hasTickCallback)\n                return;\n            this._iRuntime._RemoveRAFCallback(this._tickCallback);\n            this._hasTickCallback = false\n        }\n        Tick() {}\n    }\n    ;\n    window.RateLimiter = class RateLimiter {\n        constructor(callback, interval) {\n            this._callback = callback;\n            this._interval = interval;\n            this._timerId = -1;\n            this._lastCallTime = -Infinity;\n            this._timerCallFunc = () => this._OnTimer();\n            this._ignoreReset = false;\n            this._canRunImmediate = false\n        }\n        SetCanRunImmediate(c) {\n            this._canRunImmediate = !!c\n        }\n        Call() {\n            if (this._timerId !== -1)\n                return;\n            const nowTime = Date.now();\n            const timeSinceLastCall = nowTime - this._lastCallTime;\n            const interval = this._interval;\n            if (timeSinceLastCall >= interval && this._canRunImmediate) {\n                this._lastCallTime = nowTime;\n                this._RunCallback()\n            } else\n                this._timerId = self.setTimeout(this._timerCallFunc, Math.max(interval - timeSinceLastCall, 4))\n        }\n        _RunCallback() {\n            this._ignoreReset = true;\n            this._callback();\n            this._ignoreReset = false\n        }\n        Reset() {\n            if (this._ignoreReset)\n                return;\n            this._CancelTimer();\n            this._lastCallTime = Date.now()\n        }\n        _OnTimer() {\n            this._timerId = -1;\n            this._lastCallTime = Date.now();\n            this._RunCallback()\n        }\n        _CancelTimer() {\n            if (this._timerId !== -1) {\n                self.clearTimeout(this._timerId);\n                this._timerId = -1\n            }\n        }\n        Release() {\n            this._CancelTimer();\n            this._callback = null;\n            this._timerCallFunc = null\n        }\n    }\n}\n;\n\'use strict\';\n{\n    window.DOMElementHandler = class DOMElementHandler extends self.DOMHandler {\n        constructor(iRuntime, componentId) {\n            super(iRuntime, componentId);\n            this._elementMap = new Map;\n            this._autoAttach = true;\n            this.AddRuntimeMessageHandlers([["create", e => this._OnCreate(e)], ["destroy", e => this._OnDestroy(e)], ["set-visible", e => this._OnSetVisible(e)], ["update-position", e => this._OnUpdatePosition(e)], ["update-state", e => this._OnUpdateState(e)], ["focus", e => this._OnSetFocus(e)], ["set-css-style", e => this._OnSetCssStyle(e)], ["set-attribute", e => this._OnSetAttribute(e)], ["remove-attribute", e => this._OnRemoveAttribute(e)]]);\n            this.AddDOMElementMessageHandler("get-element", elem => elem)\n        }\n        SetAutoAttach(e) {\n            this._autoAttach = !!e\n        }\n        AddDOMElementMessageHandler(handler, func) {\n            this.AddRuntimeMessageHandler(handler, e => {\n                const elementId = e["elementId"];\n                const elem = this._elementMap.get(elementId);\n                return func(elem, e)\n            }\n            )\n        }\n        _OnCreate(e) {\n            const elementId = e["elementId"];\n            const elem = this.CreateElement(elementId, e);\n            this._elementMap.set(elementId, elem);\n            elem.style.boxSizing = "border-box";\n            if (!e["isVisible"])\n                elem.style.display = "none";\n            const focusElem = this._GetFocusElement(elem);\n            focusElem.addEventListener("focus", e => this._OnFocus(elementId));\n            focusElem.addEventListener("blur", e => this._OnBlur(elementId));\n            if (this._autoAttach)\n                document.body.appendChild(elem)\n        }\n        CreateElement(elementId, e) {\n            throw new Error("required override");\n        }\n        DestroyElement(elem) {}\n        _OnDestroy(e) {\n            const elementId = e["elementId"];\n            const elem = this._elementMap.get(elementId);\n            this.DestroyElement(elem);\n            if (this._autoAttach)\n                elem.parentElement.removeChild(elem);\n            this._elementMap.delete(elementId)\n        }\n        PostToRuntimeElement(handler, elementId, data) {\n            if (!data)\n                data = {};\n            data["elementId"] = elementId;\n            this.PostToRuntime(handler, data)\n        }\n        _PostToRuntimeElementMaybeSync(handler, elementId, data) {\n            if (!data)\n                data = {};\n            data["elementId"] = elementId;\n            this._PostToRuntimeMaybeSync(handler, data)\n        }\n        _OnSetVisible(e) {\n            if (!this._autoAttach)\n                return;\n            const elem = this._elementMap.get(e["elementId"]);\n            elem.style.display = e["isVisible"] ? "" : "none"\n        }\n        _OnUpdatePosition(e) {\n            if (!this._autoAttach)\n                return;\n            const elem = this._elementMap.get(e["elementId"]);\n            elem.style.left = e["left"] + "px";\n            elem.style.top = e["top"] + "px";\n            elem.style.width = e["width"] + "px";\n            elem.style.height = e["height"] + "px";\n            const fontSize = e["fontSize"];\n            if (fontSize !== null)\n                elem.style.fontSize = fontSize + "em"\n        }\n        _OnUpdateState(e) {\n            const elem = this._elementMap.get(e["elementId"]);\n            this.UpdateState(elem, e)\n        }\n        UpdateState(elem, e) {\n            throw new Error("required override");\n        }\n        _GetFocusElement(elem) {\n            return elem\n        }\n        _OnFocus(elementId) {\n            this.PostToRuntimeElement("elem-focused", elementId)\n        }\n        _OnBlur(elementId) {\n            this.PostToRuntimeElement("elem-blurred", elementId)\n        }\n        _OnSetFocus(e) {\n            const elem = this._GetFocusElement(this._elementMap.get(e["elementId"]));\n            if (e["focus"])\n                elem.focus();\n            else\n                elem.blur()\n        }\n        _OnSetCssStyle(e) {\n            const elem = this._elementMap.get(e["elementId"]);\n            elem.style[e["prop"]] = e["val"]\n        }\n        _OnSetAttribute(e) {\n            const elem = this._elementMap.get(e["elementId"]);\n            elem.setAttribute(e["name"], e["val"])\n        }\n        _OnRemoveAttribute(e) {\n            const elem = this._elementMap.get(e["elementId"]);\n            elem.removeAttribute(e["name"])\n        }\n        GetElementById(elementId) {\n            return this._elementMap.get(elementId)\n        }\n    }\n}\n;\n\'use strict\';\n{\n    const isiOSLike = \/(iphone|ipod|ipad|macos|macintosh|mac os x)\/i.test(navigator.userAgent);\n    const isAndroid = \/android\/i.test(navigator.userAgent);\n    let resolveCounter = 0;\n    function AddScript(url) {\n        const elem = document.createElement("script");\n        elem.async = false;\n        elem.type = "module";\n        if (url.isStringSrc)\n            return new Promise(resolve => {\n                const resolveName = "c3_resolve_" + resolveCounter;\n                ++resolveCounter;\n                self[resolveName] = resolve;\n                elem.textContent = url.str + `\\n\\nself["${resolveName}"]();`;\n                document.head.appendChild(elem)\n            }\n            );\n        else\n            return new Promise( (resolve, reject) => {\n                elem.onload = resolve;\n                elem.onerror = reject;\n                elem.src = url;\n                document.head.appendChild(elem)\n            }\n            )\n    }\n    let didCheckWorkerModuleSupport = false;\n    let isWorkerModuleSupported = false;\n    function SupportsWorkerTypeModule() {\n        if (!didCheckWorkerModuleSupport) {\n            try {\n                new Worker("blob:\/\/",{\n                    get type() {\n                        isWorkerModuleSupported = true\n                    }\n                })\n            } catch (e) {}\n            didCheckWorkerModuleSupport = true\n        }\n        return isWorkerModuleSupported\n    }\n    let tmpAudio = new Audio;\n    const supportedAudioFormats = {\n        "audio\/webm; codecs=opus": !!tmpAudio.canPlayType("audio\/webm; codecs=opus"),\n        "audio\/ogg; codecs=opus": !!tmpAudio.canPlayType("audio\/ogg; codecs=opus"),\n        "audio\/webm; codecs=vorbis": !!tmpAudio.canPlayType("audio\/webm; codecs=vorbis"),\n        "audio\/ogg; codecs=vorbis": !!tmpAudio.canPlayType("audio\/ogg; codecs=vorbis"),\n        "audio\/mp4": !!tmpAudio.canPlayType("audio\/mp4"),\n        "audio\/mpeg": !!tmpAudio.canPlayType("audio\/mpeg")\n    };\n    tmpAudio = null;\n    async function BlobToString(blob) {\n        const arrayBuffer = await BlobToArrayBuffer(blob);\n        const textDecoder = new TextDecoder("utf-8");\n        return textDecoder.decode(arrayBuffer)\n    }\n    function BlobToArrayBuffer(blob) {\n        return new Promise( (resolve, reject) => {\n            const fileReader = new FileReader;\n            fileReader.onload = e => resolve(e.target.result);\n            fileReader.onerror = err => reject(err);\n            fileReader.readAsArrayBuffer(blob)\n        }\n        )\n    }\n    const queuedArrayBufferReads = [];\n    let activeArrayBufferReads = 0;\n    const MAX_ARRAYBUFFER_READS = 8;\n    window["RealFile"] = window["File"];\n    const domHandlerClasses = [];\n    const runtimeEventHandlers = new Map;\n    const pendingResponsePromises = new Map;\n    let nextResponseId = 0;\n    const runOnStartupFunctions = [];\n    self.runOnStartup = function runOnStartup(f) {\n        if (typeof f !== "function")\n            throw new Error("runOnStartup called without a function");\n        runOnStartupFunctions.push(f)\n    }\n    ;\n    const WEBVIEW_EXPORT_TYPES = new Set(["cordova", "playable-ad", "instant-games"]);\n    function IsWebViewExportType(exportType) {\n        return WEBVIEW_EXPORT_TYPES.has(exportType)\n    }\n    let isWrapperFullscreen = false;\n    window.RuntimeInterface = class RuntimeInterface {\n        constructor(opts) {\n            this._useWorker = opts.useWorker;\n            this._messageChannelPort = null;\n            this._runtimeBaseUrl = "";\n            this._scriptFolder = opts.scriptFolder;\n            this._workerScriptURLs = {};\n            this._worker = null;\n            this._localRuntime = null;\n            this._domHandlers = [];\n            this._runtimeDomHandler = null;\n            this._canvas = null;\n            this._isExportingToVideo = false;\n            this._exportToVideoDuration = 0;\n            this._jobScheduler = null;\n            this._rafId = -1;\n            this._rafFunc = () => this._OnRAFCallback();\n            this._rafCallbacks = [];\n            this._exportType = opts.exportType;\n            this._isFileProtocol = location.protocol.substr(0, 4) === "file";\n            if (this._useWorker && (typeof OffscreenCanvas === "undefined" || !navigator["userActivation"] || !SupportsWorkerTypeModule()))\n                this._useWorker = false;\n            if (this._exportType === "playable-ad" || this._exportType === "instant-games")\n                this._useWorker = false;\n            if (this._exportType === "cordova" && this._useWorker)\n                if (isAndroid) {\n                    const chromeVer = \/Chrome\\\/(\\d+)\/i.exec(navigator.userAgent);\n                    if (!chromeVer || !(parseInt(chromeVer[1], 10) >= 90))\n                        this._useWorker = false\n                } else\n                    this._useWorker = false;\n            this._localFileBlobs = null;\n            this._localFileStrings = null;\n            if (this._exportType === "html5" && !window.isSecureContext)\n                console.warn("[Construct] Warning: the browser indicates this is not a secure context. Some features may be unavailable. Use secure (HTTPS) hosting to ensure all features are available.");\n            this.AddRuntimeComponentMessageHandler("runtime", "cordova-fetch-local-file", e => this._OnCordovaFetchLocalFile(e));\n            this.AddRuntimeComponentMessageHandler("runtime", "create-job-worker", e => this._OnCreateJobWorker(e));\n            if (this._exportType === "cordova")\n                document.addEventListener("deviceready", () => this._Init(opts));\n            else\n                this._Init(opts)\n        }\n        Release() {\n            this._CancelAnimationFrame();\n            if (this._messageChannelPort) {\n                this._messageChannelPort.onmessage = null;\n                this._messageChannelPort = null\n            }\n            if (this._worker) {\n                this._worker.terminate();\n                this._worker = null\n            }\n            if (this._localRuntime) {\n                this._localRuntime.Release();\n                this._localRuntime = null\n            }\n            if (this._canvas) {\n                this._canvas.parentElement.removeChild(this._canvas);\n                this._canvas = null\n            }\n        }\n        GetCanvas() {\n            return this._canvas\n        }\n        GetRuntimeBaseURL() {\n            return this._runtimeBaseUrl\n        }\n        UsesWorker() {\n            return this._useWorker\n        }\n        GetExportType() {\n            return this._exportType\n        }\n        IsFileProtocol() {\n            return this._isFileProtocol\n        }\n        GetScriptFolder() {\n            return this._scriptFolder\n        }\n        IsiOSCordova() {\n            return isiOSLike && this._exportType === "cordova"\n        }\n        IsiOSWebView() {\n            const ua = navigator.userAgent;\n            return isiOSLike && IsWebViewExportType(this._exportType) || navigator["standalone"] || \/crios\\\/|fxios\\\/|edgios\\\/\/i.test(ua)\n        }\n        IsAndroid() {\n            return isAndroid\n        }\n        IsAndroidWebView() {\n            return isAndroid && IsWebViewExportType(this._exportType)\n        }\n        async _Init(opts) {\n            if (this._exportType === "macos-wkwebview")\n                this._SendWrapperMessage({\n                    "type": "ready"\n                });\n            if (this._exportType === "playable-ad") {\n                this._localFileBlobs = self["c3_base64files"];\n                this._localFileStrings = {};\n                await this._ConvertDataUrisToBlobs();\n                for (let i = 0, len = opts.engineScripts.length; i < len; ++i) {\n                    const src = opts.engineScripts[i].toLowerCase();\n                    if (this._localFileStrings.hasOwnProperty(src))\n                        opts.engineScripts[i] = {\n                            isStringSrc: true,\n                            str: this._localFileStrings[src]\n                        };\n                    else if (this._localFileBlobs.hasOwnProperty(src))\n                        opts.engineScripts[i] = URL.createObjectURL(this._localFileBlobs[src])\n                }\n            }\n            if (opts.runtimeBaseUrl)\n                this._runtimeBaseUrl = opts.runtimeBaseUrl;\n            else {\n                const origin = location.origin;\n                this._runtimeBaseUrl = (origin === "null" ? "file:\/\/\/" : origin) + location.pathname;\n                const i = this._runtimeBaseUrl.lastIndexOf("\/");\n                if (i !== -1)\n                    this._runtimeBaseUrl = this._runtimeBaseUrl.substr(0, i + 1)\n            }\n            if (opts.workerScripts)\n                this._workerScriptURLs = opts.workerScripts;\n            const messageChannel = new MessageChannel;\n            this._messageChannelPort = messageChannel.port1;\n            this._messageChannelPort.onmessage = e => this["_OnMessageFromRuntime"](e.data);\n            if (window["c3_addPortMessageHandler"])\n                window["c3_addPortMessageHandler"](e => this._OnMessageFromDebugger(e));\n            this._jobScheduler = new self.JobSchedulerDOM(this);\n            await this._jobScheduler.Init();\n            if (typeof window["StatusBar"] === "object")\n                window["StatusBar"]["hide"]();\n            if (typeof window["AndroidFullScreen"] === "object")\n                try {\n                    await new Promise( (resolve, reject) => {\n                        window["AndroidFullScreen"]["immersiveMode"](resolve, reject)\n                    }\n                    )\n                } catch (err) {\n                    console.error("Failed to enter Android immersive mode: ", err)\n                }\n            if (this._useWorker)\n                await this._InitWorker(opts, messageChannel.port2);\n            else\n                await this._InitDOM(opts, messageChannel.port2)\n        }\n        _GetWorkerURL(url) {\n            let ret;\n            if (this._workerScriptURLs.hasOwnProperty(url))\n                ret = this._workerScriptURLs[url];\n            else if (url.endsWith("\/workermain.js") && this._workerScriptURLs.hasOwnProperty("workermain.js"))\n                ret = this._workerScriptURLs["workermain.js"];\n            else if (this._exportType === "playable-ad" && this._localFileBlobs.hasOwnProperty(url.toLowerCase()))\n                ret = this._localFileBlobs[url.toLowerCase()];\n            else\n                ret = url;\n            if (ret instanceof Blob)\n                ret = URL.createObjectURL(ret);\n            return ret\n        }\n        async CreateWorker(url, baseUrl, workerOpts) {\n            if (url.startsWith("blob:"))\n                return new Worker(url,workerOpts);\n            if (this._exportType === "cordova" && this._isFileProtocol) {\n                let filePath = "";\n                if (workerOpts.isC3MainWorker)\n                    filePath = url;\n                else\n                    filePath = this._scriptFolder + url;\n                const arrayBuffer = await this.CordovaFetchLocalFileAsArrayBuffer(filePath);\n                const blob = new Blob([arrayBuffer],{\n                    type: "application\/javascript"\n                });\n                return new Worker(URL.createObjectURL(blob),workerOpts)\n            }\n            const absUrl = new URL(url,baseUrl);\n            const isCrossOrigin = location.origin !== absUrl.origin;\n            if (isCrossOrigin) {\n                const response = await fetch(absUrl);\n                if (!response.ok)\n                    throw new Error("failed to fetch worker script");\n                const blob = await response.blob();\n                return new Worker(URL.createObjectURL(blob),workerOpts)\n            } else\n                return new Worker(absUrl,workerOpts)\n        }\n        _GetWindowInnerWidth() {\n            return Math.max(window.innerWidth, 1)\n        }\n        _GetWindowInnerHeight() {\n            return Math.max(window.innerHeight, 1)\n        }\n        _GetCommonRuntimeOptions(opts) {\n            return {\n                "runtimeBaseUrl": this._runtimeBaseUrl,\n                "previewUrl": location.href,\n                "windowInnerWidth": this._GetWindowInnerWidth(),\n                "windowInnerHeight": this._GetWindowInnerHeight(),\n                "devicePixelRatio": window.devicePixelRatio,\n                "isFullscreen": RuntimeInterface.IsDocumentFullscreen(),\n                "projectData": opts.projectData,\n                "previewImageBlobs": window["cr_previewImageBlobs"] || this._localFileBlobs,\n                "previewProjectFileBlobs": window["cr_previewProjectFileBlobs"],\n                "previewProjectFileSWUrls": window["cr_previewProjectFiles"],\n                "swClientId": window.cr_swClientId || "",\n                "exportType": opts.exportType,\n                "isDebug": (new URLSearchParams(self.location.search)).has("debug"),\n                "ife": !!self.ife,\n                "jobScheduler": this._jobScheduler.GetPortData(),\n                "supportedAudioFormats": supportedAudioFormats,\n                "opusWasmScriptUrl": window["cr_opusWasmScriptUrl"] || this._scriptFolder + "opus.wasm.js",\n                "opusWasmBinaryUrl": window["cr_opusWasmBinaryUrl"] || this._scriptFolder + "opus.wasm.wasm",\n                "isFileProtocol": this._isFileProtocol,\n                "isiOSCordova": this.IsiOSCordova(),\n                "isiOSWebView": this.IsiOSWebView(),\n                "isFBInstantAvailable": typeof self["FBInstant"] !== "undefined"\n            }\n        }\n        async _InitWorker(opts, port2) {\n            const workerMainUrl = this._GetWorkerURL(opts.workerMainUrl);\n            this._worker = await this.CreateWorker(workerMainUrl, this._runtimeBaseUrl, {\n                type: "module",\n                name: "Runtime",\n                isC3MainWorker: true\n            });\n            this._canvas = document.createElement("canvas");\n            this._canvas.style.display = "none";\n            const offscreenCanvas = this._canvas["transferControlToOffscreen"]();\n            document.body.appendChild(this._canvas);\n            window["c3canvas"] = this._canvas;\n            if (self["C3_InsertHTMLPlaceholders"])\n                self["C3_InsertHTMLPlaceholders"]();\n            let workerDependencyScripts = opts.workerDependencyScripts || [];\n            let engineScripts = opts.engineScripts;\n            workerDependencyScripts = await Promise.all(workerDependencyScripts.map(url => this._MaybeGetCordovaScriptURL(url)));\n            engineScripts = await Promise.all(engineScripts.map(url => this._MaybeGetCordovaScriptURL(url)));\n            if (this._exportType === "cordova")\n                for (let i = 0, len = opts.projectScripts.length; i < len; ++i) {\n                    const info = opts.projectScripts[i];\n                    const originalUrl = info[0];\n                    if (originalUrl === opts.mainProjectScript || (originalUrl === "scriptsInEvents.js" || originalUrl.endsWith("\/scriptsInEvents.js")))\n                        info[1] = await this._MaybeGetCordovaScriptURL(originalUrl)\n                }\n            this._worker.postMessage(Object.assign(this._GetCommonRuntimeOptions(opts), {\n                "type": "init-runtime",\n                "isInWorker": true,\n                "messagePort": port2,\n                "canvas": offscreenCanvas,\n                "workerDependencyScripts": workerDependencyScripts,\n                "engineScripts": engineScripts,\n                "projectScripts": opts.projectScripts,\n                "mainProjectScript": opts.mainProjectScript,\n                "projectScriptsStatus": self["C3_ProjectScriptsStatus"]\n            }), [port2, offscreenCanvas, ...this._jobScheduler.GetPortTransferables()]);\n            this._domHandlers = domHandlerClasses.map(C => new C(this));\n            this._FindRuntimeDOMHandler();\n            self["c3_callFunction"] = (name, params) => this._runtimeDomHandler._InvokeFunctionFromJS(name, params);\n            if (this._exportType === "preview")\n                self["goToLastErrorScript"] = () => this.PostToRuntimeComponent("runtime", "go-to-last-error-script")\n        }\n        async _InitDOM(opts, port2) {\n            this._canvas = document.createElement("canvas");\n            this._canvas.style.display = "none";\n            document.body.appendChild(this._canvas);\n            window["c3canvas"] = this._canvas;\n            if (self["C3_InsertHTMLPlaceholders"])\n                self["C3_InsertHTMLPlaceholders"]();\n            this._domHandlers = domHandlerClasses.map(C => new C(this));\n            this._FindRuntimeDOMHandler();\n            let engineScripts = opts.engineScripts.map(url => typeof url === "string" ? (new URL(url,this._runtimeBaseUrl)).toString() : url);\n            if (Array.isArray(opts.workerDependencyScripts))\n                engineScripts.unshift(...opts.workerDependencyScripts);\n            engineScripts = await Promise.all(engineScripts.map(url => this._MaybeGetCordovaScriptURL(url)));\n            await Promise.all(engineScripts.map(url => AddScript(url)));\n            const scriptsStatus = self["C3_ProjectScriptsStatus"];\n            const mainProjectScript = opts.mainProjectScript;\n            const allProjectScripts = opts.projectScripts;\n            for (let[originalUrl,loadUrl] of allProjectScripts) {\n                if (!loadUrl)\n                    loadUrl = originalUrl;\n                if (originalUrl === mainProjectScript)\n                    try {\n                        loadUrl = await this._MaybeGetCordovaScriptURL(loadUrl);\n                        await AddScript(loadUrl);\n                        if (this._exportType === "preview" && !scriptsStatus[originalUrl])\n                            this._ReportProjectMainScriptError(originalUrl, "main script did not run to completion")\n                    } catch (err) {\n                        this._ReportProjectMainScriptError(originalUrl, err)\n                    }\n                else if (originalUrl === "scriptsInEvents.js" || originalUrl.endsWith("\/scriptsInEvents.js")) {\n                    loadUrl = await this._MaybeGetCordovaScriptURL(loadUrl);\n                    await AddScript(loadUrl)\n                }\n            }\n            if (this._exportType === "preview" && typeof self.C3.ScriptsInEvents !== "object") {\n                this._RemoveLoadingMessage();\n                const msg = "Failed to load JavaScript code used in events. Check all your JavaScript code has valid syntax.";\n                console.error("[C3 runtime] " + msg);\n                alert(msg);\n                return\n            }\n            const runtimeOpts = Object.assign(this._GetCommonRuntimeOptions(opts), {\n                "isInWorker": false,\n                "messagePort": port2,\n                "canvas": this._canvas,\n                "runOnStartupFunctions": runOnStartupFunctions\n            });\n            this._OnBeforeCreateRuntime();\n            this._localRuntime = self["C3_CreateRuntime"](runtimeOpts);\n            await self["C3_InitRuntime"](this._localRuntime, runtimeOpts)\n        }\n        _ReportProjectMainScriptError(url, err) {\n            this._RemoveLoadingMessage();\n            console.error(`[Preview] Failed to load project main script (${url}): `, err);\n            alert(`Failed to load project main script (${url}). Check all your JavaScript code has valid syntax. Press F12 and check the console for error details.`)\n        }\n        _OnBeforeCreateRuntime() {\n            this._RemoveLoadingMessage()\n        }\n        _RemoveLoadingMessage() {\n            const loadingElem = window.cr_previewLoadingElem;\n            if (loadingElem) {\n                loadingElem.parentElement.removeChild(loadingElem);\n                window.cr_previewLoadingElem = null\n            }\n        }\n        async _OnCreateJobWorker(e) {\n            const outputPort = await this._jobScheduler._CreateJobWorker();\n            return {\n                "outputPort": outputPort,\n                "transferables": [outputPort]\n            }\n        }\n        _GetLocalRuntime() {\n            if (this._useWorker)\n                throw new Error("not available in worker mode");\n            return this._localRuntime\n        }\n        PostToRuntimeComponent(component, handler, data, dispatchOpts, transferables) {\n            this._messageChannelPort.postMessage({\n                "type": "event",\n                "component": component,\n                "handler": handler,\n                "dispatchOpts": dispatchOpts || null,\n                "data": data,\n                "responseId": null\n            }, transferables)\n        }\n        PostToRuntimeComponentAsync(component, handler, data, dispatchOpts, transferables) {\n            const responseId = nextResponseId++;\n            const ret = new Promise( (resolve, reject) => {\n                pendingResponsePromises.set(responseId, {\n                    resolve,\n                    reject\n                })\n            }\n            );\n            this._messageChannelPort.postMessage({\n                "type": "event",\n                "component": component,\n                "handler": handler,\n                "dispatchOpts": dispatchOpts || null,\n                "data": data,\n                "responseId": responseId\n            }, transferables);\n            return ret\n        }\n        ["_OnMessageFromRuntime"](data) {\n            const type = data["type"];\n            if (type === "event")\n                return this._OnEventFromRuntime(data);\n            else if (type === "result")\n                this._OnResultFromRuntime(data);\n            else if (type === "runtime-ready")\n                this._OnRuntimeReady();\n            else if (type === "alert-error") {\n                this._RemoveLoadingMessage();\n                alert(data["message"])\n            } else if (type === "creating-runtime")\n                this._OnBeforeCreateRuntime();\n            else\n                throw new Error(`unknown message \'${type}\'`);\n        }\n        _OnEventFromRuntime(e) {\n            const component = e["component"];\n            const handler = e["handler"];\n            const data = e["data"];\n            const responseId = e["responseId"];\n            const handlerMap = runtimeEventHandlers.get(component);\n            if (!handlerMap) {\n                console.warn(`[DOM] No event handlers for component \'${component}\'`);\n                return\n            }\n            const func = handlerMap.get(handler);\n            if (!func) {\n                console.warn(`[DOM] No handler \'${handler}\' for component \'${component}\'`);\n                return\n            }\n            let ret = null;\n            try {\n                ret = func(data)\n            } catch (err) {\n                console.error(`Exception in \'${component}\' handler \'${handler}\':`, err);\n                if (responseId !== null)\n                    this._PostResultToRuntime(responseId, false, "" + err);\n                return\n            }\n            if (responseId === null)\n                return ret;\n            else if (ret && ret.then)\n                ret.then(result => this._PostResultToRuntime(responseId, true, result)).catch(err => {\n                    console.error(`Rejection from \'${component}\' handler \'${handler}\':`, err);\n                    this._PostResultToRuntime(responseId, false, "" + err)\n                }\n                );\n            else\n                this._PostResultToRuntime(responseId, true, ret)\n        }\n        _PostResultToRuntime(responseId, isOk, result) {\n            let transferables;\n            if (result && result["transferables"])\n                transferables = result["transferables"];\n            this._messageChannelPort.postMessage({\n                "type": "result",\n                "responseId": responseId,\n                "isOk": isOk,\n                "result": result\n            }, transferables)\n        }\n        _OnResultFromRuntime(data) {\n            const responseId = data["responseId"];\n            const isOk = data["isOk"];\n            const result = data["result"];\n            const pendingPromise = pendingResponsePromises.get(responseId);\n            if (isOk)\n                pendingPromise.resolve(result);\n            else\n                pendingPromise.reject(result);\n            pendingResponsePromises.delete(responseId)\n        }\n        AddRuntimeComponentMessageHandler(component, handler, func) {\n            let handlerMap = runtimeEventHandlers.get(component);\n            if (!handlerMap) {\n                handlerMap = new Map;\n                runtimeEventHandlers.set(component, handlerMap)\n            }\n            if (handlerMap.has(handler))\n                throw new Error(`[DOM] Component \'${component}\' already has handler \'${handler}\'`);\n            handlerMap.set(handler, func)\n        }\n        static AddDOMHandlerClass(Class) {\n            if (domHandlerClasses.includes(Class))\n                throw new Error("DOM handler already added");\n            domHandlerClasses.push(Class)\n        }\n        _FindRuntimeDOMHandler() {\n            for (const dh of this._domHandlers)\n                if (dh.GetComponentID() === "runtime") {\n                    this._runtimeDomHandler = dh;\n                    return\n                }\n            throw new Error("cannot find runtime DOM handler");\n        }\n        _OnMessageFromDebugger(e) {\n            this.PostToRuntimeComponent("debugger", "message", e)\n        }\n        _OnRuntimeReady() {\n            for (const h of this._domHandlers)\n                h.Attach()\n        }\n        static IsDocumentFullscreen() {\n            return !!(document["fullscreenElement"] || document["webkitFullscreenElement"] || document["mozFullScreenElement"] || isWrapperFullscreen)\n        }\n        static _SetWrapperIsFullscreenFlag(f) {\n            isWrapperFullscreen = !!f\n        }\n        async GetRemotePreviewStatusInfo() {\n            return await this.PostToRuntimeComponentAsync("runtime", "get-remote-preview-status-info")\n        }\n        _AddRAFCallback(f) {\n            this._rafCallbacks.push(f);\n            this._RequestAnimationFrame()\n        }\n        _RemoveRAFCallback(f) {\n            const i = this._rafCallbacks.indexOf(f);\n            if (i === -1)\n                throw new Error("invalid callback");\n            this._rafCallbacks.splice(i, 1);\n            if (!this._rafCallbacks.length)\n                this._CancelAnimationFrame()\n        }\n        _RequestAnimationFrame() {\n            if (this._rafId === -1 && this._rafCallbacks.length)\n                this._rafId = requestAnimationFrame(this._rafFunc)\n        }\n        _CancelAnimationFrame() {\n            if (this._rafId !== -1) {\n                cancelAnimationFrame(this._rafId);\n                this._rafId = -1\n            }\n        }\n        _OnRAFCallback() {\n            this._rafId = -1;\n            for (const f of this._rafCallbacks)\n                f();\n            this._RequestAnimationFrame()\n        }\n        TryPlayMedia(mediaElem) {\n            this._runtimeDomHandler.TryPlayMedia(mediaElem)\n        }\n        RemovePendingPlay(mediaElem) {\n            this._runtimeDomHandler.RemovePendingPlay(mediaElem)\n        }\n        _PlayPendingMedia() {\n            this._runtimeDomHandler._PlayPendingMedia()\n        }\n        SetSilent(s) {\n            this._runtimeDomHandler.SetSilent(s)\n        }\n        IsAudioFormatSupported(typeStr) {\n            return !!supportedAudioFormats[typeStr]\n        }\n        async _WasmDecodeWebMOpus(arrayBuffer) {\n            const result = await this.PostToRuntimeComponentAsync("runtime", "opus-decode", {\n                "arrayBuffer": arrayBuffer\n            }, null, [arrayBuffer]);\n            return new Float32Array(result)\n        }\n        SetIsExportingToVideo(duration) {\n            this._isExportingToVideo = true;\n            this._exportToVideoDuration = duration\n        }\n        IsExportingToVideo() {\n            return this._isExportingToVideo\n        }\n        GetExportToVideoDuration() {\n            return this._exportToVideoDuration\n        }\n        IsAbsoluteURL(url) {\n            return \/^(?:[a-z\\-]+:)?\\\/\\\/\/.test(url) || url.substr(0, 5) === "data:" || url.substr(0, 5) === "blob:"\n        }\n        IsRelativeURL(url) {\n            return !this.IsAbsoluteURL(url)\n        }\n        async _MaybeGetCordovaScriptURL(url) {\n            if (this._exportType === "cordova" && (url.startsWith("file:") || this._isFileProtocol && this.IsRelativeURL(url))) {\n                let filename = url;\n                if (filename.startsWith(this._runtimeBaseUrl))\n                    filename = filename.substr(this._runtimeBaseUrl.length);\n                const arrayBuffer = await this.CordovaFetchLocalFileAsArrayBuffer(filename);\n                const blob = new Blob([arrayBuffer],{\n                    type: "application\/javascript"\n                });\n                return URL.createObjectURL(blob)\n            } else\n                return url\n        }\n        async _OnCordovaFetchLocalFile(e) {\n            const filename = e["filename"];\n            switch (e["as"]) {\n            case "text":\n                return await this.CordovaFetchLocalFileAsText(filename);\n            case "buffer":\n                return await this.CordovaFetchLocalFileAsArrayBuffer(filename);\n            default:\n                throw new Error("unsupported type");\n            }\n        }\n        _GetPermissionAPI() {\n            const api = window["cordova"] && window["cordova"]["plugins"] && window["cordova"]["plugins"]["permissions"];\n            if (typeof api !== "object")\n                throw new Error("Permission API is not loaded");\n            return api\n        }\n        _MapPermissionID(api, permission) {\n            const permissionID = api[permission];\n            if (typeof permissionID !== "string")\n                throw new Error("Invalid permission name");\n            return permissionID\n        }\n        _HasPermission(id) {\n            const api = this._GetPermissionAPI();\n            return new Promise( (resolve, reject) => api["checkPermission"](this._MapPermissionID(api, id), status => resolve(!!status["hasPermission"]), reject))\n        }\n        _RequestPermission(id) {\n            const api = this._GetPermissionAPI();\n            return new Promise( (resolve, reject) => api["requestPermission"](this._MapPermissionID(api, id), status => resolve(!!status["hasPermission"]), reject))\n        }\n        async RequestPermissions(permissions) {\n            if (this.GetExportType() !== "cordova")\n                return true;\n            if (this.IsiOSCordova())\n                return true;\n            for (const id of permissions) {\n                const alreadyGranted = await this._HasPermission(id);\n                if (alreadyGranted)\n                    continue;\n                const granted = await this._RequestPermission(id);\n                if (granted === false)\n                    return false\n            }\n            return true\n        }\n        async RequirePermissions(...permissions) {\n            if (await this.RequestPermissions(permissions) === false)\n                throw new Error("Permission not granted");\n        }\n        CordovaFetchLocalFile(filename) {\n            const path = window["cordova"]["file"]["applicationDirectory"] + "www\/" + filename.toLowerCase();\n            return new Promise( (resolve, reject) => {\n                window["resolveLocalFileSystemURL"](path, entry => {\n                    entry["file"](resolve, reject)\n                }\n                , reject)\n            }\n            )\n        }\n        async CordovaFetchLocalFileAsText(filename) {\n            const file = await this.CordovaFetchLocalFile(filename);\n            return await BlobToString(file)\n        }\n        _CordovaMaybeStartNextArrayBufferRead() {\n            if (!queuedArrayBufferReads.length)\n                return;\n            if (activeArrayBufferReads >= MAX_ARRAYBUFFER_READS)\n                return;\n            activeArrayBufferReads++;\n            const job = queuedArrayBufferReads.shift();\n            this._CordovaDoFetchLocalFileAsAsArrayBuffer(job.filename, job.successCallback, job.errorCallback)\n        }\n        CordovaFetchLocalFileAsArrayBuffer(filename) {\n            return new Promise( (resolve, reject) => {\n                queuedArrayBufferReads.push({\n                    filename: filename,\n                    successCallback: result => {\n                        activeArrayBufferReads--;\n                        this._CordovaMaybeStartNextArrayBufferRead();\n                        resolve(result)\n                    }\n                    ,\n                    errorCallback: err => {\n                        activeArrayBufferReads--;\n                        this._CordovaMaybeStartNextArrayBufferRead();\n                        reject(err)\n                    }\n                });\n                this._CordovaMaybeStartNextArrayBufferRead()\n            }\n            )\n        }\n        async _CordovaDoFetchLocalFileAsAsArrayBuffer(filename, successCallback, errorCallback) {\n            try {\n                const file = await this.CordovaFetchLocalFile(filename);\n                const arrayBuffer = await BlobToArrayBuffer(file);\n                successCallback(arrayBuffer)\n            } catch (err) {\n                errorCallback(err)\n            }\n        }\n        _SendWrapperMessage(o) {\n            if (this._exportType === "windows-webview2")\n                window["chrome"]["webview"]["postMessage"](JSON.stringify(o));\n            else if (this._exportType === "macos-wkwebview")\n                window["webkit"]["messageHandlers"]["C3Wrapper"]["postMessage"](JSON.stringify(o));\n            else\n                throw new Error("cannot send wrapper message");\n        }\n        async _ConvertDataUrisToBlobs() {\n            const promises = [];\n            for (const [filename,data] of Object.entries(this._localFileBlobs))\n                promises.push(this._ConvertDataUriToBlobs(filename, data));\n            await Promise.all(promises)\n        }\n        async _ConvertDataUriToBlobs(filename, data) {\n            if (typeof data === "object") {\n                this._localFileBlobs[filename] = new Blob([data["str"]],{\n                    "type": data["type"]\n                });\n                this._localFileStrings[filename] = data["str"]\n            } else {\n                let blob = await this._FetchDataUri(data);\n                if (!blob)\n                    blob = this._DataURIToBinaryBlobSync(data);\n                this._localFileBlobs[filename] = blob\n            }\n        }\n        async _FetchDataUri(dataUri) {\n            try {\n                const response = await fetch(dataUri);\n                return await response.blob()\n            } catch (err) {\n                console.warn("Failed to fetch a data: URI. Falling back to a slower workaround. This is probably because the Content Security Policy unnecessarily blocked it. Allow data: URIs in your CSP to avoid this.", err);\n                return null\n            }\n        }\n        _DataURIToBinaryBlobSync(datauri) {\n            const o = this._ParseDataURI(datauri);\n            return this._BinaryStringToBlob(o.data, o.mime_type)\n        }\n        _ParseDataURI(datauri) {\n            const comma = datauri.indexOf(",");\n            if (comma < 0)\n                throw new URIError("expected comma in data: uri");\n            const typepart = datauri.substring(5, comma);\n            const datapart = datauri.substring(comma + 1);\n            const typearr = typepart.split(";");\n            const mimetype = typearr[0] || "";\n            const encoding1 = typearr[1];\n            const encoding2 = typearr[2];\n            let decodeddata;\n            if (encoding1 === "base64" || encoding2 === "base64")\n                decodeddata = atob(datapart);\n            else\n                decodeddata = decodeURIComponent(datapart);\n            return {\n                mime_type: mimetype,\n                data: decodeddata\n            }\n        }\n        _BinaryStringToBlob(binstr, mime_type) {\n            let len = binstr.length;\n            let len32 = len >> 2;\n            let a8 = new Uint8Array(len);\n            let a32 = new Uint32Array(a8.buffer,0,len32);\n            let i, j;\n            for (i = 0,\n            j = 0; i < len32; ++i)\n                a32[i] = binstr.charCodeAt(j++) | binstr.charCodeAt(j++) << 8 | binstr.charCodeAt(j++) << 16 | binstr.charCodeAt(j++) << 24;\n            let tailLength = len & 3;\n            while (tailLength--) {\n                a8[j] = binstr.charCodeAt(j);\n                ++j\n            }\n            return new Blob([a8],{\n                "type": mime_type\n            })\n        }\n    }\n}\n;\n\'use strict\';\n{\n    const RuntimeInterface = self.RuntimeInterface;\n    function IsCompatibilityMouseEvent(e) {\n        return e["sourceCapabilities"] && e["sourceCapabilities"]["firesTouchEvents"] || e["originalEvent"] && e["originalEvent"]["sourceCapabilities"] && e["originalEvent"]["sourceCapabilities"]["firesTouchEvents"]\n    }\n    const KEY_CODE_ALIASES = new Map([["OSLeft", "MetaLeft"], ["OSRight", "MetaRight"]]);\n    const DISPATCH_RUNTIME_AND_SCRIPT = {\n        "dispatchRuntimeEvent": true,\n        "dispatchUserScriptEvent": true\n    };\n    const DISPATCH_SCRIPT_ONLY = {\n        "dispatchUserScriptEvent": true\n    };\n    const DISPATCH_RUNTIME_ONLY = {\n        "dispatchRuntimeEvent": true\n    };\n    function AddStyleSheet(cssUrl) {\n        return new Promise( (resolve, reject) => {\n            const styleLink = document.createElement("link");\n            styleLink.onload = () => resolve(styleLink);\n            styleLink.onerror = err => reject(err);\n            styleLink.rel = "stylesheet";\n            styleLink.href = cssUrl;\n            document.head.appendChild(styleLink)\n        }\n        )\n    }\n    function FetchImage(url) {\n        return new Promise( (resolve, reject) => {\n            const img = new Image;\n            img.onload = () => resolve(img);\n            img.onerror = err => reject(err);\n            img.src = url\n        }\n        )\n    }\n    async function BlobToImage(blob) {\n        const blobUrl = URL.createObjectURL(blob);\n        try {\n            return await FetchImage(blobUrl)\n        } finally {\n            URL.revokeObjectURL(blobUrl)\n        }\n    }\n    function BlobToString(blob) {\n        return new Promise( (resolve, reject) => {\n            let fileReader = new FileReader;\n            fileReader.onload = e => resolve(e.target.result);\n            fileReader.onerror = err => reject(err);\n            fileReader.readAsText(blob)\n        }\n        )\n    }\n    async function BlobToSvgImage(blob, width, height) {\n        if (!\/firefox\/i.test(navigator.userAgent))\n            return await BlobToImage(blob);\n        let str = await BlobToString(blob);\n        const parser = new DOMParser;\n        const doc = parser.parseFromString(str, "image\/svg+xml");\n        const rootElem = doc.documentElement;\n        if (rootElem.hasAttribute("width") && rootElem.hasAttribute("height")) {\n            const widthStr = rootElem.getAttribute("width");\n            const heightStr = rootElem.getAttribute("height");\n            if (!widthStr.includes("%") && !heightStr.includes("%"))\n                return await BlobToImage(blob)\n        }\n        rootElem.setAttribute("width", width + "px");\n        rootElem.setAttribute("height", height + "px");\n        const serializer = new XMLSerializer;\n        str = serializer.serializeToString(doc);\n        blob = new Blob([str],{\n            type: "image\/svg+xml"\n        });\n        return await BlobToImage(blob)\n    }\n    function IsInContentEditable(el) {\n        do {\n            if (el.parentNode && el.hasAttribute("contenteditable"))\n                return true;\n            el = el.parentNode\n        } while (el);\n        return false\n    }\n    const keyboardInputElementTagNames = new Set(["input", "textarea", "datalist", "select"]);\n    function IsKeyboardInputElement(elem) {\n        return keyboardInputElementTagNames.has(elem.tagName.toLowerCase()) || IsInContentEditable(elem)\n    }\n    const canvasOrDocTags = new Set(["canvas", "body", "html"]);\n    function PreventDefaultOnCanvasOrDoc(e) {\n        const tagName = e.target.tagName.toLowerCase();\n        if (canvasOrDocTags.has(tagName))\n            e.preventDefault()\n    }\n    function BlockWheelZoom(e) {\n        if (e.metaKey || e.ctrlKey)\n            e.preventDefault()\n    }\n    self["C3_GetSvgImageSize"] = async function(blob) {\n        const img = await BlobToImage(blob);\n        if (img.width > 0 && img.height > 0)\n            return [img.width, img.height];\n        else {\n            img.style.position = "absolute";\n            img.style.left = "0px";\n            img.style.top = "0px";\n            img.style.visibility = "hidden";\n            document.body.appendChild(img);\n            const rc = img.getBoundingClientRect();\n            document.body.removeChild(img);\n            return [rc.width, rc.height]\n        }\n    }\n    ;\n    self["C3_RasterSvgImageBlob"] = async function(blob, imageWidth, imageHeight, surfaceWidth, surfaceHeight) {\n        const img = await BlobToSvgImage(blob, imageWidth, imageHeight);\n        const canvas = document.createElement("canvas");\n        canvas.width = surfaceWidth;\n        canvas.height = surfaceHeight;\n        const ctx = canvas.getContext("2d");\n        ctx.drawImage(img, 0, 0, imageWidth, imageHeight);\n        return canvas\n    }\n    ;\n    let isCordovaPaused = false;\n    document.addEventListener("pause", () => isCordovaPaused = true);\n    document.addEventListener("resume", () => isCordovaPaused = false);\n    function ParentHasFocus() {\n        try {\n            return window.parent && window.parent.document.hasFocus()\n        } catch (err) {\n            return false\n        }\n    }\n    function KeyboardIsVisible() {\n        const elem = document.activeElement;\n        if (!elem)\n            return false;\n        const tagName = elem.tagName.toLowerCase();\n        const inputTypes = new Set(["email", "number", "password", "search", "tel", "text", "url"]);\n        if (tagName === "textarea")\n            return true;\n        if (tagName === "input")\n            return inputTypes.has(elem.type.toLowerCase() || "text");\n        return IsInContentEditable(elem)\n    }\n    const DOM_COMPONENT_ID = "runtime";\n    const HANDLER_CLASS = class RuntimeDOMHandler extends self.DOMHandler {\n        constructor(iRuntime) {\n            super(iRuntime, DOM_COMPONENT_ID);\n            this._isFirstSizeUpdate = true;\n            this._simulatedResizeTimerId = -1;\n            this._targetOrientation = "any";\n            this._attachedDeviceOrientationEvent = false;\n            this._attachedDeviceMotionEvent = false;\n            this._debugHighlightElem = null;\n            this._isExportToVideo = false;\n            this._exportVideoProgressMessage = "";\n            this._exportVideoUpdateTimerId = -1;\n            this._pointerRawUpdateRateLimiter = null;\n            this._lastPointerRawUpdateEvent = null;\n            this._pointerRawMovementX = 0;\n            this._pointerRawMovementY = 0;\n            this._enableAndroidVKDetection = false;\n            this._lastWindowWidth = iRuntime._GetWindowInnerWidth();\n            this._lastWindowHeight = iRuntime._GetWindowInnerHeight();\n            this._virtualKeyboardHeight = 0;\n            iRuntime.AddRuntimeComponentMessageHandler("canvas", "update-size", e => this._OnUpdateCanvasSize(e));\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "invoke-download", e => this._OnInvokeDownload(e));\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "raster-svg-image", e => this._OnRasterSvgImage(e));\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "get-svg-image-size", e => this._OnGetSvgImageSize(e));\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "set-target-orientation", e => this._OnSetTargetOrientation(e));\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "register-sw", () => this._OnRegisterSW());\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "post-to-debugger", e => this._OnPostToDebugger(e));\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "go-to-script", e => this._OnPostToDebugger(e));\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "before-start-ticking", () => this._OnBeforeStartTicking());\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "debug-highlight", e => this._OnDebugHighlight(e));\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "enable-device-orientation", () => this._AttachDeviceOrientationEvent());\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "enable-device-motion", () => this._AttachDeviceMotionEvent());\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "add-stylesheet", e => this._OnAddStylesheet(e));\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "alert", e => this._OnAlert(e));\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "hide-cordova-splash", () => this._OnHideCordovaSplash());\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "set-exporting-to-video", e => this._SetExportingToVideo(e));\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "export-to-video-progress", e => this._OnExportVideoProgress(e));\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "exported-to-video", e => this._OnExportedToVideo(e));\n            iRuntime.AddRuntimeComponentMessageHandler("runtime", "exported-to-image-sequence", e => this._OnExportedToImageSequence(e));\n            const allowDefaultContextMenuTagNames = new Set(["input", "textarea", "datalist"]);\n            window.addEventListener("contextmenu", e => {\n                const t = e.target;\n                const name = t.tagName.toLowerCase();\n                if (!allowDefaultContextMenuTagNames.has(name) && !IsInContentEditable(t))\n                    e.preventDefault()\n            }\n            );\n            const canvas = iRuntime.GetCanvas();\n            window.addEventListener("selectstart", PreventDefaultOnCanvasOrDoc);\n            window.addEventListener("gesturehold", PreventDefaultOnCanvasOrDoc);\n            canvas.addEventListener("selectstart", PreventDefaultOnCanvasOrDoc);\n            canvas.addEventListener("gesturehold", PreventDefaultOnCanvasOrDoc);\n            window.addEventListener("touchstart", PreventDefaultOnCanvasOrDoc, {\n                "passive": false\n            });\n            if (typeof PointerEvent !== "undefined") {\n                window.addEventListener("pointerdown", PreventDefaultOnCanvasOrDoc, {\n                    "passive": false\n                });\n                canvas.addEventListener("pointerdown", PreventDefaultOnCanvasOrDoc)\n            } else\n                canvas.addEventListener("touchstart", PreventDefaultOnCanvasOrDoc);\n            this._mousePointerLastButtons = 0;\n            window.addEventListener("mousedown", e => {\n                if (e.button === 1)\n                    e.preventDefault()\n            }\n            );\n            window.addEventListener("mousewheel", BlockWheelZoom, {\n                "passive": false\n            });\n            window.addEventListener("wheel", BlockWheelZoom, {\n                "passive": false\n            });\n            window.addEventListener("resize", () => this._OnWindowResize());\n            window.addEventListener("fullscreenchange", () => this._OnFullscreenChange());\n            window.addEventListener("webkitfullscreenchange", () => this._OnFullscreenChange());\n            window.addEventListener("mozfullscreenchange", () => this._OnFullscreenChange());\n            window.addEventListener("fullscreenerror", e => this._OnFullscreenError(e));\n            window.addEventListener("webkitfullscreenerror", e => this._OnFullscreenError(e));\n            window.addEventListener("mozfullscreenerror", e => this._OnFullscreenError(e));\n            if (iRuntime.IsiOSWebView())\n                if (window["visualViewport"]) {\n                    let lastVisualViewportHeight = Infinity;\n                    window["visualViewport"].addEventListener("resize", () => {\n                        const curVisualViewportHeight = window["visualViewport"].height;\n                        if (curVisualViewportHeight > lastVisualViewportHeight)\n                            document.scrollingElement.scrollTop = 0;\n                        lastVisualViewportHeight = curVisualViewportHeight\n                    }\n                    )\n                } else\n                    window.addEventListener("focusout", () => {\n                        if (!KeyboardIsVisible())\n                            document.scrollingElement.scrollTop = 0\n                    }\n                    );\n            self["C3WrapperOnMessage"] = msg => this._OnWrapperMessage(msg);\n            this._mediaPendingPlay = new Set;\n            this._mediaRemovedPendingPlay = new WeakSet;\n            this._isSilent = false\n        }\n        _OnBeforeStartTicking() {\n            self.setTimeout( () => {\n                this._enableAndroidVKDetection = true\n            }\n            , 1E3);\n            if (this._iRuntime.GetExportType() === "cordova") {\n                document.addEventListener("pause", () => this._OnVisibilityChange(true));\n                document.addEventListener("resume", () => this._OnVisibilityChange(false))\n            } else\n                document.addEventListener("visibilitychange", () => this._OnVisibilityChange(document.hidden));\n            return {\n                "isSuspended": !!(document.hidden || isCordovaPaused)\n            }\n        }\n        Attach() {\n            window.addEventListener("focus", () => this._PostRuntimeEvent("window-focus"));\n            window.addEventListener("blur", () => {\n                this._PostRuntimeEvent("window-blur", {\n                    "parentHasFocus": ParentHasFocus()\n                });\n                this._mousePointerLastButtons = 0\n            }\n            );\n            window.addEventListener("focusin", e => {\n                if (IsKeyboardInputElement(e.target))\n                    this._PostRuntimeEvent("keyboard-blur")\n            }\n            );\n            window.addEventListener("keydown", e => this._OnKeyEvent("keydown", e));\n            window.addEventListener("keyup", e => this._OnKeyEvent("keyup", e));\n            window.addEventListener("dblclick", e => this._OnMouseEvent("dblclick", e, DISPATCH_RUNTIME_AND_SCRIPT));\n            window.addEventListener("wheel", e => this._OnMouseWheelEvent("wheel", e));\n            if (typeof PointerEvent !== "undefined") {\n                window.addEventListener("pointerdown", e => {\n                    this._HandlePointerDownFocus(e);\n                    this._OnPointerEvent("pointerdown", e)\n                }\n                );\n                if (this._iRuntime.UsesWorker() && typeof window["onpointerrawupdate"] !== "undefined" && self === self.top) {\n                    this._pointerRawUpdateRateLimiter = new self.RateLimiter( () => this._DoSendPointerRawUpdate(),5);\n                    this._pointerRawUpdateRateLimiter.SetCanRunImmediate(true);\n                    window.addEventListener("pointerrawupdate", e => this._OnPointerRawUpdate(e))\n                } else\n                    window.addEventListener("pointermove", e => this._OnPointerEvent("pointermove", e));\n                window.addEventListener("pointerup", e => this._OnPointerEvent("pointerup", e));\n                window.addEventListener("pointercancel", e => this._OnPointerEvent("pointercancel", e))\n            } else {\n                window.addEventListener("mousedown", e => {\n                    this._HandlePointerDownFocus(e);\n                    this._OnMouseEventAsPointer("pointerdown", e)\n                }\n                );\n                window.addEventListener("mousemove", e => this._OnMouseEventAsPointer("pointermove", e));\n                window.addEventListener("mouseup", e => this._OnMouseEventAsPointer("pointerup", e));\n                window.addEventListener("touchstart", e => {\n                    this._HandlePointerDownFocus(e);\n                    this._OnTouchEvent("pointerdown", e)\n                }\n                );\n                window.addEventListener("touchmove", e => this._OnTouchEvent("pointermove", e));\n                window.addEventListener("touchend", e => this._OnTouchEvent("pointerup", e));\n                window.addEventListener("touchcancel", e => this._OnTouchEvent("pointercancel", e))\n            }\n            const playFunc = () => this._PlayPendingMedia();\n            window.addEventListener("pointerup", playFunc, true);\n            window.addEventListener("touchend", playFunc, true);\n            window.addEventListener("click", playFunc, true);\n            window.addEventListener("keydown", playFunc, true);\n            window.addEventListener("gamepadconnected", playFunc, true);\n            if (this._iRuntime.IsAndroid() && !this._iRuntime.IsAndroidWebView() && navigator["virtualKeyboard"]) {\n                navigator["virtualKeyboard"]["overlaysContent"] = true;\n                navigator["virtualKeyboard"].addEventListener("geometrychange", () => {\n                    this._OnAndroidVirtualKeyboardChange(this._GetWindowInnerHeight(), navigator["virtualKeyboard"]["boundingRect"]["height"])\n                }\n                )\n            }\n        }\n        _OnAndroidVirtualKeyboardChange(windowHeight, vkHeight) {\n            document.body.style.transform = "";\n            if (vkHeight > 0) {\n                const activeElement = document.activeElement;\n                if (activeElement) {\n                    const rc = activeElement.getBoundingClientRect();\n                    const rcMidY = (rc.top + rc.bottom) \/ 2;\n                    const targetY = (windowHeight - vkHeight) \/ 2;\n                    let shiftY = rcMidY - targetY;\n                    if (shiftY > vkHeight)\n                        shiftY = vkHeight;\n                    if (shiftY < 0)\n                        shiftY = 0;\n                    if (shiftY > 0)\n                        document.body.style.transform = `translateY(${-shiftY}px)`\n                }\n            }\n        }\n        _PostRuntimeEvent(name, data) {\n            this.PostToRuntime(name, data || null, DISPATCH_RUNTIME_ONLY)\n        }\n        _GetWindowInnerWidth() {\n            return this._iRuntime._GetWindowInnerWidth()\n        }\n        _GetWindowInnerHeight() {\n            return this._iRuntime._GetWindowInnerHeight()\n        }\n        _OnWindowResize() {\n            if (this._isExportToVideo)\n                return;\n            const width = this._GetWindowInnerWidth();\n            const height = this._GetWindowInnerHeight();\n            if (this._iRuntime.IsAndroidWebView())\n                if (this._enableAndroidVKDetection)\n                    if (this._lastWindowWidth === width && height < this._lastWindowHeight) {\n                        this._virtualKeyboardHeight = this._lastWindowHeight - height;\n                        this._OnAndroidVirtualKeyboardChange(this._lastWindowHeight, this._virtualKeyboardHeight);\n                        return\n                    } else {\n                        if (this._virtualKeyboardHeight > 0) {\n                            this._virtualKeyboardHeight = 0;\n                            this._OnAndroidVirtualKeyboardChange(height, this._virtualKeyboardHeight)\n                        }\n                        this._lastWindowWidth = width;\n                        this._lastWindowHeight = height\n                    }\n                else {\n                    this._lastWindowWidth = width;\n                    this._lastWindowHeight = height\n                }\n            this.PostToRuntime("window-resize", {\n                "innerWidth": width,\n                "innerHeight": height,\n                "devicePixelRatio": window.devicePixelRatio,\n                "isFullscreen": RuntimeInterface.IsDocumentFullscreen()\n            });\n            if (this._iRuntime.IsiOSWebView()) {\n                if (this._simulatedResizeTimerId !== -1)\n                    clearTimeout(this._simulatedResizeTimerId);\n                this._OnSimulatedResize(width, height, 0)\n            }\n        }\n        _ScheduleSimulatedResize(width, height, count) {\n            if (this._simulatedResizeTimerId !== -1)\n                clearTimeout(this._simulatedResizeTimerId);\n            this._simulatedResizeTimerId = setTimeout( () => this._OnSimulatedResize(width, height, count), 48)\n        }\n        _OnSimulatedResize(originalWidth, originalHeight, count) {\n            const width = this._GetWindowInnerWidth();\n            const height = this._GetWindowInnerHeight();\n            this._simulatedResizeTimerId = -1;\n            if (width != originalWidth || height != originalHeight)\n                this.PostToRuntime("window-resize", {\n                    "innerWidth": width,\n                    "innerHeight": height,\n                    "devicePixelRatio": window.devicePixelRatio,\n                    "isFullscreen": RuntimeInterface.IsDocumentFullscreen()\n                });\n            else if (count < 10)\n                this._ScheduleSimulatedResize(width, height, count + 1)\n        }\n        _OnSetTargetOrientation(e) {\n            this._targetOrientation = e["targetOrientation"]\n        }\n        _TrySetTargetOrientation() {\n            const orientation = this._targetOrientation;\n            if (screen["orientation"] && screen["orientation"]["lock"])\n                screen["orientation"]["lock"](orientation).catch(err => console.warn("[Construct] Failed to lock orientation: ", err));\n            else\n                try {\n                    let result = false;\n                    if (screen["lockOrientation"])\n                        result = screen["lockOrientation"](orientation);\n                    else if (screen["webkitLockOrientation"])\n                        result = screen["webkitLockOrientation"](orientation);\n                    else if (screen["mozLockOrientation"])\n                        result = screen["mozLockOrientation"](orientation);\n                    else if (screen["msLockOrientation"])\n                        result = screen["msLockOrientation"](orientation);\n                    if (!result)\n                        console.warn("[Construct] Failed to lock orientation")\n                } catch (err) {\n                    console.warn("[Construct] Failed to lock orientation: ", err)\n                }\n        }\n        _OnFullscreenChange() {\n            if (this._isExportToVideo)\n                return;\n            const isDocFullscreen = RuntimeInterface.IsDocumentFullscreen();\n            if (isDocFullscreen && this._targetOrientation !== "any")\n                this._TrySetTargetOrientation();\n            this.PostToRuntime("fullscreenchange", {\n                "isFullscreen": isDocFullscreen,\n                "innerWidth": this._GetWindowInnerWidth(),\n                "innerHeight": this._GetWindowInnerHeight()\n            })\n        }\n        _OnFullscreenError(e) {\n            console.warn("[Construct] Fullscreen request failed: ", e);\n            this.PostToRuntime("fullscreenerror", {\n                "isFullscreen": RuntimeInterface.IsDocumentFullscreen(),\n                "innerWidth": this._GetWindowInnerWidth(),\n                "innerHeight": this._GetWindowInnerHeight()\n            })\n        }\n        _OnVisibilityChange(isHidden) {\n            if (isHidden)\n                this._iRuntime._CancelAnimationFrame();\n            else\n                this._iRuntime._RequestAnimationFrame();\n            this.PostToRuntime("visibilitychange", {\n                "hidden": isHidden\n            })\n        }\n        _OnKeyEvent(name, e) {\n            if (e.key === "Backspace")\n                PreventDefaultOnCanvasOrDoc(e);\n            if (this._isExportToVideo)\n                return;\n            const code = KEY_CODE_ALIASES.get(e.code) || e.code;\n            this._PostToRuntimeMaybeSync(name, {\n                "code": code,\n                "key": e.key,\n                "which": e.which,\n                "repeat": e.repeat,\n                "altKey": e.altKey,\n                "ctrlKey": e.ctrlKey,\n                "metaKey": e.metaKey,\n                "shiftKey": e.shiftKey,\n                "timeStamp": e.timeStamp\n            }, DISPATCH_RUNTIME_AND_SCRIPT)\n        }\n        _OnMouseWheelEvent(name, e) {\n            if (this._isExportToVideo)\n                return;\n            this.PostToRuntime(name, {\n                "clientX": e.clientX,\n                "clientY": e.clientY,\n                "pageX": e.pageX,\n                "pageY": e.pageY,\n                "deltaX": e.deltaX,\n                "deltaY": e.deltaY,\n                "deltaZ": e.deltaZ,\n                "deltaMode": e.deltaMode,\n                "timeStamp": e.timeStamp\n            }, DISPATCH_RUNTIME_AND_SCRIPT)\n        }\n        _OnMouseEvent(name, e, opts) {\n            if (this._isExportToVideo)\n                return;\n            if (IsCompatibilityMouseEvent(e))\n                return;\n            this._PostToRuntimeMaybeSync(name, {\n                "button": e.button,\n                "buttons": e.buttons,\n                "clientX": e.clientX,\n                "clientY": e.clientY,\n                "pageX": e.pageX,\n                "pageY": e.pageY,\n                "movementX": e.movementX || 0,\n                "movementY": e.movementY || 0,\n                "timeStamp": e.timeStamp\n            }, opts)\n        }\n        _OnMouseEventAsPointer(name, e) {\n            if (this._isExportToVideo)\n                return;\n            if (IsCompatibilityMouseEvent(e))\n                return;\n            const pointerId = 1;\n            const lastButtons = this._mousePointerLastButtons;\n            if (name === "pointerdown" && lastButtons !== 0)\n                name = "pointermove";\n            else if (name === "pointerup" && e.buttons !== 0)\n                name = "pointermove";\n            this._PostToRuntimeMaybeSync(name, {\n                "pointerId": pointerId,\n                "pointerType": "mouse",\n                "button": e.button,\n                "buttons": e.buttons,\n                "lastButtons": lastButtons,\n                "clientX": e.clientX,\n                "clientY": e.clientY,\n                "pageX": e.pageX,\n                "pageY": e.pageY,\n                "movementX": e.movementX || 0,\n                "movementY": e.movementY || 0,\n                "width": 0,\n                "height": 0,\n                "pressure": 0,\n                "tangentialPressure": 0,\n                "tiltX": 0,\n                "tiltY": 0,\n                "twist": 0,\n                "timeStamp": e.timeStamp\n            }, DISPATCH_RUNTIME_AND_SCRIPT);\n            this._mousePointerLastButtons = e.buttons;\n            this._OnMouseEvent(e.type, e, DISPATCH_SCRIPT_ONLY)\n        }\n        _OnPointerEvent(name, e) {\n            if (this._isExportToVideo)\n                return;\n            if (this._pointerRawUpdateRateLimiter && name !== "pointermove")\n                this._pointerRawUpdateRateLimiter.Reset();\n            let lastButtons = 0;\n            if (e.pointerType === "mouse")\n                lastButtons = this._mousePointerLastButtons;\n            this._PostToRuntimeMaybeSync(name, {\n                "pointerId": e.pointerId,\n                "pointerType": e.pointerType,\n                "button": e.button,\n                "buttons": e.buttons,\n                "lastButtons": lastButtons,\n                "clientX": e.clientX,\n                "clientY": e.clientY,\n                "pageX": e.pageX,\n                "pageY": e.pageY,\n                "movementX": (e.movementX || 0) + this._pointerRawMovementX,\n                "movementY": (e.movementY || 0) + this._pointerRawMovementY,\n                "width": e.width || 0,\n                "height": e.height || 0,\n                "pressure": e.pressure || 0,\n                "tangentialPressure": e["tangentialPressure"] || 0,\n                "tiltX": e.tiltX || 0,\n                "tiltY": e.tiltY || 0,\n                "twist": e["twist"] || 0,\n                "timeStamp": e.timeStamp\n            }, DISPATCH_RUNTIME_AND_SCRIPT);\n            this._pointerRawMovementX = 0;\n            this._pointerRawMovementY = 0;\n            if (e.pointerType === "mouse") {\n                let mouseEventName = "mousemove";\n                if (name === "pointerdown")\n                    mouseEventName = "mousedown";\n                else if (name === "pointerup")\n                    mouseEventName = "mouseup";\n                this._OnMouseEvent(mouseEventName, e, DISPATCH_SCRIPT_ONLY);\n                this._mousePointerLastButtons = e.buttons\n            }\n        }\n        _OnPointerRawUpdate(e) {\n            if (this._lastPointerRawUpdateEvent) {\n                this._pointerRawMovementX += this._lastPointerRawUpdateEvent.movementX || 0;\n                this._pointerRawMovementY += this._lastPointerRawUpdateEvent.movementY || 0\n            }\n            this._lastPointerRawUpdateEvent = e;\n            this._pointerRawUpdateRateLimiter.Call()\n        }\n        _DoSendPointerRawUpdate() {\n            this._OnPointerEvent("pointermove", this._lastPointerRawUpdateEvent);\n            this._lastPointerRawUpdateEvent = null\n        }\n        _OnTouchEvent(fireName, e) {\n            if (this._isExportToVideo)\n                return;\n            for (let i = 0, len = e.changedTouches.length; i < len; ++i) {\n                const t = e.changedTouches[i];\n                this._PostToRuntimeMaybeSync(fireName, {\n                    "pointerId": t.identifier,\n                    "pointerType": "touch",\n                    "button": 0,\n                    "buttons": 0,\n                    "lastButtons": 0,\n                    "clientX": t.clientX,\n                    "clientY": t.clientY,\n                    "pageX": t.pageX,\n                    "pageY": t.pageY,\n                    "movementX": e.movementX || 0,\n                    "movementY": e.movementY || 0,\n                    "width": (t["radiusX"] || t["webkitRadiusX"] || 0) * 2,\n                    "height": (t["radiusY"] || t["webkitRadiusY"] || 0) * 2,\n                    "pressure": t["force"] || t["webkitForce"] || 0,\n                    "tangentialPressure": 0,\n                    "tiltX": 0,\n                    "tiltY": 0,\n                    "twist": t["rotationAngle"] || 0,\n                    "timeStamp": e.timeStamp\n                }, DISPATCH_RUNTIME_AND_SCRIPT)\n            }\n        }\n        _HandlePointerDownFocus(e) {\n            if (window !== window.top)\n                window.focus();\n            if (this._IsElementCanvasOrDocument(e.target) && document.activeElement && !this._IsElementCanvasOrDocument(document.activeElement))\n                document.activeElement.blur()\n        }\n        _IsElementCanvasOrDocument(elem) {\n            return !elem || elem === document || elem === window || elem === document.body || elem.tagName.toLowerCase() === "canvas"\n        }\n        _AttachDeviceOrientationEvent() {\n            if (this._attachedDeviceOrientationEvent)\n                return;\n            this._attachedDeviceOrientationEvent = true;\n            window.addEventListener("deviceorientation", e => this._OnDeviceOrientation(e));\n            window.addEventListener("deviceorientationabsolute", e => this._OnDeviceOrientationAbsolute(e))\n        }\n        _AttachDeviceMotionEvent() {\n            if (this._attachedDeviceMotionEvent)\n                return;\n            this._attachedDeviceMotionEvent = true;\n            window.addEventListener("devicemotion", e => this._OnDeviceMotion(e))\n        }\n        _OnDeviceOrientation(e) {\n            if (this._isExportToVideo)\n                return;\n            this.PostToRuntime("deviceorientation", {\n                "absolute": !!e["absolute"],\n                "alpha": e["alpha"] || 0,\n                "beta": e["beta"] || 0,\n                "gamma": e["gamma"] || 0,\n                "timeStamp": e.timeStamp,\n                "webkitCompassHeading": e["webkitCompassHeading"],\n                "webkitCompassAccuracy": e["webkitCompassAccuracy"]\n            }, DISPATCH_RUNTIME_AND_SCRIPT)\n        }\n        _OnDeviceOrientationAbsolute(e) {\n            if (this._isExportToVideo)\n                return;\n            this.PostToRuntime("deviceorientationabsolute", {\n                "absolute": !!e["absolute"],\n                "alpha": e["alpha"] || 0,\n                "beta": e["beta"] || 0,\n                "gamma": e["gamma"] || 0,\n                "timeStamp": e.timeStamp\n            }, DISPATCH_RUNTIME_AND_SCRIPT)\n        }\n        _OnDeviceMotion(e) {\n            if (this._isExportToVideo)\n                return;\n            let accProp = null;\n            const acc = e["acceleration"];\n            if (acc)\n                accProp = {\n                    "x": acc["x"] || 0,\n                    "y": acc["y"] || 0,\n                    "z": acc["z"] || 0\n                };\n            let withGProp = null;\n            const withG = e["accelerationIncludingGravity"];\n            if (withG)\n                withGProp = {\n                    "x": withG["x"] || 0,\n                    "y": withG["y"] || 0,\n                    "z": withG["z"] || 0\n                };\n            let rotationRateProp = null;\n            const rotationRate = e["rotationRate"];\n            if (rotationRate)\n                rotationRateProp = {\n                    "alpha": rotationRate["alpha"] || 0,\n                    "beta": rotationRate["beta"] || 0,\n                    "gamma": rotationRate["gamma"] || 0\n                };\n            this.PostToRuntime("devicemotion", {\n                "acceleration": accProp,\n                "accelerationIncludingGravity": withGProp,\n                "rotationRate": rotationRateProp,\n                "interval": e["interval"],\n                "timeStamp": e.timeStamp\n            }, DISPATCH_RUNTIME_AND_SCRIPT)\n        }\n        _OnUpdateCanvasSize(e) {\n            const runtimeInterface = this.GetRuntimeInterface();\n            if (runtimeInterface.IsExportingToVideo())\n                return;\n            const canvas = runtimeInterface.GetCanvas();\n            canvas.style.width = e["styleWidth"] + "px";\n            canvas.style.height = e["styleHeight"] + "px";\n            canvas.style.marginLeft = e["marginLeft"] + "px";\n            canvas.style.marginTop = e["marginTop"] + "px";\n            if (this._isFirstSizeUpdate) {\n                canvas.style.display = "";\n                this._isFirstSizeUpdate = false\n            }\n        }\n        _OnInvokeDownload(e) {\n            const url = e["url"];\n            const filename = e["filename"];\n            const a = document.createElement("a");\n            const body = document.body;\n            a.textContent = filename;\n            a.href = url;\n            a.download = filename;\n            body.appendChild(a);\n            a.click();\n            body.removeChild(a)\n        }\n        async _OnRasterSvgImage(e) {\n            const blob = e["blob"];\n            const imageWidth = e["imageWidth"];\n            const imageHeight = e["imageHeight"];\n            const surfaceWidth = e["surfaceWidth"];\n            const surfaceHeight = e["surfaceHeight"];\n            const imageBitmapOpts = e["imageBitmapOpts"];\n            const canvas = await self["C3_RasterSvgImageBlob"](blob, imageWidth, imageHeight, surfaceWidth, surfaceHeight);\n            let ret;\n            if (imageBitmapOpts)\n                ret = await createImageBitmap(canvas, imageBitmapOpts);\n            else\n                ret = await createImageBitmap(canvas);\n            return {\n                "imageBitmap": ret,\n                "transferables": [ret]\n            }\n        }\n        async _OnGetSvgImageSize(e) {\n            return await self["C3_GetSvgImageSize"](e["blob"])\n        }\n        async _OnAddStylesheet(e) {\n            await AddStyleSheet(e["url"])\n        }\n        _PlayPendingMedia() {\n            const mediaToTryPlay = [...this._mediaPendingPlay];\n            this._mediaPendingPlay.clear();\n            if (!this._isSilent)\n                for (const mediaElem of mediaToTryPlay) {\n                    const playRet = mediaElem.play();\n                    if (playRet)\n                        playRet.catch(err => {\n                            if (!this._mediaRemovedPendingPlay.has(mediaElem))\n                                this._mediaPendingPlay.add(mediaElem)\n                        }\n                        )\n                }\n        }\n        TryPlayMedia(mediaElem) {\n            if (typeof mediaElem.play !== "function")\n                throw new Error("missing play function");\n            this._mediaRemovedPendingPlay.delete(mediaElem);\n            let playRet;\n            try {\n                playRet = mediaElem.play()\n            } catch (err) {\n                this._mediaPendingPlay.add(mediaElem);\n                return\n            }\n            if (playRet)\n                playRet.catch(err => {\n                    if (!this._mediaRemovedPendingPlay.has(mediaElem))\n                        this._mediaPendingPlay.add(mediaElem)\n                }\n                )\n        }\n        RemovePendingPlay(mediaElem) {\n            this._mediaPendingPlay.delete(mediaElem);\n            this._mediaRemovedPendingPlay.add(mediaElem)\n        }\n        SetSilent(s) {\n            this._isSilent = !!s\n        }\n        _OnHideCordovaSplash() {\n            if (navigator["splashscreen"] && navigator["splashscreen"]["hide"])\n                navigator["splashscreen"]["hide"]()\n        }\n        _OnDebugHighlight(e) {\n            const show = e["show"];\n            if (!show) {\n                if (this._debugHighlightElem)\n                    this._debugHighlightElem.style.display = "none";\n                return\n            }\n            if (!this._debugHighlightElem) {\n                this._debugHighlightElem = document.createElement("div");\n                this._debugHighlightElem.id = "inspectOutline";\n                document.body.appendChild(this._debugHighlightElem)\n            }\n            const elem = this._debugHighlightElem;\n            elem.style.display = "";\n            elem.style.left = e["left"] - 1 + "px";\n            elem.style.top = e["top"] - 1 + "px";\n            elem.style.width = e["width"] + 2 + "px";\n            elem.style.height = e["height"] + 2 + "px";\n            elem.textContent = e["name"]\n        }\n        _OnRegisterSW() {\n            if (window["C3_RegisterSW"])\n                window["C3_RegisterSW"]()\n        }\n        _OnPostToDebugger(data) {\n            if (!window["c3_postToMessagePort"])\n                return;\n            data["from"] = "runtime";\n            window["c3_postToMessagePort"](data)\n        }\n        _InvokeFunctionFromJS(name, params) {\n            return this.PostToRuntimeAsync("js-invoke-function", {\n                "name": name,\n                "params": params\n            })\n        }\n        _OnAlert(e) {\n            alert(e["message"])\n        }\n        _OnWrapperMessage(msg) {\n            if (msg === "entered-fullscreen") {\n                RuntimeInterface._SetWrapperIsFullscreenFlag(true);\n                this._OnFullscreenChange()\n            } else if (msg === "exited-fullscreen") {\n                RuntimeInterface._SetWrapperIsFullscreenFlag(false);\n                this._OnFullscreenChange()\n            } else\n                console.warn("Unknown wrapper message: ", msg)\n        }\n        _SetExportingToVideo(e) {\n            this._isExportToVideo = true;\n            const headerElem = document.createElement("h1");\n            headerElem.id = "exportToVideoMessage";\n            headerElem.textContent = e["message"];\n            document.body.prepend(headerElem);\n            document.body.classList.add("exportingToVideo");\n            this.GetRuntimeInterface().GetCanvas().style.display = "";\n            this._iRuntime.SetIsExportingToVideo(e["duration"])\n        }\n        _OnExportVideoProgress(e) {\n            this._exportVideoProgressMessage = e["message"];\n            if (this._exportVideoUpdateTimerId === -1)\n                this._exportVideoUpdateTimerId = setTimeout( () => this._DoUpdateExportVideoProgressMessage(), 250)\n        }\n        _DoUpdateExportVideoProgressMessage() {\n            this._exportVideoUpdateTimerId = -1;\n            const headerElem = document.getElementById("exportToVideoMessage");\n            if (headerElem)\n                headerElem.textContent = this._exportVideoProgressMessage\n        }\n        _OnExportedToVideo(e) {\n            window.c3_postToMessagePort({\n                "type": "exported-video",\n                "blob": e["blob"],\n                "time": e["time"]\n            })\n        }\n        _OnExportedToImageSequence(e) {\n            window.c3_postToMessagePort({\n                "type": "exported-image-sequence",\n                "blobArr": e["blobArr"],\n                "time": e["time"]\n            })\n        }\n    }\n    ;\n    RuntimeInterface.AddDOMHandlerClass(HANDLER_CLASS)\n}\n;\n\'use strict\';\n{\n    const DISPATCH_WORKER_SCRIPT_NAME = "dispatchworker.js";\n    const JOB_WORKER_SCRIPT_NAME = "jobworker.js";\n    self.JobSchedulerDOM = class JobSchedulerDOM {\n        constructor(runtimeInterface) {\n            this._runtimeInterface = runtimeInterface;\n            this._baseUrl = runtimeInterface.GetRuntimeBaseURL();\n            if (runtimeInterface.GetExportType() === "preview")\n                this._baseUrl += "workers\/";\n            else\n                this._baseUrl += runtimeInterface.GetScriptFolder();\n            this._maxNumWorkers = Math.min(navigator.hardwareConcurrency || 2, 16);\n            this._dispatchWorker = null;\n            this._jobWorkers = [];\n            this._inputPort = null;\n            this._outputPort = null\n        }\n        async Init() {\n            if (this._hasInitialised)\n                throw new Error("already initialised");\n            this._hasInitialised = true;\n            const dispatchWorkerScriptUrl = this._runtimeInterface._GetWorkerURL(DISPATCH_WORKER_SCRIPT_NAME);\n            this._dispatchWorker = await this._runtimeInterface.CreateWorker(dispatchWorkerScriptUrl, this._baseUrl, {\n                name: "DispatchWorker"\n            });\n            const messageChannel = new MessageChannel;\n            this._inputPort = messageChannel.port1;\n            this._dispatchWorker.postMessage({\n                "type": "_init",\n                "in-port": messageChannel.port2\n            }, [messageChannel.port2]);\n            this._outputPort = await this._CreateJobWorker()\n        }\n        async _CreateJobWorker() {\n            const number = this._jobWorkers.length;\n            const jobWorkerScriptUrl = this._runtimeInterface._GetWorkerURL(JOB_WORKER_SCRIPT_NAME);\n            const jobWorker = await this._runtimeInterface.CreateWorker(jobWorkerScriptUrl, this._baseUrl, {\n                name: "JobWorker" + number\n            });\n            const dispatchChannel = new MessageChannel;\n            const outputChannel = new MessageChannel;\n            this._dispatchWorker.postMessage({\n                "type": "_addJobWorker",\n                "port": dispatchChannel.port1\n            }, [dispatchChannel.port1]);\n            jobWorker.postMessage({\n                "type": "init",\n                "number": number,\n                "dispatch-port": dispatchChannel.port2,\n                "output-port": outputChannel.port2\n            }, [dispatchChannel.port2, outputChannel.port2]);\n            this._jobWorkers.push(jobWorker);\n            return outputChannel.port1\n        }\n        GetPortData() {\n            return {\n                "inputPort": this._inputPort,\n                "outputPort": this._outputPort,\n                "maxNumWorkers": this._maxNumWorkers\n            }\n        }\n        GetPortTransferables() {\n            return [this._inputPort, this._outputPort]\n        }\n    }\n}\n;\n\'use strict\';\n{\n    if (window["C3_IsSupported"]) {\n        const enableWorker = false;\n        window["c3_runtimeInterface"] = new self.RuntimeInterface({\n            useWorker: enableWorker,\n            workerMainUrl: "workermain.js",\n            engineScripts: [],\n            projectScripts: [["scripts\/project\/poki-start.js"], ["scripts\/project\/scriptsInEvents.js"]],\n            mainProjectScript: "scripts\/project\/poki-start.js",\n            scriptFolder: "",\n            workerDependencyScripts: [],\n            exportType: "html5"\n        })\n    }\n}\n;\'use strict\';\n{\n    const DOM_COMPONENT_ID = "touch";\n    const HANDLER_CLASS = class TouchDOMHandler extends self.DOMHandler {\n        constructor(iRuntime) {\n            super(iRuntime, DOM_COMPONENT_ID);\n            this.AddRuntimeMessageHandler("request-permission", e => this._OnRequestPermission(e))\n        }\n        async _OnRequestPermission(e) {\n            const type = e["type"];\n            let result = true;\n            if (type === 0)\n                result = await this._RequestOrientationPermission();\n            else if (type === 1)\n                result = await this._RequestMotionPermission();\n            this.PostToRuntime("permission-result", {\n                "type": type,\n                "result": result\n            })\n        }\n        async _RequestOrientationPermission() {\n            if (!self["DeviceOrientationEvent"] || !self["DeviceOrientationEvent"]["requestPermission"])\n                return true;\n            try {\n                const state = await self["DeviceOrientationEvent"]["requestPermission"]();\n                return state === "granted"\n            } catch (err) {\n                console.warn("[Touch] Failed to request orientation permission: ", err);\n                return false\n            }\n        }\n        async _RequestMotionPermission() {\n            if (!self["DeviceMotionEvent"] || !self["DeviceMotionEvent"]["requestPermission"])\n                return true;\n            try {\n                const state = await self["DeviceMotionEvent"]["requestPermission"]();\n                return state === "granted"\n            } catch (err) {\n                console.warn("[Touch] Failed to request motion permission: ", err);\n                return false\n            }\n        }\n    }\n    ;\n    self.RuntimeInterface.AddDOMHandlerClass(HANDLER_CLASS)\n}\n;\'use strict\';\n{\n    const R_TO_D = 180 \/ Math.PI;\n    const DOM_COMPONENT_ID = "audio";\n    self.AudioDOMHandler = class AudioDOMHandler extends self.DOMHandler {\n        constructor(iRuntime) {\n            super(iRuntime, DOM_COMPONENT_ID);\n            this._audioContext = null;\n            this._destinationNode = null;\n            this._hasUnblocked = false;\n            this._hasAttachedUnblockEvents = false;\n            this._unblockFunc = () => this._UnblockAudioContext();\n            this._audioBuffers = [];\n            this._audioInstances = [];\n            this._lastAudioInstance = null;\n            this._lastPlayedTag = "";\n            this._lastTickCount = -1;\n            this._pendingTags = new Map;\n            this._masterVolume = 1;\n            this._isSilent = false;\n            this._timeScaleMode = 0;\n            this._timeScale = 1;\n            this._gameTime = 0;\n            this._panningModel = "HRTF";\n            this._distanceModel = "inverse";\n            this._refDistance = 600;\n            this._maxDistance = 1E4;\n            this._rolloffFactor = 1;\n            this._playMusicAsSound = false;\n            this._hasAnySoftwareDecodedMusic = false;\n            this._supportsWebMOpus = this._iRuntime.IsAudioFormatSupported("audio\/webm; codecs=opus");\n            this._effects = new Map;\n            this._analysers = new Set;\n            this._isPendingPostFxState = false;\n            this._hasStartedOfflineRender = false;\n            this._microphoneTag = "";\n            this._microphoneSource = null;\n            self["C3Audio_OnMicrophoneStream"] = (localMediaStream, tag) => this._OnMicrophoneStream(localMediaStream, tag);\n            this._destMediaStreamNode = null;\n            self["C3Audio_GetOutputStream"] = () => this._OnGetOutputStream();\n            self["C3Audio_DOMInterface"] = this;\n            this.AddRuntimeMessageHandlers([["create-audio-context", e => this._CreateAudioContext(e)], ["play", e => this._Play(e)], ["stop", e => this._Stop(e)], ["stop-all", () => this._StopAll()], ["set-paused", e => this._SetPaused(e)], ["set-volume", e => this._SetVolume(e)], ["fade-volume", e => this._FadeVolume(e)], ["set-master-volume", e => this._SetMasterVolume(e)], ["set-muted", e => this._SetMuted(e)], ["set-silent", e => this._SetSilent(e)], ["set-looping", e => this._SetLooping(e)], ["set-playback-rate", e => this._SetPlaybackRate(e)], ["seek", e => this._Seek(e)], ["preload", e => this._Preload(e)], ["unload", e => this._Unload(e)], ["unload-all", () => this._UnloadAll()], ["set-suspended", e => this._SetSuspended(e)], ["add-effect", e => this._AddEffect(e)], ["set-effect-param", e => this._SetEffectParam(e)], ["remove-effects", e => this._RemoveEffects(e)], ["tick", e => this._OnTick(e)], ["load-state", e => this._OnLoadState(e)], ["offline-render-audio", e => this._OnOfflineRenderAudio(e)], ["offline-render-finish", () => this._OnOfflineRenderFinish()]])\n        }\n        async _CreateAudioContext(e) {\n            if (e["isiOSCordova"])\n                this._playMusicAsSound = true;\n            this._timeScaleMode = e["timeScaleMode"];\n            this._panningModel = ["equalpower", "HRTF", "soundfield"][e["panningModel"]];\n            this._distanceModel = ["linear", "inverse", "exponential"][e["distanceModel"]];\n            this._refDistance = e["refDistance"];\n            this._maxDistance = e["maxDistance"];\n            this._rolloffFactor = e["rolloffFactor"];\n            if (this._iRuntime.IsExportingToVideo()) {\n                this._playMusicAsSound = true;\n                const sampleRate = 48E3;\n                this._audioContext = new OfflineAudioContext({\n                    "numberOfChannels": 2,\n                    "sampleRate": sampleRate,\n                    "length": Math.ceil(this._iRuntime.GetExportToVideoDuration() * sampleRate)\n                })\n            } else {\n                const opts = {\n                    "latencyHint": e["latencyHint"]\n                };\n                if (!this.SupportsWebMOpus())\n                    opts["sampleRate"] = 48E3;\n                if (typeof AudioContext !== "undefined")\n                    this._audioContext = new AudioContext(opts);\n                else if (typeof webkitAudioContext !== "undefined")\n                    this._audioContext = new webkitAudioContext(opts);\n                else\n                    throw new Error("Web Audio API not supported");\n                this._AttachUnblockEvents();\n                this._audioContext.onstatechange = () => {\n                    if (this._audioContext.state !== "running")\n                        this._AttachUnblockEvents();\n                    this.PostToRuntime("audiocontext-state", {\n                        "audioContextState": this._audioContext.state\n                    })\n                }\n            }\n            this._destinationNode = this._audioContext["createGain"]();\n            this._destinationNode["connect"](this._audioContext["destination"]);\n            const listenerPos = e["listenerPos"];\n            this._audioContext["listener"]["setPosition"](listenerPos[0], listenerPos[1], listenerPos[2]);\n            this._audioContext["listener"]["setOrientation"](0, 0, 1, 0, -1, 0);\n            self["C3_GetAudioContextCurrentTime"] = () => this.GetAudioCurrentTime();\n            try {\n                await Promise.all(e["preloadList"].map(o => this._GetAudioBuffer(o["originalUrl"], o["url"], o["type"], false)))\n            } catch (err) {\n                console.error("[Construct] Preloading sounds failed: ", err)\n            }\n            return {\n                "sampleRate": this._audioContext["sampleRate"],\n                "audioContextState": this._audioContext.state\n            }\n        }\n        _AttachUnblockEvents() {\n            if (this._hasAttachedUnblockEvents)\n                return;\n            this._hasUnblocked = false;\n            window.addEventListener("pointerup", this._unblockFunc, true);\n            window.addEventListener("touchend", this._unblockFunc, true);\n            window.addEventListener("click", this._unblockFunc, true);\n            window.addEventListener("keydown", this._unblockFunc, true);\n            this._hasAttachedUnblockEvents = true\n        }\n        _DetachUnblockEvents() {\n            if (!this._hasAttachedUnblockEvents)\n                return;\n            this._hasUnblocked = true;\n            window.removeEventListener("pointerup", this._unblockFunc, true);\n            window.removeEventListener("touchend", this._unblockFunc, true);\n            window.removeEventListener("click", this._unblockFunc, true);\n            window.removeEventListener("keydown", this._unblockFunc, true);\n            this._hasAttachedUnblockEvents = false\n        }\n        _UnblockAudioContext() {\n            if (this._hasUnblocked)\n                return;\n            const audioContext = this._audioContext;\n            if (audioContext["state"] === "suspended" && audioContext["resume"])\n                audioContext["resume"]();\n            const buffer = audioContext["createBuffer"](1, 220, 22050);\n            const source = audioContext["createBufferSource"]();\n            source["buffer"] = buffer;\n            source["connect"](audioContext["destination"]);\n            source["start"](0);\n            if (audioContext["state"] === "running")\n                this._DetachUnblockEvents()\n        }\n        GetAudioContext() {\n            return this._audioContext\n        }\n        GetAudioCurrentTime() {\n            return this._audioContext["currentTime"]\n        }\n        GetDestinationNode() {\n            return this._destinationNode\n        }\n        GetDestinationForTag(tag) {\n            const fxChain = this._effects.get(tag.toLowerCase());\n            if (fxChain)\n                return fxChain[0].GetInputNode();\n            else\n                return this.GetDestinationNode()\n        }\n        AddEffectForTag(tag, effect) {\n            tag = tag.toLowerCase();\n            let fxChain = this._effects.get(tag);\n            if (!fxChain) {\n                fxChain = [];\n                this._effects.set(tag, fxChain)\n            }\n            effect._SetIndex(fxChain.length);\n            effect._SetTag(tag);\n            fxChain.push(effect);\n            this._ReconnectEffects(tag)\n        }\n        _ReconnectEffects(tag) {\n            let destNode = this.GetDestinationNode();\n            const fxChain = this._effects.get(tag);\n            if (fxChain && fxChain.length) {\n                destNode = fxChain[0].GetInputNode();\n                for (let i = 0, len = fxChain.length; i < len; ++i) {\n                    const n = fxChain[i];\n                    if (i + 1 === len)\n                        n.ConnectTo(this.GetDestinationNode());\n                    else\n                        n.ConnectTo(fxChain[i + 1].GetInputNode())\n                }\n            }\n            for (const ai of this.audioInstancesByTag(tag))\n                ai.Reconnect(destNode);\n            if (this._microphoneSource && this._microphoneTag === tag) {\n                this._microphoneSource["disconnect"]();\n                this._microphoneSource["connect"](destNode)\n            }\n        }\n        GetMasterVolume() {\n            return this._masterVolume\n        }\n        IsSilent() {\n            return this._isSilent\n        }\n        GetTimeScaleMode() {\n            return this._timeScaleMode\n        }\n        GetTimeScale() {\n            return this._timeScale\n        }\n        GetGameTime() {\n            return this._gameTime\n        }\n        IsPlayMusicAsSound() {\n            return this._playMusicAsSound\n        }\n        SupportsWebMOpus() {\n            return this._supportsWebMOpus\n        }\n        _SetHasAnySoftwareDecodedMusic() {\n            this._hasAnySoftwareDecodedMusic = true\n        }\n        GetPanningModel() {\n            return this._panningModel\n        }\n        GetDistanceModel() {\n            return this._distanceModel\n        }\n        GetReferenceDistance() {\n            return this._refDistance\n        }\n        GetMaxDistance() {\n            return this._maxDistance\n        }\n        GetRolloffFactor() {\n            return this._rolloffFactor\n        }\n        DecodeAudioData(audioData, needsSoftwareDecode) {\n            if (needsSoftwareDecode)\n                return this._iRuntime._WasmDecodeWebMOpus(audioData).then(rawAudio => {\n                    const audioBuffer = this._audioContext["createBuffer"](1, rawAudio.length, 48E3);\n                    const channelBuffer = audioBuffer["getChannelData"](0);\n                    channelBuffer.set(rawAudio);\n                    return audioBuffer\n                }\n                );\n            else\n                return new Promise( (resolve, reject) => {\n                    this._audioContext["decodeAudioData"](audioData, resolve, reject)\n                }\n                )\n        }\n        TryPlayMedia(mediaElem) {\n            this._iRuntime.TryPlayMedia(mediaElem)\n        }\n        RemovePendingPlay(mediaElem) {\n            this._iRuntime.RemovePendingPlay(mediaElem)\n        }\n        ReleaseInstancesForBuffer(buffer) {\n            let j = 0;\n            for (let i = 0, len = this._audioInstances.length; i < len; ++i) {\n                const a = this._audioInstances[i];\n                this._audioInstances[j] = a;\n                if (a.GetBuffer() === buffer)\n                    a.Release();\n                else\n                    ++j\n            }\n            this._audioInstances.length = j\n        }\n        ReleaseAllMusicBuffers() {\n            let j = 0;\n            for (let i = 0, len = this._audioBuffers.length; i < len; ++i) {\n                const b = this._audioBuffers[i];\n                this._audioBuffers[j] = b;\n                if (b.IsMusic())\n                    b.Release();\n                else\n                    ++j\n            }\n            this._audioBuffers.length = j\n        }\n        *audioInstancesByTag(tag) {\n            if (tag)\n                for (const ai of this._audioInstances) {\n                    if (self.AudioDOMHandler.EqualsNoCase(ai.GetTag(), tag))\n                        yield ai\n                }\n            else if (this._lastAudioInstance && !this._lastAudioInstance.HasEnded())\n                yield this._lastAudioInstance\n        }\n        async _GetAudioBuffer(originalUrl, url, type, isMusic, dontCreate) {\n            for (const ab of this._audioBuffers)\n                if (ab.GetUrl() === url) {\n                    await ab.Load();\n                    return ab\n                }\n            if (dontCreate)\n                return null;\n            if (isMusic && (this._playMusicAsSound || this._hasAnySoftwareDecodedMusic))\n                this.ReleaseAllMusicBuffers();\n            const ret = self.C3AudioBuffer.Create(this, originalUrl, url, type, isMusic);\n            this._audioBuffers.push(ret);\n            await ret.Load();\n            return ret\n        }\n        async _GetAudioInstance(originalUrl, url, type, tag, isMusic) {\n            for (const ai of this._audioInstances)\n                if (ai.GetUrl() === url && (ai.CanBeRecycled() || isMusic)) {\n                    ai.SetTag(tag);\n                    return ai\n                }\n            const buffer = await this._GetAudioBuffer(originalUrl, url, type, isMusic);\n            const ret = buffer.CreateInstance(tag);\n            this._audioInstances.push(ret);\n            return ret\n        }\n        _AddPendingTag(tag) {\n            let info = this._pendingTags.get(tag);\n            if (!info) {\n                let resolve = null;\n                const promise = new Promise(r => resolve = r);\n                info = {\n                    pendingCount: 0,\n                    promise,\n                    resolve\n                };\n                this._pendingTags.set(tag, info)\n            }\n            info.pendingCount++\n        }\n        _RemovePendingTag(tag) {\n            const info = this._pendingTags.get(tag);\n            if (!info)\n                throw new Error("expected pending tag");\n            info.pendingCount--;\n            if (info.pendingCount === 0) {\n                info.resolve();\n                this._pendingTags.delete(tag)\n            }\n        }\n        TagReady(tag) {\n            if (!tag)\n                tag = this._lastPlayedTag;\n            const info = this._pendingTags.get(tag);\n            if (info)\n                return info.promise;\n            else\n                return Promise.resolve()\n        }\n        _MaybeStartTicking() {\n            if (this._analysers.size > 0) {\n                this._StartTicking();\n                return\n            }\n            for (const ai of this._audioInstances)\n                if (ai.IsActive()) {\n                    this._StartTicking();\n                    return\n                }\n        }\n        Tick() {\n            for (const a of this._analysers)\n                a.Tick();\n            const currentTime = this.GetAudioCurrentTime();\n            for (const ai of this._audioInstances)\n                ai.Tick(currentTime);\n            const instStates = this._audioInstances.filter(a => a.IsActive()).map(a => a.GetState());\n            this.PostToRuntime("state", {\n                "tickCount": this._lastTickCount,\n                "audioInstances": instStates,\n                "analysers": [...this._analysers].map(a => a.GetData())\n            });\n            if (instStates.length === 0 && this._analysers.size === 0)\n                this._StopTicking()\n        }\n        PostTrigger(type, tag, aiid) {\n            this.PostToRuntime("trigger", {\n                "type": type,\n                "tag": tag,\n                "aiid": aiid\n            })\n        }\n        async _Play(e) {\n            const originalUrl = e["originalUrl"];\n            const url = e["url"];\n            const type = e["type"];\n            const isMusic = e["isMusic"];\n            const tag = e["tag"];\n            const isLooping = e["isLooping"];\n            const volume = e["vol"];\n            const position = e["pos"];\n            const panning = e["panning"];\n            let startTime = e["off"];\n            if (startTime > 0 && !e["trueClock"])\n                if (this._audioContext["getOutputTimestamp"]) {\n                    const outputTimestamp = this._audioContext["getOutputTimestamp"]();\n                    startTime = startTime - outputTimestamp["performanceTime"] \/ 1E3 + outputTimestamp["contextTime"]\n                } else\n                    startTime = startTime - performance.now() \/ 1E3 + this._audioContext["currentTime"];\n            this._lastPlayedTag = tag;\n            this._AddPendingTag(tag);\n            try {\n                this._lastAudioInstance = await this._GetAudioInstance(originalUrl, url, type, tag, isMusic);\n                if (panning) {\n                    this._lastAudioInstance.SetPannerEnabled(true);\n                    this._lastAudioInstance.SetPan(panning["x"], panning["y"], panning["angle"], panning["innerAngle"], panning["outerAngle"], panning["outerGain"]);\n                    if (panning.hasOwnProperty("uid"))\n                        this._lastAudioInstance.SetUID(panning["uid"])\n                } else\n                    this._lastAudioInstance.SetPannerEnabled(false);\n                this._lastAudioInstance.Play(isLooping, volume, position, startTime)\n            } catch (err) {\n                console.error("[Construct] Audio: error starting playback: ", err);\n                return\n            } finally {\n                this._RemovePendingTag(tag)\n            }\n            this._StartTicking()\n        }\n        _Stop(e) {\n            const tag = e["tag"];\n            for (const ai of this.audioInstancesByTag(tag))\n                ai.Stop()\n        }\n        _StopAll() {\n            for (const ai of this._audioInstances)\n                ai.Stop()\n        }\n        _SetPaused(e) {\n            const tag = e["tag"];\n            const paused = e["paused"];\n            for (const ai of this.audioInstancesByTag(tag))\n                if (paused)\n                    ai.Pause();\n                else\n                    ai.Resume();\n            this._MaybeStartTicking()\n        }\n        _SetVolume(e) {\n            const tag = e["tag"];\n            const vol = e["vol"];\n            for (const ai of this.audioInstancesByTag(tag))\n                ai.SetVolume(vol)\n        }\n        async _FadeVolume(e) {\n            const tag = e["tag"];\n            const vol = e["vol"];\n            const duration = e["duration"];\n            const stopOnEnd = e["stopOnEnd"];\n            await this.TagReady(tag);\n            for (const ai of this.audioInstancesByTag(tag))\n                ai.FadeVolume(vol, duration, stopOnEnd);\n            this._MaybeStartTicking()\n        }\n        _SetMasterVolume(e) {\n            this._masterVolume = e["vol"];\n            this._destinationNode["gain"]["value"] = this._masterVolume\n        }\n        _SetMuted(e) {\n            const tag = e["tag"];\n            const isMuted = e["isMuted"];\n            for (const ai of this.audioInstancesByTag(tag))\n                ai.SetMuted(isMuted)\n        }\n        _SetSilent(e) {\n            this._isSilent = e["isSilent"];\n            this._iRuntime.SetSilent(this._isSilent);\n            for (const ai of this._audioInstances)\n                ai._UpdateMuted()\n        }\n        _SetLooping(e) {\n            const tag = e["tag"];\n            const isLooping = e["isLooping"];\n            for (const ai of this.audioInstancesByTag(tag))\n                ai.SetLooping(isLooping)\n        }\n        async _SetPlaybackRate(e) {\n            const tag = e["tag"];\n            const rate = e["rate"];\n            await this.TagReady(tag);\n            for (const ai of this.audioInstancesByTag(tag))\n                ai.SetPlaybackRate(rate)\n        }\n        async _Seek(e) {\n            const tag = e["tag"];\n            const pos = e["pos"];\n            await this.TagReady(tag);\n            for (const ai of this.audioInstancesByTag(tag))\n                ai.Seek(pos)\n        }\n        async _Preload(e) {\n            const originalUrl = e["originalUrl"];\n            const url = e["url"];\n            const type = e["type"];\n            const isMusic = e["isMusic"];\n            try {\n                await this._GetAudioInstance(originalUrl, url, type, "", isMusic)\n            } catch (err) {\n                console.error("[Construct] Audio: error preloading: ", err)\n            }\n        }\n        async _Unload(e) {\n            const url = e["url"];\n            const type = e["type"];\n            const isMusic = e["isMusic"];\n            const buffer = await this._GetAudioBuffer("", url, type, isMusic, true);\n            if (!buffer)\n                return;\n            buffer.Release();\n            const i = this._audioBuffers.indexOf(buffer);\n            if (i !== -1)\n                this._audioBuffers.splice(i, 1)\n        }\n        _UnloadAll() {\n            for (const buffer of this._audioBuffers)\n                buffer.Release();\n            this._audioBuffers.length = 0\n        }\n        _SetSuspended(e) {\n            const isSuspended = e["isSuspended"];\n            if (!isSuspended && this._audioContext["resume"])\n                this._audioContext["resume"]();\n            for (const ai of this._audioInstances)\n                ai.SetSuspended(isSuspended);\n            if (isSuspended && this._audioContext["suspend"])\n                this._audioContext["suspend"]()\n        }\n        _OnTick(e) {\n            this._timeScale = e["timeScale"];\n            this._gameTime = e["gameTime"];\n            this._lastTickCount = e["tickCount"];\n            if (this._timeScaleMode !== 0)\n                for (const ai of this._audioInstances)\n                    ai._UpdatePlaybackRate();\n            const listenerPos = e["listenerPos"];\n            if (listenerPos)\n                this._audioContext["listener"]["setPosition"](listenerPos[0], listenerPos[1], listenerPos[2]);\n            for (const instPan of e["instPans"]) {\n                const uid = instPan["uid"];\n                for (const ai of this._audioInstances)\n                    if (ai.GetUID() === uid)\n                        ai.SetPanXYA(instPan["x"], instPan["y"], instPan["angle"])\n            }\n        }\n        async _AddEffect(e) {\n            const type = e["type"];\n            const tag = e["tag"];\n            const params = e["params"];\n            let effect;\n            if (type === "filter")\n                effect = new self.C3AudioFilterFX(this,...params);\n            else if (type === "delay")\n                effect = new self.C3AudioDelayFX(this,...params);\n            else if (type === "convolution") {\n                let buffer = null;\n                try {\n                    buffer = await this._GetAudioBuffer(e["bufferOriginalUrl"], e["bufferUrl"], e["bufferType"], false)\n                } catch (err) {\n                    console.log("[Construct] Audio: error loading convolution: ", err);\n                    return\n                }\n                effect = new self.C3AudioConvolveFX(this,buffer.GetAudioBuffer(),...params);\n                effect._SetBufferInfo(e["bufferOriginalUrl"], e["bufferUrl"], e["bufferType"])\n            } else if (type === "flanger")\n                effect = new self.C3AudioFlangerFX(this,...params);\n            else if (type === "phaser")\n                effect = new self.C3AudioPhaserFX(this,...params);\n            else if (type === "gain")\n                effect = new self.C3AudioGainFX(this,...params);\n            else if (type === "tremolo")\n                effect = new self.C3AudioTremoloFX(this,...params);\n            else if (type === "ringmod")\n                effect = new self.C3AudioRingModFX(this,...params);\n            else if (type === "distortion")\n                effect = new self.C3AudioDistortionFX(this,...params);\n            else if (type === "compressor")\n                effect = new self.C3AudioCompressorFX(this,...params);\n            else if (type === "analyser")\n                effect = new self.C3AudioAnalyserFX(this,...params);\n            else\n                throw new Error("invalid effect type");\n            this.AddEffectForTag(tag, effect);\n            this._PostUpdatedFxState()\n        }\n        _SetEffectParam(e) {\n            const tag = e["tag"];\n            const index = e["index"];\n            const param = e["param"];\n            const value = e["value"];\n            const ramp = e["ramp"];\n            const time = e["time"];\n            const fxChain = this._effects.get(tag);\n            if (!fxChain || index < 0 || index >= fxChain.length)\n                return;\n            fxChain[index].SetParam(param, value, ramp, time);\n            this._PostUpdatedFxState()\n        }\n        _RemoveEffects(e) {\n            const tag = e["tag"].toLowerCase();\n            const fxChain = this._effects.get(tag);\n            if (!fxChain || !fxChain.length)\n                return;\n            for (const effect of fxChain)\n                effect.Release();\n            this._effects.delete(tag);\n            this._ReconnectEffects(tag)\n        }\n        _AddAnalyser(analyser) {\n            this._analysers.add(analyser);\n            this._MaybeStartTicking()\n        }\n        _RemoveAnalyser(analyser) {\n            this._analysers.delete(analyser)\n        }\n        _PostUpdatedFxState() {\n            if (this._isPendingPostFxState)\n                return;\n            this._isPendingPostFxState = true;\n            Promise.resolve().then( () => this._DoPostUpdatedFxState())\n        }\n        _DoPostUpdatedFxState() {\n            const fxstate = {};\n            for (const [tag,fxChain] of this._effects)\n                fxstate[tag] = fxChain.map(e => e.GetState());\n            this.PostToRuntime("fxstate", {\n                "fxstate": fxstate\n            });\n            this._isPendingPostFxState = false\n        }\n        async _OnLoadState(e) {\n            const saveLoadMode = e["saveLoadMode"];\n            if (saveLoadMode !== 3)\n                for (const ai of this._audioInstances) {\n                    if (ai.IsMusic() && saveLoadMode === 1)\n                        continue;\n                    if (!ai.IsMusic() && saveLoadMode === 2)\n                        continue;\n                    ai.Stop()\n                }\n            for (const fxChain of this._effects.values())\n                for (const effect of fxChain)\n                    effect.Release();\n            this._effects.clear();\n            this._timeScale = e["timeScale"];\n            this._gameTime = e["gameTime"];\n            const listenerPos = e["listenerPos"];\n            this._audioContext["listener"]["setPosition"](listenerPos[0], listenerPos[1], listenerPos[2]);\n            this._isSilent = e["isSilent"];\n            this._iRuntime.SetSilent(this._isSilent);\n            this._masterVolume = e["masterVolume"];\n            this._destinationNode["gain"]["value"] = this._masterVolume;\n            const promises = [];\n            for (const fxChainData of Object.values(e["effects"]))\n                promises.push(Promise.all(fxChainData.map(d => this._AddEffect(d))));\n            await Promise.all(promises);\n            await Promise.all(e["playing"].map(d => this._LoadAudioInstance(d, saveLoadMode)));\n            this._MaybeStartTicking()\n        }\n        async _LoadAudioInstance(d, saveLoadMode) {\n            if (saveLoadMode === 3)\n                return;\n            const originalUrl = d["bufferOriginalUrl"];\n            const url = d["bufferUrl"];\n            const type = d["bufferType"];\n            const isMusic = d["isMusic"];\n            const tag = d["tag"];\n            const isLooping = d["isLooping"];\n            const volume = d["volume"];\n            const position = d["playbackTime"];\n            if (isMusic && saveLoadMode === 1)\n                return;\n            if (!isMusic && saveLoadMode === 2)\n                return;\n            let ai = null;\n            try {\n                ai = await this._GetAudioInstance(originalUrl, url, type, tag, isMusic)\n            } catch (err) {\n                console.error("[Construct] Audio: error loading audio state: ", err);\n                return\n            }\n            ai.LoadPanState(d["pan"]);\n            ai.Play(isLooping, volume, position, 0);\n            if (!d["isPlaying"])\n                ai.Pause();\n            ai._LoadAdditionalState(d)\n        }\n        _OnMicrophoneStream(localMediaStream, tag) {\n            if (this._microphoneSource)\n                this._microphoneSource["disconnect"]();\n            this._microphoneTag = tag.toLowerCase();\n            this._microphoneSource = this._audioContext["createMediaStreamSource"](localMediaStream);\n            this._microphoneSource["connect"](this.GetDestinationForTag(this._microphoneTag))\n        }\n        _OnGetOutputStream() {\n            if (!this._destMediaStreamNode) {\n                this._destMediaStreamNode = this._audioContext["createMediaStreamDestination"]();\n                this._destinationNode["connect"](this._destMediaStreamNode)\n            }\n            return this._destMediaStreamNode["stream"]\n        }\n        async _OnOfflineRenderAudio(e) {\n            try {\n                const time = e["time"];\n                const suspendPromise = this._audioContext["suspend"](time);\n                if (!this._hasStartedOfflineRender) {\n                    this._audioContext["startRendering"]().then(buffer => this._OnOfflineRenderCompleted(buffer)).catch(err => this._OnOfflineRenderError(err));\n                    this._hasStartedOfflineRender = true\n                } else\n                    this._audioContext["resume"]();\n                await suspendPromise\n            } catch (err) {\n                this._OnOfflineRenderError(err)\n            }\n        }\n        _OnOfflineRenderFinish() {\n            this._audioContext["resume"]()\n        }\n        _OnOfflineRenderCompleted(buffer) {\n            const channelArrayBuffers = [];\n            for (let i = 0, len = buffer["numberOfChannels"]; i < len; ++i) {\n                const f32arr = buffer["getChannelData"](i);\n                channelArrayBuffers.push(f32arr.buffer)\n            }\n            this._iRuntime.PostToRuntimeComponent("runtime", "offline-audio-render-completed", {\n                "duration": buffer["duration"],\n                "length": buffer["length"],\n                "numberOfChannels": buffer["numberOfChannels"],\n                "sampleRate": buffer["sampleRate"],\n                "channelData": channelArrayBuffers\n            }, null, channelArrayBuffers)\n        }\n        _OnOfflineRenderError(err) {\n            console.error(`[Audio] Offline rendering error: `, err)\n        }\n        static EqualsNoCase(a, b) {\n            if (a.length !== b.length)\n                return false;\n            if (a === b)\n                return true;\n            return a.toLowerCase() === b.toLowerCase()\n        }\n        static ToDegrees(x) {\n            return x * R_TO_D\n        }\n        static DbToLinearNoCap(x) {\n            return Math.pow(10, x \/ 20)\n        }\n        static DbToLinear(x) {\n            return Math.max(Math.min(self.AudioDOMHandler.DbToLinearNoCap(x), 1), 0)\n        }\n        static LinearToDbNoCap(x) {\n            return Math.log(x) \/ Math.log(10) * 20\n        }\n        static LinearToDb(x) {\n            return self.AudioDOMHandler.LinearToDbNoCap(Math.max(Math.min(x, 1), 0))\n        }\n        static e4(x, k) {\n            return 1 - Math.exp(-k * x)\n        }\n    }\n    ;\n    self.RuntimeInterface.AddDOMHandlerClass(self.AudioDOMHandler)\n}\n;\'use strict\';\n{\n    self.C3AudioBuffer = class C3AudioBuffer {\n        constructor(audioDomHandler, originalUrl, url, type, isMusic) {\n            this._audioDomHandler = audioDomHandler;\n            this._originalUrl = originalUrl;\n            this._url = url;\n            this._type = type;\n            this._isMusic = isMusic;\n            this._api = "";\n            this._loadState = "not-loaded";\n            this._loadPromise = null\n        }\n        Release() {\n            this._loadState = "not-loaded";\n            this._audioDomHandler = null;\n            this._loadPromise = null\n        }\n        static Create(audioDomHandler, originalUrl, url, type, isMusic) {\n            const needsSoftwareDecode = type === "audio\/webm; codecs=opus" && !audioDomHandler.SupportsWebMOpus();\n            if (isMusic && needsSoftwareDecode)\n                audioDomHandler._SetHasAnySoftwareDecodedMusic();\n            if (!isMusic || audioDomHandler.IsPlayMusicAsSound() || needsSoftwareDecode)\n                return new self.C3WebAudioBuffer(audioDomHandler,originalUrl,url,type,isMusic,needsSoftwareDecode);\n            else\n                return new self.C3Html5AudioBuffer(audioDomHandler,originalUrl,url,type,isMusic)\n        }\n        CreateInstance(tag) {\n            if (this._api === "html5")\n                return new self.C3Html5AudioInstance(this._audioDomHandler,this,tag);\n            else\n                return new self.C3WebAudioInstance(this._audioDomHandler,this,tag)\n        }\n        _Load() {}\n        Load() {\n            if (!this._loadPromise)\n                this._loadPromise = this._Load();\n            return this._loadPromise\n        }\n        IsLoaded() {}\n        IsLoadedAndDecoded() {}\n        HasFailedToLoad() {\n            return this._loadState === "failed"\n        }\n        GetAudioContext() {\n            return this._audioDomHandler.GetAudioContext()\n        }\n        GetApi() {\n            return this._api\n        }\n        GetOriginalUrl() {\n            return this._originalUrl\n        }\n        GetUrl() {\n            return this._url\n        }\n        GetContentType() {\n            return this._type\n        }\n        IsMusic() {\n            return this._isMusic\n        }\n        GetDuration() {}\n    }\n}\n;\'use strict\';\n{\n    self.C3Html5AudioBuffer = class C3Html5AudioBuffer extends self.C3AudioBuffer {\n        constructor(audioDomHandler, originalUrl, url, type, isMusic) {\n            super(audioDomHandler, originalUrl, url, type, isMusic);\n            this._api = "html5";\n            this._audioElem = new Audio;\n            this._audioElem.crossOrigin = "anonymous";\n            this._audioElem.autoplay = false;\n            this._audioElem.preload = "auto";\n            this._loadResolve = null;\n            this._loadReject = null;\n            this._reachedCanPlayThrough = false;\n            this._audioElem.addEventListener("canplaythrough", () => this._reachedCanPlayThrough = true);\n            this._outNode = this.GetAudioContext()["createGain"]();\n            this._mediaSourceNode = null;\n            this._audioElem.addEventListener("canplay", () => {\n                if (this._loadResolve) {\n                    this._loadState = "loaded";\n                    this._loadResolve();\n                    this._loadResolve = null;\n                    this._loadReject = null\n                }\n                if (this._mediaSourceNode || !this._audioElem)\n                    return;\n                this._mediaSourceNode = this.GetAudioContext()["createMediaElementSource"](this._audioElem);\n                this._mediaSourceNode["connect"](this._outNode)\n            }\n            );\n            this.onended = null;\n            this._audioElem.addEventListener("ended", () => {\n                if (this.onended)\n                    this.onended()\n            }\n            );\n            this._audioElem.addEventListener("error", e => this._OnError(e))\n        }\n        Release() {\n            this._audioDomHandler.ReleaseInstancesForBuffer(this);\n            this._outNode["disconnect"]();\n            this._outNode = null;\n            this._mediaSourceNode["disconnect"]();\n            this._mediaSourceNode = null;\n            if (this._audioElem && !this._audioElem.paused)\n                this._audioElem.pause();\n            this.onended = null;\n            this._audioElem = null;\n            super.Release()\n        }\n        _Load() {\n            this._loadState = "loading";\n            return new Promise( (resolve, reject) => {\n                this._loadResolve = resolve;\n                this._loadReject = reject;\n                this._audioElem.src = this._url\n            }\n            )\n        }\n        _OnError(e) {\n            console.error(`[Construct] Audio \'${this._url}\' error: `, e);\n            if (this._loadReject) {\n                this._loadState = "failed";\n                this._loadReject(e);\n                this._loadResolve = null;\n                this._loadReject = null\n            }\n        }\n        IsLoaded() {\n            const ret = this._audioElem["readyState"] >= 4;\n            if (ret)\n                this._reachedCanPlayThrough = true;\n            return ret || this._reachedCanPlayThrough\n        }\n        IsLoadedAndDecoded() {\n            return this.IsLoaded()\n        }\n        GetAudioElement() {\n            return this._audioElem\n        }\n        GetOutputNode() {\n            return this._outNode\n        }\n        GetDuration() {\n            return this._audioElem["duration"]\n        }\n    }\n}\n;\'use strict\';\n{\n    self.C3WebAudioBuffer = class C3WebAudioBuffer extends self.C3AudioBuffer {\n        constructor(audioDomHandler, originalUrl, url, type, isMusic, needsSoftwareDecode) {\n            super(audioDomHandler, originalUrl, url, type, isMusic);\n            this._api = "webaudio";\n            this._audioData = null;\n            this._audioBuffer = null;\n            this._needsSoftwareDecode = !!needsSoftwareDecode\n        }\n        Release() {\n            this._audioDomHandler.ReleaseInstancesForBuffer(this);\n            this._audioData = null;\n            this._audioBuffer = null;\n            super.Release()\n        }\n        async _Fetch() {\n            if (this._audioData)\n                return this._audioData;\n            const iRuntime = this._audioDomHandler.GetRuntimeInterface();\n            if (iRuntime.GetExportType() === "cordova" && iRuntime.IsRelativeURL(this._url) && iRuntime.IsFileProtocol())\n                this._audioData = await iRuntime.CordovaFetchLocalFileAsArrayBuffer(this._url);\n            else {\n                const response = await fetch(this._url);\n                if (!response.ok)\n                    throw new Error(`error fetching audio data: ${response.status} ${response.statusText}`);\n                this._audioData = await response.arrayBuffer()\n            }\n        }\n        async _Decode() {\n            if (this._audioBuffer)\n                return this._audioBuffer;\n            this._audioBuffer = await this._audioDomHandler.DecodeAudioData(this._audioData, this._needsSoftwareDecode);\n            this._audioData = null\n        }\n        async _Load() {\n            try {\n                this._loadState = "loading";\n                await this._Fetch();\n                await this._Decode();\n                this._loadState = "loaded"\n            } catch (err) {\n                this._loadState = "failed";\n                console.error(`[Construct] Failed to load audio \'${this._url}\': `, err)\n            }\n        }\n        IsLoaded() {\n            return !!(this._audioData || this._audioBuffer)\n        }\n        IsLoadedAndDecoded() {\n            return !!this._audioBuffer\n        }\n        GetAudioBuffer() {\n            return this._audioBuffer\n        }\n        GetDuration() {\n            return this._audioBuffer ? this._audioBuffer["duration"] : 0\n        }\n    }\n}\n;\'use strict\';\n{\n    let nextAiId = 0;\n    self.C3AudioInstance = class C3AudioInstance {\n        constructor(audioDomHandler, buffer, tag) {\n            this._audioDomHandler = audioDomHandler;\n            this._buffer = buffer;\n            this._tag = tag;\n            this._aiId = nextAiId++;\n            this._gainNode = this.GetAudioContext()["createGain"]();\n            this._gainNode["connect"](this.GetDestinationNode());\n            this._pannerNode = null;\n            this._isPannerEnabled = false;\n            this._pannerPosition = [0, 0, 0];\n            this._pannerOrientation = [0, 0, 0];\n            this._isStopped = true;\n            this._isPaused = false;\n            this._resumeMe = false;\n            this._isLooping = false;\n            this._volume = 1;\n            this._isMuted = false;\n            this._playbackRate = 1;\n            const timeScaleMode = this._audioDomHandler.GetTimeScaleMode();\n            this._isTimescaled = timeScaleMode === 1 && !this.IsMusic() || timeScaleMode === 2;\n            this._instUid = -1;\n            this._fadeEndTime = -1;\n            this._stopOnFadeEnd = false\n        }\n        Release() {\n            this._audioDomHandler = null;\n            this._buffer = null;\n            if (this._pannerNode) {\n                this._pannerNode["disconnect"]();\n                this._pannerNode = null\n            }\n            this._gainNode["disconnect"]();\n            this._gainNode = null\n        }\n        GetAudioContext() {\n            return this._audioDomHandler.GetAudioContext()\n        }\n        GetDestinationNode() {\n            return this._audioDomHandler.GetDestinationForTag(this._tag)\n        }\n        GetCurrentTime() {\n            if (this._isTimescaled)\n                return this._audioDomHandler.GetGameTime();\n            else\n                return performance.now() \/ 1E3\n        }\n        GetOriginalUrl() {\n            return this._buffer.GetOriginalUrl()\n        }\n        GetUrl() {\n            return this._buffer.GetUrl()\n        }\n        GetContentType() {\n            return this._buffer.GetContentType()\n        }\n        GetBuffer() {\n            return this._buffer\n        }\n        IsMusic() {\n            return this._buffer.IsMusic()\n        }\n        SetTag(tag) {\n            this._tag = tag\n        }\n        GetTag() {\n            return this._tag\n        }\n        GetAiId() {\n            return this._aiId\n        }\n        HasEnded() {}\n        CanBeRecycled() {}\n        IsPlaying() {\n            return !this._isStopped && !this._isPaused && !this.HasEnded()\n        }\n        IsActive() {\n            return !this._isStopped && !this.HasEnded()\n        }\n        GetPlaybackTime() {}\n        GetDuration(applyPlaybackRate) {\n            let ret = this._buffer.GetDuration();\n            if (applyPlaybackRate)\n                ret \/= this._playbackRate || .001;\n            return ret\n        }\n        Play(isLooping, vol, seekPos, scheduledTime) {}\n        Stop() {}\n        Pause() {}\n        IsPaused() {\n            return this._isPaused\n        }\n        Resume() {}\n        SetVolume(v) {\n            this._volume = v;\n            this._gainNode["gain"]["cancelScheduledValues"](0);\n            this._fadeEndTime = -1;\n            this._gainNode["gain"]["value"] = this.GetOutputVolume()\n        }\n        FadeVolume(vol, duration, stopOnEnd) {\n            if (this.IsMuted())\n                return;\n            const gainParam = this._gainNode["gain"];\n            gainParam["cancelScheduledValues"](0);\n            const currentTime = this._audioDomHandler.GetAudioCurrentTime();\n            const endTime = currentTime + duration;\n            gainParam["setValueAtTime"](gainParam["value"], currentTime);\n            gainParam["linearRampToValueAtTime"](vol, endTime);\n            this._volume = vol;\n            this._fadeEndTime = endTime;\n            this._stopOnFadeEnd = stopOnEnd\n        }\n        _UpdateVolume() {\n            this.SetVolume(this._volume)\n        }\n        Tick(currentTime) {\n            if (this._fadeEndTime !== -1 && currentTime >= this._fadeEndTime) {\n                this._fadeEndTime = -1;\n                if (this._stopOnFadeEnd)\n                    this.Stop();\n                this._audioDomHandler.PostTrigger("fade-ended", this._tag, this._aiId)\n            }\n        }\n        GetOutputVolume() {\n            const ret = this._volume;\n            return isFinite(ret) ? ret : 0\n        }\n        SetMuted(m) {\n            m = !!m;\n            if (this._isMuted === m)\n                return;\n            this._isMuted = m;\n            this._UpdateMuted()\n        }\n        IsMuted() {\n            return this._isMuted\n        }\n        IsSilent() {\n            return this._audioDomHandler.IsSilent()\n        }\n        _UpdateMuted() {}\n        SetLooping(l) {}\n        IsLooping() {\n            return this._isLooping\n        }\n        SetPlaybackRate(r) {\n            if (this._playbackRate === r)\n                return;\n            this._playbackRate = r;\n            this._UpdatePlaybackRate()\n        }\n        _UpdatePlaybackRate() {}\n        GetPlaybackRate() {\n            return this._playbackRate\n        }\n        Seek(pos) {}\n        SetSuspended(s) {}\n        SetPannerEnabled(e) {\n            e = !!e;\n            if (this._isPannerEnabled === e)\n                return;\n            this._isPannerEnabled = e;\n            if (this._isPannerEnabled) {\n                if (!this._pannerNode) {\n                    this._pannerNode = this.GetAudioContext()["createPanner"]();\n                    this._pannerNode["panningModel"] = this._audioDomHandler.GetPanningModel();\n                    this._pannerNode["distanceModel"] = this._audioDomHandler.GetDistanceModel();\n                    this._pannerNode["refDistance"] = this._audioDomHandler.GetReferenceDistance();\n                    this._pannerNode["maxDistance"] = this._audioDomHandler.GetMaxDistance();\n                    this._pannerNode["rolloffFactor"] = this._audioDomHandler.GetRolloffFactor()\n                }\n                this._gainNode["disconnect"]();\n                this._gainNode["connect"](this._pannerNode);\n                this._pannerNode["connect"](this.GetDestinationNode())\n            } else {\n                this._pannerNode["disconnect"]();\n                this._gainNode["disconnect"]();\n                this._gainNode["connect"](this.GetDestinationNode())\n            }\n        }\n        SetPan(x, y, angle, innerAngle, outerAngle, outerGain) {\n            if (!this._isPannerEnabled)\n                return;\n            this.SetPanXYA(x, y, angle);\n            const toDegrees = self.AudioDOMHandler.ToDegrees;\n            this._pannerNode["coneInnerAngle"] = toDegrees(innerAngle);\n            this._pannerNode["coneOuterAngle"] = toDegrees(outerAngle);\n            this._pannerNode["coneOuterGain"] = outerGain\n        }\n        SetPanXYA(x, y, angle) {\n            if (!this._isPannerEnabled)\n                return;\n            this._pannerPosition[0] = x;\n            this._pannerPosition[1] = y;\n            this._pannerPosition[2] = 0;\n            this._pannerOrientation[0] = Math.cos(angle);\n            this._pannerOrientation[1] = Math.sin(angle);\n            this._pannerOrientation[2] = 0;\n            this._pannerNode["setPosition"](...this._pannerPosition);\n            this._pannerNode["setOrientation"](...this._pannerOrientation)\n        }\n        SetUID(uid) {\n            this._instUid = uid\n        }\n        GetUID() {\n            return this._instUid\n        }\n        GetResumePosition() {}\n        Reconnect(toNode) {\n            const outNode = this._pannerNode || this._gainNode;\n            outNode["disconnect"]();\n            outNode["connect"](toNode)\n        }\n        GetState() {\n            return {\n                "aiid": this.GetAiId(),\n                "tag": this._tag,\n                "duration": this.GetDuration(),\n                "volume": this._volume,\n                "isPlaying": this.IsPlaying(),\n                "playbackTime": this.GetPlaybackTime(),\n                "playbackRate": this.GetPlaybackRate(),\n                "uid": this._instUid,\n                "bufferOriginalUrl": this.GetOriginalUrl(),\n                "bufferUrl": "",\n                "bufferType": this.GetContentType(),\n                "isMusic": this.IsMusic(),\n                "isLooping": this.IsLooping(),\n                "isMuted": this.IsMuted(),\n                "resumePosition": this.GetResumePosition(),\n                "pan": this.GetPanState()\n            }\n        }\n        _LoadAdditionalState(d) {\n            this.SetPlaybackRate(d["playbackRate"]);\n            this.SetMuted(d["isMuted"])\n        }\n        GetPanState() {\n            if (!this._pannerNode)\n                return null;\n            const pn = this._pannerNode;\n            return {\n                "pos": this._pannerPosition,\n                "orient": this._pannerOrientation,\n                "cia": pn["coneInnerAngle"],\n                "coa": pn["coneOuterAngle"],\n                "cog": pn["coneOuterGain"],\n                "uid": this._instUid\n            }\n        }\n        LoadPanState(d) {\n            if (!d) {\n                this.SetPannerEnabled(false);\n                return\n            }\n            this.SetPannerEnabled(true);\n            const pn = this._pannerNode;\n            const panPos = pn["pos"];\n            this._pannerPosition[0] = panPos[0];\n            this._pannerPosition[1] = panPos[1];\n            this._pannerPosition[2] = panPos[2];\n            const panOrient = pn["orient"];\n            this._pannerOrientation[0] = panOrient[0];\n            this._pannerOrientation[1] = panOrient[1];\n            this._pannerOrientation[2] = panOrient[2];\n            pn["setPosition"](...this._pannerPosition);\n            pn["setOrientation"](...this._pannerOrientation);\n            pn["coneInnerAngle"] = pn["cia"];\n            pn["coneOuterAngle"] = pn["coa"];\n            pn["coneOuterGain"] = pn["cog"];\n            this._instUid = pn["uid"]\n        }\n    }\n}\n;\'use strict\';\n{\n    self.C3Html5AudioInstance = class C3Html5AudioInstance extends self.C3AudioInstance {\n        constructor(audioDomHandler, buffer, tag) {\n            super(audioDomHandler, buffer, tag);\n            this._buffer.GetOutputNode()["connect"](this._gainNode);\n            this._buffer.onended = () => this._OnEnded()\n        }\n        Release() {\n            this.Stop();\n            this._buffer.GetOutputNode()["disconnect"]();\n            super.Release()\n        }\n        GetAudioElement() {\n            return this._buffer.GetAudioElement()\n        }\n        _OnEnded() {\n            this._isStopped = true;\n            this._instUid = -1;\n            this._audioDomHandler.PostTrigger("ended", this._tag, this._aiId)\n        }\n        HasEnded() {\n            return this.GetAudioElement()["ended"]\n        }\n        CanBeRecycled() {\n            if (this._isStopped)\n                return true;\n            return this.HasEnded()\n        }\n        GetPlaybackTime() {\n            let ret = this.GetAudioElement()["currentTime"];\n            if (!this._isLooping)\n                ret = Math.min(ret, this.GetDuration());\n            return ret\n        }\n        Play(isLooping, vol, seekPos, scheduledTime) {\n            const audioElem = this.GetAudioElement();\n            if (audioElem.playbackRate !== 1)\n                audioElem.playbackRate = 1;\n            if (audioElem.loop !== isLooping)\n                audioElem.loop = isLooping;\n            this.SetVolume(vol);\n            if (audioElem.muted)\n                audioElem.muted = false;\n            if (audioElem.currentTime !== seekPos)\n                try {\n                    audioElem.currentTime = seekPos\n                } catch (err) {\n                    console.warn(`[Construct] Exception seeking audio \'${this._buffer.GetUrl()}\' to position \'${seekPos}\': `, err)\n                }\n            this._audioDomHandler.TryPlayMedia(audioElem);\n            this._isStopped = false;\n            this._isPaused = false;\n            this._isLooping = isLooping;\n            this._playbackRate = 1\n        }\n        Stop() {\n            const audioElem = this.GetAudioElement();\n            if (!audioElem.paused)\n                audioElem.pause();\n            this._audioDomHandler.RemovePendingPlay(audioElem);\n            this._isStopped = true;\n            this._isPaused = false;\n            this._instUid = -1\n        }\n        Pause() {\n            if (this._isPaused || this._isStopped || this.HasEnded())\n                return;\n            const audioElem = this.GetAudioElement();\n            if (!audioElem.paused)\n                audioElem.pause();\n            this._audioDomHandler.RemovePendingPlay(audioElem);\n            this._isPaused = true\n        }\n        Resume() {\n            if (!this._isPaused || this._isStopped || this.HasEnded())\n                return;\n            this._audioDomHandler.TryPlayMedia(this.GetAudioElement());\n            this._isPaused = false\n        }\n        _UpdateMuted() {\n            this.GetAudioElement().muted = this._isMuted || this.IsSilent()\n        }\n        SetLooping(l) {\n            l = !!l;\n            if (this._isLooping === l)\n                return;\n            this._isLooping = l;\n            this.GetAudioElement().loop = l\n        }\n        _UpdatePlaybackRate() {\n            let r = this._playbackRate;\n            if (this._isTimescaled)\n                r *= this._audioDomHandler.GetTimeScale();\n            try {\n                this.GetAudioElement()["playbackRate"] = r\n            } catch (err) {\n                console.warn(`[Construct] Unable to set playback rate \'${r}\':`, err)\n            }\n        }\n        Seek(pos) {\n            if (this._isStopped || this.HasEnded())\n                return;\n            try {\n                this.GetAudioElement()["currentTime"] = pos\n            } catch (err) {\n                console.warn(`[Construct] Error seeking audio to \'${pos}\': `, err)\n            }\n        }\n        GetResumePosition() {\n            return this.GetPlaybackTime()\n        }\n        SetSuspended(s) {\n            if (s)\n                if (this.IsPlaying()) {\n                    this.GetAudioElement()["pause"]();\n                    this._resumeMe = true\n                } else\n                    this._resumeMe = false;\n            else if (this._resumeMe) {\n                this._audioDomHandler.TryPlayMedia(this.GetAudioElement());\n                this._resumeMe = false\n            }\n        }\n    }\n}\n;\'use strict\';\n{\n    self.C3WebAudioInstance = class C3WebAudioInstance extends self.C3AudioInstance {\n        constructor(audioDomHandler, buffer, tag) {\n            super(audioDomHandler, buffer, tag);\n            this._bufferSource = null;\n            this._onended_handler = e => this._OnEnded(e);\n            this._hasPlaybackEnded = true;\n            this._activeSource = null;\n            this._playStartTime = 0;\n            this._playFromSeekPos = 0;\n            this._resumePosition = 0;\n            this._muteVol = 1\n        }\n        Release() {\n            this.Stop();\n            this._ReleaseBufferSource();\n            this._onended_handler = null;\n            super.Release()\n        }\n        _ReleaseBufferSource() {\n            if (this._bufferSource)\n                this._bufferSource["disconnect"]();\n            this._bufferSource = null;\n            this._activeSource = null\n        }\n        _OnEnded(e) {\n            if (this._isPaused || this._resumeMe)\n                return;\n            if (e.target !== this._activeSource)\n                return;\n            this._hasPlaybackEnded = true;\n            this._isStopped = true;\n            this._instUid = -1;\n            this._ReleaseBufferSource();\n            this._audioDomHandler.PostTrigger("ended", this._tag, this._aiId)\n        }\n        HasEnded() {\n            if (!this._isStopped && this._bufferSource && this._bufferSource["loop"])\n                return false;\n            if (this._isPaused)\n                return false;\n            return this._hasPlaybackEnded\n        }\n        CanBeRecycled() {\n            if (!this._bufferSource || this._isStopped)\n                return true;\n            return this.HasEnded()\n        }\n        GetPlaybackTime() {\n            let ret = 0;\n            if (this._isPaused)\n                ret = this._resumePosition;\n            else\n                ret = this._playFromSeekPos + (this.GetCurrentTime() - this._playStartTime) * this._playbackRate;\n            if (!this._isLooping)\n                ret = Math.min(ret, this.GetDuration());\n            return ret\n        }\n        Play(isLooping, vol, seekPos, scheduledTime) {\n            this._muteVol = 1;\n            this.SetVolume(vol);\n            this._ReleaseBufferSource();\n            this._bufferSource = this.GetAudioContext()["createBufferSource"]();\n            this._bufferSource["buffer"] = this._buffer.GetAudioBuffer();\n            this._bufferSource["connect"](this._gainNode);\n            this._activeSource = this._bufferSource;\n            this._bufferSource["onended"] = this._onended_handler;\n            this._bufferSource["loop"] = isLooping;\n            this._bufferSource["start"](scheduledTime, seekPos);\n            this._hasPlaybackEnded = false;\n            this._isStopped = false;\n            this._isPaused = false;\n            this._isLooping = isLooping;\n            this._playbackRate = 1;\n            this._playStartTime = this.GetCurrentTime();\n            this._playFromSeekPos = seekPos\n        }\n        Stop() {\n            if (this._bufferSource)\n                try {\n                    this._bufferSource["stop"](0)\n                } catch (err) {}\n            this._isStopped = true;\n            this._isPaused = false;\n            this._instUid = -1\n        }\n        Pause() {\n            if (this._isPaused || this._isStopped || this.HasEnded())\n                return;\n            this._resumePosition = this.GetPlaybackTime();\n            if (this._isLooping)\n                this._resumePosition %= this.GetDuration();\n            this._isPaused = true;\n            this._bufferSource["stop"](0)\n        }\n        Resume() {\n            if (!this._isPaused || this._isStopped || this.HasEnded())\n                return;\n            this._ReleaseBufferSource();\n            this._bufferSource = this.GetAudioContext()["createBufferSource"]();\n            this._bufferSource["buffer"] = this._buffer.GetAudioBuffer();\n            this._bufferSource["connect"](this._gainNode);\n            this._activeSource = this._bufferSource;\n            this._bufferSource["onended"] = this._onended_handler;\n            this._bufferSource["loop"] = this._isLooping;\n            this._UpdateVolume();\n            this._UpdatePlaybackRate();\n            this._bufferSource["start"](0, this._resumePosition);\n            this._playStartTime = this.GetCurrentTime();\n            this._playFromSeekPos = this._resumePosition;\n            this._isPaused = false\n        }\n        GetOutputVolume() {\n            return super.GetOutputVolume() * this._muteVol\n        }\n        _UpdateMuted() {\n            this._muteVol = this._isMuted || this.IsSilent() ? 0 : 1;\n            this._UpdateVolume()\n        }\n        SetLooping(l) {\n            l = !!l;\n            if (this._isLooping === l)\n                return;\n            this._isLooping = l;\n            if (this._bufferSource)\n                this._bufferSource["loop"] = l\n        }\n        _UpdatePlaybackRate() {\n            let r = this._playbackRate;\n            if (this._isTimescaled)\n                r *= this._audioDomHandler.GetTimeScale();\n            if (this._bufferSource)\n                this._bufferSource["playbackRate"]["value"] = r\n        }\n        Seek(pos) {\n            if (this._isStopped || this.HasEnded())\n                return;\n            if (this._isPaused)\n                this._resumePosition = pos;\n            else {\n                this.Pause();\n                this._resumePosition = pos;\n                this.Resume()\n            }\n        }\n        GetResumePosition() {\n            return this._resumePosition\n        }\n        SetSuspended(s) {\n            if (s)\n                if (this.IsPlaying()) {\n                    this._resumeMe = true;\n                    this._resumePosition = this.GetPlaybackTime();\n                    if (this._isLooping)\n                        this._resumePosition %= this.GetDuration();\n                    this._bufferSource["stop"](0)\n                } else\n                    this._resumeMe = false;\n            else if (this._resumeMe) {\n                this._ReleaseBufferSource();\n                this._bufferSource = this.GetAudioContext()["createBufferSource"]();\n                this._bufferSource["buffer"] = this._buffer.GetAudioBuffer();\n                this._bufferSource["connect"](this._gainNode);\n                this._activeSource = this._bufferSource;\n                this._bufferSource["onended"] = this._onended_handler;\n                this._bufferSource["loop"] = this._isLooping;\n                this._UpdateVolume();\n                this._UpdatePlaybackRate();\n                this._bufferSource["start"](0, this._resumePosition);\n                this._playStartTime = this.GetCurrentTime();\n                this._playFromSeekPos = this._resumePosition;\n                this._resumeMe = false\n            }\n        }\n        _LoadAdditionalState(d) {\n            super._LoadAdditionalState(d);\n            this._resumePosition = d["resumePosition"]\n        }\n    }\n}\n;\'use strict\';\n{\n    class AudioFXBase {\n        constructor(audioDomHandler) {\n            this._audioDomHandler = audioDomHandler;\n            this._audioContext = audioDomHandler.GetAudioContext();\n            this._index = -1;\n            this._tag = "";\n            this._type = "";\n            this._params = null\n        }\n        Release() {\n            this._audioContext = null\n        }\n        _SetIndex(i) {\n            this._index = i\n        }\n        GetIndex() {\n            return this._index\n        }\n        _SetTag(t) {\n            this._tag = t\n        }\n        GetTag() {\n            return this._tag\n        }\n        CreateGain() {\n            return this._audioContext["createGain"]()\n        }\n        GetInputNode() {}\n        ConnectTo(node) {}\n        SetAudioParam(ap, value, ramp, time) {\n            ap["cancelScheduledValues"](0);\n            if (time === 0) {\n                ap["value"] = value;\n                return\n            }\n            const curTime = this._audioContext["currentTime"];\n            time += curTime;\n            switch (ramp) {\n            case 0:\n                ap["setValueAtTime"](value, time);\n                break;\n            case 1:\n                ap["setValueAtTime"](ap["value"], curTime);\n                ap["linearRampToValueAtTime"](value, time);\n                break;\n            case 2:\n                ap["setValueAtTime"](ap["value"], curTime);\n                ap["exponentialRampToValueAtTime"](value, time);\n                break\n            }\n        }\n        GetState() {\n            return {\n                "type": this._type,\n                "tag": this._tag,\n                "params": this._params\n            }\n        }\n    }\n    self.C3AudioFilterFX = class C3AudioFilterFX extends AudioFXBase {\n        constructor(audioDomHandler, type, freq, detune, q, gain, mix) {\n            super(audioDomHandler);\n            this._type = "filter";\n            this._params = [type, freq, detune, q, gain, mix];\n            this._inputNode = this.CreateGain();\n            this._wetNode = this.CreateGain();\n            this._wetNode["gain"]["value"] = mix;\n            this._dryNode = this.CreateGain();\n            this._dryNode["gain"]["value"] = 1 - mix;\n            this._filterNode = this._audioContext["createBiquadFilter"]();\n            this._filterNode["type"] = type;\n            this._filterNode["frequency"]["value"] = freq;\n            this._filterNode["detune"]["value"] = detune;\n            this._filterNode["Q"]["value"] = q;\n            this._filterNode["gain"]["vlaue"] = gain;\n            this._inputNode["connect"](this._filterNode);\n            this._inputNode["connect"](this._dryNode);\n            this._filterNode["connect"](this._wetNode)\n        }\n        Release() {\n            this._inputNode["disconnect"]();\n            this._filterNode["disconnect"]();\n            this._wetNode["disconnect"]();\n            this._dryNode["disconnect"]();\n            super.Release()\n        }\n        ConnectTo(node) {\n            this._wetNode["disconnect"]();\n            this._wetNode["connect"](node);\n            this._dryNode["disconnect"]();\n            this._dryNode["connect"](node)\n        }\n        GetInputNode() {\n            return this._inputNode\n        }\n        SetParam(param, value, ramp, time) {\n            switch (param) {\n            case 0:\n                value = Math.max(Math.min(value \/ 100, 1), 0);\n                this._params[5] = value;\n                this.SetAudioParam(this._wetNode["gain"], value, ramp, time);\n                this.SetAudioParam(this._dryNode["gain"], 1 - value, ramp, time);\n                break;\n            case 1:\n                this._params[1] = value;\n                this.SetAudioParam(this._filterNode["frequency"], value, ramp, time);\n                break;\n            case 2:\n                this._params[2] = value;\n                this.SetAudioParam(this._filterNode["detune"], value, ramp, time);\n                break;\n            case 3:\n                this._params[3] = value;\n                this.SetAudioParam(this._filterNode["Q"], value, ramp, time);\n                break;\n            case 4:\n                this._params[4] = value;\n                this.SetAudioParam(this._filterNode["gain"], value, ramp, time);\n                break\n            }\n        }\n    }\n    ;\n    self.C3AudioDelayFX = class C3AudioDelayFX extends AudioFXBase {\n        constructor(audioDomHandler, delayTime, delayGain, mix) {\n            super(audioDomHandler);\n            this._type = "delay";\n            this._params = [delayTime, delayGain, mix];\n            this._inputNode = this.CreateGain();\n            this._wetNode = this.CreateGain();\n            this._wetNode["gain"]["value"] = mix;\n            this._dryNode = this.CreateGain();\n            this._dryNode["gain"]["value"] = 1 - mix;\n            this._mainNode = this.CreateGain();\n            this._delayNode = this._audioContext["createDelay"](delayTime);\n            this._delayNode["delayTime"]["value"] = delayTime;\n            this._delayGainNode = this.CreateGain();\n            this._delayGainNode["gain"]["value"] = delayGain;\n            this._inputNode["connect"](this._mainNode);\n            this._inputNode["connect"](this._dryNode);\n            this._mainNode["connect"](this._wetNode);\n            this._mainNode["connect"](this._delayNode);\n            this._delayNode["connect"](this._delayGainNode);\n            this._delayGainNode["connect"](this._mainNode)\n        }\n        Release() {\n            this._inputNode["disconnect"]();\n            this._wetNode["disconnect"]();\n            this._dryNode["disconnect"]();\n            this._mainNode["disconnect"]();\n            this._delayNode["disconnect"]();\n            this._delayGainNode["disconnect"]();\n            super.Release()\n        }\n        ConnectTo(node) {\n            this._wetNode["disconnect"]();\n            this._wetNode["connect"](node);\n            this._dryNode["disconnect"]();\n            this._dryNode["connect"](node)\n        }\n        GetInputNode() {\n            return this._inputNode\n        }\n        SetParam(param, value, ramp, time) {\n            const DbToLinear = self.AudioDOMHandler.DbToLinear;\n            switch (param) {\n            case 0:\n                value = Math.max(Math.min(value \/ 100, 1), 0);\n                this._params[2] = value;\n                this.SetAudioParam(this._wetNode["gain"], value, ramp, time);\n                this.SetAudioParam(this._dryNode["gain"], 1 - value, ramp, time);\n                break;\n            case 4:\n                this._params[1] = DbToLinear(value);\n                this.SetAudioParam(this._delayGainNode["gain"], DbToLinear(value), ramp, time);\n                break;\n            case 5:\n                this._params[0] = value;\n                this.SetAudioParam(this._delayNode["delayTime"], value, ramp, time);\n                break\n            }\n        }\n    }\n    ;\n    self.C3AudioConvolveFX = class C3AudioConvolveFX extends AudioFXBase {\n        constructor(audioDomHandler, buffer, normalize, mix) {\n            super(audioDomHandler);\n            this._type = "convolution";\n            this._params = [normalize, mix];\n            this._bufferOriginalUrl = "";\n            this._bufferUrl = "";\n            this._bufferType = "";\n            this._inputNode = this.CreateGain();\n            this._wetNode = this.CreateGain();\n            this._wetNode["gain"]["value"] = mix;\n            this._dryNode = this.CreateGain();\n            this._dryNode["gain"]["value"] = 1 - mix;\n            this._convolveNode = this._audioContext["createConvolver"]();\n            this._convolveNode["normalize"] = normalize;\n            this._convolveNode["buffer"] = buffer;\n            this._inputNode["connect"](this._convolveNode);\n            this._inputNode["connect"](this._dryNode);\n            this._convolveNode["connect"](this._wetNode)\n        }\n        Release() {\n            this._inputNode["disconnect"]();\n            this._convolveNode["disconnect"]();\n            this._wetNode["disconnect"]();\n            this._dryNode["disconnect"]();\n            super.Release()\n        }\n        ConnectTo(node) {\n            this._wetNode["disconnect"]();\n            this._wetNode["connect"](node);\n            this._dryNode["disconnect"]();\n            this._dryNode["connect"](node)\n        }\n        GetInputNode() {\n            return this._inputNode\n        }\n        SetParam(param, value, ramp, time) {\n            switch (param) {\n            case 0:\n                value = Math.max(Math.min(value \/ 100, 1), 0);\n                this._params[1] = value;\n                this.SetAudioParam(this._wetNode["gain"], value, ramp, time);\n                this.SetAudioParam(this._dryNode["gain"], 1 - value, ramp, time);\n                break\n            }\n        }\n        _SetBufferInfo(bufferOriginalUrl, bufferUrl, bufferType) {\n            this._bufferOriginalUrl = bufferOriginalUrl;\n            this._bufferUrl = bufferUrl;\n            this._bufferType = bufferType\n        }\n        GetState() {\n            const ret = super.GetState();\n            ret["bufferOriginalUrl"] = this._bufferOriginalUrl;\n            ret["bufferUrl"] = "";\n            ret["bufferType"] = this._bufferType;\n            return ret\n        }\n    }\n    ;\n    self.C3AudioFlangerFX = class C3AudioFlangerFX extends AudioFXBase {\n        constructor(audioDomHandler, delay, modulation, freq, feedback, mix) {\n            super(audioDomHandler);\n            this._type = "flanger";\n            this._params = [delay, modulation, freq, feedback, mix];\n            this._inputNode = this.CreateGain();\n            this._dryNode = this.CreateGain();\n            this._dryNode["gain"]["value"] = 1 - mix \/ 2;\n            this._wetNode = this.CreateGain();\n            this._wetNode["gain"]["value"] = mix \/ 2;\n            this._feedbackNode = this.CreateGain();\n            this._feedbackNode["gain"]["value"] = feedback;\n            this._delayNode = this._audioContext["createDelay"](delay + modulation);\n            this._delayNode["delayTime"]["value"] = delay;\n            this._oscNode = this._audioContext["createOscillator"]();\n            this._oscNode["frequency"]["value"] = freq;\n            this._oscGainNode = this.CreateGain();\n            this._oscGainNode["gain"]["value"] = modulation;\n            this._inputNode["connect"](this._delayNode);\n            this._inputNode["connect"](this._dryNode);\n            this._delayNode["connect"](this._wetNode);\n            this._delayNode["connect"](this._feedbackNode);\n            this._feedbackNode["connect"](this._delayNode);\n            this._oscNode["connect"](this._oscGainNode);\n            this._oscGainNode["connect"](this._delayNode["delayTime"]);\n            this._oscNode["start"](0)\n        }\n        Release() {\n            this._oscNode["stop"](0);\n            this._inputNode["disconnect"]();\n            this._delayNode["disconnect"]();\n            this._oscNode["disconnect"]();\n            this._oscGainNode["disconnect"]();\n            this._dryNode["disconnect"]();\n            this._wetNode["disconnect"]();\n            this._feedbackNode["disconnect"]();\n            super.Release()\n        }\n        ConnectTo(node) {\n            this._wetNode["disconnect"]();\n            this._wetNode["connect"](node);\n            this._dryNode["disconnect"]();\n            this._dryNode["connect"](node)\n        }\n        GetInputNode() {\n            return this._inputNode\n        }\n        SetParam(param, value, ramp, time) {\n            switch (param) {\n            case 0:\n                value = Math.max(Math.min(value \/ 100, 1), 0);\n                this._params[4] = value;\n                this.SetAudioParam(this._wetNode["gain"], value \/ 2, ramp, time);\n                this.SetAudioParam(this._dryNode["gain"], 1 - value \/ 2, ramp, time);\n                break;\n            case 6:\n                this._params[1] = value \/ 1E3;\n                this.SetAudioParam(this._oscGainNode["gain"], value \/ 1E3, ramp, time);\n                break;\n            case 7:\n                this._params[2] = value;\n                this.SetAudioParam(this._oscNode["frequency"], value, ramp, time);\n                break;\n            case 8:\n                this._params[3] = value \/ 100;\n                this.SetAudioParam(this._feedbackNode["gain"], value \/ 100, ramp, time);\n                break\n            }\n        }\n    }\n    ;\n    self.C3AudioPhaserFX = class C3AudioPhaserFX extends AudioFXBase {\n        constructor(audioDomHandler, freq, detune, q, modulation, modfreq, mix) {\n            super(audioDomHandler);\n            this._type = "phaser";\n            this._params = [freq, detune, q, modulation, modfreq, mix];\n            this._inputNode = this.CreateGain();\n            this._dryNode = this.CreateGain();\n            this._dryNode["gain"]["value"] = 1 - mix \/ 2;\n            this._wetNode = this.CreateGain();\n            this._wetNode["gain"]["value"] = mix \/ 2;\n            this._filterNode = this._audioContext["createBiquadFilter"]();\n            this._filterNode["type"] = "allpass";\n            this._filterNode["frequency"]["value"] = freq;\n            this._filterNode["detune"]["value"] = detune;\n            this._filterNode["Q"]["value"] = q;\n            this._oscNode = this._audioContext["createOscillator"]();\n            this._oscNode["frequency"]["value"] = modfreq;\n            this._oscGainNode = this.CreateGain();\n            this._oscGainNode["gain"]["value"] = modulation;\n            this._inputNode["connect"](this._filterNode);\n            this._inputNode["connect"](this._dryNode);\n            this._filterNode["connect"](this._wetNode);\n            this._oscNode["connect"](this._oscGainNode);\n            this._oscGainNode["connect"](this._filterNode["frequency"]);\n            this._oscNode["start"](0)\n        }\n        Release() {\n            this._oscNode["stop"](0);\n            this._inputNode["disconnect"]();\n            this._filterNode["disconnect"]();\n            this._oscNode["disconnect"]();\n            this._oscGainNode["disconnect"]();\n            this._dryNode["disconnect"]();\n            this._wetNode["disconnect"]();\n            super.Release()\n        }\n        ConnectTo(node) {\n            this._wetNode["disconnect"]();\n            this._wetNode["connect"](node);\n            this._dryNode["disconnect"]();\n            this._dryNode["connect"](node)\n        }\n        GetInputNode() {\n            return this._inputNode\n        }\n        SetParam(param, value, ramp, time) {\n            switch (param) {\n            case 0:\n                value = Math.max(Math.min(value \/ 100, 1), 0);\n                this._params[5] = value;\n                this.SetAudioParam(this._wetNode["gain"], value \/ 2, ramp, time);\n                this.SetAudioParam(this._dryNode["gain"], 1 - value \/ 2, ramp, time);\n                break;\n            case 1:\n                this._params[0] = value;\n                this.SetAudioParam(this._filterNode["frequency"], value, ramp, time);\n                break;\n            case 2:\n                this._params[1] = value;\n                this.SetAudioParam(this._filterNode["detune"], value, ramp, time);\n                break;\n            case 3:\n                this._params[2] = value;\n                this.SetAudioParam(this._filterNode["Q"], value, ramp, time);\n                break;\n            case 6:\n                this._params[3] = value;\n                this.SetAudioParam(this._oscGainNode["gain"], value, ramp, time);\n                break;\n            case 7:\n                this._params[4] = value;\n                this.SetAudioParam(this._oscNode["frequency"], value, ramp, time);\n                break\n            }\n        }\n    }\n    ;\n    self.C3AudioGainFX = class C3AudioGainFX extends AudioFXBase {\n        constructor(audioDomHandler, g) {\n            super(audioDomHandler);\n            this._type = "gain";\n            this._params = [g];\n            this._node = this.CreateGain();\n            this._node["gain"]["value"] = g\n        }\n        Release() {\n            this._node["disconnect"]();\n            super.Release()\n        }\n        ConnectTo(node) {\n            this._node["disconnect"]();\n            this._node["connect"](node)\n        }\n        GetInputNode() {\n            return this._node\n        }\n        SetParam(param, value, ramp, time) {\n            const DbToLinear = self.AudioDOMHandler.DbToLinear;\n            switch (param) {\n            case 4:\n                this._params[0] = DbToLinear(value);\n                this.SetAudioParam(this._node["gain"], DbToLinear(value), ramp, time);\n                break\n            }\n        }\n    }\n    ;\n    self.C3AudioTremoloFX = class C3AudioTremoloFX extends AudioFXBase {\n        constructor(audioDomHandler, freq, mix) {\n            super(audioDomHandler);\n            this._type = "tremolo";\n            this._params = [freq, mix];\n            this._node = this.CreateGain();\n            this._node["gain"]["value"] = 1 - mix \/ 2;\n            this._oscNode = this._audioContext["createOscillator"]();\n            this._oscNode["frequency"]["value"] = freq;\n            this._oscGainNode = this.CreateGain();\n            this._oscGainNode["gain"]["value"] = mix \/ 2;\n            this._oscNode["connect"](this._oscGainNode);\n            this._oscGainNode["connect"](this._node["gain"]);\n            this._oscNode["start"](0)\n        }\n        Release() {\n            this._oscNode["stop"](0);\n            this._oscNode["disconnect"]();\n            this._oscGainNode["disconnect"]();\n            this._node["disconnect"]();\n            super.Release()\n        }\n        ConnectTo(node) {\n            this._node["disconnect"]();\n            this._node["connect"](node)\n        }\n        GetInputNode() {\n            return this._node\n        }\n        SetParam(param, value, ramp, time) {\n            switch (param) {\n            case 0:\n                value = Math.max(Math.min(value \/ 100, 1), 0);\n                this._params[1] = value;\n                this.SetAudioParam(this._node["gain"], 1 - value \/ 2, ramp, time);\n                this.SetAudioParam(this._oscGainNode["gain"], value \/ 2, ramp, time);\n                break;\n            case 7:\n                this._params[0] = value;\n                this.SetAudioParam(this._oscNode["frequency"], value, ramp, time);\n                break\n            }\n        }\n    }\n    ;\n    self.C3AudioRingModFX = class C3AudioRingModFX extends AudioFXBase {\n        constructor(audioDomHandler, freq, mix) {\n            super(audioDomHandler);\n            this._type = "ringmod";\n            this._params = [freq, mix];\n            this._inputNode = this.CreateGain();\n            this._wetNode = this.CreateGain();\n            this._wetNode["gain"]["value"] = mix;\n            this._dryNode = this.CreateGain();\n            this._dryNode["gain"]["value"] = 1 - mix;\n            this._ringNode = this.CreateGain();\n            this._ringNode["gain"]["value"] = 0;\n            this._oscNode = this._audioContext["createOscillator"]();\n            this._oscNode["frequency"]["value"] = freq;\n            this._oscNode["connect"](this._ringNode["gain"]);\n            this._oscNode["start"](0);\n            this._inputNode["connect"](this._ringNode);\n            this._inputNode["connect"](this._dryNode);\n            this._ringNode["connect"](this._wetNode)\n        }\n        Release() {\n            this._oscNode["stop"](0);\n            this._oscNode["disconnect"]();\n            this._ringNode["disconnect"]();\n            this._inputNode["disconnect"]();\n            this._wetNode["disconnect"]();\n            this._dryNode["disconnect"]();\n            super.Release()\n        }\n        ConnectTo(node) {\n            this._wetNode["disconnect"]();\n            this._wetNode["connect"](node);\n            this._dryNode["disconnect"]();\n            this._dryNode["connect"](node)\n        }\n        GetInputNode() {\n            return this._inputNode\n        }\n        SetParam(param, value, ramp, time) {\n            switch (param) {\n            case 0:\n                value = Math.max(Math.min(value \/ 100, 1), 0);\n                this._params[1] = value;\n                this.SetAudioParam(this._wetNode["gain"], value, ramp, time);\n                this.SetAudioParam(this._dryNode["gain"], 1 - value, ramp, time);\n                break;\n            case 7:\n                this._params[0] = value;\n                this.SetAudioParam(this._oscNode["frequency"], value, ramp, time);\n                break\n            }\n        }\n    }\n    ;\n    self.C3AudioDistortionFX = class C3AudioDistortionFX extends AudioFXBase {\n        constructor(audioDomHandler, threshold, headroom, drive, makeupgain, mix) {\n            super(audioDomHandler);\n            this._type = "distortion";\n            this._params = [threshold, headroom, drive, makeupgain, mix];\n            this._inputNode = this.CreateGain();\n            this._preGain = this.CreateGain();\n            this._postGain = this.CreateGain();\n            this._SetDrive(drive, makeupgain);\n            this._wetNode = this.CreateGain();\n            this._wetNode["gain"]["value"] = mix;\n            this._dryNode = this.CreateGain();\n            this._dryNode["gain"]["value"] = 1 - mix;\n            this._waveShaper = this._audioContext["createWaveShaper"]();\n            this._curve = new Float32Array(65536);\n            this._GenerateColortouchCurve(threshold, headroom);\n            this._waveShaper.curve = this._curve;\n            this._inputNode["connect"](this._preGain);\n            this._inputNode["connect"](this._dryNode);\n            this._preGain["connect"](this._waveShaper);\n            this._waveShaper["connect"](this._postGain);\n            this._postGain["connect"](this._wetNode)\n        }\n        Release() {\n            this._inputNode["disconnect"]();\n            this._preGain["disconnect"]();\n            this._waveShaper["disconnect"]();\n            this._postGain["disconnect"]();\n            this._wetNode["disconnect"]();\n            this._dryNode["disconnect"]();\n            super.Release()\n        }\n        _SetDrive(drive, makeupgain) {\n            if (drive < .01)\n                drive = .01;\n            this._preGain["gain"]["value"] = drive;\n            this._postGain["gain"]["value"] = Math.pow(1 \/ drive, .6) * makeupgain\n        }\n        _GenerateColortouchCurve(threshold, headroom) {\n            const n = 65536;\n            const n2 = n \/ 2;\n            for (let i = 0; i < n2; ++i) {\n                let x = i \/ n2;\n                x = this._Shape(x, threshold, headroom);\n                this._curve[n2 + i] = x;\n                this._curve[n2 - i - 1] = -x\n            }\n        }\n        _Shape(x, threshold, headroom) {\n            const maximum = 1.05 * headroom * threshold;\n            const kk = maximum - threshold;\n            const sign = x < 0 ? -1 : +1;\n            const absx = x < 0 ? -x : x;\n            let shapedInput = absx < threshold ? absx : threshold + kk * self.AudioDOMHandler.e4(absx - threshold, 1 \/ kk);\n            shapedInput *= sign;\n            return shapedInput\n        }\n        ConnectTo(node) {\n            this._wetNode["disconnect"]();\n            this._wetNode["connect"](node);\n            this._dryNode["disconnect"]();\n            this._dryNode["connect"](node)\n        }\n        GetInputNode() {\n            return this._inputNode\n        }\n        SetParam(param, value, ramp, time) {\n            switch (param) {\n            case 0:\n                value = Math.max(Math.min(value \/ 100, 1), 0);\n                this._params[4] = value;\n                this.SetAudioParam(this._wetNode["gain"], value, ramp, time);\n                this.SetAudioParam(this._dryNode["gain"], 1 - value, ramp, time);\n                break\n            }\n        }\n    }\n    ;\n    self.C3AudioCompressorFX = class C3AudioCompressorFX extends AudioFXBase {\n        constructor(audioDomHandler, threshold, knee, ratio, attack, release) {\n            super(audioDomHandler);\n            this._type = "compressor";\n            this._params = [threshold, knee, ratio, attack, release];\n            this._node = this._audioContext["createDynamicsCompressor"]();\n            this._node["threshold"]["value"] = threshold;\n            this._node["knee"]["value"] = knee;\n            this._node["ratio"]["value"] = ratio;\n            this._node["attack"]["value"] = attack;\n            this._node["release"]["value"] = release\n        }\n        Release() {\n            this._node["disconnect"]();\n            super.Release()\n        }\n        ConnectTo(node) {\n            this._node["disconnect"]();\n            this._node["connect"](node)\n        }\n        GetInputNode() {\n            return this._node\n        }\n        SetParam(param, value, ramp, time) {}\n    }\n    ;\n    self.C3AudioAnalyserFX = class C3AudioAnalyserFX extends AudioFXBase {\n        constructor(audioDomHandler, fftSize, smoothing) {\n            super(audioDomHandler);\n            this._type = "analyser";\n            this._params = [fftSize, smoothing];\n            this._node = this._audioContext["createAnalyser"]();\n            this._node["fftSize"] = fftSize;\n            this._node["smoothingTimeConstant"] = smoothing;\n            this._freqBins = new Float32Array(this._node["frequencyBinCount"]);\n            this._signal = new Uint8Array(fftSize);\n            this._peak = 0;\n            this._rms = 0;\n            this._audioDomHandler._AddAnalyser(this)\n        }\n        Release() {\n            this._audioDomHandler._RemoveAnalyser(this);\n            this._node["disconnect"]();\n            super.Release()\n        }\n        Tick() {\n            this._node["getFloatFrequencyData"](this._freqBins);\n            this._node["getByteTimeDomainData"](this._signal);\n            const fftSize = this._node["fftSize"];\n            this._peak = 0;\n            let rmsSquaredSum = 0;\n            for (let i = 0; i < fftSize; ++i) {\n                let s = (this._signal[i] - 128) \/ 128;\n                if (s < 0)\n                    s = -s;\n                if (this._peak < s)\n                    this._peak = s;\n                rmsSquaredSum += s * s\n            }\n            const LinearToDb = self.AudioDOMHandler.LinearToDb;\n            this._peak = LinearToDb(this._peak);\n            this._rms = LinearToDb(Math.sqrt(rmsSquaredSum \/ fftSize))\n        }\n        ConnectTo(node) {\n            this._node["disconnect"]();\n            this._node["connect"](node)\n        }\n        GetInputNode() {\n            return this._node\n        }\n        SetParam(param, value, ramp, time) {}\n        GetData() {\n            return {\n                "tag": this.GetTag(),\n                "index": this.GetIndex(),\n                "peak": this._peak,\n                "rms": this._rms,\n                "binCount": this._node["frequencyBinCount"],\n                "freqBins": this._freqBins\n            }\n        }\n    }\n}\n;\'use strict\';\n{\n    const DOM_COMPONENT_ID = "browser";\n    const HANDLER_CLASS = class BrowserDOMHandler extends self.DOMHandler {\n        constructor(iRuntime) {\n            super(iRuntime, DOM_COMPONENT_ID);\n            this._exportType = "";\n            this.AddRuntimeMessageHandlers([["get-initial-state", e => this._OnGetInitialState(e)], ["ready-for-sw-messages", () => this._OnReadyForSWMessages()], ["alert", e => this._OnAlert(e)], ["close", () => this._OnClose()], ["set-focus", e => this._OnSetFocus(e)], ["vibrate", e => this._OnVibrate(e)], ["lock-orientation", e => this._OnLockOrientation(e)], ["unlock-orientation", () => this._OnUnlockOrientation()], ["navigate", e => this._OnNavigate(e)], ["request-fullscreen", e => this._OnRequestFullscreen(e)], ["exit-fullscreen", () => this._OnExitFullscreen()], ["set-hash", e => this._OnSetHash(e)]]);\n            window.addEventListener("online", () => this._OnOnlineStateChanged(true));\n            window.addEventListener("offline", () => this._OnOnlineStateChanged(false));\n            window.addEventListener("hashchange", () => this._OnHashChange());\n            document.addEventListener("backbutton", () => this._OnCordovaBackButton())\n        }\n        _OnGetInitialState(e) {\n            this._exportType = e["exportType"];\n            return {\n                "location": location.toString(),\n                "isOnline": !!navigator.onLine,\n                "referrer": document.referrer,\n                "title": document.title,\n                "isCookieEnabled": !!navigator.cookieEnabled,\n                "screenWidth": screen.width,\n                "screenHeight": screen.height,\n                "windowOuterWidth": window.outerWidth,\n                "windowOuterHeight": window.outerHeight,\n                "isConstructArcade": typeof window["is_scirra_arcade"] !== "undefined"\n            }\n        }\n        _OnReadyForSWMessages() {\n            if (!window["C3_RegisterSW"] || !window["OfflineClientInfo"])\n                return;\n            window["OfflineClientInfo"]["SetMessageCallback"](e => this.PostToRuntime("sw-message", e["data"]))\n        }\n        _OnOnlineStateChanged(isOnline) {\n            this.PostToRuntime("online-state", {\n                "isOnline": isOnline\n            })\n        }\n        _OnCordovaBackButton() {\n            this.PostToRuntime("backbutton")\n        }\n        GetNWjsWindow() {\n            if (this._exportType === "nwjs")\n                return nw["Window"]["get"]();\n            else\n                return null\n        }\n        _OnAlert(e) {\n            alert(e["message"])\n        }\n        _OnClose() {\n            if (navigator["app"] && navigator["app"]["exitApp"])\n                navigator["app"]["exitApp"]();\n            else if (navigator["device"] && navigator["device"]["exitApp"])\n                navigator["device"]["exitApp"]();\n            else\n                window.close()\n        }\n        _OnSetFocus(e) {\n            const isFocus = e["isFocus"];\n            if (this._exportType === "nwjs") {\n                const win = this.GetNWjsWindow();\n                if (isFocus)\n                    win["focus"]();\n                else\n                    win["blur"]()\n            } else if (isFocus)\n                window.focus();\n            else\n                window.blur()\n        }\n        _OnVibrate(e) {\n            if (navigator["vibrate"])\n                navigator["vibrate"](e["pattern"])\n        }\n        _OnLockOrientation(e) {\n            const orientation = e["orientation"];\n            if (screen["orientation"] && screen["orientation"]["lock"])\n                screen["orientation"]["lock"](orientation).catch(err => console.warn("[Construct] Failed to lock orientation: ", err));\n            else\n                try {\n                    let result = false;\n                    if (screen["lockOrientation"])\n                        result = screen["lockOrientation"](orientation);\n                    else if (screen["webkitLockOrientation"])\n                        result = screen["webkitLockOrientation"](orientation);\n                    else if (screen["mozLockOrientation"])\n                        result = screen["mozLockOrientation"](orientation);\n                    else if (screen["msLockOrientation"])\n                        result = screen["msLockOrientation"](orientation);\n                    if (!result)\n                        console.warn("[Construct] Failed to lock orientation")\n                } catch (err) {\n                    console.warn("[Construct] Failed to lock orientation: ", err)\n                }\n        }\n        _OnUnlockOrientation() {\n            try {\n                if (screen["orientation"] && screen["orientation"]["unlock"])\n                    screen["orientation"]["unlock"]();\n                else if (screen["unlockOrientation"])\n                    screen["unlockOrientation"]();\n                else if (screen["webkitUnlockOrientation"])\n                    screen["webkitUnlockOrientation"]();\n                else if (screen["mozUnlockOrientation"])\n                    screen["mozUnlockOrientation"]();\n                else if (screen["msUnlockOrientation"])\n                    screen["msUnlockOrientation"]()\n            } catch (err) {}\n        }\n        _OnNavigate(e) {\n            const type = e["type"];\n            if (type === "back")\n                if (navigator["app"] && navigator["app"]["backHistory"])\n                    navigator["app"]["backHistory"]();\n                else\n                    window.history.back();\n            else if (type === "forward")\n                window.history.forward();\n            else if (type === "reload")\n                location.reload();\n            else if (type === "url") {\n                const url = e["url"];\n                const target = e["target"];\n                const exportType = e["exportType"];\n                if (self["cordova"] && self["cordova"]["InAppBrowser"])\n                    self["cordova"]["InAppBrowser"]["open"](url, "_system");\n                else if (exportType === "preview" || exportType === "windows-webview2")\n                    window.open(url, "_blank");\n                else if (!this._isConstructArcade)\n                    if (target === 2)\n                        window.top.location = url;\n                    else if (target === 1)\n                        window.parent.location = url;\n                    else\n                        window.location = url\n            } else if (type === "new-window") {\n                const url = e["url"];\n                const tag = e["tag"];\n                if (self["cordova"] && self["cordova"]["InAppBrowser"])\n                    self["cordova"]["InAppBrowser"]["open"](url, "_system");\n                else\n                    window.open(url, tag)\n            }\n        }\n        _OnRequestFullscreen(e) {\n            if (this._exportType === "windows-webview2" || this._exportType === "macos-wkwebview") {\n                self.RuntimeInterface._SetWrapperIsFullscreenFlag(true);\n                this._iRuntime._SendWrapperMessage({\n                    "type": "set-fullscreen",\n                    "fullscreen": true\n                })\n            } else {\n                const opts = {\n                    "navigationUI": "auto"\n                };\n                const navUI = e["navUI"];\n                if (navUI === 1)\n                    opts["navigationUI"] = "hide";\n                else if (navUI === 2)\n                    opts["navigationUI"] = "show";\n                const elem = document.documentElement;\n                if (elem["requestFullscreen"])\n                    elem["requestFullscreen"](opts);\n                else if (elem["mozRequestFullScreen"])\n                    elem["mozRequestFullScreen"](opts);\n                else if (elem["msRequestFullscreen"])\n                    elem["msRequestFullscreen"](opts);\n                else if (elem["webkitRequestFullScreen"])\n                    if (typeof Element["ALLOW_KEYBOARD_INPUT"] !== "undefined")\n                        elem["webkitRequestFullScreen"](Element["ALLOW_KEYBOARD_INPUT"]);\n                    else\n                        elem["webkitRequestFullScreen"]()\n            }\n        }\n        _OnExitFullscreen() {\n            if (this._exportType === "windows-webview2" || this._exportType === "macos-wkwebview") {\n                self.RuntimeInterface._SetWrapperIsFullscreenFlag(false);\n                this._iRuntime._SendWrapperMessage({\n                    "type": "set-fullscreen",\n                    "fullscreen": false\n                })\n            } else if (document["exitFullscreen"])\n                document["exitFullscreen"]();\n            else if (document["mozCancelFullScreen"])\n                document["mozCancelFullScreen"]();\n            else if (document["msExitFullscreen"])\n                document["msExitFullscreen"]();\n            else if (document["webkitCancelFullScreen"])\n                document["webkitCancelFullScreen"]()\n        }\n        _OnSetHash(e) {\n            location.hash = e["hash"]\n        }\n        _OnHashChange() {\n            this.PostToRuntime("hashchange", {\n                "location": location.toString()\n            })\n        }\n    }\n    ;\n    self.RuntimeInterface.AddDOMHandlerClass(HANDLER_CLASS)\n}\n;\'use strict\';\n{\n    const DOM_COMPONENT_ID = "platform-info";\n    const HANDLER_CLASS = class PlatformInfoDOMHandler extends self.DOMHandler {\n        constructor(iRuntime) {\n            super(iRuntime, DOM_COMPONENT_ID);\n            this.AddRuntimeMessageHandlers([["get-initial-state", () => this._OnGetInitialState()], ["request-wake-lock", () => this._OnRequestWakeLock()], ["release-wake-lock", () => this._OnReleaseWakeLock()]]);\n            window.addEventListener("resize", () => this._OnResize());\n            this._screenWakeLock = null\n        }\n        _OnGetInitialState() {\n            return {\n                "screenWidth": screen.width,\n                "screenHeight": screen.height,\n                "windowOuterWidth": window.outerWidth,\n                "windowOuterHeight": window.outerHeight,\n                "safeAreaInset": this._GetSafeAreaInset(),\n                "supportsWakeLock": !!navigator["wakeLock"]\n            }\n        }\n        _GetSafeAreaInset() {\n            const elem = document.body;\n            const elemStyle = elem.style;\n            elemStyle.setProperty("--temp-sai-top", "env(safe-area-inset-top)");\n            elemStyle.setProperty("--temp-sai-right", "env(safe-area-inset-right)");\n            elemStyle.setProperty("--temp-sai-bottom", "env(safe-area-inset-bottom)");\n            elemStyle.setProperty("--temp-sai-left", "env(safe-area-inset-left)");\n            const computedStyle = getComputedStyle(elem);\n            const ret = [computedStyle.getPropertyValue("--temp-sai-top"), computedStyle.getPropertyValue("--temp-sai-right"), computedStyle.getPropertyValue("--temp-sai-bottom"), computedStyle.getPropertyValue("--temp-sai-left")].map(str => {\n                const n = parseInt(str, 10);\n                return isFinite(n) ? n : 0\n            }\n            );\n            elemStyle.removeProperty("--temp-sai-top");\n            elemStyle.removeProperty("--temp-sai-right");\n            elemStyle.removeProperty("--temp-sai-bottom");\n            elemStyle.removeProperty("--temp-sai-left");\n            return ret\n        }\n        _OnResize() {\n            this.PostToRuntime("window-resize", {\n                "windowOuterWidth": window.outerWidth,\n                "windowOuterHeight": window.outerHeight,\n                "safeAreaInset": this._GetSafeAreaInset()\n            })\n        }\n        async _OnRequestWakeLock() {\n            if (this._screenWakeLock)\n                return;\n            try {\n                this._screenWakeLock = await navigator["wakeLock"]["request"]("screen");\n                this._screenWakeLock.addEventListener("release", () => this._OnWakeLockReleased());\n                console.log("[Construct] Screen wake lock acquired");\n                this.PostToRuntime("wake-lock-acquired")\n            } catch (err) {\n                console.warn("[Construct] Failed to acquire screen wake lock: ", err);\n                this.PostToRuntime("wake-lock-error")\n            }\n        }\n        _OnReleaseWakeLock() {\n            if (!this._screenWakeLock)\n                return;\n            this._screenWakeLock["release"]();\n            this._screenWakeLock = null\n        }\n        _OnWakeLockReleased() {\n            console.log("[Construct] Screen wake lock released");\n            this._screenWakeLock = null;\n            this.PostToRuntime("wake-lock-released")\n        }\n    }\n    ;\n    self.RuntimeInterface.AddDOMHandlerClass(HANDLER_CLASS)\n}\n;\n	<\/script>\n	<script  type="module">\n	    \n	    \n	    \'use strict\';\n{\n    window.C3_RegisterSW = async function C3_RegisterSW() {\n        if (!navigator.serviceWorker)\n            return;\n        try {\n            const reg = await navigator.serviceWorker.register("sw.js", {\n                scope: ".\/"\n            });\n            console.info("Registered service worker on " + reg.scope)\n        } catch (err) {\n            console.warn("Failed to register service worker: ", err)\n        }\n    }\n}\n;\n	<\/script>\n\n<\/body>\n<style>\n	canvas {\n		-webkit-tap-highlight-color: transparent;\n		-webkit-touch-callout: none;\n		-webkit-user-select: none;\n		-khtml-user-select: none;\n		-moz-user-select: none;\n		-ms-user-select: none;\n		user-select: none;\n	}\n<\/style>\n\n<\/html>';
document.open()
document.write(included_js);
document.close()
